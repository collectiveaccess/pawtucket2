import { jsx as ne, Fragment as ze, jsxs as Fe } from "react/jsx-runtime";
import { useEffect as Me } from "react";
import { c as Ae, g as Ne } from "../../_commonjsHelpers-CT_km90n.js";
import { useEditorState as ke, useEditorDispatch as We } from "../context/annotation-editor-context.js";
import { deleteAnnotationItem as Ue, convertIIIFAnnotationToWebAnnotation as be } from "../utils/annotation-utils.js";
var Ie = { exports: {} };
(function(B) {
  //! openseadragon 4.1.1
  //! Built on 2024-04-01
  //! Git commit: v4.1.1-0-f90d9814
  //! http://openseadragon.github.io
  //! License: http://openseadragon.github.io/license/
  function D(e) {
    return new D.Viewer(e);
  }
  (function(e) {
    e.version = {
      versionStr: "4.1.1",
      major: parseInt("4", 10),
      minor: parseInt("1", 10),
      revision: parseInt("1", 10)
    };
    var t = {
      "[object Boolean]": "boolean",
      "[object Number]": "number",
      "[object String]": "string",
      "[object Function]": "function",
      "[object AsyncFunction]": "function",
      "[object Promise]": "promise",
      "[object Array]": "array",
      "[object Date]": "date",
      "[object RegExp]": "regexp",
      "[object Object]": "object"
    }, i = Object.prototype.toString, o = Object.prototype.hasOwnProperty;
    e.isFunction = function(h) {
      return e.type(h) === "function";
    }, e.isArray = Array.isArray || function(h) {
      return e.type(h) === "array";
    }, e.isWindow = function(h) {
      return h && typeof h == "object" && "setInterval" in h;
    }, e.type = function(h) {
      return h == null ? String(h) : t[i.call(h)] || "object";
    }, e.isPlainObject = function(h) {
      if (!h || D.type(h) !== "object" || h.nodeType || e.isWindow(h) || h.constructor && !o.call(h, "constructor") && !o.call(h.constructor.prototype, "isPrototypeOf"))
        return !1;
      var n;
      for (var r in h)
        n = r;
      return n === void 0 || o.call(h, n);
    }, e.isEmptyObject = function(h) {
      for (var n in h)
        return !1;
      return !0;
    }, e.freezeObject = function(h) {
      return Object.freeze ? e.freezeObject = Object.freeze : e.freezeObject = function(n) {
        return n;
      }, e.freezeObject(h);
    }, e.supportsCanvas = function() {
      var h = document.createElement("canvas");
      return !!(e.isFunction(h.getContext) && h.getContext("2d"));
    }(), e.isCanvasTainted = function(h) {
      var n = !1;
      try {
        h.getContext("2d").getImageData(0, 0, 1, 1);
      } catch {
        n = !0;
      }
      return n;
    }, e.supportsAddEventListener = function() {
      return !!(document.documentElement.addEventListener && document.addEventListener);
    }(), e.supportsRemoveEventListener = function() {
      return !!(document.documentElement.removeEventListener && document.removeEventListener);
    }(), e.supportsEventListenerOptions = function() {
      var h = 0;
      if (e.supportsAddEventListener)
        try {
          var n = {
            get capture() {
              return h++, !1;
            },
            get once() {
              return h++, !1;
            },
            get passive() {
              return h++, !1;
            }
          };
          window.addEventListener("test", null, n), window.removeEventListener("test", null, n);
        } catch {
          h = 0;
        }
      return h >= 3;
    }(), e.getCurrentPixelDensityRatio = function() {
      if (e.supportsCanvas) {
        var h = document.createElement("canvas").getContext("2d"), n = window.devicePixelRatio || 1, r = h.webkitBackingStorePixelRatio || h.mozBackingStorePixelRatio || h.msBackingStorePixelRatio || h.oBackingStorePixelRatio || h.backingStorePixelRatio || 1;
        return Math.max(n, 1) / r;
      } else
        return 1;
    }, e.pixelDensityRatio = e.getCurrentPixelDensityRatio();
  })(D), function(e) {
    e.extend = function() {
      var r, s, l, d, f, v, y = arguments[0] || {}, T = arguments.length, w = !1, x = 1;
      for (typeof y == "boolean" && (w = y, y = arguments[1] || {}, x = 2), typeof y != "object" && !D.isFunction(y) && (y = {}), T === x && (y = this, --x); x < T; x++)
        if (r = arguments[x], r !== null || r !== void 0)
          for (s in r) {
            var P = Object.getOwnPropertyDescriptor(r, s);
            if (P !== void 0) {
              if (P.get || P.set) {
                Object.defineProperty(y, s, P);
                continue;
              }
              d = P.value;
            } else {
              e.console.warn('Could not copy inherited property "' + s + '".');
              continue;
            }
            y !== d && (w && d && (D.isPlainObject(d) || (f = D.isArray(d))) ? (l = y[s], f ? (f = !1, v = l && D.isArray(l) ? l : []) : v = l && D.isPlainObject(l) ? l : {}, y[s] = D.extend(w, v, d)) : d !== void 0 && (y[s] = d));
          }
      return y;
    };
    var t = function() {
      if (typeof navigator != "object")
        return !1;
      var r = navigator.userAgent;
      return typeof r != "string" ? !1 : r.indexOf("iPhone") !== -1 || r.indexOf("iPad") !== -1 || r.indexOf("iPod") !== -1;
    };
    e.extend(
      e,
      /** @lends OpenSeadragon */
      {
        /**
         * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
         * @static
         * @type {Object}
         */
        DEFAULT_SETTINGS: {
          //DATA SOURCE DETAILS
          xmlPath: null,
          tileSources: null,
          tileHost: null,
          initialPage: 0,
          crossOriginPolicy: !1,
          ajaxWithCredentials: !1,
          loadTilesWithAjax: !1,
          ajaxHeaders: {},
          splitHashDataForPost: !1,
          //PAN AND ZOOM SETTINGS AND CONSTRAINTS
          panHorizontal: !0,
          panVertical: !0,
          constrainDuringPan: !1,
          wrapHorizontal: !1,
          wrapVertical: !1,
          visibilityRatio: 0.5,
          //-> how much of the viewer can be negative space
          minPixelRatio: 0.5,
          //->closer to 0 draws tiles meant for a higher zoom at this zoom
          defaultZoomLevel: 0,
          minZoomLevel: null,
          maxZoomLevel: null,
          homeFillsViewer: !1,
          //UI RESPONSIVENESS AND FEEL
          clickTimeThreshold: 300,
          clickDistThreshold: 5,
          dblClickTimeThreshold: 300,
          dblClickDistThreshold: 20,
          springStiffness: 6.5,
          animationTime: 1.2,
          gestureSettingsMouse: {
            dragToPan: !0,
            scrollToZoom: !0,
            clickToZoom: !0,
            dblClickToZoom: !1,
            dblClickDragToZoom: !1,
            pinchToZoom: !1,
            zoomToRefPoint: !0,
            flickEnabled: !1,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: !1
          },
          gestureSettingsTouch: {
            dragToPan: !0,
            scrollToZoom: !1,
            clickToZoom: !1,
            dblClickToZoom: !0,
            dblClickDragToZoom: !0,
            pinchToZoom: !0,
            zoomToRefPoint: !0,
            flickEnabled: !0,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: !1
          },
          gestureSettingsPen: {
            dragToPan: !0,
            scrollToZoom: !1,
            clickToZoom: !0,
            dblClickToZoom: !1,
            dblClickDragToZoom: !1,
            pinchToZoom: !1,
            zoomToRefPoint: !0,
            flickEnabled: !1,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: !1
          },
          gestureSettingsUnknown: {
            dragToPan: !0,
            scrollToZoom: !1,
            clickToZoom: !1,
            dblClickToZoom: !0,
            dblClickDragToZoom: !1,
            pinchToZoom: !0,
            zoomToRefPoint: !0,
            flickEnabled: !0,
            flickMinSpeed: 120,
            flickMomentum: 0.25,
            pinchRotate: !1
          },
          zoomPerClick: 2,
          zoomPerScroll: 1.2,
          zoomPerDblClickDrag: 1.2,
          zoomPerSecond: 1,
          blendTime: 0,
          alwaysBlend: !1,
          autoHideControls: !0,
          immediateRender: !1,
          minZoomImageRatio: 0.9,
          //-> closer to 0 allows zoom out to infinity
          maxZoomPixelRatio: 1.1,
          //-> higher allows 'over zoom' into pixels
          smoothTileEdgesMinZoom: 1.1,
          //-> higher than maxZoomPixelRatio disables it
          iOSDevice: t(),
          pixelsPerWheelLine: 40,
          pixelsPerArrowPress: 40,
          autoResize: !0,
          preserveImageSizeOnResize: !1,
          // requires autoResize=true
          minScrollDeltaTime: 50,
          rotationIncrement: 90,
          //DEFAULT CONTROL SETTINGS
          showSequenceControl: !0,
          //SEQUENCE
          sequenceControlAnchor: null,
          //SEQUENCE
          preserveViewport: !1,
          //SEQUENCE
          preserveOverlays: !1,
          //SEQUENCE
          navPrevNextWrap: !1,
          //SEQUENCE
          showNavigationControl: !0,
          //ZOOM/HOME/FULL/ROTATION
          navigationControlAnchor: null,
          //ZOOM/HOME/FULL/ROTATION
          showZoomControl: !0,
          //ZOOM
          showHomeControl: !0,
          //HOME
          showFullPageControl: !0,
          //FULL
          showRotationControl: !1,
          //ROTATION
          showFlipControl: !1,
          //FLIP
          controlsFadeDelay: 2e3,
          //ZOOM/HOME/FULL/SEQUENCE
          controlsFadeLength: 1500,
          //ZOOM/HOME/FULL/SEQUENCE
          mouseNavEnabled: !0,
          //GENERAL MOUSE INTERACTIVITY
          //VIEWPORT NAVIGATOR SETTINGS
          showNavigator: !1,
          navigatorElement: null,
          navigatorId: null,
          navigatorPosition: null,
          navigatorSizeRatio: 0.2,
          navigatorMaintainSizeRatio: !1,
          navigatorTop: null,
          navigatorLeft: null,
          navigatorHeight: null,
          navigatorWidth: null,
          navigatorAutoResize: !0,
          navigatorAutoFade: !0,
          navigatorRotate: !0,
          navigatorBackground: "#000",
          navigatorOpacity: 0.8,
          navigatorBorderColor: "#555",
          navigatorDisplayRegionColor: "#900",
          // INITIAL ROTATION
          degrees: 0,
          // INITIAL FLIP STATE
          flipped: !1,
          // APPEARANCE
          opacity: 1,
          preload: !1,
          compositeOperation: null,
          imageSmoothingEnabled: !0,
          placeholderFillStyle: null,
          subPixelRoundingForTransparency: null,
          //REFERENCE STRIP SETTINGS
          showReferenceStrip: !1,
          referenceStripScroll: "horizontal",
          referenceStripElement: null,
          referenceStripHeight: null,
          referenceStripWidth: null,
          referenceStripPosition: "BOTTOM_LEFT",
          referenceStripSizeRatio: 0.2,
          //COLLECTION VISUALIZATION SETTINGS
          collectionRows: 3,
          //or columns depending on layout
          collectionColumns: 0,
          //columns in horizontal layout, rows in vertical layout
          collectionLayout: "horizontal",
          //vertical
          collectionMode: !1,
          collectionTileSize: 800,
          collectionTileMargin: 80,
          //PERFORMANCE SETTINGS
          imageLoaderLimit: 0,
          maxImageCacheCount: 200,
          timeout: 3e4,
          useCanvas: !0,
          // Use canvas element for drawing if available
          tileRetryMax: 0,
          tileRetryDelay: 2500,
          //INTERFACE RESOURCE SETTINGS
          prefixUrl: "/images/",
          navImages: {
            zoomIn: {
              REST: "zoomin_rest.png",
              GROUP: "zoomin_grouphover.png",
              HOVER: "zoomin_hover.png",
              DOWN: "zoomin_pressed.png"
            },
            zoomOut: {
              REST: "zoomout_rest.png",
              GROUP: "zoomout_grouphover.png",
              HOVER: "zoomout_hover.png",
              DOWN: "zoomout_pressed.png"
            },
            home: {
              REST: "home_rest.png",
              GROUP: "home_grouphover.png",
              HOVER: "home_hover.png",
              DOWN: "home_pressed.png"
            },
            fullpage: {
              REST: "fullpage_rest.png",
              GROUP: "fullpage_grouphover.png",
              HOVER: "fullpage_hover.png",
              DOWN: "fullpage_pressed.png"
            },
            rotateleft: {
              REST: "rotateleft_rest.png",
              GROUP: "rotateleft_grouphover.png",
              HOVER: "rotateleft_hover.png",
              DOWN: "rotateleft_pressed.png"
            },
            rotateright: {
              REST: "rotateright_rest.png",
              GROUP: "rotateright_grouphover.png",
              HOVER: "rotateright_hover.png",
              DOWN: "rotateright_pressed.png"
            },
            flip: {
              // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
              REST: "flip_rest.png",
              GROUP: "flip_grouphover.png",
              HOVER: "flip_hover.png",
              DOWN: "flip_pressed.png"
            },
            previous: {
              REST: "previous_rest.png",
              GROUP: "previous_grouphover.png",
              HOVER: "previous_hover.png",
              DOWN: "previous_pressed.png"
            },
            next: {
              REST: "next_rest.png",
              GROUP: "next_grouphover.png",
              HOVER: "next_hover.png",
              DOWN: "next_pressed.png"
            }
          },
          //DEVELOPER SETTINGS
          debugMode: !1,
          debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"],
          silenceMultiImageWarnings: !1
        },
        /**
         * TODO: get rid of this.  I can't see how it's required at all.  Looks
         *       like an early legacy code artifact.
         * @static
         * @ignore
         */
        SIGNAL: "----seadragon----",
        /**
         * Returns a function which invokes the method as if it were a method belonging to the object.
         * @function
         * @param {Object} object
         * @param {Function} method
         * @returns {Function}
         */
        delegate: function(r, s) {
          return function() {
            var l = arguments;
            return l === void 0 && (l = []), s.apply(r, l);
          };
        },
        /**
         * An enumeration of Browser vendors.
         * @static
         * @type {Object}
         * @property {Number} UNKNOWN
         * @property {Number} IE
         * @property {Number} FIREFOX
         * @property {Number} SAFARI
         * @property {Number} CHROME
         * @property {Number} OPERA
         * @property {Number} EDGE
         * @property {Number} CHROMEEDGE
         */
        BROWSERS: {
          UNKNOWN: 0,
          IE: 1,
          FIREFOX: 2,
          SAFARI: 3,
          CHROME: 4,
          OPERA: 5,
          EDGE: 6,
          CHROMEEDGE: 7
        },
        /**
         * An enumeration of when subpixel rounding should occur.
         * @static
         * @type {Object}
         * @property {Number} NEVER Never apply subpixel rounding for transparency.
         * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
         * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
         */
        SUBPIXEL_ROUNDING_OCCURRENCES: {
          NEVER: 0,
          ONLY_AT_REST: 1,
          ALWAYS: 2
        },
        /**
         * Keep track of which {@link Viewer}s have been created.
         * - Key: {@link Element} to which a Viewer is attached.
         * - Value: {@link Viewer} of the element defined by the key.
         * @private
         * @static
         * @type {Object}
         */
        _viewers: /* @__PURE__ */ new Map(),
        /**
          * Returns the {@link Viewer} attached to a given DOM element. If there is
          * no viewer attached to the provided element, undefined is returned.
          * @function
          * @param {String|Element} element Accepts an id or element.
          * @returns {Viewer} The viewer attached to the given element, or undefined.
          */
        getViewer: function(r) {
          return e._viewers.get(this.getElement(r));
        },
        /**
         * Returns a DOM Element for the given id or element.
         * @function
         * @param {String|Element} element Accepts an id or element.
         * @returns {Element} The element with the given id, null, or the element itself.
         */
        getElement: function(r) {
          return typeof r == "string" && (r = document.getElementById(r)), r;
        },
        /**
         * Determines the position of the upper-left corner of the element.
         * @function
         * @param {Element|String} element - the element we want the position for.
         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
         */
        getElementPosition: function(r) {
          var s = new e.Point(), l, d;
          for (r = e.getElement(r), l = e.getElementStyle(r).position === "fixed", d = n(r, l); d; )
            s.x += r.offsetLeft, s.y += r.offsetTop, l && (s = s.plus(e.getPageScroll())), r = d, l = e.getElementStyle(r).position === "fixed", d = n(r, l);
          return s;
        },
        /**
         * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
         * @function
         * @param {Element|String} element - the element we want the position for.
         * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
         */
        getElementOffset: function(r) {
          r = e.getElement(r);
          var s = r && r.ownerDocument, l, d, f = { top: 0, left: 0 };
          return s ? (l = s.documentElement, typeof r.getBoundingClientRect < "u" && (f = r.getBoundingClientRect()), d = s === s.window ? s : s.nodeType === 9 ? s.defaultView || s.parentWindow : !1, new e.Point(
            f.left + (d.pageXOffset || l.scrollLeft) - (l.clientLeft || 0),
            f.top + (d.pageYOffset || l.scrollTop) - (l.clientTop || 0)
          )) : new e.Point();
        },
        /**
         * Determines the height and width of the given element.
         * @function
         * @param {Element|String} element
         * @returns {OpenSeadragon.Point}
         */
        getElementSize: function(r) {
          return r = e.getElement(r), new e.Point(
            r.clientWidth,
            r.clientHeight
          );
        },
        /**
         * Returns the CSSStyle object for the given element.
         * @function
         * @param {Element|String} element
         * @returns {CSSStyle}
         */
        getElementStyle: document.documentElement.currentStyle ? function(r) {
          return r = e.getElement(r), r.currentStyle;
        } : function(r) {
          return r = e.getElement(r), window.getComputedStyle(r, "");
        },
        /**
         * Returns the property with the correct vendor prefix appended.
         * @param {String} property the property name
         * @returns {String} the property with the correct prefix or null if not
         * supported.
         */
        getCssPropertyWithVendorPrefix: function(r) {
          var s = {};
          return e.getCssPropertyWithVendorPrefix = function(l) {
            if (s[l] !== void 0)
              return s[l];
            var d = document.createElement("div").style, f = null;
            if (d[l] !== void 0)
              f = l;
            else
              for (var v = [
                "Webkit",
                "Moz",
                "MS",
                "O",
                "webkit",
                "moz",
                "ms",
                "o"
              ], y = e.capitalizeFirstLetter(l), T = 0; T < v.length; T++) {
                var w = v[T] + y;
                if (d[w] !== void 0) {
                  f = w;
                  break;
                }
              }
            return s[l] = f, f;
          }, e.getCssPropertyWithVendorPrefix(r);
        },
        /**
         * Capitalizes the first letter of a string
         * @param {String} string
         * @returns {String} The string with the first letter capitalized
         */
        capitalizeFirstLetter: function(r) {
          return r.charAt(0).toUpperCase() + r.slice(1);
        },
        /**
         * Compute the modulo of a number but makes sure to always return
         * a positive value (also known as Euclidean modulo).
         * @param {Number} number the number to compute the modulo of
         * @param {Number} modulo the modulo
         * @returns {Number} the result of the modulo of number
         */
        positiveModulo: function(r, s) {
          var l = r % s;
          return l < 0 && (l += s), l;
        },
        /**
         * Determines if a point is within the bounding rectangle of the given element (hit-test).
         * @function
         * @param {Element|String} element
         * @param {OpenSeadragon.Point} point
         * @returns {Boolean}
         */
        pointInElement: function(r, s) {
          r = e.getElement(r);
          var l = e.getElementOffset(r), d = e.getElementSize(r);
          return s.x >= l.x && s.x < l.x + d.x && s.y < l.y + d.y && s.y >= l.y;
        },
        /**
         * Gets the position of the mouse on the screen for a given event.
         * @function
         * @param {Event} [event]
         * @returns {OpenSeadragon.Point}
         */
        getMousePosition: function(r) {
          if (typeof r.pageX == "number")
            e.getMousePosition = function(s) {
              var l = new e.Point();
              return l.x = s.pageX, l.y = s.pageY, l;
            };
          else if (typeof r.clientX == "number")
            e.getMousePosition = function(s) {
              var l = new e.Point();
              return l.x = s.clientX + document.body.scrollLeft + document.documentElement.scrollLeft, l.y = s.clientY + document.body.scrollTop + document.documentElement.scrollTop, l;
            };
          else
            throw new Error(
              "Unknown event mouse position, no known technique."
            );
          return e.getMousePosition(r);
        },
        /**
         * Determines the page's current scroll position.
         * @function
         * @returns {OpenSeadragon.Point}
         */
        getPageScroll: function() {
          var r = document.documentElement || {}, s = document.body || {};
          if (typeof window.pageXOffset == "number")
            e.getPageScroll = function() {
              return new e.Point(
                window.pageXOffset,
                window.pageYOffset
              );
            };
          else if (s.scrollLeft || s.scrollTop)
            e.getPageScroll = function() {
              return new e.Point(
                document.body.scrollLeft,
                document.body.scrollTop
              );
            };
          else if (r.scrollLeft || r.scrollTop)
            e.getPageScroll = function() {
              return new e.Point(
                document.documentElement.scrollLeft,
                document.documentElement.scrollTop
              );
            };
          else
            return new e.Point(0, 0);
          return e.getPageScroll();
        },
        /**
         * Set the page scroll position.
         * @function
         * @returns {OpenSeadragon.Point}
         */
        setPageScroll: function(r) {
          if (typeof window.scrollTo < "u")
            e.setPageScroll = function(d) {
              window.scrollTo(d.x, d.y);
            };
          else {
            var s = e.getPageScroll();
            if (s.x === r.x && s.y === r.y)
              return;
            document.body.scrollLeft = r.x, document.body.scrollTop = r.y;
            var l = e.getPageScroll();
            if (l.x !== s.x && l.y !== s.y) {
              e.setPageScroll = function(d) {
                document.body.scrollLeft = d.x, document.body.scrollTop = d.y;
              };
              return;
            }
            if (document.documentElement.scrollLeft = r.x, document.documentElement.scrollTop = r.y, l = e.getPageScroll(), l.x !== s.x && l.y !== s.y) {
              e.setPageScroll = function(d) {
                document.documentElement.scrollLeft = d.x, document.documentElement.scrollTop = d.y;
              };
              return;
            }
            e.setPageScroll = function(d) {
            };
          }
          e.setPageScroll(r);
        },
        /**
         * Determines the size of the browsers window.
         * @function
         * @returns {OpenSeadragon.Point}
         */
        getWindowSize: function() {
          var r = document.documentElement || {}, s = document.body || {};
          if (typeof window.innerWidth == "number")
            e.getWindowSize = function() {
              return new e.Point(
                window.innerWidth,
                window.innerHeight
              );
            };
          else if (r.clientWidth || r.clientHeight)
            e.getWindowSize = function() {
              return new e.Point(
                document.documentElement.clientWidth,
                document.documentElement.clientHeight
              );
            };
          else if (s.clientWidth || s.clientHeight)
            e.getWindowSize = function() {
              return new e.Point(
                document.body.clientWidth,
                document.body.clientHeight
              );
            };
          else
            throw new Error("Unknown window size, no known technique.");
          return e.getWindowSize();
        },
        /**
         * Wraps the given element in a nest of divs so that the element can
         * be easily centered using CSS tables
         * @function
         * @param {Element|String} element
         * @returns {Element} outermost wrapper element
         */
        makeCenteredNode: function(r) {
          r = e.getElement(r);
          var s = [
            e.makeNeutralElement("div"),
            e.makeNeutralElement("div"),
            e.makeNeutralElement("div")
          ];
          return e.extend(s[0].style, {
            display: "table",
            height: "100%",
            width: "100%"
          }), e.extend(s[1].style, {
            display: "table-row"
          }), e.extend(s[2].style, {
            display: "table-cell",
            verticalAlign: "middle",
            textAlign: "center"
          }), s[0].appendChild(s[1]), s[1].appendChild(s[2]), s[2].appendChild(r), s[0];
        },
        /**
         * Creates an easily positionable element of the given type that therefor
         * serves as an excellent container element.
         * @function
         * @param {String} tagName
         * @returns {Element}
         */
        makeNeutralElement: function(r) {
          var s = document.createElement(r), l = s.style;
          return l.background = "transparent none", l.border = "none", l.margin = "0px", l.padding = "0px", l.position = "static", s;
        },
        /**
         * Returns the current milliseconds, using Date.now() if available
         * @function
         */
        now: function() {
          return Date.now ? e.now = Date.now : e.now = function() {
            return (/* @__PURE__ */ new Date()).getTime();
          }, e.now();
        },
        /**
         * Ensures an image is loaded correctly to support alpha transparency.
         * @function
         * @param {String} src
         * @returns {Element}
         */
        makeTransparentImage: function(r) {
          var s = e.makeNeutralElement("img");
          return s.src = r, s;
        },
        /**
         * Sets the opacity of the specified element.
         * @function
         * @param {Element|String} element
         * @param {Number} opacity
         * @param {Boolean} [usesAlpha]
         */
        setElementOpacity: function(r, s, l) {
          var d, f;
          r = e.getElement(r), l && !e.Browser.alpha && (s = Math.round(s)), e.Browser.opacity ? r.style.opacity = s < 1 ? s : "" : s < 1 ? (d = Math.round(100 * s), f = "alpha(opacity=" + d + ")", r.style.filter = f) : r.style.filter = "";
        },
        /**
         * Sets the specified element's touch-action style attribute to 'none'.
         * @function
         * @param {Element|String} element
         */
        setElementTouchActionNone: function(r) {
          r = e.getElement(r), typeof r.style.touchAction < "u" ? r.style.touchAction = "none" : typeof r.style.msTouchAction < "u" && (r.style.msTouchAction = "none");
        },
        /**
         * Sets the specified element's pointer-events style attribute to the passed value.
         * @function
         * @param {Element|String} element
         * @param {String} value
         */
        setElementPointerEvents: function(r, s) {
          r = e.getElement(r), typeof r.style < "u" && typeof r.style.pointerEvents < "u" && (r.style.pointerEvents = s);
        },
        /**
         * Sets the specified element's pointer-events style attribute to 'none'.
         * @function
         * @param {Element|String} element
         */
        setElementPointerEventsNone: function(r) {
          e.setElementPointerEvents(r, "none");
        },
        /**
         * Add the specified CSS class to the element if not present.
         * @function
         * @param {Element|String} element
         * @param {String} className
         */
        addClass: function(r, s) {
          r = e.getElement(r), r.className ? (" " + r.className + " ").indexOf(" " + s + " ") === -1 && (r.className += " " + s) : r.className = s;
        },
        /**
         * Find the first index at which an element is found in an array or -1
         * if not present.
         *
         * Code taken and adapted from
         * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
         *
         * @function
         * @param {Array} array The array from which to find the element
         * @param {Object} searchElement The element to find
         * @param {Number} [fromIndex=0] Index to start research.
         * @returns {Number} The index of the element in the array.
         */
        indexOf: function(r, s, l) {
          return Array.prototype.indexOf ? this.indexOf = function(d, f, v) {
            return d.indexOf(f, v);
          } : this.indexOf = function(d, f, v) {
            var y, T = v || 0, w;
            if (!d)
              throw new TypeError();
            if (w = d.length, w === 0 || T >= w)
              return -1;
            for (T < 0 && (T = w - Math.abs(T)), y = T; y < w; y++)
              if (d[y] === f)
                return y;
            return -1;
          }, this.indexOf(r, s, l);
        },
        /**
         * Remove the specified CSS class from the element.
         * @function
         * @param {Element|String} element
         * @param {String} className
         */
        removeClass: function(r, s) {
          var l, d = [], f;
          for (r = e.getElement(r), l = r.className.split(/\s+/), f = 0; f < l.length; f++)
            l[f] && l[f] !== s && d.push(l[f]);
          r.className = d.join(" ");
        },
        /**
         * Convert passed addEventListener() options to boolean or options object,
         * depending on browser support.
         * @function
         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
         * @param {Boolean} [options.capture]
         * @param {Boolean} [options.passive]
         * @param {Boolean} [options.once]
         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
         */
        normalizeEventListenerOptions: function(r) {
          var s;
          return typeof r < "u" ? typeof r == "boolean" ? s = e.supportsEventListenerOptions ? { capture: r } : r : s = e.supportsEventListenerOptions ? r : typeof r.capture < "u" ? r.capture : !1 : s = e.supportsEventListenerOptions ? { capture: !1 } : !1, s;
        },
        /**
         * Adds an event listener for the given element, eventName and handler.
         * @function
         * @param {Element|String} element
         * @param {String} eventName
         * @param {Function} handler
         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
         * @param {Boolean} [options.capture]
         * @param {Boolean} [options.passive]
         * @param {Boolean} [options.once]
         */
        addEvent: function() {
          if (e.supportsAddEventListener)
            return function(r, s, l, d) {
              d = e.normalizeEventListenerOptions(d), r = e.getElement(r), r.addEventListener(s, l, d);
            };
          if (document.documentElement.attachEvent && document.attachEvent)
            return function(r, s, l) {
              r = e.getElement(r), r.attachEvent("on" + s, l);
            };
          throw new Error("No known event model.");
        }(),
        /**
         * Remove a given event listener for the given element, event type and
         * handler.
         * @function
         * @param {Element|String} element
         * @param {String} eventName
         * @param {Function} handler
         * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
         * @param {Boolean} [options.capture]
         */
        removeEvent: function() {
          if (e.supportsRemoveEventListener)
            return function(r, s, l, d) {
              d = e.normalizeEventListenerOptions(d), r = e.getElement(r), r.removeEventListener(s, l, d);
            };
          if (document.documentElement.detachEvent && document.detachEvent)
            return function(r, s, l) {
              r = e.getElement(r), r.detachEvent("on" + s, l);
            };
          throw new Error("No known event model.");
        }(),
        /**
         * Cancels the default browser behavior had the event propagated all
         * the way up the DOM to the window object.
         * @function
         * @param {Event} [event]
         */
        cancelEvent: function(r) {
          r.preventDefault();
        },
        /**
         * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
         * the event, otherwise returns false.
         * @function
         * @param {Event} [event]
         */
        eventIsCanceled: function(r) {
          return r.defaultPrevented;
        },
        /**
         * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
         * @function
         * @param {Event} [event]
         */
        stopEvent: function(r) {
          r.stopPropagation();
        },
        /**
         * Similar to OpenSeadragon.delegate, but it does not immediately call
         * the method on the object, returning a function which can be called
         * repeatedly to delegate the method. It also allows additional arguments
         * to be passed during construction which will be added during each
         * invocation, and each invocation can add additional arguments as well.
         *
         * @function
         * @param {Object} object
         * @param {Function} method
         * @param [args] any additional arguments are passed as arguments to the
         *  created callback
         * @returns {Function}
         */
        createCallback: function(r, s) {
          var l = [], d;
          for (d = 2; d < arguments.length; d++)
            l.push(arguments[d]);
          return function() {
            var f = l.concat([]), v;
            for (v = 0; v < arguments.length; v++)
              f.push(arguments[v]);
            return s.apply(r, f);
          };
        },
        /**
         * Retrieves the value of a url parameter from the window.location string.
         * @function
         * @param {String} key
         * @returns {String} The value of the url parameter or null if no param matches.
         */
        getUrlParameter: function(r) {
          var s = h[r];
          return s || null;
        },
        /**
         * Retrieves the protocol used by the url. The url can either be absolute
         * or relative.
         * @function
         * @private
         * @param {String} url The url to retrieve the protocol from.
         * @returns {String} The protocol (http:, https:, file:, ftp: ...)
         */
        getUrlProtocol: function(r) {
          var s = r.match(/^([a-z]+:)\/\//i);
          return s === null ? window.location.protocol : s[1].toLowerCase();
        },
        /**
         * Create an XHR object
         * @private
         * @param {type} [local] If set to true, the XHR will be file: protocol
         * compatible if possible (but may raise a warning in the browser).
         * @returns {XMLHttpRequest}
         */
        createAjaxRequest: function(r) {
          var s;
          try {
            s = !!new ActiveXObject("Microsoft.XMLHTTP");
          } catch {
            s = !1;
          }
          if (s)
            window.XMLHttpRequest ? e.createAjaxRequest = function(l) {
              return l ? new ActiveXObject("Microsoft.XMLHTTP") : new XMLHttpRequest();
            } : e.createAjaxRequest = function() {
              return new ActiveXObject("Microsoft.XMLHTTP");
            };
          else if (window.XMLHttpRequest)
            e.createAjaxRequest = function() {
              return new XMLHttpRequest();
            };
          else
            throw new Error("Browser doesn't support XMLHttpRequest.");
          return e.createAjaxRequest(r);
        },
        /**
         * Makes an AJAX request.
         * @param {Object} options
         * @param {String} options.url - the url to request
         * @param {Function} options.success - a function to call on a successful response
         * @param {Function} options.error - a function to call on when an error occurs
         * @param {Object} options.headers - headers to add to the AJAX request
         * @param {String} options.responseType - the response type of the AJAX request
         * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
         *      see TileSource::getPostData), GET method used if null
         * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
         * @throws {Error}
         * @returns {XMLHttpRequest}
         */
        makeAjaxRequest: function(r, s, l) {
          var d, f, v, y;
          e.isPlainObject(r) && (s = r.success, l = r.error, d = r.withCredentials, f = r.headers, v = r.responseType || null, y = r.postData || null, r = r.url);
          var T = e.getUrlProtocol(r), w = e.createAjaxRequest(T === "file:");
          if (!e.isFunction(s))
            throw new Error("makeAjaxRequest requires a success callback");
          w.onreadystatechange = function() {
            w.readyState === 4 && (w.onreadystatechange = function() {
            }, w.status >= 200 && w.status < 300 || w.status === 0 && T !== "http:" && T !== "https:" ? s(w) : e.isFunction(l) ? l(w) : e.console.error("AJAX request returned %d: %s", w.status, r));
          };
          var x = y ? "POST" : "GET";
          try {
            if (w.open(x, r, !0), v && (w.responseType = v), f)
              for (var P in f)
                Object.prototype.hasOwnProperty.call(f, P) && f[P] && w.setRequestHeader(P, f[P]);
            d && (w.withCredentials = !0), w.send(y);
          } catch (C) {
            e.console.error("%s while making AJAX request: %s", C.name, C.message), w.onreadystatechange = function() {
            }, e.isFunction(l) && l(w, C);
          }
          return w;
        },
        /**
         * Taken from jQuery 1.6.1
         * @function
         * @param {Object} options
         * @param {String} options.url
         * @param {Function} options.callback
         * @param {String} [options.param='callback'] The name of the url parameter
         *      to request the jsonp provider with.
         * @param {String} [options.callbackName=] The name of the callback to
         *      request the jsonp provider with.
         */
        jsonp: function(r) {
          var s, l = r.url, d = document.head || document.getElementsByTagName("head")[0] || document.documentElement, f = r.callbackName || "openseadragon" + e.now(), v = window[f], y = "$1" + f + "$2", T = r.param || "callback", w = r.callback;
          l = l.replace(/(=)\?(&|$)|\?\?/i, y), l += (/\?/.test(l) ? "&" : "?") + T + "=" + f, window[f] = function(x) {
            if (v)
              window[f] = v;
            else
              try {
                delete window[f];
              } catch {
              }
            w && e.isFunction(w) && w(x);
          }, s = document.createElement("script"), (r.async !== void 0 || r.async !== !1) && (s.async = "async"), r.scriptCharset && (s.charset = r.scriptCharset), s.src = l, s.onload = s.onreadystatechange = function(x, P) {
            (P || !s.readyState || /loaded|complete/.test(s.readyState)) && (s.onload = s.onreadystatechange = null, d && s.parentNode && d.removeChild(s), s = void 0);
          }, d.insertBefore(s, d.firstChild);
        },
        /**
         * Fully deprecated. Will throw an error.
         * @function
         * @deprecated use {@link OpenSeadragon.Viewer#open}
         */
        createFromDZI: function() {
          throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
        },
        /**
         * Parses an XML string into a DOM Document.
         * @function
         * @param {String} string
         * @returns {Document}
         */
        parseXml: function(r) {
          if (window.DOMParser)
            e.parseXml = function(s) {
              var l = null, d;
              return d = new DOMParser(), l = d.parseFromString(s, "text/xml"), l;
            };
          else if (window.ActiveXObject)
            e.parseXml = function(s) {
              var l = null;
              return l = new ActiveXObject("Microsoft.XMLDOM"), l.async = !1, l.loadXML(s), l;
            };
          else
            throw new Error("Browser doesn't support XML DOM.");
          return e.parseXml(r);
        },
        /**
         * Parses a JSON string into a Javascript object.
         * @function
         * @param {String} string
         * @returns {Object}
         */
        parseJSON: function(r) {
          return e.parseJSON = window.JSON.parse, e.parseJSON(r);
        },
        /**
         * Reports whether the image format is supported for tiling in this
         * version.
         * @function
         * @param {String} [extension]
         * @returns {Boolean}
         */
        imageFormatSupported: function(r) {
          return r = r || "", !!o[r.toLowerCase()];
        },
        /**
         * Updates supported image formats with user-specified values.
         * Preexisting formats that are not being updated are left unchanged.
         * By default, the defined formats are
         * <pre><code>{
         *      bmp:  false,
         *      jpeg: true,
         *      jpg:  true,
         *      png:  true,
         *      tif:  false,
         *      wdp:  false
         * }
         * </code></pre>
         * @function
         * @example
         * // sets webp as supported and png as unsupported
         * setImageFormatsSupported({webp: true, png: false});
         * @param {Object} formats An object containing format extensions as
         * keys and booleans as values.
         */
        setImageFormatsSupported: function(r) {
          e.extend(o, r);
        }
      }
    );
    var i = function(r) {
    };
    e.console = window.console || {
      log: i,
      debug: i,
      info: i,
      warn: i,
      error: i,
      assert: i
    }, e.Browser = {
      vendor: e.BROWSERS.UNKNOWN,
      version: 0,
      alpha: !0
    };
    var o = {
      bmp: !1,
      jpeg: !0,
      jpg: !0,
      png: !0,
      tif: !1,
      wdp: !1
    }, h = {};
    (function() {
      var r = navigator.appVersion, s = navigator.userAgent, l;
      switch (navigator.appName) {
        case "Microsoft Internet Explorer":
          window.attachEvent && window.ActiveXObject && (e.Browser.vendor = e.BROWSERS.IE, e.Browser.version = parseFloat(
            s.substring(
              s.indexOf("MSIE") + 5,
              s.indexOf(";", s.indexOf("MSIE"))
            )
          ));
          break;
        case "Netscape":
          window.addEventListener && (s.indexOf("Edge") >= 0 ? (e.Browser.vendor = e.BROWSERS.EDGE, e.Browser.version = parseFloat(
            s.substring(s.indexOf("Edge") + 5)
          )) : s.indexOf("Edg") >= 0 ? (e.Browser.vendor = e.BROWSERS.CHROMEEDGE, e.Browser.version = parseFloat(
            s.substring(s.indexOf("Edg") + 4)
          )) : s.indexOf("Firefox") >= 0 ? (e.Browser.vendor = e.BROWSERS.FIREFOX, e.Browser.version = parseFloat(
            s.substring(s.indexOf("Firefox") + 8)
          )) : s.indexOf("Safari") >= 0 ? (e.Browser.vendor = s.indexOf("Chrome") >= 0 ? e.BROWSERS.CHROME : e.BROWSERS.SAFARI, e.Browser.version = parseFloat(
            s.substring(
              s.substring(0, s.indexOf("Safari")).lastIndexOf("/") + 1,
              s.indexOf("Safari")
            )
          )) : (l = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})"), l.exec(s) !== null && (e.Browser.vendor = e.BROWSERS.IE, e.Browser.version = parseFloat(RegExp.$1))));
          break;
        case "Opera":
          e.Browser.vendor = e.BROWSERS.OPERA, e.Browser.version = parseFloat(r);
          break;
      }
      var d = window.location.search.substring(1), f = d.split("&"), v, y, T;
      for (T = 0; T < f.length; T++)
        if (v = f[T], y = v.indexOf("="), y > 0) {
          var w = v.substring(0, y), x = v.substring(y + 1);
          try {
            h[w] = decodeURIComponent(x);
          } catch {
            e.console.error("Ignoring malformed URL parameter: %s=%s", w, x);
          }
        }
      e.Browser.alpha = !(e.Browser.vendor === e.BROWSERS.CHROME && e.Browser.version < 2), e.Browser.opacity = !0, e.Browser.vendor === e.BROWSERS.IE && e.Browser.version < 11 && e.console.error("Internet Explorer versions < 11 are not supported by OpenSeadragon");
    })(), function(r) {
      var s = r.requestAnimationFrame || r.mozRequestAnimationFrame || r.webkitRequestAnimationFrame || r.msRequestAnimationFrame, l = r.cancelAnimationFrame || r.mozCancelAnimationFrame || r.webkitCancelAnimationFrame || r.msCancelAnimationFrame;
      if (s && l)
        e.requestAnimationFrame = function() {
          return s.apply(r, arguments);
        }, e.cancelAnimationFrame = function() {
          return l.apply(r, arguments);
        };
      else {
        var d = [], f = [], v = 0, y;
        e.requestAnimationFrame = function(T) {
          return d.push([++v, T]), y || (y = setInterval(function() {
            if (d.length) {
              var w = e.now(), x = f;
              for (f = d, d = x; f.length; )
                f.shift()[1](w);
            } else
              clearInterval(y), y = void 0;
          }, 1e3 / 50)), v;
        }, e.cancelAnimationFrame = function(T) {
          var w, x;
          for (w = 0, x = d.length; w < x; w += 1)
            if (d[w][0] === T) {
              d.splice(w, 1);
              return;
            }
          for (w = 0, x = f.length; w < x; w += 1)
            if (f[w][0] === T) {
              f.splice(w, 1);
              return;
            }
        };
      }
    }(window);
    function n(r, s) {
      return s && r !== document.body ? document.body : r.offsetParent;
    }
  }(D), function(e, t) {
    B.exports ? B.exports = t() : e.OpenSeadragon = t();
  }(Ae, function() {
    return D;
  }), function(e) {
    var t = {
      supportsFullScreen: !1,
      isFullScreen: function() {
        return !1;
      },
      getFullScreenElement: function() {
        return null;
      },
      requestFullScreen: function() {
      },
      exitFullScreen: function() {
      },
      cancelFullScreen: function() {
      },
      fullScreenEventName: "",
      fullScreenErrorEventName: ""
    };
    document.exitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
      return document.fullscreenElement;
    }, t.requestFullScreen = function(i) {
      return i.requestFullscreen();
    }, t.exitFullScreen = function() {
      document.exitFullscreen();
    }, t.fullScreenEventName = "fullscreenchange", t.fullScreenErrorEventName = "fullscreenerror") : document.msExitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
      return document.msFullscreenElement;
    }, t.requestFullScreen = function(i) {
      return i.msRequestFullscreen();
    }, t.exitFullScreen = function() {
      document.msExitFullscreen();
    }, t.fullScreenEventName = "MSFullscreenChange", t.fullScreenErrorEventName = "MSFullscreenError") : document.webkitExitFullscreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
      return document.webkitFullscreenElement;
    }, t.requestFullScreen = function(i) {
      return i.webkitRequestFullscreen();
    }, t.exitFullScreen = function() {
      document.webkitExitFullscreen();
    }, t.fullScreenEventName = "webkitfullscreenchange", t.fullScreenErrorEventName = "webkitfullscreenerror") : document.webkitCancelFullScreen ? (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
      return document.webkitCurrentFullScreenElement;
    }, t.requestFullScreen = function(i) {
      return i.webkitRequestFullScreen();
    }, t.exitFullScreen = function() {
      document.webkitCancelFullScreen();
    }, t.fullScreenEventName = "webkitfullscreenchange", t.fullScreenErrorEventName = "webkitfullscreenerror") : document.mozCancelFullScreen && (t.supportsFullScreen = !0, t.getFullScreenElement = function() {
      return document.mozFullScreenElement;
    }, t.requestFullScreen = function(i) {
      return i.mozRequestFullScreen();
    }, t.exitFullScreen = function() {
      document.mozCancelFullScreen();
    }, t.fullScreenEventName = "mozfullscreenchange", t.fullScreenErrorEventName = "mozfullscreenerror"), t.isFullScreen = function() {
      return t.getFullScreenElement() !== null;
    }, t.cancelFullScreen = function() {
      e.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead."), t.exitFullScreen();
    }, e.extend(e, t);
  }(D), function(e) {
    e.EventSource = function() {
      this.events = {};
    }, e.EventSource.prototype = {
      /**
       * Add an event handler to be triggered only once (or a given number of times)
       * for a given event. It is not removable with removeHandler().
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {OpenSeadragon.EventHandler} handler - Function to call when event
       * is triggered.
       * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
       * to the handler.
       * @param {Number} [times=1] - The number of times to handle the event
       * before removing it.
       * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
       */
      addOnceHandler: function(t, i, o, h, n) {
        var r = this;
        h = h || 1;
        var s = 0, l = function(d) {
          return s++, s === h && r.removeHandler(t, l), i(d);
        };
        this.addHandler(t, l, o, n);
      },
      /**
       * Add an event handler for a given event.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
       * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
       * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
       */
      addHandler: function(t, i, o, h) {
        var n = this.events[t];
        if (n || (this.events[t] = n = []), i && e.isFunction(i)) {
          var r = n.length, s = { handler: i, userData: o || null, priority: h || 0 };
          for (n[r] = s; r > 0 && n[r - 1].priority < n[r].priority; )
            n[r] = n[r - 1], n[r - 1] = s, r--;
        }
      },
      /**
       * Remove a specific event handler for a given event.
       * @function
       * @param {String} eventName - Name of event for which the handler is to be removed.
       * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
       */
      removeHandler: function(t, i) {
        var o = this.events[t], h = [], n;
        if (o && e.isArray(o)) {
          for (n = 0; n < o.length; n++)
            o[n].handler !== i && h.push(o[n]);
          this.events[t] = h;
        }
      },
      /**
       * Get the amount of handlers registered for a given event.
       * @param {String} eventName - Name of event to inspect.
       * @returns {number} amount of events
       */
      numberOfHandlers: function(t) {
        var i = this.events[t];
        return i ? i.length : 0;
      },
      /**
       * Remove all event handlers for a given event type. If no type is given all
       * event handlers for every event type are removed.
       * @function
       * @param {String} eventName - Name of event for which all handlers are to be removed.
       */
      removeAllHandlers: function(t) {
        if (t)
          this.events[t] = [];
        else
          for (var i in this.events)
            this.events[i] = [];
      },
      /**
       * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
       * @function
       * @param {String} eventName - Name of event to get handlers for.
       */
      getHandler: function(t) {
        var i = this.events[t];
        return !i || !i.length ? null : (i = i.length === 1 ? [i[0]] : Array.apply(null, i), function(o, h) {
          var n, r = i.length;
          for (n = 0; n < r; n++)
            i[n] && (h.eventSource = o, h.userData = i[n].userData, i[n].handler(h));
        });
      },
      /**
       * Trigger an event, optionally passing additional information.
       * @function
       * @param {String} eventName - Name of event to register.
       * @param {Object} eventArgs - Event-specific data.
       */
      raiseEvent: function(t, i) {
        var o = this.getHandler(t);
        if (o)
          return o(this, i || {});
      }
    };
  }(D), function(e) {
    var t = {};
    e.MouseTracker = function(c) {
      var u = arguments;
      e.isPlainObject(c) || (c = {
        element: u[0],
        clickTimeThreshold: u[1],
        clickDistThreshold: u[2]
      }), this.hash = Math.random(), this.element = e.getElement(c.element), this.clickTimeThreshold = c.clickTimeThreshold || e.DEFAULT_SETTINGS.clickTimeThreshold, this.clickDistThreshold = c.clickDistThreshold || e.DEFAULT_SETTINGS.clickDistThreshold, this.dblClickTimeThreshold = c.dblClickTimeThreshold || e.DEFAULT_SETTINGS.dblClickTimeThreshold, this.dblClickDistThreshold = c.dblClickDistThreshold || e.DEFAULT_SETTINGS.dblClickDistThreshold, this.userData = c.userData || null, this.stopDelay = c.stopDelay || 50, this.preProcessEventHandler = c.preProcessEventHandler || null, this.contextMenuHandler = c.contextMenuHandler || null, this.enterHandler = c.enterHandler || null, this.leaveHandler = c.leaveHandler || null, this.exitHandler = c.exitHandler || null, this.overHandler = c.overHandler || null, this.outHandler = c.outHandler || null, this.pressHandler = c.pressHandler || null, this.nonPrimaryPressHandler = c.nonPrimaryPressHandler || null, this.releaseHandler = c.releaseHandler || null, this.nonPrimaryReleaseHandler = c.nonPrimaryReleaseHandler || null, this.moveHandler = c.moveHandler || null, this.scrollHandler = c.scrollHandler || null, this.clickHandler = c.clickHandler || null, this.dblClickHandler = c.dblClickHandler || null, this.dragHandler = c.dragHandler || null, this.dragEndHandler = c.dragEndHandler || null, this.pinchHandler = c.pinchHandler || null, this.stopHandler = c.stopHandler || null, this.keyDownHandler = c.keyDownHandler || null, this.keyUpHandler = c.keyUpHandler || null, this.keyHandler = c.keyHandler || null, this.focusHandler = c.focusHandler || null, this.blurHandler = c.blurHandler || null;
      var p = this;
      t[this.hash] = {
        click: function(m) {
          C(p, m);
        },
        dblclick: function(m) {
          A(p, m);
        },
        keydown: function(m) {
          W(p, m);
        },
        keyup: function(m) {
          k(p, m);
        },
        keypress: function(m) {
          U(p, m);
        },
        focus: function(m) {
          H(p, m);
        },
        blur: function(m) {
          M(p, m);
        },
        contextmenu: function(m) {
          X(p, m);
        },
        wheel: function(m) {
          Z(p, m);
        },
        mousewheel: function(m) {
          Y(p, m);
        },
        DOMMouseScroll: function(m) {
          Y(p, m);
        },
        MozMousePixelScroll: function(m) {
          Y(p, m);
        },
        losecapture: function(m) {
          te(p, m);
        },
        mouseenter: function(m) {
          N(p, m);
        },
        mouseleave: function(m) {
          fe(p, m);
        },
        mouseover: function(m) {
          pe(p, m);
        },
        mouseout: function(m) {
          ge(p, m);
        },
        mousedown: function(m) {
          le(p, m);
        },
        mouseup: function(m) {
          me(p, m);
        },
        mousemove: function(m) {
          ye(p, m);
        },
        touchstart: function(m) {
          ce(p, m);
        },
        touchend: function(m) {
          ee(p, m);
        },
        touchmove: function(m) {
          ie(p, m);
        },
        touchcancel: function(m) {
          re(p, m);
        },
        gesturestart: function(m) {
          oe(p, m);
        },
        // Safari/Safari iOS
        gesturechange: function(m) {
          se(p, m);
        },
        // Safari/Safari iOS
        gotpointercapture: function(m) {
          Te(p, m);
        },
        lostpointercapture: function(m) {
          xe(p, m);
        },
        pointerenter: function(m) {
          N(p, m);
        },
        pointerleave: function(m) {
          fe(p, m);
        },
        pointerover: function(m) {
          pe(p, m);
        },
        pointerout: function(m) {
          ge(p, m);
        },
        pointerdown: function(m) {
          le(p, m);
        },
        pointerup: function(m) {
          me(p, m);
        },
        pointermove: function(m) {
          ye(p, m);
        },
        pointercancel: function(m) {
          Pe(p, m);
        },
        pointerupcaptured: function(m) {
          Se(p, m);
        },
        pointermovecaptured: function(m) {
          Ee(p, m);
        },
        tracking: !1,
        // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
        // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
        // Active pointers are any pointer being tracked for this element which are in the hit-test area
        //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
        activePointersLists: [],
        // Tracking for double-click gesture
        lastClickPos: null,
        dblClickTimeOut: null,
        // Tracking for pinch gesture
        pinchGPoints: [],
        lastPinchDist: 0,
        currentPinchDist: 0,
        lastPinchCenter: null,
        currentPinchCenter: null,
        // Tracking for drag
        sentDragEvent: !1
      }, this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler), this.hasScrollHandler = !!this.scrollHandler, e.MouseTracker.havePointerEvents && e.setElementPointerEvents(this.element, "auto"), this.exitHandler && e.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead."), c.startDisabled || this.setTracking(!0);
    }, e.MouseTracker.prototype = {
      /**
       * Clean up any events or objects created by the tracker.
       * @function
       */
      destroy: function() {
        r(this), this.element = null, t[this.hash] = null, delete t[this.hash];
      },
      /**
       * Are we currently tracking events on this element.
       * @deprecated Just use this.tracking
       * @function
       * @returns {Boolean} Are we currently tracking events on this element.
       */
      isTracking: function() {
        return t[this.hash].tracking;
      },
      /**
       * Enable or disable whether or not we are tracking events on this element.
       * @function
       * @param {Boolean} track True to start tracking, false to stop tracking.
       * @returns {OpenSeadragon.MouseTracker} Chainable.
       */
      setTracking: function(c) {
        return c ? n(this) : r(this), this;
      },
      /**
       * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
       * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
       * @function
       * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
       * @returns {OpenSeadragon.MouseTracker.GesturePointList}
       */
      getActivePointersListByType: function(c) {
        var u = t[this.hash], p, m = u.activePointersLists.length, E;
        for (p = 0; p < m; p++)
          if (u.activePointersLists[p].type === c)
            return u.activePointersLists[p];
        return E = new e.MouseTracker.GesturePointList(c), u.activePointersLists.push(E), E;
      },
      /**
       * Returns the total number of pointers currently active on the tracked element.
       * @function
       * @returns {Number}
       */
      getActivePointerCount: function() {
        var c = t[this.hash], u, p = c.activePointersLists.length, m = 0;
        for (u = 0; u < p; u++)
          m += c.activePointersLists[u].getLength();
        return m;
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
       */
      preProcessEventHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the contextmenu event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      contextMenuHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      enterHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @since v2.5.0
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      leaveHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @deprecated v2.5.0 Use leaveHandler instead
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      exitHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @since v2.5.0
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      overHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @since v2.5.0
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Number} event.pointers
       *      Number of pointers (all types) active in the tracked element.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.buttonDownAny
       *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      outHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      pressHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.button
       *      Button which caused the event.
       *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      nonPrimaryPressHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.insideElementPressed
       *      True if the left mouse button is currently being pressed and was
       *      initiated inside the tracked element, otherwise false.
       * @param {Boolean} event.insideElementReleased
       *      True if the cursor inside the tracked element when the button was released.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      releaseHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.button
       *      Button which caused the event.
       *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      nonPrimaryReleaseHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      moveHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.scroll
       *      The scroll delta for the event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the wheel event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      scrollHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Boolean} event.quick
       *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Element} event.originalTarget
       *      The DOM element clicked on.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      clickHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      dblClickHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {OpenSeadragon.Point} event.delta
       *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
       * @param {Number} event.speed
       *     Current computed speed, in pixels per second.
       * @param {Number} event.direction
       *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      dragHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.speed
       *     Speed at the end of a drag gesture, in pixels per second.
       * @param {Number} event.direction
       *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      dragEndHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
       *      Gesture points associated with the gesture. Velocity data can be found here.
       * @param {OpenSeadragon.Point} event.lastCenter
       *      The previous center point of the two pinch contact points relative to the tracked element.
       * @param {OpenSeadragon.Point} event.center
       *      The center point of the two pinch contact points relative to the tracked element.
       * @param {Number} event.lastDistance
       *      The previous distance between the two pinch contact points in CSS pixels.
       * @param {Number} event.distance
       *      The distance between the two pinch contact points in CSS pixels.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      pinchHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {String} event.pointerType
       *     "mouse", "touch", "pen", etc.
       * @param {OpenSeadragon.Point} event.position
       *      The position of the event relative to the tracked element.
       * @param {Number} event.buttons
       *      Current buttons pressed.
       *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
       * @param {Boolean} event.isTouchEvent
       *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      stopHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Number} event.keyCode
       *      The key code that was pressed.
       * @param {Boolean} event.ctrl
       *      True if the ctrl key was pressed during this event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.alt
       *      True if the alt key was pressed during this event.
       * @param {Boolean} event.meta
       *      True if the meta key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the keydown event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      keyDownHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Number} event.keyCode
       *      The key code that was pressed.
       * @param {Boolean} event.ctrl
       *      True if the ctrl key was pressed during this event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.alt
       *      True if the alt key was pressed during this event.
       * @param {Boolean} event.meta
       *      True if the meta key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the keyup event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      keyUpHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Number} event.keyCode
       *      The key code that was pressed.
       * @param {Boolean} event.ctrl
       *      True if the ctrl key was pressed during this event.
       * @param {Boolean} event.shift
       *      True if the shift key was pressed during this event.
       * @param {Boolean} event.alt
       *      True if the alt key was pressed during this event.
       * @param {Boolean} event.meta
       *      True if the meta key was pressed during this event.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Boolean} event.preventDefault
       *      Set to true to prevent the default user-agent's handling of the keypress event.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      keyHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      focusHandler: function() {
      },
      /**
       * Implement or assign implementation to these handlers during or after
       * calling the constructor.
       * @function
       * @param {Object} event
       * @param {OpenSeadragon.MouseTracker} event.eventSource
       *      A reference to the tracker instance.
       * @param {Object} event.originalEvent
       *      The original event object.
       * @param {Object} event.userData
       *      Arbitrary user-defined object.
       */
      blurHandler: function() {
      }
    };
    var i = function() {
      try {
        return window.self !== window.top;
      } catch {
        return !0;
      }
    }();
    function o(c) {
      try {
        return c.addEventListener && c.removeEventListener;
      } catch {
        return !1;
      }
    }
    e.MouseTracker.gesturePointVelocityTracker = /* @__PURE__ */ function() {
      var c = [], u = 0, p = 0, m = function(V, z) {
        return V.hash.toString() + z.type + z.id.toString();
      }, E = function() {
        var V, z = c.length, Q, J, ue = e.now(), _e, Ce, Re;
        for (_e = ue - p, p = ue, V = 0; V < z; V++)
          Q = c[V], J = Q.gPoint, J.direction = Math.atan2(J.currentPos.y - Q.lastPos.y, J.currentPos.x - Q.lastPos.x), Ce = Q.lastPos.distanceTo(J.currentPos), Q.lastPos = J.currentPos, Re = 1e3 * Ce / (_e + 1), J.speed = 0.75 * Re + 0.25 * J.speed;
      }, R = function(V, z) {
        var Q = m(V, z);
        c.push(
          {
            guid: Q,
            gPoint: z,
            lastPos: z.currentPos
          }
        ), c.length === 1 && (p = e.now(), u = window.setInterval(E, 50));
      }, L = function(V, z) {
        var Q = m(V, z), J, ue = c.length;
        for (J = 0; J < ue; J++)
          if (c[J].guid === Q) {
            c.splice(J, 1), ue--, ue === 0 && window.clearInterval(u);
            break;
          }
      };
      return {
        addPoint: R,
        removePoint: L
      };
    }(), e.MouseTracker.captureElement = document, e.MouseTracker.wheelEventName = e.Browser.vendor === e.BROWSERS.IE && e.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : (
      // Modern browsers support 'wheel'
      document.onmousewheel !== void 0 ? "mousewheel" : (
        // Webkit and IE support at least 'mousewheel'
        "DOMMouseScroll"
      )
    ), e.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", e.MouseTracker.wheelEventName], e.MouseTracker.wheelEventName === "DOMMouseScroll" && e.MouseTracker.subscribeEvents.push("MozMousePixelScroll"), window.PointerEvent ? (e.MouseTracker.havePointerEvents = !0, e.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel"), e.MouseTracker.havePointerCapture = function() {
      var c = document.createElement("div");
      return e.isFunction(c.setPointerCapture) && e.isFunction(c.releasePointerCapture);
    }(), e.MouseTracker.havePointerCapture && e.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture")) : (e.MouseTracker.havePointerEvents = !1, e.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove"), e.MouseTracker.mousePointerId = "legacy-mouse", e.MouseTracker.havePointerCapture = function() {
      var c = document.createElement("div");
      return e.isFunction(c.setCapture) && e.isFunction(c.releaseCapture);
    }(), e.MouseTracker.havePointerCapture && e.MouseTracker.subscribeEvents.push("losecapture"), "ontouchstart" in window && e.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel"), "ongesturestart" in window && e.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange")), e.MouseTracker.GesturePointList = function(c) {
      this._gPoints = [], this.type = c, this.buttons = 0, this.contacts = 0, this.clicks = 0, this.captureCount = 0;
    }, e.MouseTracker.GesturePointList.prototype = {
      /**
       * @function
       * @returns {Number} Number of gesture points in the list.
       */
      getLength: function() {
        return this._gPoints.length;
      },
      /**
       * @function
       * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
       */
      asArray: function() {
        return this._gPoints;
      },
      /**
       * @function
       * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
       * @returns {Number} Number of gesture points in the list.
       */
      add: function(c) {
        return this._gPoints.push(c);
      },
      /**
       * @function
       * @param {Number} id - The id of the gesture point to remove from the list.
       * @returns {Number} Number of gesture points in the list.
       */
      removeById: function(c) {
        var u, p = this._gPoints.length;
        for (u = 0; u < p; u++)
          if (this._gPoints[u].id === c) {
            this._gPoints.splice(u, 1);
            break;
          }
        return this._gPoints.length;
      },
      /**
       * @function
       * @param {Number} index - The index of the gesture point to retrieve from the list.
       * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
       */
      getByIndex: function(c) {
        return c < this._gPoints.length ? this._gPoints[c] : null;
      },
      /**
       * @function
       * @param {Number} id - The id of the gesture point to retrieve from the list.
       * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
       */
      getById: function(c) {
        var u, p = this._gPoints.length;
        for (u = 0; u < p; u++)
          if (this._gPoints[u].id === c)
            return this._gPoints[u];
        return null;
      },
      /**
       * @function
       * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
       */
      getPrimary: function(c) {
        var u, p = this._gPoints.length;
        for (u = 0; u < p; u++)
          if (this._gPoints[u].isPrimary)
            return this._gPoints[u];
        return null;
      },
      /**
       * Increment this pointer list's contact count.
       * It will evaluate whether this pointer type is allowed to have multiple contacts.
       * @function
       */
      addContact: function() {
        ++this.contacts, this.contacts > 1 && (this.type === "mouse" || this.type === "pen") && (e.console.warn("GesturePointList.addContact() Implausible contacts value"), this.contacts = 1);
      },
      /**
       * Decrement this pointer list's contact count.
       * It will make sure the count does not go below 0.
       * @function
       */
      removeContact: function() {
        --this.contacts, this.contacts < 0 && (this.contacts = 0);
      }
    };
    function h(c) {
      var u = t[c.hash], p, m, E, R, L, V = u.activePointersLists.length;
      for (p = 0; p < V; p++)
        if (E = u.activePointersLists[p], E.getLength() > 0) {
          for (L = [], R = E.asArray(), m = 0; m < R.length; m++)
            L.push(R[m]);
          for (m = 0; m < L.length; m++)
            he(c, E, L[m]);
        }
      for (p = 0; p < V; p++)
        u.activePointersLists.pop();
      u.sentDragEvent = !1;
    }
    function n(c) {
      var u = t[c.hash], p, m;
      if (!u.tracking) {
        for (m = 0; m < e.MouseTracker.subscribeEvents.length; m++)
          p = e.MouseTracker.subscribeEvents[m], e.addEvent(
            c.element,
            p,
            u[p],
            p === e.MouseTracker.wheelEventName ? { passive: !1, capture: !1 } : !1
          );
        h(c), u.tracking = !0;
      }
    }
    function r(c) {
      var u = t[c.hash], p, m;
      if (u.tracking) {
        for (m = 0; m < e.MouseTracker.subscribeEvents.length; m++)
          p = e.MouseTracker.subscribeEvents[m], e.removeEvent(
            c.element,
            p,
            u[p],
            !1
          );
        h(c), u.tracking = !1;
      }
    }
    function s(c, u) {
      var p = t[c.hash];
      if (u === "pointerevent")
        return {
          upName: "pointerup",
          upHandler: p.pointerupcaptured,
          moveName: "pointermove",
          moveHandler: p.pointermovecaptured
        };
      if (u === "mouse")
        return {
          upName: "pointerup",
          upHandler: p.pointerupcaptured,
          moveName: "pointermove",
          moveHandler: p.pointermovecaptured
        };
      if (u === "touch")
        return {
          upName: "touchend",
          upHandler: p.touchendcaptured,
          moveName: "touchmove",
          moveHandler: p.touchmovecaptured
        };
      throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
    }
    function l(c, u) {
      var p;
      if (e.MouseTracker.havePointerCapture)
        if (e.MouseTracker.havePointerEvents)
          try {
            c.element.setPointerCapture(u.id);
          } catch {
            e.console.warn("setPointerCapture() called on invalid pointer ID");
            return;
          }
        else
          c.element.setCapture(!0);
      else
        p = s(c, e.MouseTracker.havePointerEvents ? "pointerevent" : u.type), i && o(window.top) && e.addEvent(
          window.top,
          p.upName,
          p.upHandler,
          !0
        ), e.addEvent(
          e.MouseTracker.captureElement,
          p.upName,
          p.upHandler,
          !0
        ), e.addEvent(
          e.MouseTracker.captureElement,
          p.moveName,
          p.moveHandler,
          !0
        );
      S(c, u, !0);
    }
    function d(c, u) {
      var p, m, E;
      if (e.MouseTracker.havePointerCapture)
        if (e.MouseTracker.havePointerEvents) {
          if (m = c.getActivePointersListByType(u.type), E = m.getById(u.id), !E || !E.captured)
            return;
          try {
            c.element.releasePointerCapture(u.id);
          } catch {
          }
        } else
          c.element.releaseCapture();
      else
        p = s(c, e.MouseTracker.havePointerEvents ? "pointerevent" : u.type), i && o(window.top) && e.removeEvent(
          window.top,
          p.upName,
          p.upHandler,
          !0
        ), e.removeEvent(
          e.MouseTracker.captureElement,
          p.moveName,
          p.moveHandler,
          !0
        ), e.removeEvent(
          e.MouseTracker.captureElement,
          p.upName,
          p.upHandler,
          !0
        );
      S(c, u, !1);
    }
    function f(c) {
      return e.MouseTracker.havePointerEvents ? c.pointerId : e.MouseTracker.mousePointerId;
    }
    function v(c) {
      return e.MouseTracker.havePointerEvents ? c.pointerType || (e.Browser.vendor === e.BROWSERS.IE ? "mouse" : "") : "mouse";
    }
    function y(c) {
      return e.MouseTracker.havePointerEvents ? c.isPrimary : !0;
    }
    function T(c) {
      return e.getMousePosition(c);
    }
    function w(c, u) {
      return x(T(c), u);
    }
    function x(c, u) {
      var p = e.getElementOffset(u);
      return c.minus(p);
    }
    function P(c, u) {
      return new e.Point((c.x + u.x) / 2, (c.y + u.y) / 2);
    }
    function C(c, u) {
      var p = {
        originalEvent: u,
        eventType: "click",
        pointerType: "mouse",
        isEmulated: !1
      };
      g(c, p), p.preventDefault && !p.defaultPrevented && e.cancelEvent(u), p.stopPropagation && e.stopEvent(u);
    }
    function A(c, u) {
      var p = {
        originalEvent: u,
        eventType: "dblclick",
        pointerType: "mouse",
        isEmulated: !1
      };
      g(c, p), p.preventDefault && !p.defaultPrevented && e.cancelEvent(u), p.stopPropagation && e.stopEvent(u);
    }
    function W(c, u) {
      var p = null, m = {
        originalEvent: u,
        eventType: "keydown",
        pointerType: "",
        isEmulated: !1
      };
      g(c, m), c.keyDownHandler && !m.preventGesture && !m.defaultPrevented && (p = {
        eventSource: c,
        keyCode: u.keyCode ? u.keyCode : u.charCode,
        ctrl: u.ctrlKey,
        shift: u.shiftKey,
        alt: u.altKey,
        meta: u.metaKey,
        originalEvent: u,
        preventDefault: m.preventDefault || m.defaultPrevented,
        userData: c.userData
      }, c.keyDownHandler(p)), (p && p.preventDefault || m.preventDefault && !m.defaultPrevented) && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function k(c, u) {
      var p = null, m = {
        originalEvent: u,
        eventType: "keyup",
        pointerType: "",
        isEmulated: !1
      };
      g(c, m), c.keyUpHandler && !m.preventGesture && !m.defaultPrevented && (p = {
        eventSource: c,
        keyCode: u.keyCode ? u.keyCode : u.charCode,
        ctrl: u.ctrlKey,
        shift: u.shiftKey,
        alt: u.altKey,
        meta: u.metaKey,
        originalEvent: u,
        preventDefault: m.preventDefault || m.defaultPrevented,
        userData: c.userData
      }, c.keyUpHandler(p)), (p && p.preventDefault || m.preventDefault && !m.defaultPrevented) && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function U(c, u) {
      var p = null, m = {
        originalEvent: u,
        eventType: "keypress",
        pointerType: "",
        isEmulated: !1
      };
      g(c, m), c.keyHandler && !m.preventGesture && !m.defaultPrevented && (p = {
        eventSource: c,
        keyCode: u.keyCode ? u.keyCode : u.charCode,
        ctrl: u.ctrlKey,
        shift: u.shiftKey,
        alt: u.altKey,
        meta: u.metaKey,
        originalEvent: u,
        preventDefault: m.preventDefault || m.defaultPrevented,
        userData: c.userData
      }, c.keyHandler(p)), (p && p.preventDefault || m.preventDefault && !m.defaultPrevented) && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function H(c, u) {
      var p = {
        originalEvent: u,
        eventType: "focus",
        pointerType: "",
        isEmulated: !1
      };
      g(c, p), c.focusHandler && !p.preventGesture && c.focusHandler(
        {
          eventSource: c,
          originalEvent: u,
          userData: c.userData
        }
      );
    }
    function M(c, u) {
      var p = {
        originalEvent: u,
        eventType: "blur",
        pointerType: "",
        isEmulated: !1
      };
      g(c, p), c.blurHandler && !p.preventGesture && c.blurHandler(
        {
          eventSource: c,
          originalEvent: u,
          userData: c.userData
        }
      );
    }
    function X(c, u) {
      var p = null, m = {
        originalEvent: u,
        eventType: "contextmenu",
        pointerType: "mouse",
        isEmulated: !1
      };
      g(c, m), c.contextMenuHandler && !m.preventGesture && !m.defaultPrevented && (p = {
        eventSource: c,
        position: x(T(u), c.element),
        originalEvent: m.originalEvent,
        preventDefault: m.preventDefault || m.defaultPrevented,
        userData: c.userData
      }, c.contextMenuHandler(p)), (p && p.preventDefault || m.preventDefault && !m.defaultPrevented) && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function Z(c, u) {
      $(c, u, u);
    }
    function Y(c, u) {
      var p = {
        target: u.target || u.srcElement,
        type: "wheel",
        shiftKey: u.shiftKey || !1,
        clientX: u.clientX,
        clientY: u.clientY,
        pageX: u.pageX ? u.pageX : u.clientX,
        pageY: u.pageY ? u.pageY : u.clientY,
        deltaMode: u.type === "MozMousePixelScroll" ? 0 : 1,
        // 0=pixel, 1=line, 2=page
        deltaX: 0,
        deltaZ: 0
      };
      e.MouseTracker.wheelEventName === "mousewheel" ? p.deltaY = -u.wheelDelta / e.DEFAULT_SETTINGS.pixelsPerWheelLine : p.deltaY = u.detail, $(c, p, u);
    }
    function $(c, u, p) {
      var m = 0, E, R = null;
      m = u.deltaY < 0 ? 1 : -1, E = {
        originalEvent: u,
        eventType: "wheel",
        pointerType: "mouse",
        isEmulated: u !== p
      }, g(c, E), c.scrollHandler && !E.preventGesture && !E.defaultPrevented && (R = {
        eventSource: c,
        pointerType: "mouse",
        position: w(u, c.element),
        scroll: m,
        shift: u.shiftKey,
        isTouchEvent: !1,
        originalEvent: p,
        preventDefault: E.preventDefault || E.defaultPrevented,
        userData: c.userData
      }, c.scrollHandler(R)), E.stopPropagation && e.stopEvent(p), (R && R.preventDefault || E.preventDefault && !E.defaultPrevented) && e.cancelEvent(p);
    }
    function te(c, u) {
      var p = {
        id: e.MouseTracker.mousePointerId,
        type: "mouse"
      }, m = {
        originalEvent: u,
        eventType: "lostpointercapture",
        pointerType: "mouse",
        isEmulated: !1
      };
      g(c, m), u.target === c.element && S(c, p, !1), m.stopPropagation && e.stopEvent(u);
    }
    function ce(c, u) {
      var p, m, E = u.changedTouches.length, R, L = c.getActivePointersListByType("touch");
      p = e.now(), L.getLength() > u.touches.length - E && e.console.warn("Tracked touch contact count doesn't match event.touches.length");
      var V = {
        originalEvent: u,
        eventType: "pointerdown",
        pointerType: "touch",
        isEmulated: !1
      };
      for (g(c, V), m = 0; m < E; m++)
        R = {
          id: u.changedTouches[m].identifier,
          type: "touch",
          // Simulate isPrimary
          isPrimary: L.getLength() === 0,
          currentPos: T(u.changedTouches[m]),
          currentTime: p
        }, b(c, V, R), G(c, V, R, 0), S(c, R, !0);
      V.preventDefault && !V.defaultPrevented && e.cancelEvent(u), V.stopPropagation && e.stopEvent(u);
    }
    function ee(c, u) {
      var p, m, E = u.changedTouches.length, R;
      p = e.now();
      var L = {
        originalEvent: u,
        eventType: "pointerup",
        pointerType: "touch",
        isEmulated: !1
      };
      for (g(c, L), m = 0; m < E; m++)
        R = {
          id: u.changedTouches[m].identifier,
          type: "touch",
          currentPos: T(u.changedTouches[m]),
          currentTime: p
        }, j(c, L, R, 0), S(c, R, !1), _(c, L, R);
      L.preventDefault && !L.defaultPrevented && e.cancelEvent(u), L.stopPropagation && e.stopEvent(u);
    }
    function ie(c, u) {
      var p, m, E = u.changedTouches.length, R;
      p = e.now();
      var L = {
        originalEvent: u,
        eventType: "pointermove",
        pointerType: "touch",
        isEmulated: !1
      };
      for (g(c, L), m = 0; m < E; m++)
        R = {
          id: u.changedTouches[m].identifier,
          type: "touch",
          currentPos: T(u.changedTouches[m]),
          currentTime: p
        }, q(c, L, R);
      L.preventDefault && !L.defaultPrevented && e.cancelEvent(u), L.stopPropagation && e.stopEvent(u);
    }
    function re(c, u) {
      var p = u.changedTouches.length, m, E, R = {
        originalEvent: u,
        eventType: "pointercancel",
        pointerType: "touch",
        isEmulated: !1
      };
      for (g(c, R), m = 0; m < p; m++)
        E = {
          id: u.changedTouches[m].identifier,
          type: "touch"
        }, F(c, R, E);
      R.stopPropagation && e.stopEvent(u);
    }
    function oe(c, u) {
      return e.eventIsCanceled(u) || u.preventDefault(), !1;
    }
    function se(c, u) {
      return e.eventIsCanceled(u) || u.preventDefault(), !1;
    }
    function Te(c, u) {
      var p = {
        originalEvent: u,
        eventType: "gotpointercapture",
        pointerType: v(u),
        isEmulated: !1
      };
      g(c, p), u.target === c.element && S(c, {
        id: u.pointerId,
        type: v(u)
      }, !0), p.stopPropagation && e.stopEvent(u);
    }
    function xe(c, u) {
      var p = {
        originalEvent: u,
        eventType: "lostpointercapture",
        pointerType: v(u),
        isEmulated: !1
      };
      g(c, p), u.target === c.element && S(c, {
        id: u.pointerId,
        type: v(u)
      }, !1), p.stopPropagation && e.stopEvent(u);
    }
    function N(c, u) {
      var p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      }, m = {
        originalEvent: u,
        eventType: "pointerenter",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), b(c, m, p);
    }
    function fe(c, u) {
      var p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      }, m = {
        originalEvent: u,
        eventType: "pointerleave",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), _(c, m, p);
    }
    function pe(c, u) {
      var p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      }, m = {
        originalEvent: u,
        eventType: "pointerover",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), I(c, m, p), m.preventDefault && !m.defaultPrevented && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function ge(c, u) {
      var p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      }, m = {
        originalEvent: u,
        eventType: "pointerout",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), O(c, m, p), m.preventDefault && !m.defaultPrevented && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function le(c, u) {
      var p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      }, m = e.MouseTracker.havePointerEvents && p.type === "touch" && e.Browser.vendor !== e.BROWSERS.IE, E = {
        originalEvent: u,
        eventType: "pointerdown",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, E), G(c, E, p, u.button), E.preventDefault && !E.defaultPrevented && e.cancelEvent(u), E.stopPropagation && e.stopEvent(u), E.shouldCapture && (m ? S(c, p, !0) : l(c, p));
    }
    function me(c, u) {
      ve(c, u);
    }
    function Se(c, u) {
      var p = c.getActivePointersListByType(v(u));
      p.getById(u.pointerId) && ve(c, u), e.stopEvent(u);
    }
    function ve(c, u) {
      var p;
      p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      };
      var m = {
        originalEvent: u,
        eventType: "pointerup",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), j(c, m, p, u.button), m.preventDefault && !m.defaultPrevented && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u), m.shouldReleaseCapture && (u.target === c.element ? d(c, p) : S(c, p, !1));
    }
    function ye(c, u) {
      we(c, u);
    }
    function Ee(c, u) {
      var p = c.getActivePointersListByType(v(u));
      p.getById(u.pointerId) && we(c, u), e.stopEvent(u);
    }
    function we(c, u) {
      var p = {
        id: f(u),
        type: v(u),
        isPrimary: y(u),
        currentPos: T(u),
        currentTime: e.now()
      }, m = {
        originalEvent: u,
        eventType: "pointermove",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), q(c, m, p), m.preventDefault && !m.defaultPrevented && e.cancelEvent(u), m.stopPropagation && e.stopEvent(u);
    }
    function Pe(c, u) {
      var p = {
        id: u.pointerId,
        type: v(u)
      }, m = {
        originalEvent: u,
        eventType: "pointercancel",
        pointerType: p.type,
        isEmulated: !1
      };
      g(c, m), F(c, m, p), m.stopPropagation && e.stopEvent(u);
    }
    function de(c, u) {
      return u.speed = 0, u.direction = 0, u.contactPos = u.currentPos, u.contactTime = u.currentTime, u.lastPos = u.currentPos, u.lastTime = u.currentTime, c.add(u);
    }
    function he(c, u, p) {
      var m, E = u.getById(p.id);
      return E ? (E.captured && (e.console.warn("stopTrackingPointer() called on captured pointer"), d(c, E)), u.removeContact(), m = u.removeById(p.id)) : m = u.getLength(), m;
    }
    function a(c, u) {
      switch (u.eventType) {
        case "pointermove":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !1, u.preventGesture = !c.hasGestureHandlers, u.stopPropagation = !1;
          break;
        case "pointerover":
        case "pointerout":
        case "contextmenu":
        case "keydown":
        case "keyup":
        case "keypress":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !1, u.preventGesture = !1, u.stopPropagation = !1;
          break;
        case "pointerdown":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !1, u.preventGesture = !c.hasGestureHandlers, u.stopPropagation = !1;
          break;
        case "pointerup":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !1, u.preventGesture = !c.hasGestureHandlers, u.stopPropagation = !1;
          break;
        case "wheel":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !1, u.preventGesture = !c.hasScrollHandler, u.stopPropagation = !1;
          break;
        case "gotpointercapture":
        case "lostpointercapture":
        case "pointercancel":
          u.isStoppable = !0, u.isCancelable = !1, u.preventDefault = !1, u.preventGesture = !1, u.stopPropagation = !1;
          break;
        case "click":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !!c.clickHandler, u.preventGesture = !1, u.stopPropagation = !1;
          break;
        case "dblclick":
          u.isStoppable = !0, u.isCancelable = !0, u.preventDefault = !!c.dblClickHandler, u.preventGesture = !1, u.stopPropagation = !1;
          break;
        case "focus":
        case "blur":
        case "pointerenter":
        case "pointerleave":
        default:
          u.isStoppable = !1, u.isCancelable = !1, u.preventDefault = !1, u.preventGesture = !1, u.stopPropagation = !1;
          break;
      }
    }
    function g(c, u) {
      u.eventSource = c, u.eventPhase = u.originalEvent && typeof u.originalEvent.eventPhase < "u" ? u.originalEvent.eventPhase : 0, u.defaultPrevented = e.eventIsCanceled(u.originalEvent), u.shouldCapture = !1, u.shouldReleaseCapture = !1, u.userData = c.userData, a(c, u), c.preProcessEventHandler && c.preProcessEventHandler(u);
    }
    function S(c, u, p) {
      var m = c.getActivePointersListByType(u.type), E = m.getById(u.id);
      E ? p && !E.captured ? (E.captured = !0, m.captureCount++) : !p && E.captured && (E.captured = !1, m.captureCount--, m.captureCount < 0 && (m.captureCount = 0, e.console.warn("updatePointerCaptured() - pointsList.captureCount went negative"))) : e.console.warn("updatePointerCaptured() called on untracked pointer");
    }
    function b(c, u, p) {
      var m = c.getActivePointersListByType(p.type), E;
      E = m.getById(p.id), E ? (E.insideElement = !0, E.lastPos = E.currentPos, E.lastTime = E.currentTime, E.currentPos = p.currentPos, E.currentTime = p.currentTime, p = E) : (p.captured = !1, p.insideElementPressed = !1, p.insideElement = !0, de(m, p)), c.enterHandler && c.enterHandler(
        {
          eventSource: c,
          pointerType: p.type,
          position: x(p.currentPos, c.element),
          buttons: m.buttons,
          pointers: c.getActivePointerCount(),
          insideElementPressed: p.insideElementPressed,
          buttonDownAny: m.buttons !== 0,
          isTouchEvent: p.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      );
    }
    function _(c, u, p) {
      var m = c.getActivePointersListByType(p.type), E, R;
      E = m.getById(p.id), E ? (E.captured ? (E.insideElement = !1, E.lastPos = E.currentPos, E.lastTime = E.currentTime, E.currentPos = p.currentPos, E.currentTime = p.currentTime) : he(c, m, E), p = E) : (p.captured = !1, p.insideElementPressed = !1), (c.leaveHandler || c.exitHandler) && (R = {
        eventSource: c,
        pointerType: p.type,
        // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos && )
        position: p.currentPos && x(p.currentPos, c.element),
        buttons: m.buttons,
        pointers: c.getActivePointerCount(),
        insideElementPressed: p.insideElementPressed,
        buttonDownAny: m.buttons !== 0,
        isTouchEvent: p.type === "touch",
        originalEvent: u.originalEvent,
        userData: c.userData
      }, c.leaveHandler && c.leaveHandler(R), c.exitHandler && c.exitHandler(R));
    }
    function I(c, u, p) {
      var m, E;
      m = c.getActivePointersListByType(p.type), E = m.getById(p.id), E ? p = E : (p.captured = !1, p.insideElementPressed = !1), c.overHandler && c.overHandler(
        {
          eventSource: c,
          pointerType: p.type,
          position: x(p.currentPos, c.element),
          buttons: m.buttons,
          pointers: c.getActivePointerCount(),
          insideElementPressed: p.insideElementPressed,
          buttonDownAny: m.buttons !== 0,
          isTouchEvent: p.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      );
    }
    function O(c, u, p) {
      var m, E;
      m = c.getActivePointersListByType(p.type), E = m.getById(p.id), E ? p = E : (p.captured = !1, p.insideElementPressed = !1), c.outHandler && c.outHandler({
        eventSource: c,
        pointerType: p.type,
        position: p.currentPos && x(p.currentPos, c.element),
        buttons: m.buttons,
        pointers: c.getActivePointerCount(),
        insideElementPressed: p.insideElementPressed,
        buttonDownAny: m.buttons !== 0,
        isTouchEvent: p.type === "touch",
        originalEvent: u.originalEvent,
        userData: c.userData
      });
    }
    function G(c, u, p, m) {
      var E = t[c.hash], R = c.getActivePointersListByType(p.type), L;
      if (typeof u.originalEvent.buttons < "u" ? R.buttons = u.originalEvent.buttons : m === 0 ? R.buttons |= 1 : m === 1 ? R.buttons |= 4 : m === 2 ? R.buttons |= 2 : m === 3 ? R.buttons |= 8 : m === 4 ? R.buttons |= 16 : m === 5 && (R.buttons |= 32), m !== 0) {
        u.shouldCapture = !1, u.shouldReleaseCapture = !1, c.nonPrimaryPressHandler && !u.preventGesture && !u.defaultPrevented && (u.preventDefault = !0, c.nonPrimaryPressHandler(
          {
            eventSource: c,
            pointerType: p.type,
            position: x(p.currentPos, c.element),
            button: m,
            buttons: R.buttons,
            isTouchEvent: p.type === "touch",
            originalEvent: u.originalEvent,
            userData: c.userData
          }
        ));
        return;
      }
      L = R.getById(p.id), L ? (L.insideElementPressed = !0, L.insideElement = !0, L.originalTarget = u.originalEvent.target, L.contactPos = p.currentPos, L.contactTime = p.currentTime, L.lastPos = L.currentPos, L.lastTime = L.currentTime, L.currentPos = p.currentPos, L.currentTime = p.currentTime, p = L) : (p.captured = !1, p.insideElementPressed = !0, p.insideElement = !0, p.originalTarget = u.originalEvent.target, de(R, p)), R.addContact(), !u.preventGesture && !u.defaultPrevented ? (u.shouldCapture = !0, u.shouldReleaseCapture = !1, u.preventDefault = !0, (c.dragHandler || c.dragEndHandler || c.pinchHandler) && e.MouseTracker.gesturePointVelocityTracker.addPoint(c, p), R.contacts === 1 ? c.pressHandler && !u.preventGesture && c.pressHandler(
        {
          eventSource: c,
          pointerType: p.type,
          position: x(p.contactPos, c.element),
          buttons: R.buttons,
          isTouchEvent: p.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ) : R.contacts === 2 && c.pinchHandler && p.type === "touch" && (E.pinchGPoints = R.asArray(), E.lastPinchDist = E.currentPinchDist = E.pinchGPoints[0].currentPos.distanceTo(E.pinchGPoints[1].currentPos), E.lastPinchCenter = E.currentPinchCenter = P(E.pinchGPoints[0].currentPos, E.pinchGPoints[1].currentPos))) : (u.shouldCapture = !1, u.shouldReleaseCapture = !1);
    }
    function j(c, u, p, m) {
      var E = t[c.hash], R = c.getActivePointersListByType(p.type), L, V, z, Q = !1, J;
      if (typeof u.originalEvent.buttons < "u" ? R.buttons = u.originalEvent.buttons : m === 0 ? R.buttons ^= -2 : m === 1 ? R.buttons ^= -5 : m === 2 ? R.buttons ^= -3 : m === 3 ? R.buttons ^= -9 : m === 4 ? R.buttons ^= -17 : m === 5 && (R.buttons ^= -33), u.shouldCapture = !1, m !== 0) {
        u.shouldReleaseCapture = !1, c.nonPrimaryReleaseHandler && !u.preventGesture && !u.defaultPrevented && (u.preventDefault = !0, c.nonPrimaryReleaseHandler(
          {
            eventSource: c,
            pointerType: p.type,
            position: x(p.currentPos, c.element),
            button: m,
            buttons: R.buttons,
            isTouchEvent: p.type === "touch",
            originalEvent: u.originalEvent,
            userData: c.userData
          }
        ));
        return;
      }
      z = R.getById(p.id), z ? (R.removeContact(), z.captured && (Q = !0), z.lastPos = z.currentPos, z.lastTime = z.currentTime, z.currentPos = p.currentPos, z.currentTime = p.currentTime, z.insideElement || he(c, R, z), L = z.currentPos, V = z.currentTime) : (p.captured = !1, p.insideElementPressed = !1, p.insideElement = !0, de(R, p), z = p), !u.preventGesture && !u.defaultPrevented && (Q ? (u.shouldReleaseCapture = !0, u.preventDefault = !0, (c.dragHandler || c.dragEndHandler || c.pinchHandler) && e.MouseTracker.gesturePointVelocityTracker.removePoint(c, z), R.contacts === 0 ? (c.releaseHandler && L && c.releaseHandler(
        {
          eventSource: c,
          pointerType: z.type,
          position: x(L, c.element),
          buttons: R.buttons,
          insideElementPressed: z.insideElementPressed,
          insideElementReleased: z.insideElement,
          isTouchEvent: z.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ), c.dragEndHandler && E.sentDragEvent && c.dragEndHandler(
        {
          eventSource: c,
          pointerType: z.type,
          position: x(z.currentPos, c.element),
          speed: z.speed,
          direction: z.direction,
          shift: u.originalEvent.shiftKey,
          isTouchEvent: z.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ), E.sentDragEvent = !1, (c.clickHandler || c.dblClickHandler) && z.insideElement && (J = V - z.contactTime <= c.clickTimeThreshold && z.contactPos.distanceTo(L) <= c.clickDistThreshold, c.clickHandler && c.clickHandler(
        {
          eventSource: c,
          pointerType: z.type,
          position: x(z.currentPos, c.element),
          quick: J,
          shift: u.originalEvent.shiftKey,
          isTouchEvent: z.type === "touch",
          originalEvent: u.originalEvent,
          originalTarget: z.originalTarget,
          userData: c.userData
        }
      ), c.dblClickHandler && J && (R.clicks++, R.clicks === 1 ? (E.lastClickPos = L, E.dblClickTimeOut = setTimeout(function() {
        R.clicks = 0;
      }, c.dblClickTimeThreshold)) : R.clicks === 2 && (clearTimeout(E.dblClickTimeOut), R.clicks = 0, E.lastClickPos.distanceTo(L) <= c.dblClickDistThreshold && c.dblClickHandler(
        {
          eventSource: c,
          pointerType: z.type,
          position: x(z.currentPos, c.element),
          shift: u.originalEvent.shiftKey,
          isTouchEvent: z.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ), E.lastClickPos = null)))) : R.contacts === 2 && c.pinchHandler && z.type === "touch" && (E.pinchGPoints = R.asArray(), E.lastPinchDist = E.currentPinchDist = E.pinchGPoints[0].currentPos.distanceTo(E.pinchGPoints[1].currentPos), E.lastPinchCenter = E.currentPinchCenter = P(E.pinchGPoints[0].currentPos, E.pinchGPoints[1].currentPos))) : (u.shouldReleaseCapture = !1, c.releaseHandler && L && (c.releaseHandler(
        {
          eventSource: c,
          pointerType: z.type,
          position: x(L, c.element),
          buttons: R.buttons,
          insideElementPressed: z.insideElementPressed,
          insideElementReleased: z.insideElement,
          isTouchEvent: z.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ), u.preventDefault = !0)));
    }
    function q(c, u, p) {
      var m = t[c.hash], E = c.getActivePointersListByType(p.type), R, L, V;
      if (typeof u.originalEvent.buttons < "u" && (E.buttons = u.originalEvent.buttons), R = E.getById(p.id), R)
        R.lastPos = R.currentPos, R.lastTime = R.currentTime, R.currentPos = p.currentPos, R.currentTime = p.currentTime;
      else
        return;
      u.shouldCapture = !1, u.shouldReleaseCapture = !1, c.stopHandler && p.type === "mouse" && (clearTimeout(c.stopTimeOut), c.stopTimeOut = setTimeout(function() {
        K(c, u.originalEvent, p.type);
      }, c.stopDelay)), E.contacts === 0 ? c.moveHandler && c.moveHandler(
        {
          eventSource: c,
          pointerType: p.type,
          position: x(p.currentPos, c.element),
          buttons: E.buttons,
          isTouchEvent: p.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ) : E.contacts === 1 ? (c.moveHandler && (R = E.asArray()[0], c.moveHandler(
        {
          eventSource: c,
          pointerType: R.type,
          position: x(R.currentPos, c.element),
          buttons: E.buttons,
          isTouchEvent: R.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      )), c.dragHandler && !u.preventGesture && !u.defaultPrevented && (R = E.asArray()[0], V = R.currentPos.minus(R.lastPos), c.dragHandler(
        {
          eventSource: c,
          pointerType: R.type,
          position: x(R.currentPos, c.element),
          buttons: E.buttons,
          delta: V,
          speed: R.speed,
          direction: R.direction,
          shift: u.originalEvent.shiftKey,
          isTouchEvent: R.type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ), u.preventDefault = !0, m.sentDragEvent = !0)) : E.contacts === 2 && (c.moveHandler && (L = E.asArray(), c.moveHandler(
        {
          eventSource: c,
          pointerType: L[0].type,
          position: x(P(L[0].currentPos, L[1].currentPos), c.element),
          buttons: E.buttons,
          isTouchEvent: L[0].type === "touch",
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      )), c.pinchHandler && p.type === "touch" && !u.preventGesture && !u.defaultPrevented && (V = m.pinchGPoints[0].currentPos.distanceTo(m.pinchGPoints[1].currentPos), V !== m.currentPinchDist && (m.lastPinchDist = m.currentPinchDist, m.currentPinchDist = V, m.lastPinchCenter = m.currentPinchCenter, m.currentPinchCenter = P(m.pinchGPoints[0].currentPos, m.pinchGPoints[1].currentPos), c.pinchHandler(
        {
          eventSource: c,
          pointerType: "touch",
          gesturePoints: m.pinchGPoints,
          lastCenter: x(m.lastPinchCenter, c.element),
          center: x(m.currentPinchCenter, c.element),
          lastDistance: m.lastPinchDist,
          distance: m.currentPinchDist,
          shift: u.originalEvent.shiftKey,
          originalEvent: u.originalEvent,
          userData: c.userData
        }
      ), u.preventDefault = !0)));
    }
    function F(c, u, p) {
      var m = c.getActivePointersListByType(p.type), E;
      E = m.getById(p.id), E && he(c, m, E);
    }
    function K(c, u, p) {
      c.stopHandler && c.stopHandler({
        eventSource: c,
        pointerType: p,
        position: w(u, c.element),
        buttons: c.getActivePointersListByType(p).buttons,
        isTouchEvent: p === "touch",
        originalEvent: u,
        userData: c.userData
      });
    }
  }(D), function(e) {
    e.ControlAnchor = {
      NONE: 0,
      TOP_LEFT: 1,
      TOP_RIGHT: 2,
      BOTTOM_RIGHT: 3,
      BOTTOM_LEFT: 4,
      ABSOLUTE: 5
    }, e.Control = function(t, i, o) {
      var h = t.parentNode;
      typeof i == "number" && (e.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013"), i = { anchor: i }), i.attachToViewer = typeof i.attachToViewer > "u" ? !0 : i.attachToViewer, this.autoFade = typeof i.autoFade > "u" ? !0 : i.autoFade, this.element = t, this.anchor = i.anchor, this.container = o, this.anchor === e.ControlAnchor.ABSOLUTE ? (this.wrapper = e.makeNeutralElement("div"), this.wrapper.style.position = "absolute", this.wrapper.style.top = typeof i.top == "number" ? i.top + "px" : i.top, this.wrapper.style.left = typeof i.left == "number" ? i.left + "px" : i.left, this.wrapper.style.height = typeof i.height == "number" ? i.height + "px" : i.height, this.wrapper.style.width = typeof i.width == "number" ? i.width + "px" : i.width, this.wrapper.style.margin = "0px", this.wrapper.style.padding = "0px", this.element.style.position = "relative", this.element.style.top = "0px", this.element.style.left = "0px", this.element.style.height = "100%", this.element.style.width = "100%") : (this.wrapper = e.makeNeutralElement("div"), this.wrapper.style.display = "inline-block", this.anchor === e.ControlAnchor.NONE && (this.wrapper.style.width = this.wrapper.style.height = "100%")), this.wrapper.appendChild(this.element), i.attachToViewer ? this.anchor === e.ControlAnchor.TOP_RIGHT || this.anchor === e.ControlAnchor.BOTTOM_RIGHT ? this.container.insertBefore(
        this.wrapper,
        this.container.firstChild
      ) : this.container.appendChild(this.wrapper) : h.appendChild(this.wrapper);
    }, e.Control.prototype = {
      /**
       * Removes the control from the container.
       * @function
       */
      destroy: function() {
        this.wrapper.removeChild(this.element), this.anchor !== e.ControlAnchor.NONE && this.container.removeChild(this.wrapper);
      },
      /**
       * Determines if the control is currently visible.
       * @function
       * @returns {Boolean} true if currently visible, false otherwise.
       */
      isVisible: function() {
        return this.wrapper.style.display !== "none";
      },
      /**
       * Toggles the visibility of the control.
       * @function
       * @param {Boolean} visible - true to make visible, false to hide.
       */
      setVisible: function(t) {
        this.wrapper.style.display = t ? this.anchor === e.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
      },
      /**
       * Sets the opacity level for the control.
       * @function
       * @param {Number} opactiy - a value between 1 and 0 inclusively.
       */
      setOpacity: function(t) {
        this.element[e.SIGNAL] && e.Browser.vendor === e.BROWSERS.IE ? e.setElementOpacity(this.element, t, !0) : e.setElementOpacity(this.wrapper, t, !0);
      }
    };
  }(D), function(e) {
    e.ControlDock = function(i) {
      var o = ["topleft", "topright", "bottomright", "bottomleft"], h, n;
      for (e.extend(!0, this, {
        id: "controldock-" + e.now() + "-" + Math.floor(Math.random() * 1e6),
        container: e.makeNeutralElement("div"),
        controls: []
      }, i), this.container.onsubmit = function() {
        return !1;
      }, this.element && (this.element = e.getElement(this.element), this.element.appendChild(this.container), this.element.style.position = "relative", this.container.style.width = "100%", this.container.style.height = "100%"), n = 0; n < o.length; n++)
        h = o[n], this.controls[h] = e.makeNeutralElement("div"), this.controls[h].style.position = "absolute", h.match("left") && (this.controls[h].style.left = "0px"), h.match("right") && (this.controls[h].style.right = "0px"), h.match("top") && (this.controls[h].style.top = "0px"), h.match("bottom") && (this.controls[h].style.bottom = "0px");
      this.container.appendChild(this.controls.topleft), this.container.appendChild(this.controls.topright), this.container.appendChild(this.controls.bottomright), this.container.appendChild(this.controls.bottomleft);
    }, e.ControlDock.prototype = {
      /**
       * @function
       */
      addControl: function(i, o) {
        i = e.getElement(i);
        var h = null;
        if (!(t(this, i) >= 0)) {
          switch (o.anchor) {
            case e.ControlAnchor.TOP_RIGHT:
              h = this.controls.topright, i.style.position = "relative", i.style.paddingRight = "0px", i.style.paddingTop = "0px";
              break;
            case e.ControlAnchor.BOTTOM_RIGHT:
              h = this.controls.bottomright, i.style.position = "relative", i.style.paddingRight = "0px", i.style.paddingBottom = "0px";
              break;
            case e.ControlAnchor.BOTTOM_LEFT:
              h = this.controls.bottomleft, i.style.position = "relative", i.style.paddingLeft = "0px", i.style.paddingBottom = "0px";
              break;
            case e.ControlAnchor.TOP_LEFT:
              h = this.controls.topleft, i.style.position = "relative", i.style.paddingLeft = "0px", i.style.paddingTop = "0px";
              break;
            case e.ControlAnchor.ABSOLUTE:
              h = this.container, i.style.margin = "0px", i.style.padding = "0px";
              break;
            default:
            case e.ControlAnchor.NONE:
              h = this.container, i.style.margin = "0px", i.style.padding = "0px";
              break;
          }
          this.controls.push(
            new e.Control(i, o, h)
          ), i.style.display = "inline-block";
        }
      },
      /**
       * @function
       * @returns {OpenSeadragon.ControlDock} Chainable.
       */
      removeControl: function(i) {
        i = e.getElement(i);
        var o = t(this, i);
        return o >= 0 && (this.controls[o].destroy(), this.controls.splice(o, 1)), this;
      },
      /**
       * @function
       * @returns {OpenSeadragon.ControlDock} Chainable.
       */
      clearControls: function() {
        for (; this.controls.length > 0; )
          this.controls.pop().destroy();
        return this;
      },
      /**
       * @function
       * @returns {Boolean}
       */
      areControlsEnabled: function() {
        var i;
        for (i = this.controls.length - 1; i >= 0; i--)
          if (this.controls[i].isVisible())
            return !0;
        return !1;
      },
      /**
       * @function
       * @returns {OpenSeadragon.ControlDock} Chainable.
       */
      setControlsEnabled: function(i) {
        var o;
        for (o = this.controls.length - 1; o >= 0; o--)
          this.controls[o].setVisible(i);
        return this;
      }
    };
    function t(i, o) {
      var h = i.controls, n;
      for (n = h.length - 1; n >= 0; n--)
        if (h[n].element === o)
          return n;
      return -1;
    }
  }(D), function(e) {
    e.Placement = e.freezeObject({
      CENTER: 0,
      TOP_LEFT: 1,
      TOP: 2,
      TOP_RIGHT: 3,
      RIGHT: 4,
      BOTTOM_RIGHT: 5,
      BOTTOM: 6,
      BOTTOM_LEFT: 7,
      LEFT: 8,
      properties: {
        0: {
          isLeft: !1,
          isHorizontallyCentered: !0,
          isRight: !1,
          isTop: !1,
          isVerticallyCentered: !0,
          isBottom: !1
        },
        1: {
          isLeft: !0,
          isHorizontallyCentered: !1,
          isRight: !1,
          isTop: !0,
          isVerticallyCentered: !1,
          isBottom: !1
        },
        2: {
          isLeft: !1,
          isHorizontallyCentered: !0,
          isRight: !1,
          isTop: !0,
          isVerticallyCentered: !1,
          isBottom: !1
        },
        3: {
          isLeft: !1,
          isHorizontallyCentered: !1,
          isRight: !0,
          isTop: !0,
          isVerticallyCentered: !1,
          isBottom: !1
        },
        4: {
          isLeft: !1,
          isHorizontallyCentered: !1,
          isRight: !0,
          isTop: !1,
          isVerticallyCentered: !0,
          isBottom: !1
        },
        5: {
          isLeft: !1,
          isHorizontallyCentered: !1,
          isRight: !0,
          isTop: !1,
          isVerticallyCentered: !1,
          isBottom: !0
        },
        6: {
          isLeft: !1,
          isHorizontallyCentered: !0,
          isRight: !1,
          isTop: !1,
          isVerticallyCentered: !1,
          isBottom: !0
        },
        7: {
          isLeft: !0,
          isHorizontallyCentered: !1,
          isRight: !1,
          isTop: !1,
          isVerticallyCentered: !1,
          isBottom: !0
        },
        8: {
          isLeft: !0,
          isHorizontallyCentered: !1,
          isRight: !1,
          isTop: !1,
          isVerticallyCentered: !0,
          isBottom: !1
        }
      }
    });
  }(D), function(e) {
    var t = {}, i = 1;
    e.Viewer = function(a) {
      var g = arguments, S = this, b;
      if (e.isPlainObject(a) || (a = {
        id: g[0],
        xmlPath: g.length > 1 ? g[1] : void 0,
        prefixUrl: g.length > 2 ? g[2] : void 0,
        controls: g.length > 3 ? g[3] : void 0,
        overlays: g.length > 4 ? g[4] : void 0
      }), a.config && (e.extend(!0, a, a.config), delete a.config), e.extend(!0, this, {
        //internal state and dom identifiers
        id: a.id,
        hash: a.hash || i++,
        /**
         * Index for page to be shown first next time open() is called (only used in sequenceMode).
         * @member {Number} initialPage
         * @memberof OpenSeadragon.Viewer#
         */
        initialPage: 0,
        //dom nodes
        /**
         * The parent element of this Viewer instance, passed in when the Viewer was created.
         * @member {Element} element
         * @memberof OpenSeadragon.Viewer#
         */
        element: null,
        /**
         * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
         * Child element of {@link OpenSeadragon.Viewer#element}.
         * @member {Element} container
         * @memberof OpenSeadragon.Viewer#
         */
        container: null,
        /**
         * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
         * Child element of {@link OpenSeadragon.Viewer#container},
         * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
         * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
         * @member {Element} canvas
         * @memberof OpenSeadragon.Viewer#
         */
        canvas: null,
        // Overlays list. An overlay allows to add html on top of the viewer.
        overlays: [],
        // Container inside the canvas where overlays are drawn.
        overlaysContainer: null,
        //private state properties
        previousBody: [],
        //This was originally initialized in the constructor and so could never
        //have anything in it.  now it can because we allow it to be specified
        //in the options and is only empty by default if not specified. Also
        //this array was returned from get_controls which I find confusing
        //since this object has a controls property which is treated in other
        //functions like clearControls.  I'm removing the accessors.
        customControls: [],
        //These are originally not part options but declared as members
        //in initialize.  It's still considered idiomatic to put them here
        //source is here for backwards compatibility. It is not an official
        //part of the API and should not be relied upon.
        source: null,
        /**
         * Handles rendering of tiles in the viewer. Created for each TileSource opened.
         * @member {OpenSeadragon.Drawer} drawer
         * @memberof OpenSeadragon.Viewer#
         */
        drawer: null,
        /**
         * Keeps track of all of the tiled images in the scene.
         * @member {OpenSeadragon.World} world
         * @memberof OpenSeadragon.Viewer#
         */
        world: null,
        /**
         * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
         * @member {OpenSeadragon.Viewport} viewport
         * @memberof OpenSeadragon.Viewer#
         */
        viewport: null,
        /**
         * @member {OpenSeadragon.Navigator} navigator
         * @memberof OpenSeadragon.Viewer#
         */
        navigator: null,
        //A collection viewport is a separate viewport used to provide
        //simultaneous rendering of sets of tiles
        collectionViewport: null,
        collectionDrawer: null,
        //UI image resources
        //TODO: rename navImages to uiImages
        navImages: null,
        //interface button controls
        buttonGroup: null,
        //TODO: this is defunct so safely remove it
        profiler: null
      }, e.DEFAULT_SETTINGS, a), typeof this.hash > "u")
        throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
      for (typeof t[this.hash] < "u" && e.console.warn("Hash " + this.hash + " has already been used."), t[this.hash] = {
        fsBoundsDelta: new e.Point(1, 1),
        prevContainerSize: null,
        animating: !1,
        forceRedraw: !1,
        needsResize: !1,
        forceResize: !1,
        mouseInside: !1,
        group: null,
        // whether we should be continuously zooming
        zooming: !1,
        // how much we should be continuously zooming by
        zoomFactor: null,
        lastZoomTime: null,
        fullPage: !1,
        onfullscreenchange: null,
        lastClickTime: null,
        draggingToZoom: !1
      }, this._sequenceIndex = 0, this._firstOpen = !0, this._updateRequestId = null, this._loadQueue = [], this.currentOverlays = [], this._updatePixelDensityRatioBind = null, this._lastScrollTime = e.now(), e.EventSource.call(this), this.addHandler("open-failed", function(_) {
        var I = e.getString("Errors.OpenFailed", _.eventSource, _.message);
        S._showMessage(I);
      }), e.ControlDock.call(this, a), this.xmlPath && (this.tileSources = [this.xmlPath]), this.element = this.element || document.getElementById(this.id), this.canvas = e.makeNeutralElement("div"), this.canvas.className = "openseadragon-canvas", function(_) {
        _.width = "100%", _.height = "100%", _.overflow = "hidden", _.position = "absolute", _.top = "0px", _.left = "0px";
      }(this.canvas.style), e.setElementTouchActionNone(this.canvas), a.tabIndex !== "" && (this.canvas.tabIndex = a.tabIndex === void 0 ? 0 : a.tabIndex), this.container.className = "openseadragon-container", function(_) {
        _.width = "100%", _.height = "100%", _.position = "relative", _.overflow = "hidden", _.left = "0px", _.top = "0px", _.textAlign = "left";
      }(this.container.style), e.setElementTouchActionNone(this.container), this.container.insertBefore(this.canvas, this.container.firstChild), this.element.appendChild(this.container), this.bodyWidth = document.body.style.width, this.bodyHeight = document.body.style.height, this.bodyOverflow = document.body.style.overflow, this.docOverflow = document.documentElement.style.overflow, this.innerTracker = new e.MouseTracker({
        userData: "Viewer.innerTracker",
        element: this.canvas,
        startDisabled: !this.mouseNavEnabled,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        dblClickTimeThreshold: this.dblClickTimeThreshold,
        dblClickDistThreshold: this.dblClickDistThreshold,
        contextMenuHandler: e.delegate(this, w),
        keyDownHandler: e.delegate(this, x),
        keyHandler: e.delegate(this, P),
        clickHandler: e.delegate(this, C),
        dblClickHandler: e.delegate(this, A),
        dragHandler: e.delegate(this, W),
        dragEndHandler: e.delegate(this, k),
        enterHandler: e.delegate(this, U),
        leaveHandler: e.delegate(this, H),
        pressHandler: e.delegate(this, M),
        releaseHandler: e.delegate(this, X),
        nonPrimaryPressHandler: e.delegate(this, Z),
        nonPrimaryReleaseHandler: e.delegate(this, Y),
        scrollHandler: e.delegate(this, ee),
        pinchHandler: e.delegate(this, $),
        focusHandler: e.delegate(this, te),
        blurHandler: e.delegate(this, ce)
      }), this.outerTracker = new e.MouseTracker({
        userData: "Viewer.outerTracker",
        element: this.container,
        startDisabled: !this.mouseNavEnabled,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        dblClickTimeThreshold: this.dblClickTimeThreshold,
        dblClickDistThreshold: this.dblClickDistThreshold,
        enterHandler: e.delegate(this, ie),
        leaveHandler: e.delegate(this, re)
      }), this.toolbar && (this.toolbar = new e.ControlDock({ element: this.toolbar })), this.bindStandardControls(), t[this.hash].prevContainerSize = o(this.container), window.ResizeObserver ? (this._autoResizePolling = !1, this._resizeObserver = new ResizeObserver(function() {
        t[S.hash].needsResize = !0;
      }), this._resizeObserver.observe(this.container, {})) : this._autoResizePolling = !0, this.world = new e.World({
        viewer: this
      }), this.world.addHandler("add-item", function(_) {
        S.source = S.world.getItemAt(0).source, t[S.hash].forceRedraw = !0, S._updateRequestId || (S._updateRequestId = s(S, oe));
      }), this.world.addHandler("remove-item", function(_) {
        S.world.getItemCount() ? S.source = S.world.getItemAt(0).source : S.source = null, t[S.hash].forceRedraw = !0;
      }), this.world.addHandler("metrics-change", function(_) {
        S.viewport && S.viewport._setContentBounds(S.world.getHomeBounds(), S.world.getContentFactor());
      }), this.world.addHandler("item-index-change", function(_) {
        S.source = S.world.getItemAt(0).source;
      }), this.viewport = new e.Viewport({
        containerSize: t[this.hash].prevContainerSize,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime,
        minZoomImageRatio: this.minZoomImageRatio,
        maxZoomPixelRatio: this.maxZoomPixelRatio,
        visibilityRatio: this.visibilityRatio,
        wrapHorizontal: this.wrapHorizontal,
        wrapVertical: this.wrapVertical,
        defaultZoomLevel: this.defaultZoomLevel,
        minZoomLevel: this.minZoomLevel,
        maxZoomLevel: this.maxZoomLevel,
        viewer: this,
        degrees: this.degrees,
        flipped: this.flipped,
        navigatorRotate: this.navigatorRotate,
        homeFillsViewer: this.homeFillsViewer,
        margins: this.viewportMargins,
        silenceMultiImageWarnings: this.silenceMultiImageWarnings
      }), this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor()), this.imageLoader = new e.ImageLoader({
        jobLimit: this.imageLoaderLimit,
        timeout: a.timeout,
        tileRetryMax: this.tileRetryMax,
        tileRetryDelay: this.tileRetryDelay
      }), this.tileCache = new e.TileCache({
        maxImageCacheCount: this.maxImageCacheCount
      }), this.drawer = new e.Drawer({
        viewer: this,
        viewport: this.viewport,
        element: this.canvas,
        debugGridColor: this.debugGridColor
      }), this.overlaysContainer = e.makeNeutralElement("div"), this.canvas.appendChild(this.overlaysContainer), this.drawer.canRotate() || (this.rotateLeft && (b = this.buttonGroup.buttons.indexOf(this.rotateLeft), this.buttonGroup.buttons.splice(b, 1), this.buttonGroup.element.removeChild(this.rotateLeft.element)), this.rotateRight && (b = this.buttonGroup.buttons.indexOf(this.rotateRight), this.buttonGroup.buttons.splice(b, 1), this.buttonGroup.element.removeChild(this.rotateRight.element))), this._addUpdatePixelDensityRatioEvent(), this.showNavigator && (this.navigator = new e.Navigator({
        element: this.navigatorElement,
        id: this.navigatorId,
        position: this.navigatorPosition,
        sizeRatio: this.navigatorSizeRatio,
        maintainSizeRatio: this.navigatorMaintainSizeRatio,
        top: this.navigatorTop,
        left: this.navigatorLeft,
        width: this.navigatorWidth,
        height: this.navigatorHeight,
        autoResize: this.navigatorAutoResize,
        autoFade: this.navigatorAutoFade,
        prefixUrl: this.prefixUrl,
        viewer: this,
        navigatorRotate: this.navigatorRotate,
        background: this.navigatorBackground,
        opacity: this.navigatorOpacity,
        borderColor: this.navigatorBorderColor,
        displayRegionColor: this.navigatorDisplayRegionColor,
        crossOriginPolicy: this.crossOriginPolicy,
        animationTime: this.animationTime
      })), this.sequenceMode && this.bindSequenceControls(), this.tileSources && this.open(this.tileSources), b = 0; b < this.customControls.length; b++)
        this.addControl(
          this.customControls[b].id,
          { anchor: this.customControls[b].anchor }
        );
      e.requestAnimationFrame(function() {
        d(S);
      }), this.imageSmoothingEnabled !== void 0 && !this.imageSmoothingEnabled && this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled), e._viewers.set(this.element, this);
    }, e.extend(
      e.Viewer.prototype,
      e.EventSource.prototype,
      e.ControlDock.prototype,
      /** @lends OpenSeadragon.Viewer.prototype */
      {
        /**
         * @function
         * @returns {Boolean}
         */
        isOpen: function() {
          return !!this.world.getItemCount();
        },
        // deprecated
        openDzi: function(a) {
          return e.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead."), this.open(a);
        },
        // deprecated
        openTileSource: function(a) {
          return e.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead."), this.open(a);
        },
        //deprecated
        get buttons() {
          return e.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup"), this.buttonGroup;
        },
        /**
         * Open tiled images into the viewer, closing any others.
         * To get the TiledImage instance created by open, add an event listener for
         * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
         * to the instance, i.e., viewer.world.getItemAt(0).
         * @function
         * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
         * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
         * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
         * except for the index property; images are added in sequence.
         * A TileSource specifier is anything you could pass as the tileSource property
         * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
         * @param {Number} initialPage - If sequenceMode is true, display this page initially
         * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:open
         * @fires OpenSeadragon.Viewer.event:open-failed
         */
        open: function(a, g) {
          var S = this;
          if (this.close(), !a)
            return this;
          if (this.sequenceMode && e.isArray(a))
            return this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), typeof g < "u" && !isNaN(g) && (this.initialPage = g), this.tileSources = a, this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage)), this.tileSources.length && (this.open(this.tileSources[this._sequenceIndex]), this.showReferenceStrip && this.addReferenceStrip()), this._updateSequenceButtons(this._sequenceIndex), this;
          if (e.isArray(a) || (a = [a]), !a.length)
            return this;
          this._opening = !0;
          for (var b = a.length, _ = 0, I = 0, O, G = function() {
            if (_ + I === b)
              if (_) {
                (S._firstOpen || !S.preserveViewport) && (S.viewport.goHome(!0), S.viewport.update()), S._firstOpen = !1;
                var F = a[0];
                if (F.tileSource && (F = F.tileSource), S.overlays && !S.preserveOverlays)
                  for (var K = 0; K < S.overlays.length; K++)
                    S.currentOverlays[K] = n(S, S.overlays[K]);
                S._drawOverlays(), S._opening = !1, S.raiseEvent("open", { source: F });
              } else
                S._opening = !1, S.raiseEvent("open-failed", O);
          }, j = function(F) {
            (!e.isPlainObject(F) || !F.tileSource) && (F = {
              tileSource: F
            }), F.index !== void 0 && (e.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead"), delete F.index), F.collectionImmediately === void 0 && (F.collectionImmediately = !0);
            var K = F.success;
            F.success = function(u) {
              if (_++, F.tileSource.overlays)
                for (var p = 0; p < F.tileSource.overlays.length; p++)
                  S.addOverlay(F.tileSource.overlays[p]);
              K && K(u), G();
            };
            var c = F.error;
            F.error = function(u) {
              I++, O || (O = u), c && c(u), G();
            }, S.addTiledImage(F);
          }, q = 0; q < a.length; q++)
            j(a[q]);
          return this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:close
         */
        close: function() {
          return t[this.hash] ? (this._opening = !1, this.navigator && this.navigator.close(), this.preserveOverlays || (this.clearOverlays(), this.overlaysContainer.innerHTML = ""), t[this.hash].animating = !1, this.world.removeAll(), this.imageLoader.clear(), this.raiseEvent("close"), this) : this;
        },
        /**
         * Function to destroy the viewer and clean up everything created by OpenSeadragon.
         *
         * Example:
         * var viewer = OpenSeadragon({
         *   [...]
         * });
         *
         * //when you are done with the viewer:
         * viewer.destroy();
         * viewer = null; //important
         *
         * @function
         * @fires OpenSeadragon.Viewer.event:before-destroy
         * @fires OpenSeadragon.Viewer.event:destroy
         */
        destroy: function() {
          if (t[this.hash]) {
            if (this.raiseEvent("before-destroy"), this._removeUpdatePixelDensityRatioEvent(), this.close(), this.clearOverlays(), this.overlaysContainer.innerHTML = "", this._resizeObserver && this._resizeObserver.disconnect(), this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null), this._updateRequestId !== null && (e.cancelAnimationFrame(this._updateRequestId), this._updateRequestId = null), this.drawer && this.drawer.destroy(), this.navigator && (this.navigator.destroy(), t[this.navigator.hash] = null, delete t[this.navigator.hash], this.navigator = null), this.buttonGroup)
              this.buttonGroup.destroy();
            else if (this.customButtons)
              for (; this.customButtons.length; )
                this.customButtons.pop().destroy();
            if (this.paging && this.paging.destroy(), this.element)
              for (; this.element.firstChild; )
                this.element.removeChild(this.element.firstChild);
            this.container.onsubmit = null, this.clearControls(), this.innerTracker && this.innerTracker.destroy(), this.outerTracker && this.outerTracker.destroy(), t[this.hash] = null, delete t[this.hash], this.canvas = null, this.container = null, e._viewers.delete(this.element), this.element = null, this.raiseEvent("destroy"), this.removeAllHandlers();
          }
        },
        /**
         * @function
         * @returns {Boolean}
         */
        isMouseNavEnabled: function() {
          return this.innerTracker.isTracking();
        },
        /**
         * @function
         * @param {Boolean} enabled - true to enable, false to disable
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:mouse-enabled
         */
        setMouseNavEnabled: function(a) {
          return this.innerTracker.setTracking(a), this.outerTracker.setTracking(a), this.raiseEvent("mouse-enabled", { enabled: a }), this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        areControlsEnabled: function() {
          var a = this.controls.length, g;
          for (g = 0; g < this.controls.length; g++)
            a = a && this.controls[g].isVisible();
          return a;
        },
        /**
         * Shows or hides the controls (e.g. the default navigation buttons).
         *
         * @function
         * @param {Boolean} true to show, false to hide.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:controls-enabled
         */
        setControlsEnabled: function(a) {
          return a ? v(this) : d(this), this.raiseEvent("controls-enabled", { enabled: a }), this;
        },
        /**
         * Turns debugging mode on or off for this viewer.
         *
         * @function
         * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
         */
        setDebugMode: function(a) {
          for (var g = 0; g < this.world.getItemCount(); g++)
            this.world.getItemAt(g).debugMode = a;
          this.debugMode = a, this.forceRedraw();
        },
        /**
         * Update headers to include when making AJAX requests.
         *
         * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
         * the updated headers are propagated to all tiled images, each of which will subsequently
         * propagate the changed headers to all their tiles.
         * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
         *
         * Note that the rules for merging headers still apply, i.e. headers returned by
         * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
         * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
         *
         * @function
         * @param {Object} ajaxHeaders Updated AJAX headers.
         * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
         */
        setAjaxHeaders: function(a, g) {
          if (a === null && (a = {}), !e.isPlainObject(a)) {
            console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
            return;
          }
          if (g === void 0 && (g = !0), this.ajaxHeaders = a, g) {
            for (var S = 0; S < this.world.getItemCount(); S++)
              this.world.getItemAt(S)._updateAjaxHeaders(!0);
            if (this.navigator && this.navigator.setAjaxHeaders(this.ajaxHeaders, !0), this.referenceStrip && this.referenceStrip.miniViewers)
              for (var b in this.referenceStrip.miniViewers)
                this.referenceStrip.miniViewers[b].setAjaxHeaders(this.ajaxHeaders, !0);
          }
        },
        /**
         * Adds the given button to this viewer.
         *
         * @function
         * @param {OpenSeadragon.Button} button
         */
        addButton: function(a) {
          this.buttonGroup.addButton(a);
        },
        /**
         * @function
         * @returns {Boolean}
         */
        isFullPage: function() {
          return t[this.hash].fullPage;
        },
        /**
         * Toggle full page mode.
         * @function
         * @param {Boolean} fullPage
         *      If true, enter full page mode.  If false, exit full page mode.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:pre-full-page
         * @fires OpenSeadragon.Viewer.event:full-page
         */
        setFullPage: function(a) {
          var g = document.body, S = g.style, b = document.documentElement.style, _ = this, I, O;
          if (a === this.isFullPage())
            return this;
          var G = {
            fullPage: a,
            preventDefaultAction: !1
          };
          if (this.raiseEvent("pre-full-page", G), G.preventDefaultAction)
            return this;
          if (a) {
            for (this.elementSize = e.getElementSize(this.element), this.pageScroll = e.getPageScroll(), this.elementMargin = this.element.style.margin, this.element.style.margin = "0", this.elementPadding = this.element.style.padding, this.element.style.padding = "0", this.bodyMargin = S.margin, this.docMargin = b.margin, S.margin = "0", b.margin = "0", this.bodyPadding = S.padding, this.docPadding = b.padding, S.padding = "0", b.padding = "0", this.bodyWidth = S.width, this.docWidth = b.width, S.width = "100%", b.width = "100%", this.bodyHeight = S.height, this.docHeight = b.height, S.height = "100%", b.height = "100%", this.bodyDisplay = S.display, S.display = "block", this.previousBody = [], t[this.hash].prevElementParent = this.element.parentNode, t[this.hash].prevNextSibling = this.element.nextSibling, t[this.hash].prevElementWidth = this.element.style.width, t[this.hash].prevElementHeight = this.element.style.height, I = g.childNodes.length, O = 0; O < I; O++)
              this.previousBody.push(g.childNodes[0]), g.removeChild(g.childNodes[0]);
            this.toolbar && this.toolbar.element && (this.toolbar.parentNode = this.toolbar.element.parentNode, this.toolbar.nextSibling = this.toolbar.element.nextSibling, g.appendChild(this.toolbar.element), e.addClass(this.toolbar.element, "fullpage")), e.addClass(this.element, "fullpage"), g.appendChild(this.element), this.element.style.height = "100vh", this.element.style.width = "100vw", this.toolbar && this.toolbar.element && (this.element.style.height = e.getElementSize(this.element).y - e.getElementSize(this.toolbar.element).y + "px"), t[this.hash].fullPage = !0, e.delegate(this, ie)({});
          } else {
            for (this.element.style.margin = this.elementMargin, this.element.style.padding = this.elementPadding, S.margin = this.bodyMargin, b.margin = this.docMargin, S.padding = this.bodyPadding, b.padding = this.docPadding, S.width = this.bodyWidth, b.width = this.docWidth, S.height = this.bodyHeight, b.height = this.docHeight, S.display = this.bodyDisplay, g.removeChild(this.element), I = this.previousBody.length, O = 0; O < I; O++)
              g.appendChild(this.previousBody.shift());
            e.removeClass(this.element, "fullpage"), t[this.hash].prevElementParent.insertBefore(
              this.element,
              t[this.hash].prevNextSibling
            ), this.toolbar && this.toolbar.element && (g.removeChild(this.toolbar.element), e.removeClass(this.toolbar.element, "fullpage"), this.toolbar.parentNode.insertBefore(
              this.toolbar.element,
              this.toolbar.nextSibling
            ), delete this.toolbar.parentNode, delete this.toolbar.nextSibling), this.element.style.width = t[this.hash].prevElementWidth, this.element.style.height = t[this.hash].prevElementHeight;
            var j = 0, q = function() {
              e.setPageScroll(_.pageScroll);
              var F = e.getPageScroll();
              j++, j < 10 && (F.x !== _.pageScroll.x || F.y !== _.pageScroll.y) && e.requestAnimationFrame(q);
            };
            e.requestAnimationFrame(q), t[this.hash].fullPage = !1, e.delegate(this, re)({});
          }
          return this.navigator && this.viewport && this.navigator.update(this.viewport), this.raiseEvent("full-page", { fullPage: a }), this;
        },
        /**
         * Toggle full screen mode if supported. Toggle full page mode otherwise.
         * @function
         * @param {Boolean} fullScreen
         *      If true, enter full screen mode.  If false, exit full screen mode.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:pre-full-screen
         * @fires OpenSeadragon.Viewer.event:full-screen
         */
        setFullScreen: function(a) {
          var g = this;
          if (!e.supportsFullScreen)
            return this.setFullPage(a);
          if (e.isFullScreen() === a)
            return this;
          var S = {
            fullScreen: a,
            preventDefaultAction: !1
          };
          if (this.raiseEvent("pre-full-screen", S), S.preventDefaultAction)
            return this;
          if (a) {
            if (this.setFullPage(!0), !this.isFullPage())
              return this;
            this.fullPageStyleWidth = this.element.style.width, this.fullPageStyleHeight = this.element.style.height, this.element.style.width = "100%", this.element.style.height = "100%";
            var b = function() {
              var _ = e.isFullScreen();
              _ || (e.removeEvent(document, e.fullScreenEventName, b), e.removeEvent(document, e.fullScreenErrorEventName, b), g.setFullPage(!1), g.isFullPage() && (g.element.style.width = g.fullPageStyleWidth, g.element.style.height = g.fullPageStyleHeight)), g.navigator && g.viewport && setTimeout(function() {
                g.navigator.update(g.viewport);
              }), g.raiseEvent("full-screen", { fullScreen: _ });
            };
            e.addEvent(document, e.fullScreenEventName, b), e.addEvent(document, e.fullScreenErrorEventName, b), e.requestFullScreen(document.body);
          } else
            e.exitFullScreen();
          return this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        isVisible: function() {
          return this.container.style.visibility !== "hidden";
        },
        //
        /**
         * @function
         * @returns {Boolean} returns true if the viewer is in fullscreen
         */
        isFullScreen: function() {
          return e.isFullScreen() && this.isFullPage();
        },
        /**
         * @function
         * @param {Boolean} visible
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:visible
         */
        setVisible: function(a) {
          return this.container.style.visibility = a ? "" : "hidden", this.raiseEvent("visible", { visible: a }), this;
        },
        /**
         * Add a tiled image to the viewer.
         * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
         *  supports except arrays of images.
         * Note that you can specify options.width or options.height, but not both.
         * The other dimension will be calculated according to the item's aspect ratio.
         * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
         * automatically arranged with the others.
         * @function
         * @param {Object} options
         * @param {String|Object|Function} options.tileSource - The TileSource specifier.
         * A String implies a url used to determine the tileSource implementation
         *      based on the file extension of url. JSONP is implied by *.js,
         *      otherwise the url is retrieved as text and the resulting text is
         *      introspected to determine if its json, xml, or text and parsed.
         * An Object implies an inline configuration which has a single
         *      property sufficient for being able to determine tileSource
         *      implementation. If the object has a property which is a function
         *      named 'getTileUrl', it is treated as a custom TileSource.
         * @param {Number} [options.index] The index of the item. Added on top of
         * all other items if not specified.
         * @param {Boolean} [options.replace=false] If true, the item at options.index will be
         * removed and the new item is added in its place. options.tileSource will be
         * interpreted and fetched if necessary before the old item is removed to avoid leaving
         * a gap in the world.
         * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
         * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
         * @param {Number} [options.width=1] The width for the image in viewport coordinates.
         * @param {Number} [options.height] The height for the image in viewport coordinates.
         * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
         * to fit the image into. If specified, x, y, width and height get ignored.
         * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
         * How to anchor the image in the bounds if options.fitBounds is set.
         * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
         * (portions of the image outside of this area will not be visible). Only works on
         * browsers that support the HTML5 canvas.
         * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
         * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
         * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
         * its top left corner in degrees.
         * @param {Boolean} [options.flipped=false] Whether to horizontally flip the image.
         * @param {String} [options.compositeOperation] How the image is composited onto other images.
         * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
         * overriding viewer.crossOriginPolicy.
         * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
         * @param {Boolean} [options.loadTilesWithAjax]
         *      Whether to load tile data using AJAX requests.
         *      Defaults to the setting in {@link OpenSeadragon.Options}.
         * @param {Object} [options.ajaxHeaders]
         *      A set of headers to include when making tile AJAX requests.
         *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
         *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
         * @param {Function} [options.success] A function that gets called when the image is
         * successfully added. It's passed the event object which contains a single property:
         * "item", which is the resulting instance of TiledImage.
         * @param {Function} [options.error] A function that gets called if the image is
         * unable to be added. It's passed the error event object, which contains "message"
         * and "source" properties.
         * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
         * specifies whether to snap to the new arrangement immediately or to animate to it.
         * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
         * @fires OpenSeadragon.World.event:add-item
         * @fires OpenSeadragon.Viewer.event:add-item-failed
         */
        addTiledImage: function(a) {
          e.console.assert(a, "[Viewer.addTiledImage] options is required"), e.console.assert(a.tileSource, "[Viewer.addTiledImage] options.tileSource is required"), e.console.assert(
            !a.replace || a.index > -1 && a.index < this.world.getItemCount(),
            "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
          );
          var g = this;
          a.replace && (a.replaceItem = g.world.getItemAt(a.index)), this._hideMessage(), a.placeholderFillStyle === void 0 && (a.placeholderFillStyle = this.placeholderFillStyle), a.opacity === void 0 && (a.opacity = this.opacity), a.preload === void 0 && (a.preload = this.preload), a.compositeOperation === void 0 && (a.compositeOperation = this.compositeOperation), a.crossOriginPolicy === void 0 && (a.crossOriginPolicy = a.tileSource.crossOriginPolicy !== void 0 ? a.tileSource.crossOriginPolicy : this.crossOriginPolicy), a.ajaxWithCredentials === void 0 && (a.ajaxWithCredentials = this.ajaxWithCredentials), a.loadTilesWithAjax === void 0 && (a.loadTilesWithAjax = this.loadTilesWithAjax), e.isPlainObject(a.ajaxHeaders) || (a.ajaxHeaders = {});
          var S = {
            options: a
          };
          function b(O) {
            for (var G = 0; G < g._loadQueue.length; G++)
              if (g._loadQueue[G] === S) {
                g._loadQueue.splice(G, 1);
                break;
              }
            g._loadQueue.length === 0 && _(S), g.raiseEvent("add-item-failed", O), a.error && a.error(O);
          }
          function _(O) {
            g.collectionMode && (g.world.arrange({
              immediately: O.options.collectionImmediately,
              rows: g.collectionRows,
              columns: g.collectionColumns,
              layout: g.collectionLayout,
              tileSize: g.collectionTileSize,
              tileMargin: g.collectionTileMargin
            }), g.world.setAutoRefigureSizes(!0));
          }
          if (e.isArray(a.tileSource)) {
            setTimeout(function() {
              b({
                message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                source: a.tileSource,
                options: a
              });
            });
            return;
          }
          this._loadQueue.push(S);
          function I() {
            for (var O, G, j; g._loadQueue.length && (O = g._loadQueue[0], !!O.tileSource); ) {
              if (g._loadQueue.splice(0, 1), O.options.replace) {
                var q = g.world.getIndexOfItem(O.options.replaceItem);
                q !== -1 && (O.options.index = q), g.world.removeItem(O.options.replaceItem);
              }
              G = new e.TiledImage({
                viewer: g,
                source: O.tileSource,
                viewport: g.viewport,
                drawer: g.drawer,
                tileCache: g.tileCache,
                imageLoader: g.imageLoader,
                x: O.options.x,
                y: O.options.y,
                width: O.options.width,
                height: O.options.height,
                fitBounds: O.options.fitBounds,
                fitBoundsPlacement: O.options.fitBoundsPlacement,
                clip: O.options.clip,
                placeholderFillStyle: O.options.placeholderFillStyle,
                opacity: O.options.opacity,
                preload: O.options.preload,
                degrees: O.options.degrees,
                flipped: O.options.flipped,
                compositeOperation: O.options.compositeOperation,
                springStiffness: g.springStiffness,
                animationTime: g.animationTime,
                minZoomImageRatio: g.minZoomImageRatio,
                wrapHorizontal: g.wrapHorizontal,
                wrapVertical: g.wrapVertical,
                immediateRender: g.immediateRender,
                blendTime: g.blendTime,
                alwaysBlend: g.alwaysBlend,
                minPixelRatio: g.minPixelRatio,
                smoothTileEdgesMinZoom: g.smoothTileEdgesMinZoom,
                iOSDevice: g.iOSDevice,
                crossOriginPolicy: O.options.crossOriginPolicy,
                ajaxWithCredentials: O.options.ajaxWithCredentials,
                loadTilesWithAjax: O.options.loadTilesWithAjax,
                ajaxHeaders: O.options.ajaxHeaders,
                debugMode: g.debugMode,
                subPixelRoundingForTransparency: g.subPixelRoundingForTransparency
              }), g.collectionMode && g.world.setAutoRefigureSizes(!1), g.navigator && (j = e.extend({}, O.options, {
                replace: !1,
                // navigator already removed the layer, nothing to replace
                originalTiledImage: G,
                tileSource: O.tileSource
              }), g.navigator.addTiledImage(j)), g.world.addItem(G, {
                index: O.options.index
              }), g._loadQueue.length === 0 && _(O), g.world.getItemCount() === 1 && !g.preserveViewport && g.viewport.goHome(!0), O.options.success && O.options.success({
                item: G
              });
            }
          }
          h(this, a.tileSource, a, function(O) {
            S.tileSource = O, I();
          }, function(O) {
            O.options = a, b(O), I();
          });
        },
        /**
         * Add a simple image to the viewer.
         * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
         * except for options.tileSource which is replaced by options.url.
         * @function
         * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
         * for all the options
         * @param {String} options.url - The URL of the image to add.
         * @fires OpenSeadragon.World.event:add-item
         * @fires OpenSeadragon.Viewer.event:add-item-failed
         */
        addSimpleImage: function(a) {
          e.console.assert(a, "[Viewer.addSimpleImage] options is required"), e.console.assert(a.url, "[Viewer.addSimpleImage] options.url is required");
          var g = e.extend({}, a, {
            tileSource: {
              type: "image",
              url: a.url
            }
          });
          delete g.url, this.addTiledImage(g);
        },
        // deprecated
        addLayer: function(a) {
          var g = this;
          e.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
          var S = e.extend({}, a, {
            success: function(b) {
              g.raiseEvent("add-layer", {
                options: a,
                drawer: b.item
              });
            },
            error: function(b) {
              g.raiseEvent("add-layer-failed", b);
            }
          });
          return this.addTiledImage(S), this;
        },
        // deprecated
        getLayerAtLevel: function(a) {
          return e.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead."), this.world.getItemAt(a);
        },
        // deprecated
        getLevelOfLayer: function(a) {
          return e.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead."), this.world.getIndexOfItem(a);
        },
        // deprecated
        getLayersCount: function() {
          return e.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead."), this.world.getItemCount();
        },
        // deprecated
        setLayerLevel: function(a, g) {
          return e.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead."), this.world.setItemIndex(a, g);
        },
        // deprecated
        removeLayer: function(a) {
          return e.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead."), this.world.removeItem(a);
        },
        /**
         * Force the viewer to redraw its contents.
         * @returns {OpenSeadragon.Viewer} Chainable.
         */
        forceRedraw: function() {
          return t[this.hash].forceRedraw = !0, this;
        },
        /**
         * Force the viewer to reset its size to match its container.
         */
        forceResize: function() {
          t[this.hash].needsResize = !0, t[this.hash].forceResize = !0;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         */
        bindSequenceControls: function() {
          var a = e.delegate(this, y), g = e.delegate(this, T), S = e.delegate(this, this.goToNextPage), b = e.delegate(this, this.goToPreviousPage), _ = this.navImages, I = !0;
          return this.showSequenceControl && ((this.previousButton || this.nextButton) && (I = !1), this.previousButton = new e.Button({
            element: this.previousButton ? e.getElement(this.previousButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.PreviousPage"),
            srcRest: N(this.prefixUrl, _.previous.REST),
            srcGroup: N(this.prefixUrl, _.previous.GROUP),
            srcHover: N(this.prefixUrl, _.previous.HOVER),
            srcDown: N(this.prefixUrl, _.previous.DOWN),
            onRelease: b,
            onFocus: a,
            onBlur: g
          }), this.nextButton = new e.Button({
            element: this.nextButton ? e.getElement(this.nextButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.NextPage"),
            srcRest: N(this.prefixUrl, _.next.REST),
            srcGroup: N(this.prefixUrl, _.next.GROUP),
            srcHover: N(this.prefixUrl, _.next.HOVER),
            srcDown: N(this.prefixUrl, _.next.DOWN),
            onRelease: S,
            onFocus: a,
            onBlur: g
          }), this.navPrevNextWrap || this.previousButton.disable(), (!this.tileSources || !this.tileSources.length) && this.nextButton.disable(), I && (this.paging = new e.ButtonGroup({
            buttons: [
              this.previousButton,
              this.nextButton
            ],
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold
          }), this.pagingControl = this.paging.element, this.toolbar ? this.toolbar.addControl(
            this.pagingControl,
            { anchor: e.ControlAnchor.BOTTOM_RIGHT }
          ) : this.addControl(
            this.pagingControl,
            { anchor: this.sequenceControlAnchor || e.ControlAnchor.TOP_LEFT }
          ))), this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         */
        bindStandardControls: function() {
          var a = e.delegate(this, fe), g = e.delegate(this, ge), S = e.delegate(this, Se), b = e.delegate(this, pe), _ = e.delegate(this, ve), I = e.delegate(this, Ee), O = e.delegate(this, we), G = e.delegate(this, Pe), j = e.delegate(this, de), q = e.delegate(this, he), F = e.delegate(this, y), K = e.delegate(this, T), c = this.navImages, u = [], p = !0;
          return this.showNavigationControl && ((this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) && (p = !1), this.showZoomControl && (u.push(this.zoomInButton = new e.Button({
            element: this.zoomInButton ? e.getElement(this.zoomInButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.ZoomIn"),
            srcRest: N(this.prefixUrl, c.zoomIn.REST),
            srcGroup: N(this.prefixUrl, c.zoomIn.GROUP),
            srcHover: N(this.prefixUrl, c.zoomIn.HOVER),
            srcDown: N(this.prefixUrl, c.zoomIn.DOWN),
            onPress: a,
            onRelease: g,
            onClick: S,
            onEnter: a,
            onExit: g,
            onFocus: F,
            onBlur: K
          })), u.push(this.zoomOutButton = new e.Button({
            element: this.zoomOutButton ? e.getElement(this.zoomOutButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.ZoomOut"),
            srcRest: N(this.prefixUrl, c.zoomOut.REST),
            srcGroup: N(this.prefixUrl, c.zoomOut.GROUP),
            srcHover: N(this.prefixUrl, c.zoomOut.HOVER),
            srcDown: N(this.prefixUrl, c.zoomOut.DOWN),
            onPress: b,
            onRelease: g,
            onClick: _,
            onEnter: b,
            onExit: g,
            onFocus: F,
            onBlur: K
          }))), this.showHomeControl && u.push(this.homeButton = new e.Button({
            element: this.homeButton ? e.getElement(this.homeButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.Home"),
            srcRest: N(this.prefixUrl, c.home.REST),
            srcGroup: N(this.prefixUrl, c.home.GROUP),
            srcHover: N(this.prefixUrl, c.home.HOVER),
            srcDown: N(this.prefixUrl, c.home.DOWN),
            onRelease: I,
            onFocus: F,
            onBlur: K
          })), this.showFullPageControl && u.push(this.fullPageButton = new e.Button({
            element: this.fullPageButton ? e.getElement(this.fullPageButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.FullPage"),
            srcRest: N(this.prefixUrl, c.fullpage.REST),
            srcGroup: N(this.prefixUrl, c.fullpage.GROUP),
            srcHover: N(this.prefixUrl, c.fullpage.HOVER),
            srcDown: N(this.prefixUrl, c.fullpage.DOWN),
            onRelease: O,
            onFocus: F,
            onBlur: K
          })), this.showRotationControl && (u.push(this.rotateLeftButton = new e.Button({
            element: this.rotateLeftButton ? e.getElement(this.rotateLeftButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.RotateLeft"),
            srcRest: N(this.prefixUrl, c.rotateleft.REST),
            srcGroup: N(this.prefixUrl, c.rotateleft.GROUP),
            srcHover: N(this.prefixUrl, c.rotateleft.HOVER),
            srcDown: N(this.prefixUrl, c.rotateleft.DOWN),
            onRelease: G,
            onFocus: F,
            onBlur: K
          })), u.push(this.rotateRightButton = new e.Button({
            element: this.rotateRightButton ? e.getElement(this.rotateRightButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.RotateRight"),
            srcRest: N(this.prefixUrl, c.rotateright.REST),
            srcGroup: N(this.prefixUrl, c.rotateright.GROUP),
            srcHover: N(this.prefixUrl, c.rotateright.HOVER),
            srcDown: N(this.prefixUrl, c.rotateright.DOWN),
            onRelease: j,
            onFocus: F,
            onBlur: K
          }))), this.showFlipControl && u.push(this.flipButton = new e.Button({
            element: this.flipButton ? e.getElement(this.flipButton) : null,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            tooltip: e.getString("Tooltips.Flip"),
            srcRest: N(this.prefixUrl, c.flip.REST),
            srcGroup: N(this.prefixUrl, c.flip.GROUP),
            srcHover: N(this.prefixUrl, c.flip.HOVER),
            srcDown: N(this.prefixUrl, c.flip.DOWN),
            onRelease: q,
            onFocus: F,
            onBlur: K
          })), p ? (this.buttonGroup = new e.ButtonGroup({
            buttons: u,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold
          }), this.navControl = this.buttonGroup.element, this.addHandler("open", e.delegate(this, ye)), this.toolbar ? this.toolbar.addControl(
            this.navControl,
            { anchor: this.navigationControlAnchor || e.ControlAnchor.TOP_LEFT }
          ) : this.addControl(
            this.navControl,
            { anchor: this.navigationControlAnchor || e.ControlAnchor.TOP_LEFT }
          )) : this.customButtons = u), this;
        },
        /**
         * Gets the active page of a sequence
         * @function
         * @returns {Number}
         */
        currentPage: function() {
          return this._sequenceIndex;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:page
         */
        goToPage: function(a) {
          return this.tileSources && a >= 0 && a < this.tileSources.length && (this._sequenceIndex = a, this._updateSequenceButtons(a), this.open(this.tileSources[a]), this.referenceStrip && this.referenceStrip.setFocus(a), this.raiseEvent("page", { page: a })), this;
        },
        /**
          * Adds an html element as an overlay to the current viewport.  Useful for
          * highlighting words or areas of interest on an image or other zoomable
          * interface. The overlays added via this method are removed when the viewport
          * is closed which include when changing page.
          * @method
          * @param {Element|String|Object} element - A reference to an element or an id for
          *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
          *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
          *      all available options.
          * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
          *      rectangle which will be overlaid. This is a viewport relative location.
          * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
          *      viewport which the location coordinates will be treated as relative
          *      to.
          * @param {function} [onDraw] - If supplied the callback is called when the overlay
          *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.
          *      It is passed position, size and element.
          * @returns {OpenSeadragon.Viewer} Chainable.
          * @fires OpenSeadragon.Viewer.event:add-overlay
          */
        addOverlay: function(a, g, S, b) {
          var _;
          if (e.isPlainObject(a) ? _ = a : _ = {
            element: a,
            location: g,
            placement: S,
            onDraw: b
          }, a = e.getElement(_.element), r(this.currentOverlays, a) >= 0)
            return this;
          var I = n(this, _);
          return this.currentOverlays.push(I), I.drawHTML(this.overlaysContainer, this.viewport), this.raiseEvent("add-overlay", {
            element: a,
            location: _.location,
            placement: _.placement
          }), this;
        },
        /**
         * Updates the overlay represented by the reference to the element or
         * element id moving it to the new location, relative to the new placement.
         * @method
         * @param {Element|String} element - A reference to an element or an id for
         *      the element which is overlaid.
         * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
         *      rectangle which will be overlaid. This is a viewport relative location.
         * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
         *      viewport which the location coordinates will be treated as relative
         *      to.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:update-overlay
         */
        updateOverlay: function(a, g, S) {
          var b;
          return a = e.getElement(a), b = r(this.currentOverlays, a), b >= 0 && (this.currentOverlays[b].update(g, S), t[this.hash].forceRedraw = !0, this.raiseEvent("update-overlay", {
            element: a,
            location: g,
            placement: S
          })), this;
        },
        /**
         * Removes an overlay identified by the reference element or element id
         * and schedules an update.
         * @method
         * @param {Element|String} element - A reference to the element or an
         *      element id which represent the ovelay content to be removed.
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:remove-overlay
         */
        removeOverlay: function(a) {
          var g;
          return a = e.getElement(a), g = r(this.currentOverlays, a), g >= 0 && (this.currentOverlays[g].destroy(), this.currentOverlays.splice(g, 1), t[this.hash].forceRedraw = !0, this.raiseEvent("remove-overlay", {
            element: a
          })), this;
        },
        /**
         * Removes all currently configured Overlays from this Viewer and schedules
         * an update.
         * @method
         * @returns {OpenSeadragon.Viewer} Chainable.
         * @fires OpenSeadragon.Viewer.event:clear-overlay
         */
        clearOverlays: function() {
          for (; this.currentOverlays.length > 0; )
            this.currentOverlays.pop().destroy();
          return t[this.hash].forceRedraw = !0, this.raiseEvent("clear-overlay", {}), this;
        },
        /**
        * Finds an overlay identified by the reference element or element id
        * and returns it as an object, return null if not found.
        * @method
        * @param {Element|String} element - A reference to the element or an
        *      element id which represents the overlay content.
        * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
        */
        getOverlayById: function(a) {
          var g;
          return a = e.getElement(a), g = r(this.currentOverlays, a), g >= 0 ? this.currentOverlays[g] : null;
        },
        /**
         * Updates the sequence buttons.
         * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
         * @private
         * @param {Number} Sequence Value
         */
        _updateSequenceButtons: function(a) {
          this.nextButton && (!this.tileSources || this.tileSources.length - 1 === a ? this.navPrevNextWrap || this.nextButton.disable() : this.nextButton.enable()), this.previousButton && (a > 0 ? this.previousButton.enable() : this.navPrevNextWrap || this.previousButton.disable());
        },
        /**
         * Display a message in the viewport
         * @function OpenSeadragon.Viewer.prototype._showMessage
         * @private
         * @param {String} text message
         */
        _showMessage: function(a) {
          this._hideMessage();
          var g = e.makeNeutralElement("div");
          g.appendChild(document.createTextNode(a)), this.messageDiv = e.makeCenteredNode(g), e.addClass(this.messageDiv, "openseadragon-message"), this.container.appendChild(this.messageDiv);
        },
        /**
         * Hide any currently displayed viewport message
         * @function OpenSeadragon.Viewer.prototype._hideMessage
         * @private
         */
        _hideMessage: function() {
          var a = this.messageDiv;
          a && (a.parentNode.removeChild(a), delete this.messageDiv);
        },
        /**
         * Gets this viewer's gesture settings for the given pointer device type.
         * @method
         * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
         * @returns {OpenSeadragon.GestureSettings}
         */
        gestureSettingsByDeviceType: function(a) {
          switch (a) {
            case "mouse":
              return this.gestureSettingsMouse;
            case "touch":
              return this.gestureSettingsTouch;
            case "pen":
              return this.gestureSettingsPen;
            default:
              return this.gestureSettingsUnknown;
          }
        },
        // private
        _drawOverlays: function() {
          var a, g = this.currentOverlays.length;
          for (a = 0; a < g; a++)
            this.currentOverlays[a].drawHTML(this.overlaysContainer, this.viewport);
        },
        /**
         * Cancel the "in flight" images.
         */
        _cancelPendingImages: function() {
          this._loadQueue = [];
        },
        /**
         * Removes the reference strip and disables displaying it.
         * @function
         */
        removeReferenceStrip: function() {
          this.showReferenceStrip = !1, this.referenceStrip && (this.referenceStrip.destroy(), this.referenceStrip = null);
        },
        /**
         * Enables and displays the reference strip based on the currently set tileSources.
         * Works only when the Viewer has sequenceMode set to true.
         * @function
         */
        addReferenceStrip: function() {
          if (this.showReferenceStrip = !0, this.sequenceMode) {
            if (this.referenceStrip)
              return;
            this.tileSources.length && this.tileSources.length > 1 && (this.referenceStrip = new e.ReferenceStrip({
              id: this.referenceStripElement,
              position: this.referenceStripPosition,
              sizeRatio: this.referenceStripSizeRatio,
              scroll: this.referenceStripScroll,
              height: this.referenceStripHeight,
              width: this.referenceStripWidth,
              tileSources: this.tileSources,
              prefixUrl: this.prefixUrl,
              useCanvas: this.useCanvas,
              viewer: this
            }), this.referenceStrip.setFocus(this._sequenceIndex));
          } else
            e.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
        },
        /**
         * Adds _updatePixelDensityRatio to the window resize event.
         * @private
         */
        _addUpdatePixelDensityRatioEvent: function() {
          this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this), e.addEvent(window, "resize", this._updatePixelDensityRatioBind);
        },
        /**
         * Removes _updatePixelDensityRatio from the window resize event.
         * @private
         */
        _removeUpdatePixelDensityRatioEvent: function() {
          e.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
        },
        /**
         * Update pixel density ratio, clears all tiles and triggers updates for
         * all items if the ratio has changed.
         * @private
         */
        _updatePixelDensityRatio: function() {
          var a = e.pixelDensityRatio, g = e.getCurrentPixelDensityRatio();
          a !== g && (e.pixelDensityRatio = g, this.world.resetItems(), this.forceRedraw());
        },
        /**
         * Sets the image source to the source with index equal to
         * currentIndex - 1. Changes current image in sequence mode.
         * If specified, wraps around (see navPrevNextWrap in
         * {@link OpenSeadragon.Options})
         *
         * @method
         */
        goToPreviousPage: function() {
          var a = this._sequenceIndex - 1;
          this.navPrevNextWrap && a < 0 && (a += this.tileSources.length), this.goToPage(a);
        },
        /**
         * Sets the image source to the source with index equal to
         * currentIndex + 1. Changes current image in sequence mode.
         * If specified, wraps around (see navPrevNextWrap in
         * {@link OpenSeadragon.Options})
         *
         * @method
         */
        goToNextPage: function() {
          var a = this._sequenceIndex + 1;
          this.navPrevNextWrap && a >= this.tileSources.length && (a = 0), this.goToPage(a);
        },
        isAnimating: function() {
          return t[this.hash].animating;
        }
      }
    );
    function o(a) {
      return a = e.getElement(a), new e.Point(
        a.clientWidth === 0 ? 1 : a.clientWidth,
        a.clientHeight === 0 ? 1 : a.clientHeight
      );
    }
    function h(a, g, S, b, _) {
      var I = a;
      if (e.type(g) === "string") {
        if (g.match(/^\s*<.*>\s*$/))
          g = e.parseXml(g);
        else if (g.match(/^\s*[{[].*[}\]]\s*$/))
          try {
            var O = e.parseJSON(g);
            g = O;
          } catch {
          }
      }
      function G(j, q) {
        j.ready ? b(j) : (j.addHandler("ready", function() {
          b(j);
        }), j.addHandler("open-failed", function(F) {
          _({
            message: F.message,
            source: q
          });
        }));
      }
      setTimeout(function() {
        if (e.type(g) === "string")
          g = new e.TileSource({
            url: g,
            crossOriginPolicy: S.crossOriginPolicy !== void 0 ? S.crossOriginPolicy : a.crossOriginPolicy,
            ajaxWithCredentials: a.ajaxWithCredentials,
            ajaxHeaders: S.ajaxHeaders ? S.ajaxHeaders : a.ajaxHeaders,
            splitHashDataForPost: a.splitHashDataForPost,
            useCanvas: a.useCanvas,
            success: function(K) {
              b(K.tileSource);
            }
          }), g.addHandler("open-failed", function(K) {
            _(K);
          });
        else if (e.isPlainObject(g) || g.nodeType)
          if (g.crossOriginPolicy === void 0 && (S.crossOriginPolicy !== void 0 || a.crossOriginPolicy !== void 0) && (g.crossOriginPolicy = S.crossOriginPolicy !== void 0 ? S.crossOriginPolicy : a.crossOriginPolicy), g.ajaxWithCredentials === void 0 && (g.ajaxWithCredentials = a.ajaxWithCredentials), g.useCanvas === void 0 && (g.useCanvas = a.useCanvas), e.isFunction(g.getTileUrl)) {
            var j = new e.TileSource(g);
            j.getTileUrl = g.getTileUrl, b(j);
          } else {
            var q = e.TileSource.determineType(I, g);
            if (!q) {
              _({
                message: "Unable to load TileSource",
                source: g
              });
              return;
            }
            var F = q.prototype.configure.apply(I, [g]);
            G(new q(F), g);
          }
        else
          G(g, g);
      });
    }
    function n(a, g) {
      if (g instanceof e.Overlay)
        return g;
      var S = null;
      if (g.element)
        S = e.getElement(g.element);
      else {
        var b = g.id ? g.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
        S = e.getElement(g.id), S || (S = document.createElement("a"), S.href = "#/overlay/" + b), S.id = b, e.addClass(
          S,
          g.className ? g.className : "openseadragon-overlay"
        );
      }
      var _ = g.location, I = g.width, O = g.height;
      if (!_) {
        var G = g.x, j = g.y;
        if (g.px !== void 0) {
          var q = a.viewport.imageToViewportRectangle(new e.Rect(
            g.px,
            g.py,
            I || 0,
            O || 0
          ));
          G = q.x, j = q.y, I = I !== void 0 ? q.width : void 0, O = O !== void 0 ? q.height : void 0;
        }
        _ = new e.Point(G, j);
      }
      var F = g.placement;
      return F && e.type(F) === "string" && (F = e.Placement[g.placement.toUpperCase()]), new e.Overlay({
        element: S,
        location: _,
        placement: F,
        onDraw: g.onDraw,
        checkResize: g.checkResize,
        width: I,
        height: O,
        rotationMode: g.rotationMode
      });
    }
    function r(a, g) {
      var S;
      for (S = a.length - 1; S >= 0; S--)
        if (a[S].element === g)
          return S;
      return -1;
    }
    function s(a, g) {
      return e.requestAnimationFrame(function() {
        g(a);
      });
    }
    function l(a) {
      e.requestAnimationFrame(function() {
        f(a);
      });
    }
    function d(a) {
      a.autoHideControls && (a.controlsShouldFade = !0, a.controlsFadeBeginTime = e.now() + a.controlsFadeDelay, window.setTimeout(function() {
        l(a);
      }, a.controlsFadeDelay));
    }
    function f(a) {
      var g, S, b, _;
      if (a.controlsShouldFade) {
        for (g = e.now(), S = g - a.controlsFadeBeginTime, b = 1 - S / a.controlsFadeLength, b = Math.min(1, b), b = Math.max(0, b), _ = a.controls.length - 1; _ >= 0; _--)
          a.controls[_].autoFade && a.controls[_].setOpacity(b);
        b > 0 && l(a);
      }
    }
    function v(a) {
      var g;
      for (a.controlsShouldFade = !1, g = a.controls.length - 1; g >= 0; g--)
        a.controls[g].setOpacity(1);
    }
    function y() {
      v(this);
    }
    function T() {
      d(this);
    }
    function w(a) {
      var g = {
        tracker: a.eventSource,
        position: a.position,
        originalEvent: a.originalEvent,
        preventDefault: a.preventDefault
      };
      this.raiseEvent("canvas-contextmenu", g), a.preventDefault = g.preventDefault;
    }
    function x(a) {
      var g = {
        originalEvent: a.originalEvent,
        preventDefaultAction: !1,
        preventVerticalPan: a.preventVerticalPan || !this.panVertical,
        preventHorizontalPan: a.preventHorizontalPan || !this.panHorizontal
      };
      if (this.raiseEvent("canvas-key", g), !g.preventDefaultAction && !a.ctrl && !a.alt && !a.meta)
        switch (a.keyCode) {
          case 38:
            g.preventVerticalPan || (a.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, -this.pixelsPerArrowPress))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 40:
            g.preventVerticalPan || (a.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, this.pixelsPerArrowPress))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 37:
            g.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(-this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 39:
            g.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(this.pixelsPerArrowPress, 0))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 187:
            this.viewport.zoomBy(1.1), this.viewport.applyConstraints(), a.preventDefault = !0;
            break;
          case 189:
            this.viewport.zoomBy(0.9), this.viewport.applyConstraints(), a.preventDefault = !0;
            break;
          case 48:
            this.viewport.goHome(), this.viewport.applyConstraints(), a.preventDefault = !0;
            break;
          case 87:
            g.preventVerticalPan || (a.shift ? this.viewport.zoomBy(1.1) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, -40))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 83:
            g.preventVerticalPan || (a.shift ? this.viewport.zoomBy(0.9) : this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(0, 40))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 65:
            g.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(-40, 0))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 68:
            g.preventHorizontalPan || (this.viewport.panBy(this.viewport.deltaPointsFromPixels(new e.Point(40, 0))), this.viewport.applyConstraints()), a.preventDefault = !0;
            break;
          case 82:
            a.shift ? this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.flipped ? this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement) : this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement), this.viewport.applyConstraints(), a.preventDefault = !0;
            break;
          case 70:
            this.viewport.toggleFlip(), a.preventDefault = !0;
            break;
          case 74:
            this.goToPreviousPage();
            break;
          case 75:
            this.goToNextPage();
            break;
          default:
            a.preventDefault = !1;
            break;
        }
      else
        a.preventDefault = !1;
    }
    function P(a) {
      var g = {
        originalEvent: a.originalEvent
      };
      this.raiseEvent("canvas-key-press", g);
    }
    function C(a) {
      var g, S = document.activeElement === this.canvas;
      S || this.canvas.focus(), this.viewport.flipped && (a.position.x = this.viewport.getContainerSize().x - a.position.x);
      var b = {
        tracker: a.eventSource,
        position: a.position,
        quick: a.quick,
        shift: a.shift,
        originalEvent: a.originalEvent,
        originalTarget: a.originalTarget,
        preventDefaultAction: !1
      };
      this.raiseEvent("canvas-click", b), !b.preventDefaultAction && this.viewport && a.quick && (g = this.gestureSettingsByDeviceType(a.pointerType), g.clickToZoom === !0 && (this.viewport.zoomBy(
        a.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
        g.zoomToRefPoint ? this.viewport.pointFromPixel(a.position, !0) : null
      ), this.viewport.applyConstraints()), g.dblClickDragToZoom && (t[this.hash].draggingToZoom === !0 ? (t[this.hash].lastClickTime = null, t[this.hash].draggingToZoom = !1) : t[this.hash].lastClickTime = e.now()));
    }
    function A(a) {
      var g, S = {
        tracker: a.eventSource,
        position: a.position,
        shift: a.shift,
        originalEvent: a.originalEvent,
        preventDefaultAction: !1
      };
      this.raiseEvent("canvas-double-click", S), !S.preventDefaultAction && this.viewport && (g = this.gestureSettingsByDeviceType(a.pointerType), g.dblClickToZoom && (this.viewport.zoomBy(
        a.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
        g.zoomToRefPoint ? this.viewport.pointFromPixel(a.position, !0) : null
      ), this.viewport.applyConstraints()));
    }
    function W(a) {
      var g, S = {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        delta: a.delta,
        speed: a.speed,
        direction: a.direction,
        shift: a.shift,
        originalEvent: a.originalEvent,
        preventDefaultAction: !1
      };
      if (this.raiseEvent("canvas-drag", S), g = this.gestureSettingsByDeviceType(a.pointerType), !S.preventDefaultAction && this.viewport) {
        if (g.dblClickDragToZoom && t[this.hash].draggingToZoom) {
          var b = Math.pow(this.zoomPerDblClickDrag, a.delta.y / 50);
          this.viewport.zoomBy(b);
        } else if (g.dragToPan && !t[this.hash].draggingToZoom) {
          if (this.panHorizontal || (a.delta.x = 0), this.panVertical || (a.delta.y = 0), this.viewport.flipped && (a.delta.x = -a.delta.x), this.constrainDuringPan) {
            var _ = this.viewport.deltaPointsFromPixels(a.delta.negate());
            this.viewport.centerSpringX.target.value += _.x, this.viewport.centerSpringY.target.value += _.y;
            var I = this.viewport.getConstrainedBounds();
            this.viewport.centerSpringX.target.value -= _.x, this.viewport.centerSpringY.target.value -= _.y, I.xConstrained && (a.delta.x = 0), I.yConstrained && (a.delta.y = 0);
          }
          this.viewport.panBy(this.viewport.deltaPointsFromPixels(a.delta.negate()), g.flickEnabled && !this.constrainDuringPan);
        }
      }
    }
    function k(a) {
      var g, S = {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        speed: a.speed,
        direction: a.direction,
        shift: a.shift,
        originalEvent: a.originalEvent,
        preventDefaultAction: !1
      };
      if (this.raiseEvent("canvas-drag-end", S), g = this.gestureSettingsByDeviceType(a.pointerType), !S.preventDefaultAction && this.viewport) {
        if (!t[this.hash].draggingToZoom && g.flickEnabled && a.speed >= g.flickMinSpeed) {
          var b = 0;
          this.panHorizontal && (b = g.flickMomentum * a.speed * Math.cos(a.direction));
          var _ = 0;
          this.panVertical && (_ = g.flickMomentum * a.speed * Math.sin(a.direction));
          var I = this.viewport.pixelFromPoint(
            this.viewport.getCenter(!0)
          ), O = this.viewport.pointFromPixel(
            new e.Point(I.x - b, I.y - _)
          );
          this.viewport.panTo(O, !1);
        }
        this.viewport.applyConstraints();
      }
      g.dblClickDragToZoom && t[this.hash].draggingToZoom === !0 && (t[this.hash].draggingToZoom = !1);
    }
    function U(a) {
      this.raiseEvent("canvas-enter", {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        buttons: a.buttons,
        pointers: a.pointers,
        insideElementPressed: a.insideElementPressed,
        buttonDownAny: a.buttonDownAny,
        originalEvent: a.originalEvent
      });
    }
    function H(a) {
      this.raiseEvent("canvas-exit", {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        buttons: a.buttons,
        pointers: a.pointers,
        insideElementPressed: a.insideElementPressed,
        buttonDownAny: a.buttonDownAny,
        originalEvent: a.originalEvent
      });
    }
    function M(a) {
      var g;
      if (this.raiseEvent("canvas-press", {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        insideElementPressed: a.insideElementPressed,
        insideElementReleased: a.insideElementReleased,
        originalEvent: a.originalEvent
      }), g = this.gestureSettingsByDeviceType(a.pointerType), g.dblClickDragToZoom) {
        var S = t[this.hash].lastClickTime, b = e.now();
        if (S === null)
          return;
        b - S < this.dblClickTimeThreshold && (t[this.hash].draggingToZoom = !0), t[this.hash].lastClickTime = null;
      }
    }
    function X(a) {
      this.raiseEvent("canvas-release", {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        insideElementPressed: a.insideElementPressed,
        insideElementReleased: a.insideElementReleased,
        originalEvent: a.originalEvent
      });
    }
    function Z(a) {
      this.raiseEvent("canvas-nonprimary-press", {
        tracker: a.eventSource,
        position: a.position,
        pointerType: a.pointerType,
        button: a.button,
        buttons: a.buttons,
        originalEvent: a.originalEvent
      });
    }
    function Y(a) {
      this.raiseEvent("canvas-nonprimary-release", {
        tracker: a.eventSource,
        position: a.position,
        pointerType: a.pointerType,
        button: a.button,
        buttons: a.buttons,
        originalEvent: a.originalEvent
      });
    }
    function $(a) {
      var g, S, b, _, I = {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        gesturePoints: a.gesturePoints,
        lastCenter: a.lastCenter,
        center: a.center,
        lastDistance: a.lastDistance,
        distance: a.distance,
        shift: a.shift,
        originalEvent: a.originalEvent,
        preventDefaultPanAction: !1,
        preventDefaultZoomAction: !1,
        preventDefaultRotateAction: !1
      };
      if (this.raiseEvent("canvas-pinch", I), this.viewport && (g = this.gestureSettingsByDeviceType(a.pointerType), g.pinchToZoom && (!I.preventDefaultPanAction || !I.preventDefaultZoomAction) && (S = this.viewport.pointFromPixel(a.center, !0), g.zoomToRefPoint && !I.preventDefaultPanAction && (b = this.viewport.pointFromPixel(a.lastCenter, !0), _ = b.minus(S), this.panHorizontal || (_.x = 0), this.panVertical || (_.y = 0), this.viewport.panBy(_, !0)), I.preventDefaultZoomAction || this.viewport.zoomBy(a.distance / a.lastDistance, S, !0), this.viewport.applyConstraints()), g.pinchRotate && !I.preventDefaultRotateAction)) {
        var O = Math.atan2(
          a.gesturePoints[0].currentPos.y - a.gesturePoints[1].currentPos.y,
          a.gesturePoints[0].currentPos.x - a.gesturePoints[1].currentPos.x
        ), G = Math.atan2(
          a.gesturePoints[0].lastPos.y - a.gesturePoints[1].lastPos.y,
          a.gesturePoints[0].lastPos.x - a.gesturePoints[1].lastPos.x
        );
        S = this.viewport.pointFromPixel(a.center, !0), this.viewport.rotateTo(this.viewport.getRotation(!0) + (O - G) * (180 / Math.PI), S, !0);
      }
    }
    function te(a) {
      this.raiseEvent("canvas-focus", {
        tracker: a.eventSource,
        originalEvent: a.originalEvent
      });
    }
    function ce(a) {
      this.raiseEvent("canvas-blur", {
        tracker: a.eventSource,
        originalEvent: a.originalEvent
      });
    }
    function ee(a) {
      var g, S, b, _, I;
      _ = e.now(), I = _ - this._lastScrollTime, I > this.minScrollDeltaTime ? (this._lastScrollTime = _, g = {
        tracker: a.eventSource,
        position: a.position,
        scroll: a.scroll,
        shift: a.shift,
        originalEvent: a.originalEvent,
        preventDefaultAction: !1,
        preventDefault: !0
      }, this.raiseEvent("canvas-scroll", g), !g.preventDefaultAction && this.viewport && (this.viewport.flipped && (a.position.x = this.viewport.getContainerSize().x - a.position.x), S = this.gestureSettingsByDeviceType(a.pointerType), S.scrollToZoom && (b = Math.pow(this.zoomPerScroll, a.scroll), this.viewport.zoomBy(
        b,
        S.zoomToRefPoint ? this.viewport.pointFromPixel(a.position, !0) : null
      ), this.viewport.applyConstraints())), a.preventDefault = g.preventDefault) : a.preventDefault = !0;
    }
    function ie(a) {
      t[this.hash].mouseInside = !0, v(this), this.raiseEvent("container-enter", {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        buttons: a.buttons,
        pointers: a.pointers,
        insideElementPressed: a.insideElementPressed,
        buttonDownAny: a.buttonDownAny,
        originalEvent: a.originalEvent
      });
    }
    function re(a) {
      a.pointers < 1 && (t[this.hash].mouseInside = !1, t[this.hash].animating || d(this)), this.raiseEvent("container-exit", {
        tracker: a.eventSource,
        pointerType: a.pointerType,
        position: a.position,
        buttons: a.buttons,
        pointers: a.pointers,
        insideElementPressed: a.insideElementPressed,
        buttonDownAny: a.buttonDownAny,
        originalEvent: a.originalEvent
      });
    }
    function oe(a) {
      Te(a), a.isOpen() ? a._updateRequestId = s(a, oe) : a._updateRequestId = !1;
    }
    function se(a, g) {
      var S = a.viewport, b = S.getZoom(), _ = S.getCenter();
      S.resize(g, a.preserveImageSizeOnResize), S.panTo(_, !0);
      var I;
      if (a.preserveImageSizeOnResize)
        I = t[a.hash].prevContainerSize.x / g.x;
      else {
        var O = new e.Point(0, 0), G = new e.Point(t[a.hash].prevContainerSize.x, t[a.hash].prevContainerSize.y).distanceTo(O), j = new e.Point(g.x, g.y).distanceTo(O);
        I = j / G * t[a.hash].prevContainerSize.x / g.x;
      }
      S.zoomTo(b * I, null, !0), t[a.hash].prevContainerSize = g, t[a.hash].forceRedraw = !0, t[a.hash].needsResize = !1, t[a.hash].forceResize = !1;
    }
    function Te(a) {
      if (!(a._opening || !t[a.hash])) {
        if (a.autoResize || t[a.hash].forceResize) {
          var g;
          if (a._autoResizePolling) {
            g = o(a.container);
            var S = t[a.hash].prevContainerSize;
            g.equals(S) || (t[a.hash].needsResize = !0);
          }
          t[a.hash].needsResize && se(a, g || o(a.container));
        }
        var b = a.viewport.update(), _ = a.world.update() || b;
        b && a.raiseEvent("viewport-change"), a.referenceStrip && (_ = a.referenceStrip.update(a.viewport) || _);
        var I = t[a.hash].animating;
        !I && _ && (a.raiseEvent("animation-start"), v(a));
        var O = I && !_;
        O && (t[a.hash].animating = !1), (_ || O || t[a.hash].forceRedraw || a.world.needsDraw()) && (xe(a), a._drawOverlays(), a.navigator && a.navigator.update(a.viewport), t[a.hash].forceRedraw = !1, _ && a.raiseEvent("animation")), O && (a.raiseEvent("animation-finish"), t[a.hash].mouseInside || d(a)), t[a.hash].animating = _;
      }
    }
    function xe(a) {
      a.imageLoader.clear(), a.drawer.clear(), a.world.draw(), a.raiseEvent("update-viewport", {});
    }
    function N(a, g) {
      return a ? a + g : g;
    }
    function fe() {
      t[this.hash].lastZoomTime = e.now(), t[this.hash].zoomFactor = this.zoomPerSecond, t[this.hash].zooming = !0, le(this);
    }
    function pe() {
      t[this.hash].lastZoomTime = e.now(), t[this.hash].zoomFactor = 1 / this.zoomPerSecond, t[this.hash].zooming = !0, le(this);
    }
    function ge() {
      t[this.hash].zooming = !1;
    }
    function le(a) {
      e.requestAnimationFrame(e.delegate(a, me));
    }
    function me() {
      var a, g, S;
      t[this.hash].zooming && this.viewport && (a = e.now(), g = a - t[this.hash].lastZoomTime, S = Math.pow(t[this.hash].zoomFactor, g / 1e3), this.viewport.zoomBy(S), this.viewport.applyConstraints(), t[this.hash].lastZoomTime = a, le(this));
    }
    function Se() {
      this.viewport && (t[this.hash].zooming = !1, this.viewport.zoomBy(
        this.zoomPerClick / 1
      ), this.viewport.applyConstraints());
    }
    function ve() {
      this.viewport && (t[this.hash].zooming = !1, this.viewport.zoomBy(
        1 / this.zoomPerClick
      ), this.viewport.applyConstraints());
    }
    function ye() {
      this.buttonGroup && (this.buttonGroup.emulateEnter(), this.buttonGroup.emulateLeave());
    }
    function Ee() {
      this.viewport && this.viewport.goHome();
    }
    function we() {
      this.isFullPage() && !e.isFullScreen() ? this.setFullPage(!1) : this.setFullScreen(!this.isFullPage()), this.buttonGroup && this.buttonGroup.emulateLeave(), this.fullPageButton.element.focus(), this.viewport && this.viewport.applyConstraints();
    }
    function Pe() {
      if (this.viewport) {
        var a = this.viewport.getRotation();
        this.viewport.flipped ? a += this.rotationIncrement : a -= this.rotationIncrement, this.viewport.setRotation(a);
      }
    }
    function de() {
      if (this.viewport) {
        var a = this.viewport.getRotation();
        this.viewport.flipped ? a -= this.rotationIncrement : a += this.rotationIncrement, this.viewport.setRotation(a);
      }
    }
    function he() {
      this.viewport.toggleFlip();
    }
  }(D), function(e) {
    e.Navigator = function(s) {
      var l = s.viewer, d = this, f, v;
      s.element || s.id ? (s.element ? (s.id && e.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead."), s.element.id ? s.id = s.element.id : s.id = "navigator-" + e.now(), this.element = s.element) : this.element = document.getElementById(s.id), s.controlOptions = {
        anchor: e.ControlAnchor.NONE,
        attachToViewer: !1,
        autoFade: !1
      }) : (s.id = "navigator-" + e.now(), this.element = e.makeNeutralElement("div"), s.controlOptions = {
        anchor: e.ControlAnchor.TOP_RIGHT,
        attachToViewer: !0,
        autoFade: s.autoFade
      }, s.position && (s.position === "BOTTOM_RIGHT" ? s.controlOptions.anchor = e.ControlAnchor.BOTTOM_RIGHT : s.position === "BOTTOM_LEFT" ? s.controlOptions.anchor = e.ControlAnchor.BOTTOM_LEFT : s.position === "TOP_RIGHT" ? s.controlOptions.anchor = e.ControlAnchor.TOP_RIGHT : s.position === "TOP_LEFT" ? s.controlOptions.anchor = e.ControlAnchor.TOP_LEFT : s.position === "ABSOLUTE" && (s.controlOptions.anchor = e.ControlAnchor.ABSOLUTE, s.controlOptions.top = s.top, s.controlOptions.left = s.left, s.controlOptions.height = s.height, s.controlOptions.width = s.width))), this.element.id = s.id, this.element.className += " navigator", s = e.extend(!0, {
        sizeRatio: e.DEFAULT_SETTINGS.navigatorSizeRatio
      }, s, {
        element: this.element,
        tabIndex: -1,
        // No keyboard navigation, omit from tab order
        //These need to be overridden to prevent recursion since
        //the navigator is a viewer and a viewer has a navigator
        showNavigator: !1,
        mouseNavEnabled: !1,
        showNavigationControl: !1,
        showSequenceControl: !1,
        immediateRender: !0,
        blendTime: 0,
        animationTime: s.animationTime,
        // disable autoResize since resize behavior is implemented differently by the navigator
        autoResize: !1,
        // prevent resizing the navigator from adding unwanted space around the image
        minZoomImageRatio: 1,
        background: s.background,
        opacity: s.opacity,
        borderColor: s.borderColor,
        displayRegionColor: s.displayRegionColor
      }), s.minPixelRatio = this.minPixelRatio = l.minPixelRatio, e.setElementTouchActionNone(this.element), this.borderWidth = 2, this.fudge = new e.Point(1, 1), this.totalBorderWidths = new e.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge), s.controlOptions.anchor !== e.ControlAnchor.NONE && function(w, x) {
        w.margin = "0px", w.border = x + "px solid " + s.borderColor, w.padding = "0px", w.background = s.background, w.opacity = s.opacity, w.overflow = "hidden";
      }(this.element.style, this.borderWidth), this.displayRegion = e.makeNeutralElement("div"), this.displayRegion.id = this.element.id + "-displayregion", this.displayRegion.className = "displayregion", function(w, x) {
        w.position = "relative", w.top = "0px", w.left = "0px", w.fontSize = "0px", w.overflow = "hidden", w.border = x + "px solid " + s.displayRegionColor, w.margin = "0px", w.padding = "0px", w.background = "transparent", w.float = "left", w.cssFloat = "left", w.styleFloat = "left", w.zIndex = 999999999, w.cursor = "default", w.boxSizing = "content-box";
      }(this.displayRegion.style, this.borderWidth), e.setElementPointerEventsNone(this.displayRegion), e.setElementTouchActionNone(this.displayRegion), this.displayRegionContainer = e.makeNeutralElement("div"), this.displayRegionContainer.id = this.element.id + "-displayregioncontainer", this.displayRegionContainer.className = "displayregioncontainer", this.displayRegionContainer.style.width = "100%", this.displayRegionContainer.style.height = "100%", e.setElementPointerEventsNone(this.displayRegionContainer), e.setElementTouchActionNone(this.displayRegionContainer), l.addControl(
        this.element,
        s.controlOptions
      ), this._resizeWithViewer = s.controlOptions.anchor !== e.ControlAnchor.ABSOLUTE && s.controlOptions.anchor !== e.ControlAnchor.NONE, s.width && s.height ? (this.setWidth(s.width), this.setHeight(s.height)) : this._resizeWithViewer && (f = e.getElementSize(l.element), this.element.style.height = Math.round(f.y * s.sizeRatio) + "px", this.element.style.width = Math.round(f.x * s.sizeRatio) + "px", this.oldViewerSize = f, v = e.getElementSize(this.element), this.elementArea = v.x * v.y), this.oldContainerSize = new e.Point(0, 0), e.Viewer.apply(this, [s]), this.displayRegionContainer.appendChild(this.displayRegion), this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
      function y(w, x) {
        n(d.displayRegionContainer, w), n(d.displayRegion, -w), d.viewport.setRotation(w, x);
      }
      if (s.navigatorRotate) {
        var T = s.viewer.viewport ? s.viewer.viewport.getRotation() : s.viewer.degrees || 0;
        y(T, !0), s.viewer.addHandler("rotate", function(w) {
          y(w.degrees, w.immediately);
        });
      }
      this.innerTracker.destroy(), this.innerTracker = new e.MouseTracker({
        userData: "Navigator.innerTracker",
        element: this.element,
        //this.canvas,
        dragHandler: e.delegate(this, i),
        clickHandler: e.delegate(this, t),
        releaseHandler: e.delegate(this, o),
        scrollHandler: e.delegate(this, h),
        preProcessEventHandler: function(w) {
          w.eventType === "wheel" && (w.preventDefault = !0);
        }
      }), this.outerTracker.userData = "Navigator.outerTracker", e.setElementPointerEventsNone(this.canvas), e.setElementPointerEventsNone(this.container), this.addHandler("reset-size", function() {
        d.viewport && d.viewport.goHome(!0);
      }), l.world.addHandler("item-index-change", function(w) {
        window.setTimeout(function() {
          var x = d.world.getItemAt(w.previousIndex);
          d.world.setItemIndex(x, w.newIndex);
        }, 1);
      }), l.world.addHandler("remove-item", function(w) {
        var x = w.item, P = d._getMatchingItem(x);
        P && d.world.removeItem(P);
      }), this.update(l.viewport);
    }, e.extend(
      e.Navigator.prototype,
      e.EventSource.prototype,
      e.Viewer.prototype,
      /** @lends OpenSeadragon.Navigator.prototype */
      {
        /**
         * Used to notify the navigator when its size has changed.
         * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
         * @function
         */
        updateSize: function() {
          if (this.viewport) {
            var s = new e.Point(
              this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
              this.container.clientHeight === 0 ? 1 : this.container.clientHeight
            );
            s.equals(this.oldContainerSize) || (this.viewport.resize(s, !0), this.viewport.goHome(!0), this.oldContainerSize = s, this.drawer.clear(), this.world.draw());
          }
        },
        /**
         * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
         * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
         */
        setWidth: function(s) {
          this.width = s, this.element.style.width = typeof s == "number" ? s + "px" : s, this._resizeWithViewer = !1, this.updateSize();
        },
        /**
         * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
         * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
         */
        setHeight: function(s) {
          this.height = s, this.element.style.height = typeof s == "number" ? s + "px" : s, this._resizeWithViewer = !1, this.updateSize();
        },
        /**
          * Flip navigator element
          * @param {Boolean} state - Flip state to set.
          */
        setFlip: function(s) {
          return this.viewport.setFlip(s), this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)"), this;
        },
        setDisplayTransform: function(s) {
          r(this.displayRegion, s), r(this.canvas, s), r(this.element, s);
        },
        /**
         * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
         * @function
         * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.
         */
        update: function(s) {
          var l, d, f, v, y, T;
          if (l = e.getElementSize(this.viewer.element), this._resizeWithViewer && l.x && l.y && !l.equals(this.oldViewerSize) && (this.oldViewerSize = l, this.maintainSizeRatio || !this.elementArea ? (d = l.x * this.sizeRatio, f = l.y * this.sizeRatio) : (d = Math.sqrt(this.elementArea * (l.x / l.y)), f = this.elementArea / d), this.element.style.width = Math.round(d) + "px", this.element.style.height = Math.round(f) + "px", this.elementArea || (this.elementArea = d * f), this.updateSize()), s && this.viewport) {
            if (v = s.getBoundsNoRotate(!0), y = this.viewport.pixelFromPointNoRotate(v.getTopLeft(), !1), T = this.viewport.pixelFromPointNoRotate(v.getBottomRight(), !1).minus(this.totalBorderWidths), !this.navigatorRotate) {
              var w = s.getRotation(!0);
              n(this.displayRegion, -w);
            }
            var x = this.displayRegion.style;
            x.display = this.world.getItemCount() ? "block" : "none", x.top = y.y.toFixed(2) + "px", x.left = y.x.toFixed(2) + "px";
            var P = T.x - y.x, C = T.y - y.y;
            x.width = Math.round(Math.max(P, 0)) + "px", x.height = Math.round(Math.max(C, 0)) + "px";
          }
        },
        // overrides Viewer.addTiledImage
        addTiledImage: function(s) {
          var l = this, d = s.originalTiledImage;
          delete s.original;
          var f = e.extend({}, s, {
            success: function(v) {
              var y = v.item;
              y._originalForNavigator = d, l._matchBounds(y, d, !0), l._matchOpacity(y, d), l._matchCompositeOperation(y, d);
              function T() {
                l._matchBounds(y, d);
              }
              function w() {
                l._matchOpacity(y, d);
              }
              function x() {
                l._matchCompositeOperation(y, d);
              }
              d.addHandler("bounds-change", T), d.addHandler("clip-change", T), d.addHandler("opacity-change", w), d.addHandler("composite-operation-change", x);
            }
          });
          return e.Viewer.prototype.addTiledImage.apply(this, [f]);
        },
        destroy: function() {
          return e.Viewer.prototype.destroy.apply(this);
        },
        // private
        _getMatchingItem: function(s) {
          for (var l = this.world.getItemCount(), d, f = 0; f < l; f++)
            if (d = this.world.getItemAt(f), d._originalForNavigator === s)
              return d;
          return null;
        },
        // private
        _matchBounds: function(s, l, d) {
          var f = l.getBoundsNoRotate();
          s.setPosition(f.getTopLeft(), d), s.setWidth(f.width, d), s.setRotation(l.getRotation(), d), s.setClip(l.getClip()), s.setFlip(l.getFlip());
        },
        // private
        _matchOpacity: function(s, l) {
          s.setOpacity(l.opacity);
        },
        // private
        _matchCompositeOperation: function(s, l) {
          s.setCompositeOperation(l.compositeOperation);
        }
      }
    );
    function t(s) {
      var l = {
        tracker: s.eventSource,
        position: s.position,
        quick: s.quick,
        shift: s.shift,
        originalEvent: s.originalEvent,
        preventDefaultAction: !1
      };
      if (this.viewer.raiseEvent("navigator-click", l), !l.preventDefaultAction && s.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
        this.viewer.viewport.flipped && (s.position.x = this.viewport.getContainerSize().x - s.position.x);
        var d = this.viewport.pointFromPixel(s.position);
        this.panVertical ? this.panHorizontal || (d.x = this.viewer.viewport.getCenter(!0).x) : d.y = this.viewer.viewport.getCenter(!0).y, this.viewer.viewport.panTo(d), this.viewer.viewport.applyConstraints();
      }
    }
    function i(s) {
      var l = {
        tracker: s.eventSource,
        position: s.position,
        delta: s.delta,
        speed: s.speed,
        direction: s.direction,
        shift: s.shift,
        originalEvent: s.originalEvent,
        preventDefaultAction: !1
      };
      this.viewer.raiseEvent("navigator-drag", l), !l.preventDefaultAction && this.viewer.viewport && (this.panHorizontal || (s.delta.x = 0), this.panVertical || (s.delta.y = 0), this.viewer.viewport.flipped && (s.delta.x = -s.delta.x), this.viewer.viewport.panBy(
        this.viewport.deltaPointsFromPixels(
          s.delta
        )
      ), this.viewer.constrainDuringPan && this.viewer.viewport.applyConstraints());
    }
    function o(s) {
      s.insideElementPressed && this.viewer.viewport && this.viewer.viewport.applyConstraints();
    }
    function h(s) {
      var l = {
        tracker: s.eventSource,
        position: s.position,
        scroll: s.scroll,
        shift: s.shift,
        originalEvent: s.originalEvent,
        preventDefault: s.preventDefault
      };
      this.viewer.raiseEvent("navigator-scroll", l), s.preventDefault = l.preventDefault;
    }
    function n(s, l) {
      r(s, "rotate(" + l + "deg)");
    }
    function r(s, l) {
      s.style.webkitTransform = l, s.style.mozTransform = l, s.style.msTransform = l, s.style.oTransform = l, s.style.transform = l;
    }
  }(D), function(e) {
    var t = {
      Errors: {
        Dzc: "Sorry, we don't support Deep Zoom Collections!",
        Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
        Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
        ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
        Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
        Status: "This space unintentionally left blank ({0} {1}).",
        OpenFailed: "Unable to open {0}: {1}"
      },
      Tooltips: {
        FullPage: "Toggle full page",
        Home: "Go home",
        ZoomIn: "Zoom in",
        ZoomOut: "Zoom out",
        NextPage: "Next page",
        PreviousPage: "Previous page",
        RotateLeft: "Rotate left",
        RotateRight: "Rotate right",
        Flip: "Flip Horizontally"
      }
    };
    e.extend(
      e,
      /** @lends OpenSeadragon */
      {
        /**
         * @function
         * @param {String} property
         */
        getString: function(i) {
          var o = i.split("."), h = null, n = arguments, r = t, s;
          for (s = 0; s < o.length - 1; s++)
            r = r[o[s]] || {};
          return h = r[o[s]], typeof h != "string" && (e.console.error("Untranslated source string:", i), h = ""), h.replace(/\{\d+\}/g, function(l) {
            var d = parseInt(l.match(/\d+/), 10) + 1;
            return d < n.length ? n[d] : "";
          });
        },
        /**
         * @function
         * @param {String} property
         * @param {*} value
         */
        setString: function(i, o) {
          var h = i.split("."), n = t, r;
          for (r = 0; r < h.length - 1; r++)
            n[h[r]] || (n[h[r]] = {}), n = n[h[r]];
          n[h[r]] = o;
        }
      }
    );
  }(D), function(e) {
    e.Point = function(t, i) {
      this.x = typeof t == "number" ? t : 0, this.y = typeof i == "number" ? i : 0;
    }, e.Point.prototype = {
      /**
       * @function
       * @returns {OpenSeadragon.Point} a duplicate of this Point
       */
      clone: function() {
        return new e.Point(this.x, this.y);
      },
      /**
       * Add another Point to this point and return a new Point.
       * @function
       * @param {OpenSeadragon.Point} point The point to add vector components.
       * @returns {OpenSeadragon.Point} A new point representing the sum of the
       *  vector components
       */
      plus: function(t) {
        return new e.Point(
          this.x + t.x,
          this.y + t.y
        );
      },
      /**
       * Subtract another Point to this point and return a new Point.
       * @function
       * @param {OpenSeadragon.Point} point The point to subtract vector components.
       * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
       *  vector components
       */
      minus: function(t) {
        return new e.Point(
          this.x - t.x,
          this.y - t.y
        );
      },
      /**
       * Multiply this point by a factor and return a new Point.
       * @function
       * @param {Number} factor The factor to multiply vector components.
       * @returns {OpenSeadragon.Point} A new point representing the multiplication
       *  of the vector components by the factor
       */
      times: function(t) {
        return new e.Point(
          this.x * t,
          this.y * t
        );
      },
      /**
       * Divide this point by a factor and return a new Point.
       * @function
       * @param {Number} factor The factor to divide vector components.
       * @returns {OpenSeadragon.Point} A new point representing the division of the
       *  vector components by the factor
       */
      divide: function(t) {
        return new e.Point(
          this.x / t,
          this.y / t
        );
      },
      /**
       * Compute the opposite of this point and return a new Point.
       * @function
       * @returns {OpenSeadragon.Point} A new point representing the opposite of the
       *  vector components
       */
      negate: function() {
        return new e.Point(-this.x, -this.y);
      },
      /**
       * Compute the distance between this point and another point.
       * @function
       * @param {OpenSeadragon.Point} point The point to compute the distance with.
       * @returns {Number} The distance between the 2 points
       */
      distanceTo: function(t) {
        return Math.sqrt(
          Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2)
        );
      },
      /**
       * Compute the squared distance between this point and another point.
       * Useful for optimizing things like comparing distances.
       * @function
       * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
       * @returns {Number} The squared distance between the 2 points
       */
      squaredDistanceTo: function(t) {
        return Math.pow(this.x - t.x, 2) + Math.pow(this.y - t.y, 2);
      },
      /**
       * Apply a function to each coordinate of this point and return a new point.
       * @function
       * @param {function} func The function to apply to each coordinate.
       * @returns {OpenSeadragon.Point} A new point with the coordinates computed
       * by the specified function
       */
      apply: function(t) {
        return new e.Point(t(this.x), t(this.y));
      },
      /**
       * Check if this point is equal to another one.
       * @function
       * @param {OpenSeadragon.Point} point The point to compare this point with.
       * @returns {Boolean} true if they are equal, false otherwise.
       */
      equals: function(t) {
        return t instanceof e.Point && this.x === t.x && this.y === t.y;
      },
      /**
       * Rotates the point around the specified pivot
       * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
       * @function
       * @param {Number} degress to rotate around the pivot.
       * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
       * Defaults to the origin.
       * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
       */
      rotate: function(t, i) {
        i = i || new e.Point(0, 0);
        var o, h;
        if (t % 90 === 0) {
          var n = e.positiveModulo(t, 360);
          switch (n) {
            case 0:
              o = 1, h = 0;
              break;
            case 90:
              o = 0, h = 1;
              break;
            case 180:
              o = -1, h = 0;
              break;
            case 270:
              o = 0, h = -1;
              break;
          }
        } else {
          var r = t * Math.PI / 180;
          o = Math.cos(r), h = Math.sin(r);
        }
        var s = o * (this.x - i.x) - h * (this.y - i.y) + i.x, l = h * (this.x - i.x) + o * (this.y - i.y) + i.y;
        return new e.Point(s, l);
      },
      /**
       * Convert this point to a string in the format (x,y) where x and y are
       * rounded to the nearest integer.
       * @function
       * @returns {String} A string representation of this point.
       */
      toString: function() {
        return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
      }
    };
  }(D), function(e) {
    e.TileSource = function(i, o, h, n, r, s) {
      var l = this, d = arguments, f, v;
      if (e.isPlainObject(i) ? f = i : f = {
        width: d[0],
        height: d[1],
        tileSize: d[2],
        tileOverlap: d[3],
        minLevel: d[4],
        maxLevel: d[5]
      }, e.EventSource.call(this), e.extend(!0, this, f), !this.success) {
        for (v = 0; v < arguments.length; v++)
          if (e.isFunction(arguments[v])) {
            this.success = arguments[v];
            break;
          }
      }
      this.success && this.addHandler("ready", function(y) {
        l.success(y);
      }), e.type(arguments[0]) === "string" && (this.url = arguments[0]), this.url ? (this.aspectRatio = 1, this.dimensions = new e.Point(10, 10), this._tileWidth = 0, this._tileHeight = 0, this.tileOverlap = 0, this.minLevel = 0, this.maxLevel = 0, this.ready = !1, this.getImageInfo(this.url)) : (this.ready = !0, this.aspectRatio = f.width && f.height ? f.width / f.height : 1, this.dimensions = new e.Point(f.width, f.height), this.tileSize ? (this._tileWidth = this._tileHeight = this.tileSize, delete this.tileSize) : (this.tileWidth ? (this._tileWidth = this.tileWidth, delete this.tileWidth) : this._tileWidth = 0, this.tileHeight ? (this._tileHeight = this.tileHeight, delete this.tileHeight) : this._tileHeight = 0), this.tileOverlap = f.tileOverlap ? f.tileOverlap : 0, this.minLevel = f.minLevel ? f.minLevel : 0, this.maxLevel = f.maxLevel !== void 0 && f.maxLevel !== null ? f.maxLevel : f.width && f.height ? Math.ceil(
        Math.log(Math.max(f.width, f.height)) / Math.log(2)
      ) : 0, this.success && e.isFunction(this.success) && this.success(this));
    }, e.TileSource.prototype = {
      getTileSize: function(i) {
        return e.console.error(
          "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
        ), this._tileWidth;
      },
      /**
       * Return the tileWidth for a given level.
       * Subclasses should override this if tileWidth can be different at different levels
       *   such as in IIIFTileSource.  Code should use this function rather than reading
       *   from ._tileWidth directly.
       * @function
       * @param {Number} level
       */
      getTileWidth: function(i) {
        return this._tileWidth ? this._tileWidth : this.getTileSize(i);
      },
      /**
       * Return the tileHeight for a given level.
       * Subclasses should override this if tileHeight can be different at different levels
       *   such as in IIIFTileSource.  Code should use this function rather than reading
       *   from ._tileHeight directly.
       * @function
       * @param {Number} level
       */
      getTileHeight: function(i) {
        return this._tileHeight ? this._tileHeight : this.getTileSize(i);
      },
      /**
       * Set the maxLevel to the given level, and perform the memoization of
       * getLevelScale with the new maxLevel. This function can be useful if the
       * memoization is required before the first call of getLevelScale, or both
       * memoized getLevelScale and maxLevel should be changed accordingly.
       * @function
       * @param {Number} level
       */
      setMaxLevel: function(i) {
        this.maxLevel = i, this._memoizeLevelScale();
      },
      /**
       * @function
       * @param {Number} level
       */
      getLevelScale: function(i) {
        return this._memoizeLevelScale(), this.getLevelScale(i);
      },
      // private
      _memoizeLevelScale: function() {
        var i = {}, o;
        for (o = 0; o <= this.maxLevel; o++)
          i[o] = 1 / Math.pow(2, this.maxLevel - o);
        this.getLevelScale = function(h) {
          return i[h];
        };
      },
      /**
       * @function
       * @param {Number} level
       */
      getNumTiles: function(i) {
        var o = this.getLevelScale(i), h = Math.ceil(o * this.dimensions.x / this.getTileWidth(i)), n = Math.ceil(o * this.dimensions.y / this.getTileHeight(i));
        return new e.Point(h, n);
      },
      /**
       * @function
       * @param {Number} level
       */
      getPixelRatio: function(i) {
        var o = this.dimensions.times(this.getLevelScale(i)), h = 1 / o.x * e.pixelDensityRatio, n = 1 / o.y * e.pixelDensityRatio;
        return new e.Point(h, n);
      },
      /**
       * @function
       * @returns {Number} The highest level in this tile source that can be contained in a single tile.
       */
      getClosestLevel: function() {
        var i, o;
        for (i = this.minLevel + 1; i <= this.maxLevel && (o = this.getNumTiles(i), !(o.x > 1 || o.y > 1)); i++)
          ;
        return i - 1;
      },
      /**
       * @function
       * @param {Number} level
       * @param {OpenSeadragon.Point} point
       */
      getTileAtPoint: function(i, o) {
        var h = o.x >= 0 && o.x <= 1 && o.y >= 0 && o.y <= 1 / this.aspectRatio;
        e.console.assert(h, "[TileSource.getTileAtPoint] must be called with a valid point.");
        var n = this.dimensions.x * this.getLevelScale(i), r = o.x * n, s = o.y * n, l = Math.floor(r / this.getTileWidth(i)), d = Math.floor(s / this.getTileHeight(i));
        o.x >= 1 && (l = this.getNumTiles(i).x - 1);
        var f = 1e-15;
        return o.y >= 1 / this.aspectRatio - f && (d = this.getNumTiles(i).y - 1), new e.Point(l, d);
      },
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
       * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
       * portion of the tile to use as the source of the drawing operation (in pixels), depending on
       * the isSource parameter.
       */
      getTileBounds: function(i, o, h, n) {
        var r = this.dimensions.times(this.getLevelScale(i)), s = this.getTileWidth(i), l = this.getTileHeight(i), d = o === 0 ? 0 : s * o - this.tileOverlap, f = h === 0 ? 0 : l * h - this.tileOverlap, v = s + (o === 0 ? 1 : 2) * this.tileOverlap, y = l + (h === 0 ? 1 : 2) * this.tileOverlap, T = 1 / r.x;
        return v = Math.min(v, r.x - d), y = Math.min(y, r.y - f), n ? new e.Rect(0, 0, v, y) : new e.Rect(d * T, f * T, v * T, y * T);
      },
      /**
       * Responsible for retrieving, and caching the
       * image metadata pertinent to this TileSources implementation.
       * @function
       * @param {String} url
       * @throws {Error}
       */
      getImageInfo: function(i) {
        var o = this, h, n, r, s, l, d, f;
        i && (l = i.split("/"), d = l[l.length - 1], f = d.lastIndexOf("."), f > -1 && (l[l.length - 1] = d.slice(0, f)));
        var v = null;
        if (this.splitHashDataForPost) {
          var y = i.indexOf("#");
          y !== -1 && (v = i.substring(y + 1), i = i.substr(0, y));
        }
        n = function(T) {
          typeof T == "string" && (T = e.parseXml(T));
          var w = e.TileSource.determineType(o, T, i);
          if (!w) {
            o.raiseEvent("open-failed", { message: "Unable to load TileSource", source: i });
            return;
          }
          s = w.prototype.configure.apply(o, [T, i, v]), s.ajaxWithCredentials === void 0 && (s.ajaxWithCredentials = o.ajaxWithCredentials), r = new w(s), o.ready = !0, o.raiseEvent("ready", { tileSource: r });
        }, i.match(/\.js$/) ? (h = i.split("/").pop().replace(".js", ""), e.jsonp({
          url: i,
          async: !1,
          callbackName: h,
          callback: n
        })) : e.makeAjaxRequest({
          url: i,
          postData: v,
          withCredentials: this.ajaxWithCredentials,
          headers: this.ajaxHeaders,
          success: function(T) {
            var w = t(T);
            n(w);
          },
          error: function(T, w) {
            var x;
            try {
              x = "HTTP " + T.status + " attempting to load TileSource: " + i;
            } catch {
              var P;
              typeof w > "u" || !w.toString ? P = "Unknown error" : P = w.toString(), x = P + " attempting to load TileSource: " + i;
            }
            e.console.error(x), o.raiseEvent("open-failed", {
              message: x,
              source: i,
              postData: v
            });
          }
        });
      },
      /**
       * Responsible determining if a the particular TileSource supports the
       * data format ( and allowed to apply logic against the url the data was
       * loaded from, if any ). Overriding implementations are expected to do
       * something smart with data and / or url to determine support.  Also
       * understand that iteration order of TileSources is not guarunteed so
       * please make sure your data or url is expressive enough to ensure a simple
       * and sufficient mechanisim for clear determination.
       * @function
       * @param {String|Object|Array|Document} data
       * @param {String} url - the url the data was loaded
       *      from if any.
       * @returns {Boolean}
       */
      supports: function(i, o) {
        return !1;
      },
      /**
       * Responsible for parsing and configuring the
       * image metadata pertinent to this TileSources implementation.
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {String|Object|Array|Document} data
       * @param {String} url - the url the data was loaded
       *      from if any.
       * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null value obtained from
       *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
       * @returns {Object} options - A dictionary of keyword arguments sufficient
       *      to configure the tile source constructor (include all values you want to
       *      instantiate the TileSource subclass with - what _options_ object should contain).
       * @throws {Error}
       */
      configure: function(i, o, h) {
        throw new Error("Method not implemented.");
      },
      /**
       * Responsible for retrieving the url which will return an image for the
       * region specified by the given x, y, and level components.
       * This method is not implemented by this class other than to throw an Error
       * announcing you have to implement it.  Because of the variety of tile
       * server technologies, and various specifications for building image
       * pyramids, this method is here to allow easy integration.
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {String|Function} url - A string for the url or a function that returns a url string.
       * @throws {Error}
       */
      getTileUrl: function(i, o, h) {
        throw new Error("Method not implemented.");
      },
      /**
       * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
       * If a value is returned, ajax issues POST request to the tile url.
       * If null is returned, ajax issues GET request.
       * The return value must comply to the header 'content type'.
       *
       * Examples (USED HEADER --> getTilePostData CODE):
       * 'Content-type': 'application/x-www-form-urlencoded' -->
       *   return "key1=value=1&key2=value2";
       *
       * 'Content-type': 'application/x-www-form-urlencoded' -->
       *   return JSON.stringify({key: "value", number: 5});
       *
       * 'Content-type': 'multipart/form-data' -->
       *   let result = new FormData();
       *   result.append("data", myData);
       *   return result;
       *
       * IMPORTANT: in case you move all the logic on image fetching
       * to post data, you must re-define 'getTileHashKey(...)' to
       * stay unique for different tile images.
       *
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {*|null} post data to send with tile configuration request
       */
      getTilePostData: function(i, o, h) {
        return null;
      },
      /**
       * Responsible for retrieving the headers which will be attached to the image request for the
       * region specified by the given x, y, and level components.
       * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
       * The headers returned here will override headers specified at the Viewer or TiledImage level.
       * Specifying a falsy value for a header will clear its existing value set at the Viewer or
       * TiledImage level (if any).
       *
       * Note that the headers of existing tiles don't automatically change when this function
       * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
       * and propagate the changes.
       *
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       * @returns {Object}
       */
      getTileAjaxHeaders: function(i, o, h) {
        return {};
      },
      /**
       * The tile cache object is uniquely determined by this key and used to lookup
       * the image data in cache: keys should be different if images are different.
       *
       * In case a tile has context2D property defined (TileSource.prototype.getContext2D)
       * or its context2D is set manually; the cache is not used and this function
       * is irrelevant.
       * Note: default behaviour does not take into account post data.
       * @param {Number} level tile level it was fetched with
       * @param {Number} x x-coordinate in the pyramid level
       * @param {Number} y y-coordinate in the pyramid level
       * @param {String} url the tile was fetched with
       * @param {Object} ajaxHeaders the tile was fetched with
       * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
       */
      getTileHashKey: function(i, o, h, n, r, s) {
        function l(d) {
          return r ? d + "+" + JSON.stringify(r) : d;
        }
        return l(typeof n != "string" ? i + "/" + o + "_" + h : n);
      },
      /**
       * @function
       * @param {Number} level
       * @param {Number} x
       * @param {Number} y
       */
      tileExists: function(i, o, h) {
        var n = this.getNumTiles(i);
        return i >= this.minLevel && i <= this.maxLevel && o >= 0 && h >= 0 && o < n.x && h < n.y;
      },
      /**
       * Decide whether tiles have transparency: this is crucial for correct images blending.
       * @returns {boolean} true if the image has transparency
       */
      hasTransparency: function(i, o, h, n) {
        return !!i || o.match(".png");
      },
      /**
       * Download tile data.
       * Note that if you override this function, you should override also downloadTileAbort().
       * @param {ImageJob} context job context that you have to call finish(...) on.
       * @param {String} [context.src] - URL of image to download.
       * @param {String} [context.loadWithAjax] - Whether to load this image with AJAX.
       * @param {String} [context.ajaxHeaders] - Headers to add to the image request if using AJAX.
       * @param {Boolean} [context.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
       * @param {String} [context.crossOriginPolicy] - CORS policy to use for downloads
       * @param {String} [context.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
       *   see TileSource::getPostData) or null
       * @param {*} [context.userData] - Empty object to attach your own data and helper variables to.
       * @param {Function} [context.finish] - Should be called unless abort() was executed, e.g. on all occasions,
       *   be it successful or unsuccessful request.
       *   Usage: context.finish(data, request, errMessage). Pass the downloaded data object or null upon failure.
       *   Add also reference to an ajax request if used. Provide error message in case of failure.
       * @param {Function} [context.abort] - Called automatically when the job times out.
       *   Usage: context.abort().
       * @param {Function} [context.callback] @private - Called automatically once image has been downloaded
       *   (triggered by finish).
       * @param {Number} [context.timeout] @private - The max number of milliseconds that
       *   this image job may take to complete.
       * @param {string} [context.errorMsg] @private - The final error message, default null (set by finish).
       */
      downloadTileStart: function(i) {
        var o = i.userData, h = new Image();
        o.image = h, o.request = null;
        var n = function(r) {
          if (!h) {
            i.finish(null, o.request, "Image load failed: undefined Image instance.");
            return;
          }
          h.onload = h.onerror = h.onabort = null, i.finish(r ? null : h, o.request, r);
        };
        h.onload = function() {
          n();
        }, h.onabort = h.onerror = function() {
          n("Image load aborted.");
        }, i.loadWithAjax ? o.request = e.makeAjaxRequest({
          url: i.src,
          withCredentials: i.ajaxWithCredentials,
          headers: i.ajaxHeaders,
          responseType: "arraybuffer",
          postData: i.postData,
          success: function(r) {
            var s;
            try {
              s = new window.Blob([r.response]);
            } catch (f) {
              var l = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
              if (f.name === "TypeError" && l) {
                var d = new l();
                d.append(r.response), s = d.getBlob();
              }
            }
            s.size === 0 ? n("Empty image response.") : h.src = (window.URL || window.webkitURL).createObjectURL(s);
          },
          error: function(r) {
            n("Image load aborted - XHR error");
          }
        }) : (i.crossOriginPolicy !== !1 && (h.crossOrigin = i.crossOriginPolicy), h.src = i.src);
      },
      /**
       * Provide means of aborting the execution.
       * Note that if you override this function, you should override also downloadTileStart().
       * @param {ImageJob} context job, the same object as with downloadTileStart(..)
       * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
       */
      downloadTileAbort: function(i) {
        i.userData.request && i.userData.request.abort();
        var o = i.userData.image;
        i.userData.image && (o.onload = o.onerror = o.onabort = null);
      },
      /**
       * Create cache object from the result of the download process. The
       * cacheObject parameter should be used to attach the data to, there are no
       * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
       *
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
       * @param {Tile} tile instance the cache was created with
       */
      createTileCache: function(i, o, h) {
        i._data = o;
      },
      /**
       * Cache object destructor, unset all properties you created to allow GC collection.
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       */
      destroyTileCache: function(i) {
        i._data = null, i._renderedContext = null;
      },
      /**
       * Raw data getter
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       * @returns {*} cache data
       */
      getTileCacheData: function(i) {
        return i._data;
      },
      /**
       * Compatibility image element getter
       *  - plugins might need image representation of the data
       *  - div HTML rendering relies on image element presence
       * Note that if you override any of *TileCache() functions, you should override all of them.
       *  @param {object} cacheObject context cache object
       *  @returns {Image} cache data as an Image
       */
      getTileCacheDataAsImage: function(i) {
        return i._data;
      },
      /**
       * Compatibility context 2D getter
       *  - most heavily used rendering method is a canvas-based approach,
       *    convert the data to a canvas and return it's 2D context
       * Note that if you override any of *TileCache() functions, you should override all of them.
       * @param {object} cacheObject context cache object
       * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
       */
      getTileCacheDataAsContext2D: function(i) {
        if (!i._renderedContext) {
          var o = document.createElement("canvas");
          o.width = i._data.width, o.height = i._data.height, i._renderedContext = o.getContext("2d"), i._renderedContext.drawImage(i._data, 0, 0), i._data = null;
        }
        return i._renderedContext;
      }
    }, e.extend(!0, e.TileSource.prototype, e.EventSource.prototype);
    function t(i) {
      var o = i.responseText, h = i.status, n, r;
      if (i) {
        if (i.status !== 200 && i.status !== 0)
          throw h = i.status, n = h === 404 ? "Not Found" : i.statusText, new Error(e.getString("Errors.Status", h, n));
      } else
        throw new Error(e.getString("Errors.Security"));
      if (o.match(/^\s*<.*/))
        try {
          r = i.responseXML && i.responseXML.documentElement ? i.responseXML : e.parseXml(o);
        } catch {
          r = i.responseText;
        }
      else if (o.match(/\s*[{[].*/))
        try {
          r = e.parseJSON(o);
        } catch {
          r = o;
        }
      else
        r = o;
      return r;
    }
    e.TileSource.determineType = function(i, o, h) {
      var n;
      for (n in D)
        if (n.match(/.+TileSource$/) && e.isFunction(D[n]) && e.isFunction(D[n].prototype.supports) && D[n].prototype.supports.call(i, o, h))
          return D[n];
      return e.console.error("No TileSource was able to open %s %s", h, o), null;
    };
  }(D), function(e) {
    e.DziTileSource = function(o, h, n, r, s, l, d, f, v) {
      var y, T, w, x;
      if (e.isPlainObject(o) ? x = o : x = {
        width: arguments[0],
        height: arguments[1],
        tileSize: arguments[2],
        tileOverlap: arguments[3],
        tilesUrl: arguments[4],
        fileFormat: arguments[5],
        displayRects: arguments[6],
        minLevel: arguments[7],
        maxLevel: arguments[8]
      }, this._levelRects = {}, this.tilesUrl = x.tilesUrl, this.fileFormat = x.fileFormat, this.displayRects = x.displayRects, this.displayRects)
        for (y = this.displayRects.length - 1; y >= 0; y--)
          for (T = this.displayRects[y], w = T.minLevel; w <= T.maxLevel; w++)
            this._levelRects[w] || (this._levelRects[w] = []), this._levelRects[w].push(T);
      e.TileSource.apply(this, [x]);
    }, e.extend(
      e.DziTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.DziTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(o, h) {
          var n;
          return o.Image ? n = o.Image.xmlns : o.documentElement && (o.documentElement.localName === "Image" || o.documentElement.tagName === "Image") && (n = o.documentElement.namespaceURI), n = (n || "").toLowerCase(), n.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || n.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
        },
        /**
         *
         * @function
         * @param {Object|XMLDocument} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(o, h, n) {
          var r;
          return e.isPlainObject(o) ? r = i(this, o) : r = t(this, o), h && !r.tilesUrl && (r.tilesUrl = h.replace(
            /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/,
            "$1_files/"
          ), h.search(/\.(dzi|xml|js)\?/) !== -1 ? r.queryParams = h.match(/\?.*/) : r.queryParams = ""), r;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(o, h, n) {
          return [this.tilesUrl, o, "/", h, "_", n, ".", this.fileFormat, this.queryParams].join("");
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        tileExists: function(o, h, n) {
          var r = this._levelRects[o], s, l, d, f, v, y, T;
          if (this.minLevel && o < this.minLevel || this.maxLevel && o > this.maxLevel)
            return !1;
          if (!r || !r.length)
            return !0;
          for (T = r.length - 1; T >= 0; T--)
            if (s = r[T], !(o < s.minLevel || o > s.maxLevel) && (l = this.getLevelScale(o), d = s.x * l, f = s.y * l, v = d + s.width * l, y = f + s.height * l, d = Math.floor(d / this._tileWidth), f = Math.floor(f / this._tileWidth), v = Math.ceil(v / this._tileWidth), y = Math.ceil(y / this._tileWidth), d <= h && h < v && f <= n && n < y))
              return !0;
          return !1;
        }
      }
    );
    function t(o, h) {
      if (!h || !h.documentElement)
        throw new Error(e.getString("Errors.Xml"));
      var n = h.documentElement, r = n.localName || n.tagName, s = h.documentElement.namespaceURI, l = null, d = [], f, v, y, T, w;
      if (r === "Image")
        try {
          if (T = n.getElementsByTagName("Size")[0], T === void 0 && (T = n.getElementsByTagNameNS(s, "Size")[0]), l = {
            Image: {
              xmlns: "http://schemas.microsoft.com/deepzoom/2008",
              Url: n.getAttribute("Url"),
              Format: n.getAttribute("Format"),
              DisplayRect: null,
              Overlap: parseInt(n.getAttribute("Overlap"), 10),
              TileSize: parseInt(n.getAttribute("TileSize"), 10),
              Size: {
                Height: parseInt(T.getAttribute("Height"), 10),
                Width: parseInt(T.getAttribute("Width"), 10)
              }
            }
          }, !e.imageFormatSupported(l.Image.Format))
            throw new Error(
              e.getString("Errors.ImageFormat", l.Image.Format.toUpperCase())
            );
          for (f = n.getElementsByTagName("DisplayRect"), f === void 0 && (f = n.getElementsByTagNameNS(s, "DisplayRect")[0]), w = 0; w < f.length; w++)
            v = f[w], y = v.getElementsByTagName("Rect")[0], y === void 0 && (y = v.getElementsByTagNameNS(s, "Rect")[0]), d.push({
              Rect: {
                X: parseInt(y.getAttribute("X"), 10),
                Y: parseInt(y.getAttribute("Y"), 10),
                Width: parseInt(y.getAttribute("Width"), 10),
                Height: parseInt(y.getAttribute("Height"), 10),
                MinLevel: parseInt(v.getAttribute("MinLevel"), 10),
                MaxLevel: parseInt(v.getAttribute("MaxLevel"), 10)
              }
            });
          return d.length && (l.Image.DisplayRect = d), i(o, l);
        } catch (C) {
          throw C instanceof Error ? C : new Error(e.getString("Errors.Dzi"));
        }
      else {
        if (r === "Collection")
          throw new Error(e.getString("Errors.Dzc"));
        if (r === "Error") {
          var x = n.getElementsByTagName("Message")[0], P = x.firstChild.nodeValue;
          throw new Error(P);
        }
      }
      throw new Error(e.getString("Errors.Dzi"));
    }
    function i(o, h) {
      var n = h.Image, r = n.Url, s = n.Format, l = n.Size, d = n.DisplayRect || [], f = parseInt(l.Width, 10), v = parseInt(l.Height, 10), y = parseInt(n.TileSize, 10), T = parseInt(n.Overlap, 10), w = [], x, P;
      for (P = 0; P < d.length; P++)
        x = d[P].Rect, w.push(new e.DisplayRect(
          parseInt(x.X, 10),
          parseInt(x.Y, 10),
          parseInt(x.Width, 10),
          parseInt(x.Height, 10),
          parseInt(x.MinLevel, 10),
          parseInt(x.MaxLevel, 10)
        ));
      return e.extend(!0, {
        width: f,
        /* width *required */
        height: v,
        /* height *required */
        tileSize: y,
        /* tileSize *required */
        tileOverlap: T,
        /* tileOverlap *required */
        minLevel: null,
        /* minLevel */
        maxLevel: null,
        /* maxLevel */
        tilesUrl: r,
        /* tilesUrl */
        fileFormat: s,
        /* fileFormat */
        displayRects: w
        /* displayRects */
      }, h);
    }
  }(D), function(e) {
    e.IIIFTileSource = function(n) {
      if (e.extend(!0, this, n), this._id = this["@id"] || this.id || this.identifier || null, !(this.height && this.width && this._id))
        throw new Error("IIIF required parameters (width, height, or id) not provided.");
      if (n.tileSizePerScaleFactor = {}, this.tileFormat = this.tileFormat || "jpg", this.version = n.version, this.tile_width && this.tile_height)
        n.tileWidth = this.tile_width, n.tileHeight = this.tile_height;
      else if (this.tile_width)
        n.tileSize = this.tile_width;
      else if (this.tile_height)
        n.tileSize = this.tile_height;
      else if (this.tiles)
        if (this.tiles.length === 1)
          n.tileWidth = this.tiles[0].width, n.tileHeight = this.tiles[0].height || this.tiles[0].width, this.scale_factors = this.tiles[0].scaleFactors;
        else {
          this.scale_factors = [];
          for (var r = 0; r < this.tiles.length; r++)
            for (var s = 0; s < this.tiles[r].scaleFactors.length; s++) {
              var l = this.tiles[r].scaleFactors[s];
              this.scale_factors.push(l), n.tileSizePerScaleFactor[l] = {
                width: this.tiles[r].width,
                height: this.tiles[r].height || this.tiles[r].width
              };
            }
        }
      else if (t(n)) {
        for (var d = Math.min(this.height, this.width), f = [256, 512, 1024], v = [], y = 0; y < f.length; y++)
          f[y] <= d && v.push(f[y]);
        v.length > 0 ? n.tileSize = Math.max.apply(null, v) : n.tileSize = d;
      } else
        this.sizes && this.sizes.length > 0 ? (this.emulateLegacyImagePyramid = !0, n.levels = i(this), e.extend(!0, n, {
          width: n.levels[n.levels.length - 1].width,
          height: n.levels[n.levels.length - 1].height,
          tileSize: Math.max(n.height, n.width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: n.levels.length - 1
        }), this.levels = n.levels) : e.console.error("Nothing in the info.json to construct image pyramids from");
      if (!n.maxLevel && !this.emulateLegacyImagePyramid)
        if (!this.scale_factors)
          n.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
        else {
          var T = Math.max.apply(null, this.scale_factors);
          n.maxLevel = Math.round(Math.log(T) * Math.LOG2E);
        }
      if (this.sizes) {
        var w = this.sizes.length;
        (w === n.maxLevel || w === n.maxLevel + 1) && (this.levelSizes = this.sizes.slice().sort(function(x, P) {
          return x.width - P.width;
        }), w === n.maxLevel && this.levelSizes.push({ width: this.width, height: this.height }));
      }
      e.TileSource.apply(this, [n]);
    }, e.extend(
      e.IIIFTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.IIIFTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} [url] - url
         */
        supports: function(n, r) {
          return n.protocol && n.protocol === "http://iiif.io/api/image" || n["@context"] && (n["@context"] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" || n["@context"] === "http://iiif.io/api/image/1/context.json") || n.profile && n.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0 || n.identifier && n.width && n.height ? !0 : !!(n.documentElement && n.documentElement.tagName === "info" && n.documentElement.namespaceURI === "http://library.stanford.edu/iiif/image-api/ns/");
        },
        /**
         * A static function used to prepare an incoming IIIF Image API info.json
         * response for processing by the tile handler. Normalizes data for all
         * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
         * may be passed to the IIIFTileSource.
         *
         * @function
         * @static
         * @param {Object} data - the raw configuration
         * @param {String} url - the url configuration was retrieved from
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} A normalized IIIF data object
         * @example <caption>IIIF 2.x Info Looks like this</caption>
         * {
         * "@context": "http://iiif.io/api/image/2/context.json",
         * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
         * "protocol": "http://iiif.io/api/image",
         * "height": 1024,
         * "width": 775,
         * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
         *  "profile": ["http://iiif.io/api/image/2/level1.json", {
         *    "qualities": [ "native", "bitonal", "grey", "color" ],
         *    "formats": [ "jpg", "png", "gif" ]
         *   }]
         * }
         */
        configure: function(n, r, s) {
          if (e.isPlainObject(n)) {
            if (!n["@context"])
              n["@context"] = "http://iiif.io/api/image/1.0/context.json", n["@id"] = r.replace("/info.json", ""), n.version = 1;
            else {
              var d = n["@context"];
              if (Array.isArray(d)) {
                for (var f = 0; f < d.length; f++)
                  if (typeof d[f] == "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(d[f]) || d[f] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                    d = d[f];
                    break;
                  }
              }
              switch (d) {
                case "http://iiif.io/api/image/1/context.json":
                case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                  n.version = 1;
                  break;
                case "http://iiif.io/api/image/2/context.json":
                  n.version = 2;
                  break;
                case "http://iiif.io/api/image/3/context.json":
                  n.version = 3;
                  break;
                default:
                  e.console.error("Data has a @context property which contains no known IIIF context URI.");
              }
            }
            if (n.preferredFormats) {
              for (var v = 0; v < n.preferredFormats.length; v++)
                if (D.imageFormatSupported(n.preferredFormats[v])) {
                  n.tileFormat = n.preferredFormats[v];
                  break;
                }
            }
            return n;
          } else {
            var l = o(n);
            return l["@context"] = "http://iiif.io/api/image/1.0/context.json", l["@id"] = r.replace("/info.xml", ""), l.version = 1, l;
          }
        },
        /**
         * Return the tileWidth for the given level.
         * @function
         * @param {Number} level
         */
        getTileWidth: function(n) {
          if (this.emulateLegacyImagePyramid)
            return e.TileSource.prototype.getTileWidth.call(this, n);
          var r = Math.pow(2, this.maxLevel - n);
          return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[r] ? this.tileSizePerScaleFactor[r].width : this._tileWidth;
        },
        /**
         * Return the tileHeight for the given level.
         * @function
         * @param {Number} level
         */
        getTileHeight: function(n) {
          if (this.emulateLegacyImagePyramid)
            return e.TileSource.prototype.getTileHeight.call(this, n);
          var r = Math.pow(2, this.maxLevel - n);
          return this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[r] ? this.tileSizePerScaleFactor[r].height : this._tileHeight;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(n) {
          if (this.emulateLegacyImagePyramid) {
            var r = NaN;
            return this.levels.length > 0 && n >= this.minLevel && n <= this.maxLevel && (r = this.levels[n].width / this.levels[this.maxLevel].width), r;
          }
          return e.TileSource.prototype.getLevelScale.call(this, n);
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(n) {
          if (this.emulateLegacyImagePyramid) {
            var r = this.getLevelScale(n);
            return r ? new e.Point(1, 1) : new e.Point(0, 0);
          }
          if (this.levelSizes) {
            var s = this.levelSizes[n], l = Math.ceil(s.width / this.getTileWidth(n)), d = Math.ceil(s.height / this.getTileHeight(n));
            return new e.Point(l, d);
          } else
            return e.TileSource.prototype.getNumTiles.call(this, n);
        },
        /**
         * @function
         * @param {Number} level
         * @param {OpenSeadragon.Point} point
         */
        getTileAtPoint: function(n, r) {
          if (this.emulateLegacyImagePyramid)
            return new e.Point(0, 0);
          if (this.levelSizes) {
            var s = r.x >= 0 && r.x <= 1 && r.y >= 0 && r.y <= 1 / this.aspectRatio;
            e.console.assert(s, "[TileSource.getTileAtPoint] must be called with a valid point.");
            var l = this.levelSizes[n].width, d = r.x * l, f = r.y * l, v = Math.floor(d / this.getTileWidth(n)), y = Math.floor(f / this.getTileHeight(n));
            r.x >= 1 && (v = this.getNumTiles(n).x - 1);
            var T = 1e-15;
            return r.y >= 1 / this.aspectRatio - T && (y = this.getNumTiles(n).y - 1), new e.Point(v, y);
          }
          return e.TileSource.prototype.getTileAtPoint.call(this, n, r);
        },
        /**
         * Responsible for retrieving the url which will return an image for the
         * region specified by the given x, y, and level components.
         * @function
         * @param {Number} level - z index
         * @param {Number} x
         * @param {Number} y
         * @throws {Error}
         */
        getTileUrl: function(n, r, s) {
          if (this.emulateLegacyImagePyramid) {
            var l = null;
            return this.levels.length > 0 && n >= this.minLevel && n <= this.maxLevel && (l = this.levels[n].url), l;
          }
          var d = "0", f = Math.pow(0.5, this.maxLevel - n), v, y, T, w, x, P, C, A, W, k, U, H, M, X, Z, Y;
          return this.levelSizes ? (v = this.levelSizes[n].width, y = this.levelSizes[n].height) : (v = Math.ceil(this.width * f), y = Math.ceil(this.height * f)), T = this.getTileWidth(n), w = this.getTileHeight(n), x = Math.round(T / f), P = Math.round(w / f), this.version === 1 ? Z = "native." + this.tileFormat : Z = "default." + this.tileFormat, v < T && y < w ? (this.version === 2 && v === this.width ? H = "full" : this.version === 3 && v === this.width && y === this.height ? H = "max" : this.version === 3 ? H = v + "," + y : H = v + ",", C = "full") : (A = r * x, W = s * P, k = Math.min(x, this.width - A), U = Math.min(P, this.height - W), r === 0 && s === 0 && k === this.width && U === this.height ? C = "full" : C = [A, W, k, U].join(","), M = Math.min(T, v - r * T), X = Math.min(w, y - s * w), this.version === 2 && M === this.width ? H = "full" : this.version === 3 && M === this.width && X === this.height ? H = "max" : this.version === 3 ? H = M + "," + X : H = M + ","), Y = [this._id, C, H, d, Z].join("/"), Y;
        },
        __testonly__: {
          canBeTiled: t,
          constructLevels: i
        }
      }
    );
    function t(n) {
      var r = [
        "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
        "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
        "http://iiif.io/api/image/2/level0.json",
        "level0",
        "https://iiif.io/api/image/3/level0.json"
      ], s = Array.isArray(n.profile) ? n.profile[0] : n.profile, l = r.indexOf(s) !== -1, d = !1;
      return n.version === 2 && n.profile.length > 1 && n.profile[1].supports && (d = n.profile[1].supports.indexOf("sizeByW") !== -1), n.version === 3 && n.extraFeatures && (d = n.extraFeatures.indexOf("sizeByWh") !== -1), !l || d;
    }
    function i(n) {
      for (var r = [], s = 0; s < n.sizes.length; s++)
        r.push({
          url: n._id + "/full/" + n.sizes[s].width + "," + (n.version === 3 ? n.sizes[s].height : "") + "/0/default." + n.tileFormat,
          width: n.sizes[s].width,
          height: n.sizes[s].height
        });
      return r.sort(function(l, d) {
        return l.width - d.width;
      });
    }
    function o(n) {
      if (!n || !n.documentElement)
        throw new Error(e.getString("Errors.Xml"));
      var r = n.documentElement, s = r.tagName, l = null;
      if (s === "info")
        try {
          return l = {}, h(r, l), l;
        } catch (d) {
          throw d instanceof Error ? d : new Error(e.getString("Errors.IIIF"));
        }
      throw new Error(e.getString("Errors.IIIF"));
    }
    function h(n, r, s) {
      var l, d;
      if (n.nodeType === 3 && s)
        d = n.nodeValue.trim(), d.match(/^\d*$/) && (d = Number(d)), r[s] ? (e.isArray(r[s]) || (r[s] = [r[s]]), r[s].push(d)) : r[s] = d;
      else if (n.nodeType === 1)
        for (l = 0; l < n.childNodes.length; l++)
          h(n.childNodes[l], r, n.nodeName);
    }
  }(D), function(e) {
    e.OsmTileSource = function(t, i, o, h, n) {
      var r;
      e.isPlainObject(t) ? r = t : r = {
        width: arguments[0],
        height: arguments[1],
        tileSize: arguments[2],
        tileOverlap: arguments[3],
        tilesUrl: arguments[4]
      }, (!r.width || !r.height) && (r.width = 65572864, r.height = 65572864), r.tileSize || (r.tileSize = 256, r.tileOverlap = 0), r.tilesUrl || (r.tilesUrl = "http://tile.openstreetmap.org/"), r.minLevel = 8, e.TileSource.apply(this, [r]);
    }, e.extend(
      e.OsmTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.OsmTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(t, i) {
          return t.type && t.type === "openstreetmaps";
        },
        /**
         *
         * @function
         * @param {Object} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(t, i, o) {
          return t;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(t, i, o) {
          return this.tilesUrl + (t - 8) + "/" + i + "/" + o + ".png";
        }
      }
    );
  }(D), function(e) {
    e.TmsTileSource = function(t, i, o, h, n) {
      var r;
      e.isPlainObject(t) ? r = t : r = {
        width: arguments[0],
        height: arguments[1],
        tileSize: arguments[2],
        tileOverlap: arguments[3],
        tilesUrl: arguments[4]
      };
      var s = Math.ceil(r.width / 256) * 256, l = Math.ceil(r.height / 256) * 256, d;
      s > l ? d = s / 256 : d = l / 256, r.maxLevel = Math.ceil(Math.log(d) / Math.log(2)) - 1, r.tileSize = 256, r.width = s, r.height = l, e.TileSource.apply(this, [r]);
    }, e.extend(
      e.TmsTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.TmsTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(t, i) {
          return t.type && t.type === "tiledmapservice";
        },
        /**
         *
         * @function
         * @param {Object} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(t, i, o) {
          return t;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(t, i, o) {
          var h = this.getNumTiles(t).y - 1;
          return this.tilesUrl + t + "/" + i + "/" + (h - o) + ".png";
        }
      }
    );
  }(D), function(e) {
    e.ZoomifyTileSource = function(t) {
      typeof t.tileSize > "u" && (t.tileSize = 256), typeof t.fileFormat > "u" && (t.fileFormat = "jpg", this.fileFormat = t.fileFormat);
      var i = {
        x: t.width,
        y: t.height
      };
      for (t.imageSizes = [{
        x: t.width,
        y: t.height
      }], t.gridSize = [this._getGridSize(t.width, t.height, t.tileSize)]; parseInt(i.x, 10) > t.tileSize || parseInt(i.y, 10) > t.tileSize; )
        i.x = Math.floor(i.x / 2), i.y = Math.floor(i.y / 2), t.imageSizes.push({
          x: i.x,
          y: i.y
        }), t.gridSize.push(this._getGridSize(i.x, i.y, t.tileSize));
      t.imageSizes.reverse(), t.gridSize.reverse(), t.minLevel = 0, t.maxLevel = t.gridSize.length - 1, D.TileSource.apply(this, [t]);
    }, e.extend(
      e.ZoomifyTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.ZoomifyTileSource.prototype */
      {
        //private
        _getGridSize: function(t, i, o) {
          return {
            x: Math.ceil(t / o),
            y: Math.ceil(i / o)
          };
        },
        //private
        _calculateAbsoluteTileNumber: function(t, i, o) {
          for (var h = 0, n = {}, r = 0; r < t; r++)
            n = this.gridSize[r], h += n.x * n.y;
          return n = this.gridSize[t], h += n.x * o + i, h;
        },
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(t, i) {
          return t.type && t.type === "zoomifytileservice";
        },
        /**
         *
         * @function
         * @param {Object} data - the raw configuration
         * @param {String} url - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(t, i, o) {
          return t;
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        getTileUrl: function(t, i, o) {
          var h = 0, n = this._calculateAbsoluteTileNumber(t, i, o);
          return h = Math.floor(n / 256), this.tilesUrl + "TileGroup" + h + "/" + t + "-" + i + "-" + o + "." + this.fileFormat;
        }
      }
    );
  }(D), function(e) {
    e.LegacyTileSource = function(h) {
      var n, r, s;
      e.isArray(h) && (n = {
        type: "legacy-image-pyramid",
        levels: h
      }), n.levels = t(n.levels), n.levels.length > 0 ? (r = n.levels[n.levels.length - 1].width, s = n.levels[n.levels.length - 1].height) : (r = 0, s = 0, e.console.error("No supported image formats found")), e.extend(!0, n, {
        width: r,
        height: s,
        tileSize: Math.max(s, r),
        tileOverlap: 0,
        minLevel: 0,
        maxLevel: n.levels.length > 0 ? n.levels.length - 1 : 0
      }), e.TileSource.apply(this, [n]), this.levels = n.levels;
    }, e.extend(
      e.LegacyTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.LegacyTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(h, n) {
          return h.type && h.type === "legacy-image-pyramid" || h.documentElement && h.documentElement.getAttribute("type") === "legacy-image-pyramid";
        },
        /**
         *
         * @function
         * @param {Object|XMLDocument} configuration - the raw configuration
         * @param {String} dataUrl - the url the data was retrieved from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(h, n, r) {
          var s;
          return e.isPlainObject(h) ? s = o(this, h) : s = i(this, h), s;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(h) {
          var n = NaN;
          return this.levels.length > 0 && h >= this.minLevel && h <= this.maxLevel && (n = this.levels[h].width / this.levels[this.maxLevel].width), n;
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(h) {
          var n = this.getLevelScale(h);
          return n ? new e.Point(1, 1) : new e.Point(0, 0);
        },
        /**
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @throws {Error}
         */
        getTileUrl: function(h, n, r) {
          var s = null;
          return this.levels.length > 0 && h >= this.minLevel && h <= this.maxLevel && (s = this.levels[h].url), s;
        }
      }
    );
    function t(h) {
      var n = [], r, s;
      for (s = 0; s < h.length; s++)
        r = h[s], r.height && r.width && r.url ? n.push({
          url: r.url,
          width: Number(r.width),
          height: Number(r.height)
        }) : e.console.error("Unsupported image format: %s", r.url ? r.url : "<no URL>");
      return n.sort(function(l, d) {
        return l.height - d.height;
      });
    }
    function i(h, n) {
      if (!n || !n.documentElement)
        throw new Error(e.getString("Errors.Xml"));
      var r = n.documentElement, s = r.tagName, l = null, d = [], f, v;
      if (s === "image")
        try {
          for (l = {
            type: r.getAttribute("type"),
            levels: []
          }, d = r.getElementsByTagName("level"), v = 0; v < d.length; v++)
            f = d[v], l.levels.push({
              url: f.getAttribute("url"),
              width: parseInt(f.getAttribute("width"), 10),
              height: parseInt(f.getAttribute("height"), 10)
            });
          return o(h, l);
        } catch (y) {
          throw y instanceof Error ? y : new Error("Unknown error parsing Legacy Image Pyramid XML.");
        }
      else {
        if (s === "collection")
          throw new Error("Legacy Image Pyramid Collections not yet supported.");
        if (s === "error")
          throw new Error("Error: " + n);
      }
      throw new Error("Unknown element " + s);
    }
    function o(h, n) {
      return n.levels;
    }
  }(D), function(e) {
    e.ImageTileSource = function(t) {
      t = e.extend({
        buildPyramid: !0,
        crossOriginPolicy: !1,
        ajaxWithCredentials: !1,
        useCanvas: !0
      }, t), e.TileSource.apply(this, [t]);
    }, e.extend(
      e.ImageTileSource.prototype,
      e.TileSource.prototype,
      /** @lends OpenSeadragon.ImageTileSource.prototype */
      {
        /**
         * Determine if the data and/or url imply the image service is supported by
         * this tile source.
         * @function
         * @param {Object|Array} data
         * @param {String} optional - url
         */
        supports: function(t, i) {
          return t.type && t.type === "image";
        },
        /**
         *
         * @function
         * @param {Object} options - the options
         * @param {String} dataUrl - the url the image was retrieved from, if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure this tile sources constructor.
         */
        configure: function(t, i, o) {
          return t;
        },
        /**
         * Responsible for retrieving, and caching the
         * image metadata pertinent to this TileSources implementation.
         * @function
         * @param {String} url
         * @throws {Error}
         */
        getImageInfo: function(t) {
          var i = this._image = new Image(), o = this;
          this.crossOriginPolicy && (i.crossOrigin = this.crossOriginPolicy), this.ajaxWithCredentials && (i.useCredentials = this.ajaxWithCredentials), e.addEvent(i, "load", function() {
            o.width = i.naturalWidth, o.height = i.naturalHeight, o.aspectRatio = o.width / o.height, o.dimensions = new e.Point(o.width, o.height), o._tileWidth = o.width, o._tileHeight = o.height, o.tileOverlap = 0, o.minLevel = 0, o.levels = o._buildLevels(), o.maxLevel = o.levels.length - 1, o.ready = !0, o.raiseEvent("ready", { tileSource: o });
          }), e.addEvent(i, "error", function() {
            o.raiseEvent("open-failed", {
              message: "Error loading image at " + t,
              source: t
            });
          }), i.src = t;
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(t) {
          var i = NaN;
          return t >= this.minLevel && t <= this.maxLevel && (i = this.levels[t].width / this.levels[this.maxLevel].width), i;
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(t) {
          var i = this.getLevelScale(t);
          return i ? new e.Point(1, 1) : new e.Point(0, 0);
        },
        /**
         * Retrieves a tile url
         * @function
         * @param {Number} level Level of the tile
         * @param {Number} x x coordinate of the tile
         * @param {Number} y y coordinate of the tile
         */
        getTileUrl: function(t, i, o) {
          var h = null;
          return t >= this.minLevel && t <= this.maxLevel && (h = this.levels[t].url), h;
        },
        /**
         * Retrieves a tile context 2D
         * @function
         * @param {Number} level Level of the tile
         * @param {Number} x x coordinate of the tile
         * @param {Number} y y coordinate of the tile
         */
        getContext2D: function(t, i, o) {
          var h = null;
          return t >= this.minLevel && t <= this.maxLevel && (h = this.levels[t].context2D), h;
        },
        /**
         * Destroys ImageTileSource
         * @function
         */
        destroy: function() {
          this._freeupCanvasMemory();
        },
        // private
        //
        // Builds the different levels of the pyramid if possible
        // (i.e. if canvas API enabled and no canvas tainting issue).
        _buildLevels: function() {
          var t = [{
            url: this._image.src,
            width: this._image.naturalWidth,
            height: this._image.naturalHeight
          }];
          if (!this.buildPyramid || !e.supportsCanvas || !this.useCanvas)
            return delete this._image, t;
          var i = this._image.naturalWidth, o = this._image.naturalHeight, h = document.createElement("canvas"), n = h.getContext("2d");
          if (h.width = i, h.height = o, n.drawImage(this._image, 0, 0, i, o), t[0].context2D = n, delete this._image, e.isCanvasTainted(h))
            return t;
          for (; i >= 2 && o >= 2; ) {
            i = Math.floor(i / 2), o = Math.floor(o / 2);
            var r = document.createElement("canvas"), s = r.getContext("2d");
            r.width = i, r.height = o, s.drawImage(h, 0, 0, i, o), t.splice(0, 0, {
              context2D: s,
              width: i,
              height: o
            }), h = r, n = s;
          }
          return t;
        },
        /**
         * Free up canvas memory
         * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
         * and Safari keeps canvas until its height and width will be set to 0).
         * @function
         */
        _freeupCanvasMemory: function() {
          for (var t = 0; t < this.levels.length; t++)
            this.levels[t].context2D && (this.levels[t].context2D.canvas.height = 0, this.levels[t].context2D.canvas.width = 0);
        }
      }
    );
  }(D), function(e) {
    e.TileSourceCollection = function(t, i, o, h) {
      e.console.error("TileSourceCollection is deprecated; use World instead");
    };
  }(D), function(e) {
    e.ButtonState = {
      REST: 0,
      GROUP: 1,
      HOVER: 2,
      DOWN: 3
    }, e.Button = function(s) {
      var l = this;
      e.EventSource.call(this), e.extend(!0, this, {
        tooltip: null,
        srcRest: null,
        srcGroup: null,
        srcHover: null,
        srcDown: null,
        clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold,
        clickDistThreshold: e.DEFAULT_SETTINGS.clickDistThreshold,
        /**
         * How long to wait before fading.
         * @member {Number} fadeDelay
         * @memberof OpenSeadragon.Button#
         */
        fadeDelay: 0,
        /**
         * How long should it take to fade the button.
         * @member {Number} fadeLength
         * @memberof OpenSeadragon.Button#
         */
        fadeLength: 2e3,
        onPress: null,
        onRelease: null,
        onClick: null,
        onEnter: null,
        onExit: null,
        onFocus: null,
        onBlur: null,
        userData: null
      }, s), this.element = s.element || e.makeNeutralElement("div"), s.element || (this.imgRest = e.makeTransparentImage(this.srcRest), this.imgGroup = e.makeTransparentImage(this.srcGroup), this.imgHover = e.makeTransparentImage(this.srcHover), this.imgDown = e.makeTransparentImage(this.srcDown), this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip, e.setElementPointerEventsNone(this.imgRest), e.setElementPointerEventsNone(this.imgGroup), e.setElementPointerEventsNone(this.imgHover), e.setElementPointerEventsNone(this.imgDown), this.element.style.position = "relative", e.setElementTouchActionNone(this.element), this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute", this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px", this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px", this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden", e.Browser.vendor === e.BROWSERS.FIREFOX && e.Browser.version < 3 && (this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = ""), this.element.appendChild(this.imgRest), this.element.appendChild(this.imgGroup), this.element.appendChild(this.imgHover), this.element.appendChild(this.imgDown)), this.addHandler("press", this.onPress), this.addHandler("release", this.onRelease), this.addHandler("click", this.onClick), this.addHandler("enter", this.onEnter), this.addHandler("exit", this.onExit), this.addHandler("focus", this.onFocus), this.addHandler("blur", this.onBlur), this.currentState = e.ButtonState.GROUP, this.fadeBeginTime = null, this.shouldFade = !1, this.element.style.display = "inline-block", this.element.style.position = "relative", this.element.title = this.tooltip, this.tracker = new e.MouseTracker({
        userData: "Button.tracker",
        element: this.element,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        enterHandler: function(d) {
          d.insideElementPressed ? (n(l, e.ButtonState.DOWN), l.raiseEvent("enter", { originalEvent: d.originalEvent })) : d.buttonDownAny || n(l, e.ButtonState.HOVER);
        },
        focusHandler: function(d) {
          l.tracker.enterHandler(d), l.raiseEvent("focus", { originalEvent: d.originalEvent });
        },
        leaveHandler: function(d) {
          r(l, e.ButtonState.GROUP), d.insideElementPressed && l.raiseEvent("exit", { originalEvent: d.originalEvent });
        },
        blurHandler: function(d) {
          l.tracker.leaveHandler(d), l.raiseEvent("blur", { originalEvent: d.originalEvent });
        },
        pressHandler: function(d) {
          n(l, e.ButtonState.DOWN), l.raiseEvent("press", { originalEvent: d.originalEvent });
        },
        releaseHandler: function(d) {
          d.insideElementPressed && d.insideElementReleased ? (r(l, e.ButtonState.HOVER), l.raiseEvent("release", { originalEvent: d.originalEvent })) : d.insideElementPressed ? r(l, e.ButtonState.GROUP) : n(l, e.ButtonState.HOVER);
        },
        clickHandler: function(d) {
          d.quick && l.raiseEvent("click", { originalEvent: d.originalEvent });
        },
        keyHandler: function(d) {
          d.keyCode === 13 ? (l.raiseEvent("click", { originalEvent: d.originalEvent }), l.raiseEvent("release", { originalEvent: d.originalEvent }), d.preventDefault = !0) : d.preventDefault = !1;
        }
      }), r(this, e.ButtonState.REST);
    }, e.extend(
      e.Button.prototype,
      e.EventSource.prototype,
      /** @lends OpenSeadragon.Button.prototype */
      {
        /**
         * Used by a button container element (e.g. a ButtonGroup) to transition the button state
         * to ButtonState.GROUP.
         * @function
         */
        notifyGroupEnter: function() {
          n(this, e.ButtonState.GROUP);
        },
        /**
         * Used by a button container element (e.g. a ButtonGroup) to transition the button state
         * to ButtonState.REST.
         * @function
         */
        notifyGroupExit: function() {
          r(this, e.ButtonState.REST);
        },
        /**
         * @function
         */
        disable: function() {
          this.notifyGroupExit(), this.element.disabled = !0, this.tracker.setTracking(!1), e.setElementOpacity(this.element, 0.2, !0);
        },
        /**
         * @function
         */
        enable: function() {
          this.element.disabled = !1, this.tracker.setTracking(!0), e.setElementOpacity(this.element, 1, !0), this.notifyGroupEnter();
        },
        destroy: function() {
          this.imgRest && (this.element.removeChild(this.imgRest), this.imgRest = null), this.imgGroup && (this.element.removeChild(this.imgGroup), this.imgGroup = null), this.imgHover && (this.element.removeChild(this.imgHover), this.imgHover = null), this.imgDown && (this.element.removeChild(this.imgDown), this.imgDown = null), this.removeAllHandlers(), this.tracker.destroy(), this.element = null;
        }
      }
    );
    function t(s) {
      e.requestAnimationFrame(function() {
        i(s);
      });
    }
    function i(s) {
      var l, d, f;
      s.shouldFade && (l = e.now(), d = l - s.fadeBeginTime, f = 1 - d / s.fadeLength, f = Math.min(1, f), f = Math.max(0, f), s.imgGroup && e.setElementOpacity(s.imgGroup, f, !0), f > 0 && t(s));
    }
    function o(s) {
      s.shouldFade = !0, s.fadeBeginTime = e.now() + s.fadeDelay, window.setTimeout(function() {
        t(s);
      }, s.fadeDelay);
    }
    function h(s) {
      s.shouldFade = !1, s.imgGroup && e.setElementOpacity(s.imgGroup, 1, !0);
    }
    function n(s, l) {
      s.element.disabled || (l >= e.ButtonState.GROUP && s.currentState === e.ButtonState.REST && (h(s), s.currentState = e.ButtonState.GROUP), l >= e.ButtonState.HOVER && s.currentState === e.ButtonState.GROUP && (s.imgHover && (s.imgHover.style.visibility = ""), s.currentState = e.ButtonState.HOVER), l >= e.ButtonState.DOWN && s.currentState === e.ButtonState.HOVER && (s.imgDown && (s.imgDown.style.visibility = ""), s.currentState = e.ButtonState.DOWN));
    }
    function r(s, l) {
      s.element.disabled || (l <= e.ButtonState.HOVER && s.currentState === e.ButtonState.DOWN && (s.imgDown && (s.imgDown.style.visibility = "hidden"), s.currentState = e.ButtonState.HOVER), l <= e.ButtonState.GROUP && s.currentState === e.ButtonState.HOVER && (s.imgHover && (s.imgHover.style.visibility = "hidden"), s.currentState = e.ButtonState.GROUP), l <= e.ButtonState.REST && s.currentState === e.ButtonState.GROUP && (o(s), s.currentState = e.ButtonState.REST));
    }
  }(D), function(e) {
    e.ButtonGroup = function(t) {
      e.extend(!0, this, {
        /**
         * An array containing the buttons themselves.
         * @member {Array} buttons
         * @memberof OpenSeadragon.ButtonGroup#
         */
        buttons: [],
        clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold,
        clickDistThreshold: e.DEFAULT_SETTINGS.clickDistThreshold,
        labelText: ""
      }, t);
      var i = this.buttons.concat([]), o = this, h;
      if (this.element = t.element || e.makeNeutralElement("div"), !t.group)
        for (this.element.style.display = "inline-block", h = 0; h < i.length; h++)
          this.element.appendChild(i[h].element);
      e.setElementTouchActionNone(this.element), this.tracker = new e.MouseTracker({
        userData: "ButtonGroup.tracker",
        element: this.element,
        clickTimeThreshold: this.clickTimeThreshold,
        clickDistThreshold: this.clickDistThreshold,
        enterHandler: function(n) {
          var r;
          for (r = 0; r < o.buttons.length; r++)
            o.buttons[r].notifyGroupEnter();
        },
        leaveHandler: function(n) {
          var r;
          if (!n.insideElementPressed)
            for (r = 0; r < o.buttons.length; r++)
              o.buttons[r].notifyGroupExit();
        }
      });
    }, e.ButtonGroup.prototype = {
      /**
       * Adds the given button to this button group.
       *
       * @function
       * @param {OpenSeadragon.Button} button
       */
      addButton: function(t) {
        this.buttons.push(t), this.element.appendChild(t.element);
      },
      /**
       * TODO: Figure out why this is used on the public API and if a more useful
       * api can be created.
       * @function
       * @private
       */
      emulateEnter: function() {
        this.tracker.enterHandler({ eventSource: this.tracker });
      },
      /**
       * TODO: Figure out why this is used on the public API and if a more useful
       * api can be created.
       * @function
       * @private
       */
      emulateLeave: function() {
        this.tracker.leaveHandler({ eventSource: this.tracker });
      },
      destroy: function() {
        for (; this.buttons.length; ) {
          var t = this.buttons.pop();
          this.element.removeChild(t.element), t.destroy();
        }
        this.tracker.destroy(), this.element = null;
      }
    };
  }(D), function(e) {
    e.Rect = function(t, i, o, h, n) {
      this.x = typeof t == "number" ? t : 0, this.y = typeof i == "number" ? i : 0, this.width = typeof o == "number" ? o : 0, this.height = typeof h == "number" ? h : 0, this.degrees = typeof n == "number" ? n : 0, this.degrees = e.positiveModulo(this.degrees, 360);
      var r, s;
      this.degrees >= 270 ? (r = this.getTopRight(), this.x = r.x, this.y = r.y, s = this.height, this.height = this.width, this.width = s, this.degrees -= 270) : this.degrees >= 180 ? (r = this.getBottomRight(), this.x = r.x, this.y = r.y, this.degrees -= 180) : this.degrees >= 90 && (r = this.getBottomLeft(), this.x = r.x, this.y = r.y, s = this.height, this.height = this.width, this.width = s, this.degrees -= 90);
    }, e.Rect.fromSummits = function(t, i, o) {
      var h = t.distanceTo(i), n = t.distanceTo(o), r = i.minus(t), s = Math.atan(r.y / r.x);
      return r.x < 0 ? s += Math.PI : r.y < 0 && (s += 2 * Math.PI), new e.Rect(
        t.x,
        t.y,
        h,
        n,
        s / Math.PI * 180
      );
    }, e.Rect.prototype = {
      /**
       * @function
       * @returns {OpenSeadragon.Rect} a duplicate of this Rect
       */
      clone: function() {
        return new e.Rect(
          this.x,
          this.y,
          this.width,
          this.height,
          this.degrees
        );
      },
      /**
       * The aspect ratio is simply the ratio of width to height.
       * @function
       * @returns {Number} The ratio of width to height.
       */
      getAspectRatio: function() {
        return this.width / this.height;
      },
      /**
       * Provides the coordinates of the upper-left corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
       *  the rectangle.
       */
      getTopLeft: function() {
        return new e.Point(
          this.x,
          this.y
        );
      },
      /**
       * Provides the coordinates of the bottom-right corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
       *  the rectangle.
       */
      getBottomRight: function() {
        return new e.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Provides the coordinates of the top-right corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
       *  the rectangle.
       */
      getTopRight: function() {
        return new e.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Provides the coordinates of the bottom-left corner of the rectangle as a
       * point.
       * @function
       * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
       *  the rectangle.
       */
      getBottomLeft: function() {
        return new e.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Computes the center of the rectangle.
       * @function
       * @returns {OpenSeadragon.Point} The center of the rectangle as represented
       *  as represented by a 2-dimensional vector (x,y)
       */
      getCenter: function() {
        return new e.Point(
          this.x + this.width / 2,
          this.y + this.height / 2
        ).rotate(this.degrees, this.getTopLeft());
      },
      /**
       * Returns the width and height component as a vector OpenSeadragon.Point
       * @function
       * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
       *  width and height of the rectangle.
       */
      getSize: function() {
        return new e.Point(this.width, this.height);
      },
      /**
       * Determines if two Rectangles have equivalent components.
       * @function
       * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
       * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
       */
      equals: function(t) {
        return t instanceof e.Rect && this.x === t.x && this.y === t.y && this.width === t.width && this.height === t.height && this.degrees === t.degrees;
      },
      /**
      * Multiply all dimensions (except degrees) in this Rect by a factor and
      * return a new Rect.
      * @function
      * @param {Number} factor The factor to multiply vector components.
      * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
      *  of the vector components by the factor
      */
      times: function(t) {
        return new e.Rect(
          this.x * t,
          this.y * t,
          this.width * t,
          this.height * t,
          this.degrees
        );
      },
      /**
      * Translate/move this Rect by a vector and return new Rect.
      * @function
      * @param {OpenSeadragon.Point} delta The translation vector.
      * @returns {OpenSeadragon.Rect} A new rect with altered position
      */
      translate: function(t) {
        return new e.Rect(
          this.x + t.x,
          this.y + t.y,
          this.width,
          this.height,
          this.degrees
        );
      },
      /**
       * Returns the smallest rectangle that will contain this and the given
       * rectangle bounding boxes.
       * @param {OpenSeadragon.Rect} rect
       * @returns {OpenSeadragon.Rect} The new rectangle.
       */
      union: function(t) {
        var i = this.getBoundingBox(), o = t.getBoundingBox(), h = Math.min(i.x, o.x), n = Math.min(i.y, o.y), r = Math.max(
          i.x + i.width,
          o.x + o.width
        ), s = Math.max(
          i.y + i.height,
          o.y + o.height
        );
        return new e.Rect(
          h,
          n,
          r - h,
          s - n
        );
      },
      /**
       * Returns the bounding box of the intersection of this rectangle with the
       * given rectangle.
       * @param {OpenSeadragon.Rect} rect
       * @returns {OpenSeadragon.Rect} the bounding box of the intersection
       * or null if the rectangles don't intersect.
       */
      intersection: function(t) {
        var i = 1e-10, o = [], h = this.getTopLeft();
        t.containsPoint(h, i) && o.push(h);
        var n = this.getTopRight();
        t.containsPoint(n, i) && o.push(n);
        var r = this.getBottomLeft();
        t.containsPoint(r, i) && o.push(r);
        var s = this.getBottomRight();
        t.containsPoint(s, i) && o.push(s);
        var l = t.getTopLeft();
        this.containsPoint(l, i) && o.push(l);
        var d = t.getTopRight();
        this.containsPoint(d, i) && o.push(d);
        var f = t.getBottomLeft();
        this.containsPoint(f, i) && o.push(f);
        var v = t.getBottomRight();
        this.containsPoint(v, i) && o.push(v);
        for (var y = this._getSegments(), T = t._getSegments(), w = 0; w < y.length; w++)
          for (var x = y[w], P = 0; P < T.length; P++) {
            var C = T[P], A = W(
              x[0],
              x[1],
              C[0],
              C[1]
            );
            A && o.push(A);
          }
        function W(Y, $, te, ce) {
          var ee = $.minus(Y), ie = ce.minus(te), re = -ie.x * ee.y + ee.x * ie.y;
          if (re === 0)
            return null;
          var oe = (ee.x * (Y.y - te.y) - ee.y * (Y.x - te.x)) / re, se = (ie.x * (Y.y - te.y) - ie.y * (Y.x - te.x)) / re;
          return -i <= oe && oe <= 1 - i && -i <= se && se <= 1 - i ? new e.Point(Y.x + se * ee.x, Y.y + se * ee.y) : null;
        }
        if (o.length === 0)
          return null;
        for (var k = o[0].x, U = o[0].x, H = o[0].y, M = o[0].y, X = 1; X < o.length; X++) {
          var Z = o[X];
          Z.x < k && (k = Z.x), Z.x > U && (U = Z.x), Z.y < H && (H = Z.y), Z.y > M && (M = Z.y);
        }
        return new e.Rect(k, H, U - k, M - H);
      },
      // private
      _getSegments: function() {
        var t = this.getTopLeft(), i = this.getTopRight(), o = this.getBottomLeft(), h = this.getBottomRight();
        return [
          [t, i],
          [i, h],
          [h, o],
          [o, t]
        ];
      },
      /**
       * Rotates a rectangle around a point.
       * @function
       * @param {Number} degrees The angle in degrees to rotate.
       * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
       * Defaults to the center of the rectangle.
       * @returns {OpenSeadragon.Rect}
       */
      rotate: function(t, i) {
        if (t = e.positiveModulo(t, 360), t === 0)
          return this.clone();
        i = i || this.getCenter();
        var o = this.getTopLeft().rotate(t, i), h = this.getTopRight().rotate(t, i), n = h.minus(o);
        n = n.apply(function(s) {
          var l = 1e-15;
          return Math.abs(s) < l ? 0 : s;
        });
        var r = Math.atan(n.y / n.x);
        return n.x < 0 ? r += Math.PI : n.y < 0 && (r += 2 * Math.PI), new e.Rect(
          o.x,
          o.y,
          this.width,
          this.height,
          r / Math.PI * 180
        );
      },
      /**
       * Retrieves the smallest horizontal (degrees=0) rectangle which contains
       * this rectangle.
       * @returns {OpenSeadragon.Rect}
       */
      getBoundingBox: function() {
        if (this.degrees === 0)
          return this.clone();
        var t = this.getTopLeft(), i = this.getTopRight(), o = this.getBottomLeft(), h = this.getBottomRight(), n = Math.min(t.x, i.x, o.x, h.x), r = Math.max(t.x, i.x, o.x, h.x), s = Math.min(t.y, i.y, o.y, h.y), l = Math.max(t.y, i.y, o.y, h.y);
        return new e.Rect(
          n,
          s,
          r - n,
          l - s
        );
      },
      /**
       * Retrieves the smallest horizontal (degrees=0) rectangle which contains
       * this rectangle and has integers x, y, width and height
       * @returns {OpenSeadragon.Rect}
       */
      getIntegerBoundingBox: function() {
        var t = this.getBoundingBox(), i = Math.floor(t.x), o = Math.floor(t.y), h = Math.ceil(t.width + t.x - i), n = Math.ceil(t.height + t.y - o);
        return new e.Rect(i, o, h, n);
      },
      /**
       * Determines whether a point is inside this rectangle (edge included).
       * @function
       * @param {OpenSeadragon.Point} point
       * @param {Number} [epsilon=0] the margin of error allowed
       * @returns {Boolean} true if the point is inside this rectangle, false
       * otherwise.
       */
      containsPoint: function(t, i) {
        i = i || 0;
        var o = this.getTopLeft(), h = this.getTopRight(), n = this.getBottomLeft(), r = h.minus(o), s = n.minus(o);
        return (t.x - o.x) * r.x + (t.y - o.y) * r.y >= -i && (t.x - h.x) * r.x + (t.y - h.y) * r.y <= i && (t.x - o.x) * s.x + (t.y - o.y) * s.y >= -i && (t.x - n.x) * s.x + (t.y - n.y) * s.y <= i;
      },
      /**
       * Provides a string representation of the rectangle which is useful for
       * debugging.
       * @function
       * @returns {String} A string representation of the rectangle.
       */
      toString: function() {
        return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
      }
    };
  }(D), function(e) {
    var t = {};
    e.ReferenceStrip = function(f) {
      var v = this, y = f.viewer, T = e.getElementSize(y.element), w, x, P;
      for (f.id || (f.id = "referencestrip-" + e.now(), this.element = e.makeNeutralElement("div"), this.element.id = f.id, this.element.className = "referencestrip"), f = e.extend(!0, {
        sizeRatio: e.DEFAULT_SETTINGS.referenceStripSizeRatio,
        position: e.DEFAULT_SETTINGS.referenceStripPosition,
        scroll: e.DEFAULT_SETTINGS.referenceStripScroll,
        clickTimeThreshold: e.DEFAULT_SETTINGS.clickTimeThreshold
      }, f, {
        element: this.element
      }), e.extend(this, f), t[this.id] = {
        animating: !1
      }, this.minPixelRatio = this.viewer.minPixelRatio, this.element.tabIndex = 0, x = this.element.style, x.marginTop = "0px", x.marginRight = "0px", x.marginBottom = "0px", x.marginLeft = "0px", x.left = "0px", x.bottom = "0px", x.border = "0px", x.background = "#000", x.position = "relative", e.setElementTouchActionNone(this.element), e.setElementOpacity(this.element, 0.8), this.viewer = y, this.tracker = new e.MouseTracker({
        userData: "ReferenceStrip.tracker",
        element: this.element,
        clickHandler: e.delegate(this, i),
        dragHandler: e.delegate(this, o),
        scrollHandler: e.delegate(this, h),
        enterHandler: e.delegate(this, r),
        leaveHandler: e.delegate(this, s),
        keyDownHandler: e.delegate(this, l),
        keyHandler: e.delegate(this, d),
        preProcessEventHandler: function(C) {
          C.eventType === "wheel" && (C.preventDefault = !0);
        }
      }), f.width && f.height ? (this.element.style.width = f.width + "px", this.element.style.height = f.height + "px", y.addControl(
        this.element,
        { anchor: e.ControlAnchor.BOTTOM_LEFT }
      )) : f.scroll === "horizontal" ? (this.element.style.width = T.x * f.sizeRatio * y.tileSources.length + 12 * y.tileSources.length + "px", this.element.style.height = T.y * f.sizeRatio + "px", y.addControl(
        this.element,
        { anchor: e.ControlAnchor.BOTTOM_LEFT }
      )) : (this.element.style.height = T.y * f.sizeRatio * y.tileSources.length + 12 * y.tileSources.length + "px", this.element.style.width = T.x * f.sizeRatio + "px", y.addControl(
        this.element,
        { anchor: e.ControlAnchor.TOP_LEFT }
      )), this.panelWidth = T.x * this.sizeRatio + 8, this.panelHeight = T.y * this.sizeRatio + 8, this.panels = [], this.miniViewers = {}, P = 0; P < y.tileSources.length; P++)
        w = e.makeNeutralElement("div"), w.id = this.element.id + "-" + P, w.style.width = v.panelWidth + "px", w.style.height = v.panelHeight + "px", w.style.display = "inline", w.style.float = "left", w.style.cssFloat = "left", w.style.styleFloat = "left", w.style.padding = "2px", e.setElementTouchActionNone(w), e.setElementPointerEventsNone(w), this.element.appendChild(w), w.activePanel = !1, this.panels.push(w);
      n(this, this.scroll === "vertical" ? T.y : T.x, 0), this.setFocus(0);
    }, e.ReferenceStrip.prototype = {
      /**
       * @function
       */
      setFocus: function(f) {
        var v = this.element.querySelector("#" + this.element.id + "-" + f), y = e.getElementSize(this.viewer.canvas), T = Number(this.element.style.width.replace("px", "")), w = Number(this.element.style.height.replace("px", "")), x = -Number(this.element.style.marginLeft.replace("px", "")), P = -Number(this.element.style.marginTop.replace("px", "")), C;
        this.currentSelected !== v && (this.currentSelected && (this.currentSelected.style.background = "#000"), this.currentSelected = v, this.currentSelected.style.background = "#999", this.scroll === "horizontal" ? (C = Number(f) * (this.panelWidth + 3), C > x + y.x - this.panelWidth ? (C = Math.min(C, T - y.x), this.element.style.marginLeft = -C + "px", n(this, y.x, -C)) : C < x && (C = Math.max(0, C - y.x / 2), this.element.style.marginLeft = -C + "px", n(this, y.x, -C))) : (C = Number(f) * (this.panelHeight + 3), C > P + y.y - this.panelHeight ? (C = Math.min(C, w - y.y), this.element.style.marginTop = -C + "px", n(this, y.y, -C)) : C < P && (C = Math.max(0, C - y.y / 2), this.element.style.marginTop = -C + "px", n(this, y.y, -C))), this.currentPage = f, r.call(this, { eventSource: this.tracker }));
      },
      /**
       * @function
       */
      update: function() {
        return !!t[this.id].animating;
      },
      destroy: function() {
        if (this.miniViewers)
          for (var f in this.miniViewers)
            this.miniViewers[f].destroy();
        this.tracker.destroy(), this.element && this.viewer.removeControl(this.element);
      }
    };
    function i(f) {
      if (f.quick) {
        var v;
        this.scroll === "horizontal" ? v = Math.floor(f.position.x / (this.panelWidth + 4)) : v = Math.floor(f.position.y / this.panelHeight), this.viewer.goToPage(v);
      }
      this.element.focus();
    }
    function o(f) {
      if (this.dragging = !0, this.element) {
        var v = Number(this.element.style.marginLeft.replace("px", "")), y = Number(this.element.style.marginTop.replace("px", "")), T = Number(this.element.style.width.replace("px", "")), w = Number(this.element.style.height.replace("px", "")), x = e.getElementSize(this.viewer.canvas);
        this.scroll === "horizontal" ? -f.delta.x > 0 ? v > -(T - x.x) && (this.element.style.marginLeft = v + f.delta.x * 2 + "px", n(this, x.x, v + f.delta.x * 2)) : -f.delta.x < 0 && v < 0 && (this.element.style.marginLeft = v + f.delta.x * 2 + "px", n(this, x.x, v + f.delta.x * 2)) : -f.delta.y > 0 ? y > -(w - x.y) && (this.element.style.marginTop = y + f.delta.y * 2 + "px", n(this, x.y, y + f.delta.y * 2)) : -f.delta.y < 0 && y < 0 && (this.element.style.marginTop = y + f.delta.y * 2 + "px", n(this, x.y, y + f.delta.y * 2));
      }
    }
    function h(f) {
      if (this.element) {
        var v = Number(this.element.style.marginLeft.replace("px", "")), y = Number(this.element.style.marginTop.replace("px", "")), T = Number(this.element.style.width.replace("px", "")), w = Number(this.element.style.height.replace("px", "")), x = e.getElementSize(this.viewer.canvas);
        this.scroll === "horizontal" ? f.scroll > 0 ? v > -(T - x.x) && (this.element.style.marginLeft = v - f.scroll * 60 + "px", n(this, x.x, v - f.scroll * 60)) : f.scroll < 0 && v < 0 && (this.element.style.marginLeft = v - f.scroll * 60 + "px", n(this, x.x, v - f.scroll * 60)) : f.scroll < 0 ? y > x.y - w && (this.element.style.marginTop = y + f.scroll * 60 + "px", n(this, x.y, y + f.scroll * 60)) : f.scroll > 0 && y < 0 && (this.element.style.marginTop = y + f.scroll * 60 + "px", n(this, x.y, y + f.scroll * 60)), f.preventDefault = !0;
      }
    }
    function n(f, v, y) {
      var T, w, x, P, C, A;
      for (f.scroll === "horizontal" ? T = f.panelWidth : T = f.panelHeight, w = Math.ceil(v / T) + 5, x = Math.ceil((Math.abs(y) + v) / T) + 1, w = x - w, w = w < 0 ? 0 : w, C = w; C < x && C < f.panels.length; C++)
        if (A = f.panels[C], !A.activePanel) {
          var W, k = f.viewer.tileSources[C];
          k.referenceStripThumbnailUrl ? W = {
            type: "image",
            url: k.referenceStripThumbnailUrl
          } : W = k, P = new e.Viewer({
            id: A.id,
            tileSources: [W],
            element: A,
            navigatorSizeRatio: f.sizeRatio,
            showNavigator: !1,
            mouseNavEnabled: !1,
            showNavigationControl: !1,
            showSequenceControl: !1,
            immediateRender: !0,
            blendTime: 0,
            animationTime: 0,
            loadTilesWithAjax: f.viewer.loadTilesWithAjax,
            ajaxHeaders: f.viewer.ajaxHeaders,
            useCanvas: f.useCanvas
          }), e.setElementPointerEventsNone(P.canvas), e.setElementPointerEventsNone(P.container), P.innerTracker.setTracking(!1), P.outerTracker.setTracking(!1), f.miniViewers[A.id] = P, A.activePanel = !0;
        }
    }
    function r(f) {
      var v = f.eventSource.element;
      this.scroll === "horizontal" ? v.style.marginBottom = "0px" : v.style.marginLeft = "0px";
    }
    function s(f) {
      var v = f.eventSource.element;
      this.scroll === "horizontal" ? v.style.marginBottom = "-" + e.getElementSize(v).y / 2 + "px" : v.style.marginLeft = "-" + e.getElementSize(v).x / 2 + "px";
    }
    function l(f) {
      if (!f.ctrl && !f.alt && !f.meta)
        switch (f.keyCode) {
          case 38:
            h.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), f.preventDefault = !0;
            break;
          case 40:
            h.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), f.preventDefault = !0;
            break;
          case 37:
            h.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), f.preventDefault = !0;
            break;
          case 39:
            h.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), f.preventDefault = !0;
            break;
          default:
            f.preventDefault = !1;
            break;
        }
      else
        f.preventDefault = !1;
    }
    function d(f) {
      if (!f.ctrl && !f.alt && !f.meta)
        switch (f.keyCode) {
          case 61:
            h.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), f.preventDefault = !0;
            break;
          case 45:
            h.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), f.preventDefault = !0;
            break;
          case 48:
          case 119:
          case 87:
            h.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), f.preventDefault = !0;
            break;
          case 115:
          case 83:
            h.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), f.preventDefault = !0;
            break;
          case 97:
            h.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null }), f.preventDefault = !0;
            break;
          case 100:
            h.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null }), f.preventDefault = !0;
            break;
          default:
            f.preventDefault = !1;
            break;
        }
      else
        f.preventDefault = !1;
    }
  }(D), function(e) {
    e.DisplayRect = function(t, i, o, h, n, r) {
      e.Rect.apply(this, [t, i, o, h]), this.minLevel = n, this.maxLevel = r;
    }, e.extend(e.DisplayRect.prototype, e.Rect.prototype);
  }(D), function(e) {
    e.Spring = function(i) {
      var o = arguments;
      typeof i != "object" && (i = {
        initial: o.length && typeof o[0] == "number" ? o[0] : void 0,
        /**
         * Spring stiffness.
         * @member {Number} springStiffness
         * @memberof OpenSeadragon.Spring#
         */
        springStiffness: o.length > 1 ? o[1].springStiffness : 5,
        /**
         * Animation duration per spring.
         * @member {Number} animationTime
         * @memberof OpenSeadragon.Spring#
         */
        animationTime: o.length > 1 ? o[1].animationTime : 1.5
      }), e.console.assert(
        typeof i.springStiffness == "number" && i.springStiffness !== 0,
        "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
      ), e.console.assert(
        typeof i.animationTime == "number" && i.animationTime >= 0,
        "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
      ), i.exponential && (this._exponential = !0, delete i.exponential), e.extend(!0, this, i), this.current = {
        value: typeof this.initial == "number" ? this.initial : this._exponential ? 0 : 1,
        time: e.now()
        // always work in milliseconds
      }, e.console.assert(
        !this._exponential || this.current.value !== 0,
        "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
      ), this.start = {
        value: this.current.value,
        time: this.current.time
      }, this.target = {
        value: this.current.value,
        time: this.current.time
      }, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
    }, e.Spring.prototype = {
      /**
       * @function
       * @param {Number} target
       */
      resetTo: function(i) {
        e.console.assert(
          !this._exponential || i !== 0,
          "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
        ), this.start.value = this.target.value = this.current.value = i, this.start.time = this.target.time = this.current.time = e.now(), this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
      },
      /**
       * @function
       * @param {Number} target
       */
      springTo: function(i) {
        e.console.assert(
          !this._exponential || i !== 0,
          "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
        ), this.start.value = this.current.value, this.start.time = this.current.time, this.target.value = i, this.target.time = this.start.time + 1e3 * this.animationTime, this._exponential && (this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
      },
      /**
       * @function
       * @param {Number} delta
       */
      shiftBy: function(i) {
        this.start.value += i, this.target.value += i, this._exponential && (e.console.assert(
          this.target.value !== 0 && this.start.value !== 0,
          "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
        ), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value));
      },
      setExponential: function(i) {
        this._exponential = i, this._exponential && (e.console.assert(
          this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
          "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
        ), this.start._logValue = Math.log(this.start.value), this.target._logValue = Math.log(this.target.value), this.current._logValue = Math.log(this.current.value));
      },
      /**
       * @function
       * @returns true if the value got updated, false otherwise
       */
      update: function() {
        this.current.time = e.now();
        var i, o;
        this._exponential ? (i = this.start._logValue, o = this.target._logValue) : (i = this.start.value, o = this.target.value);
        var h = this.current.time >= this.target.time ? o : i + (o - i) * t(
          this.springStiffness,
          (this.current.time - this.start.time) / (this.target.time - this.start.time)
        ), n = this.current.value;
        return this._exponential ? this.current.value = Math.exp(h) : this.current.value = h, n !== this.current.value;
      },
      /**
       * Returns whether the spring is at the target value
       * @function
       * @returns {Boolean} True if at target value, false otherwise
       */
      isAtTargetValue: function() {
        return this.current.value === this.target.value;
      }
    };
    function t(i, o) {
      return (1 - Math.exp(i * -o)) / (1 - Math.exp(-i));
    }
  }(D), function(e) {
    e.ImageJob = function(i) {
      e.extend(!0, this, {
        timeout: e.DEFAULT_SETTINGS.timeout,
        jobId: null,
        tries: 0
      }, i), this.data = null, this.userData = {}, this.errorMsg = null;
    }, e.ImageJob.prototype = {
      /**
       * Starts the image job.
       * @method
       */
      start: function() {
        this.tries++;
        var i = this, o = this.abort;
        this.jobId = window.setTimeout(function() {
          i.finish(null, null, "Image load exceeded timeout (" + i.timeout + " ms)");
        }, this.timeout), this.abort = function() {
          i.source.downloadTileAbort(i), typeof o == "function" && o();
        }, this.source.downloadTileStart(this);
      },
      /**
       * Finish this job.
       * @param {*} data data that has been downloaded
       * @param {XMLHttpRequest} request reference to the request if used
       * @param {string} errorMessage description upon failure
       */
      finish: function(i, o, h) {
        this.data = i, this.request = o, this.errorMsg = h, this.jobId && window.clearTimeout(this.jobId), this.callback(this);
      }
    }, e.ImageLoader = function(i) {
      e.extend(!0, this, {
        jobLimit: e.DEFAULT_SETTINGS.imageLoaderLimit,
        timeout: e.DEFAULT_SETTINGS.timeout,
        jobQueue: [],
        failedTiles: [],
        jobsInProgress: 0
      }, i);
    }, e.ImageLoader.prototype = {
      /**
       * Add an unloaded image to the loader queue.
       * @method
       * @param {Object} options - Options for this job.
       * @param {String} [options.src] - URL of image to download.
       * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
       *      is not internally used and serves for custom TileSources implementations.
       * @param {TileSource} [options.source] - Image loading strategy
       * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
       * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
       * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
       * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&k2=v2... form,
       *      see TileSource::getPostData) or null
       * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
       *      requests.
       * @param {Function} [options.callback] - Called once image has been downloaded.
       * @param {Function} [options.abort] - Called when this image job is aborted.
       */
      addJob: function(i) {
        if (!i.source) {
          e.console.error("ImageLoader.prototype.addJob() requires [options.source]. TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
          var o = e.TileSource.prototype;
          i.source = {
            downloadTileStart: o.downloadTileStart,
            downloadTileAbort: o.downloadTileAbort
          };
        }
        var h = this, n = function(l) {
          t(h, l, i.callback);
        }, r = {
          src: i.src,
          tile: i.tile || {},
          source: i.source,
          loadWithAjax: i.loadWithAjax,
          ajaxHeaders: i.loadWithAjax ? i.ajaxHeaders : null,
          crossOriginPolicy: i.crossOriginPolicy,
          ajaxWithCredentials: i.ajaxWithCredentials,
          postData: i.postData,
          callback: n,
          abort: i.abort,
          timeout: this.timeout
        }, s = new e.ImageJob(r);
        !this.jobLimit || this.jobsInProgress < this.jobLimit ? (s.start(), this.jobsInProgress++) : this.jobQueue.push(s);
      },
      /**
       * Clear any unstarted image loading jobs from the queue.
       * @method
       */
      clear: function() {
        for (var i = 0; i < this.jobQueue.length; i++) {
          var o = this.jobQueue[i];
          typeof o.abort == "function" && o.abort();
        }
        this.jobQueue = [];
      }
    };
    function t(i, o, h) {
      o.errorMsg !== "" && (o.data === null || o.data === void 0) && o.tries < 1 + i.tileRetryMax && i.failedTiles.push(o);
      var n;
      i.jobsInProgress--, (!i.jobLimit || i.jobsInProgress < i.jobLimit) && i.jobQueue.length > 0 && (n = i.jobQueue.shift(), n.start(), i.jobsInProgress++), i.tileRetryMax > 0 && i.jobQueue.length === 0 && (!i.jobLimit || i.jobsInProgress < i.jobLimit) && i.failedTiles.length > 0 && (n = i.failedTiles.shift(), setTimeout(function() {
        n.start();
      }, i.tileRetryDelay), i.jobsInProgress++), h(o.data, o.errorMsg, o.request);
    }
  }(D), function(e) {
    e.Tile = function(t, i, o, h, n, r, s, l, d, f, v, y) {
      this.level = t, this.x = i, this.y = o, this.bounds = h, this.sourceBounds = f, this.exists = n, this._url = r, this.postData = v, this.context2D = s, this.loadWithAjax = l, this.ajaxHeaders = d, y === void 0 && (e.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used."), y = e.TileSource.prototype.getTileHashKey(t, i, o, r, d, v)), this.cacheKey = y, this.loaded = !1, this.loading = !1, this.element = null, this.imgElement = null, this.style = null, this.position = null, this.size = null, this.flipped = !1, this.blendStart = null, this.opacity = null, this.squaredDistance = null, this.visibility = null, this.hasTransparency = !1, this.beingDrawn = !1, this.lastTouchTime = 0, this.isRightMost = !1, this.isBottomMost = !1;
    }, e.Tile.prototype = {
      /**
       * Provides a string representation of this tiles level and (x,y)
       * components.
       * @function
       * @returns {String}
       */
      toString: function() {
        return this.level + "/" + this.x + "_" + this.y;
      },
      // private
      _hasTransparencyChannel: function() {
        return console.warn("Tile.prototype._hasTransparencyChannel() has been deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead."), !!this.context2D || this.getUrl().match(".png");
      },
      /**
       * Renders the tile in an html container.
       * @function
       * @param {Element} container
       */
      drawHTML: function(t) {
        if (!this.cacheImageRecord) {
          e.console.warn(
            "[Tile.drawHTML] attempting to draw tile %s when it's not cached",
            this.toString()
          );
          return;
        }
        if (!this.loaded) {
          e.console.warn(
            "Attempting to draw tile %s when it's not yet loaded.",
            this.toString()
          );
          return;
        }
        if (!this.element) {
          var i = this.getImage();
          if (!i)
            return;
          this.element = e.makeNeutralElement("div"), this.imgElement = i.cloneNode(), this.imgElement.style.msInterpolationMode = "nearest-neighbor", this.imgElement.style.width = "100%", this.imgElement.style.height = "100%", this.style = this.element.style, this.style.position = "absolute";
        }
        this.element.parentNode !== t && t.appendChild(this.element), this.imgElement.parentNode !== this.element && this.element.appendChild(this.imgElement), this.style.top = this.position.y + "px", this.style.left = this.position.x + "px", this.style.height = this.size.y + "px", this.style.width = this.size.x + "px", this.flipped && (this.style.transform = "scaleX(-1)"), e.setElementOpacity(this.element, this.opacity);
      },
      /**
       * The Image object for this tile.
       * @member {Object} image
       * @memberof OpenSeadragon.Tile#
       * @deprecated
       * @returns {Image}
       */
      get image() {
        return e.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead."), this.getImage();
      },
      /**
       * The URL of this tile's image.
       * @member {String} url
       * @memberof OpenSeadragon.Tile#
       * @deprecated
       * @returns {String}
       */
      get url() {
        return e.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead."), this.getUrl();
      },
      /**
       * Get the Image object for this tile.
       * @returns {Image}
       */
      getImage: function() {
        return this.cacheImageRecord.getImage();
      },
      /**
       * Get the url string for this tile.
       * @returns {String}
       */
      getUrl: function() {
        return typeof this._url == "function" ? this._url() : this._url;
      },
      /**
       * Get the CanvasRenderingContext2D instance for tile image data drawn
       * onto Canvas if enabled and available
       * @returns {CanvasRenderingContext2D}
       */
      getCanvasContext: function() {
        return this.context2D || this.cacheImageRecord.getRenderedContext();
      },
      /**
       * Renders the tile in a canvas-based context.
       * @function
       * @param {Canvas} context
       * @param {Function} drawingHandler - Method for firing the drawing event.
       * drawingHandler({context, tile, rendered})
       * where <code>rendered</code> is the context with the pre-drawn image.
       * @param {Number} [scale=1] - Apply a scale to position and size
       * @param {OpenSeadragon.Point} [translate] - A translation vector
       * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
       * position and size of tiles supporting alpha channel in non-transparency
       * context.
       * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
       */
      drawCanvas: function(t, i, o, h, n, r) {
        var s = this.position.times(e.pixelDensityRatio), l = this.size.times(e.pixelDensityRatio), d;
        if (!this.context2D && !this.cacheImageRecord) {
          e.console.warn(
            "[Tile.drawCanvas] attempting to draw tile %s when it's not cached",
            this.toString()
          );
          return;
        }
        if (d = this.getCanvasContext(), !this.loaded || !d) {
          e.console.warn(
            "Attempting to draw tile %s when it's not yet loaded.",
            this.toString()
          );
          return;
        }
        t.save(), t.globalAlpha = this.opacity, typeof o == "number" && o !== 1 && (s = s.times(o), l = l.times(o)), h instanceof e.Point && (s = s.plus(h)), t.globalAlpha === 1 && this.hasTransparency && (n && (s.x = Math.round(s.x), s.y = Math.round(s.y), l.x = Math.round(l.x), l.y = Math.round(l.y)), t.clearRect(
          s.x,
          s.y,
          l.x,
          l.y
        )), i({ context: t, tile: this, rendered: d });
        var f, v;
        this.sourceBounds ? (f = Math.min(this.sourceBounds.width, d.canvas.width), v = Math.min(this.sourceBounds.height, d.canvas.height)) : (f = d.canvas.width, v = d.canvas.height), t.translate(s.x + l.x / 2, 0), this.flipped && t.scale(-1, 1), t.drawImage(
          d.canvas,
          0,
          0,
          f,
          v,
          -l.x / 2,
          s.y,
          l.x,
          l.y
        ), t.restore();
      },
      /**
       * Get the ratio between current and original size.
       * @function
       * @returns {Float}
       */
      getScaleForEdgeSmoothing: function() {
        var t;
        if (this.cacheImageRecord)
          t = this.cacheImageRecord.getRenderedContext();
        else if (this.context2D)
          t = this.context2D;
        else
          return e.console.warn(
            "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
            this.toString()
          ), 1;
        return t.canvas.width / (this.size.x * e.pixelDensityRatio);
      },
      /**
       * Get a translation vector that when applied to the tile position produces integer coordinates.
       * Needed to avoid swimming and twitching.
       * @function
       * @param {Number} [scale=1] - Scale to be applied to position.
       * @returns {OpenSeadragon.Point}
       */
      getTranslationForEdgeSmoothing: function(t, i, o) {
        var h = Math.max(1, Math.ceil((o.x - i.x) / 2)), n = Math.max(1, Math.ceil((o.y - i.y) / 2));
        return new e.Point(h, n).minus(
          this.position.times(e.pixelDensityRatio).times(t || 1).apply(function(r) {
            return r % 1;
          })
        );
      },
      /**
       * Removes tile from its container.
       * @function
       */
      unload: function() {
        this.imgElement && this.imgElement.parentNode && this.imgElement.parentNode.removeChild(this.imgElement), this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = null, this.imgElement = null, this.loaded = !1, this.loading = !1;
      }
    };
  }(D), function(e) {
    e.OverlayPlacement = e.Placement, e.OverlayRotationMode = e.freezeObject({
      NO_ROTATION: 1,
      EXACT: 2,
      BOUNDING_BOX: 3
    }), e.Overlay = function(t, i, o) {
      var h;
      e.isPlainObject(t) ? h = t : h = {
        element: t,
        location: i,
        placement: o
      }, this.element = h.element, this.style = h.element.style, this._init(h);
    }, e.Overlay.prototype = {
      // private
      _init: function(t) {
        this.location = t.location, this.placement = t.placement === void 0 ? e.Placement.TOP_LEFT : t.placement, this.onDraw = t.onDraw, this.checkResize = t.checkResize === void 0 ? !0 : t.checkResize, this.width = t.width === void 0 ? null : t.width, this.height = t.height === void 0 ? null : t.height, this.rotationMode = t.rotationMode || e.OverlayRotationMode.EXACT, this.location instanceof e.Rect && (this.width = this.location.width, this.height = this.location.height, this.location = this.location.getTopLeft(), this.placement = e.Placement.TOP_LEFT), this.scales = this.width !== null && this.height !== null, this.bounds = new e.Rect(
          this.location.x,
          this.location.y,
          this.width,
          this.height
        ), this.position = this.location;
      },
      /**
       * Internal function to adjust the position of an overlay
       * depending on it size and placement.
       * @function
       * @param {OpenSeadragon.Point} position
       * @param {OpenSeadragon.Point} size
       */
      adjust: function(t, i) {
        var o = e.Placement.properties[this.placement];
        o && (o.isHorizontallyCentered ? t.x -= i.x / 2 : o.isRight && (t.x -= i.x), o.isVerticallyCentered ? t.y -= i.y / 2 : o.isBottom && (t.y -= i.y));
      },
      /**
       * @function
       */
      destroy: function() {
        var t = this.element, i = this.style;
        t.parentNode && (t.parentNode.removeChild(t), t.prevElementParent && (i.display = "none", document.body.appendChild(t))), this.onDraw = null, i.top = "", i.left = "", i.position = "", this.width !== null && (i.width = ""), this.height !== null && (i.height = "");
        var o = e.getCssPropertyWithVendorPrefix(
          "transformOrigin"
        ), h = e.getCssPropertyWithVendorPrefix(
          "transform"
        );
        o && h && (i[o] = "", i[h] = "");
      },
      /**
       * @function
       * @param {Element} container
       */
      drawHTML: function(t, i) {
        var o = this.element;
        o.parentNode !== t && (o.prevElementParent = o.parentNode, o.prevNextSibling = o.nextSibling, t.appendChild(o), this.style.position = "absolute", this.size = e.getElementSize(o));
        var h = this._getOverlayPositionAndSize(i), n = h.position, r = this.size = h.size, s = h.rotate;
        if (this.onDraw)
          this.onDraw(n, r, this.element);
        else {
          var l = this.style;
          l.left = n.x + "px", l.top = n.y + "px", this.width !== null && (l.width = r.x + "px"), this.height !== null && (l.height = r.y + "px");
          var d = e.getCssPropertyWithVendorPrefix(
            "transformOrigin"
          ), f = e.getCssPropertyWithVendorPrefix(
            "transform"
          );
          d && f && (s ? (l[d] = this._getTransformOrigin(), l[f] = "rotate(" + s + "deg)") : (l[d] = "", l[f] = "")), l.display = "block";
        }
      },
      // private
      _getOverlayPositionAndSize: function(t) {
        var i = t.pixelFromPoint(this.location, !0), o = this._getSizeInPixels(t);
        this.adjust(i, o);
        var h = 0;
        if (t.getRotation(!0) && this.rotationMode !== e.OverlayRotationMode.NO_ROTATION)
          if (this.rotationMode === e.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
            var n = new e.Rect(i.x, i.y, o.x, o.y), r = this._getBoundingBox(n, t.getRotation(!0));
            i = r.getTopLeft(), o = r.getSize();
          } else
            h = t.getRotation(!0);
        return {
          position: i,
          size: o,
          rotate: h
        };
      },
      // private
      _getSizeInPixels: function(t) {
        var i = this.size.x, o = this.size.y;
        if (this.width !== null || this.height !== null) {
          var h = t.deltaPixelsFromPointsNoRotate(
            new e.Point(this.width || 0, this.height || 0),
            !0
          );
          this.width !== null && (i = h.x), this.height !== null && (o = h.y);
        }
        if (this.checkResize && (this.width === null || this.height === null)) {
          var n = this.size = e.getElementSize(this.element);
          this.width === null && (i = n.x), this.height === null && (o = n.y);
        }
        return new e.Point(i, o);
      },
      // private
      _getBoundingBox: function(t, i) {
        var o = this._getPlacementPoint(t);
        return t.rotate(i, o).getBoundingBox();
      },
      // private
      _getPlacementPoint: function(t) {
        var i = new e.Point(t.x, t.y), o = e.Placement.properties[this.placement];
        return o && (o.isHorizontallyCentered ? i.x += t.width / 2 : o.isRight && (i.x += t.width), o.isVerticallyCentered ? i.y += t.height / 2 : o.isBottom && (i.y += t.height)), i;
      },
      // private
      _getTransformOrigin: function() {
        var t = "", i = e.Placement.properties[this.placement];
        return i && (i.isLeft ? t = "left" : i.isRight && (t = "right"), i.isTop ? t += " top" : i.isBottom && (t += " bottom")), t;
      },
      /**
       * Changes the overlay settings.
       * @function
       * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
       * If an object is specified, the options are the same than the constructor
       * except for the element which can not be changed.
       * @param {OpenSeadragon.Placement} placement
       */
      update: function(t, i) {
        var o = e.isPlainObject(t) ? t : {
          location: t,
          placement: i
        };
        this._init({
          location: o.location || this.location,
          placement: o.placement !== void 0 ? o.placement : this.placement,
          onDraw: o.onDraw || this.onDraw,
          checkResize: o.checkResize || this.checkResize,
          width: o.width !== void 0 ? o.width : this.width,
          height: o.height !== void 0 ? o.height : this.height,
          rotationMode: o.rotationMode || this.rotationMode
        });
      },
      /**
       * Returns the current bounds of the overlay in viewport coordinates
       * @function
       * @param {OpenSeadragon.Viewport} viewport the viewport
       * @returns {OpenSeadragon.Rect} overlay bounds
       */
      getBounds: function(t) {
        e.console.assert(
          t,
          "A viewport must now be passed to Overlay.getBounds."
        );
        var i = this.width, o = this.height;
        if (i === null || o === null) {
          var h = t.deltaPointsFromPixelsNoRotate(this.size, !0);
          i === null && (i = h.x), o === null && (o = h.y);
        }
        var n = this.location.clone();
        return this.adjust(n, new e.Point(i, o)), this._adjustBoundsForRotation(
          t,
          new e.Rect(n.x, n.y, i, o)
        );
      },
      // private
      _adjustBoundsForRotation: function(t, i) {
        if (!t || t.getRotation(!0) === 0 || this.rotationMode === e.OverlayRotationMode.EXACT)
          return i;
        if (this.rotationMode === e.OverlayRotationMode.BOUNDING_BOX) {
          if (this.width === null || this.height === null)
            return i;
          var o = this._getOverlayPositionAndSize(t);
          return t.viewerElementToViewportRectangle(new e.Rect(
            o.position.x,
            o.position.y,
            o.size.x,
            o.size.y
          ));
        }
        return i.rotate(
          -t.getRotation(!0),
          this._getPlacementPoint(i)
        );
      }
    };
  }(D), function(e) {
    e.Drawer = function(t) {
      e.console.assert(t.viewer, "[Drawer] options.viewer is required");
      var i = arguments;
      if (e.isPlainObject(t) || (t = {
        source: i[0],
        // Reference to Viewer tile source.
        viewport: i[1],
        // Reference to Viewer viewport.
        element: i[2]
        // Parent element.
      }), e.console.assert(t.viewport, "[Drawer] options.viewport is required"), e.console.assert(t.element, "[Drawer] options.element is required"), t.source && e.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead"), this.viewer = t.viewer, this.viewport = t.viewport, this.debugGridColor = typeof t.debugGridColor == "string" ? [t.debugGridColor] : t.debugGridColor || e.DEFAULT_SETTINGS.debugGridColor, t.opacity && e.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead"), this.useCanvas = e.supportsCanvas && (this.viewer ? this.viewer.useCanvas : !0), this.container = e.getElement(t.element), this.canvas = e.makeNeutralElement(this.useCanvas ? "canvas" : "div"), this.context = this.useCanvas ? this.canvas.getContext("2d") : null, this.sketchCanvas = null, this.sketchContext = null, this.element = this.container, this.container.dir = "ltr", this.useCanvas) {
        var o = this._calculateCanvasSize();
        this.canvas.width = o.x, this.canvas.height = o.y;
      }
      this.canvas.style.width = "100%", this.canvas.style.height = "100%", this.canvas.style.position = "absolute", e.setElementOpacity(this.canvas, this.opacity, !0), e.setElementPointerEventsNone(this.canvas), e.setElementTouchActionNone(this.canvas), this.container.style.textAlign = "left", this.container.appendChild(this.canvas), this._imageSmoothingEnabled = !0;
    }, e.Drawer.prototype = {
      // deprecated
      addOverlay: function(t, i, o, h) {
        return e.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead."), this.viewer.addOverlay(t, i, o, h), this;
      },
      // deprecated
      updateOverlay: function(t, i, o) {
        return e.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead."), this.viewer.updateOverlay(t, i, o), this;
      },
      // deprecated
      removeOverlay: function(t) {
        return e.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead."), this.viewer.removeOverlay(t), this;
      },
      // deprecated
      clearOverlays: function() {
        return e.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead."), this.viewer.clearOverlays(), this;
      },
      /**
       * This function converts the given point from to the drawer coordinate by
       * multiplying it with the pixel density.
       * This function does not take rotation into account, thus assuming provided
       * point is at 0 degree.
       * @param {OpenSeadragon.Point} point - the pixel point to convert
       * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
       */
      viewportCoordToDrawerCoord: function(t) {
        var i = this.viewport.pixelFromPointNoRotate(t, !0);
        return new e.Point(
          i.x * e.pixelDensityRatio,
          i.y * e.pixelDensityRatio
        );
      },
      /**
       * This function will create multiple polygon paths on the drawing context by provided polygons,
       * then clip the context to the paths.
       * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
       * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
       */
      clipWithPolygons: function(t, i) {
        if (this.useCanvas) {
          var o = this._getContext(i);
          o.beginPath(), t.forEach(function(h) {
            h.forEach(function(n, r) {
              o[r === 0 ? "moveTo" : "lineTo"](n.x, n.y);
            });
          }), o.clip();
        }
      },
      /**
       * Set the opacity of the drawer.
       * @param {Number} opacity
       * @returns {OpenSeadragon.Drawer} Chainable.
       */
      setOpacity: function(t) {
        e.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
        for (var i = this.viewer.world, o = 0; o < i.getItemCount(); o++)
          i.getItemAt(o).setOpacity(t);
        return this;
      },
      /**
       * Get the opacity of the drawer.
       * @returns {Number}
       */
      getOpacity: function() {
        e.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
        for (var t = this.viewer.world, i = 0, o = 0; o < t.getItemCount(); o++) {
          var h = t.getItemAt(o).getOpacity();
          h > i && (i = h);
        }
        return i;
      },
      // deprecated
      needsUpdate: function() {
        return e.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead."), this.viewer.world.needsDraw();
      },
      // deprecated
      numTilesLoaded: function() {
        return e.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead."), this.viewer.tileCache.numTilesLoaded();
      },
      // deprecated
      reset: function() {
        return e.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead."), this.viewer.world.resetItems(), this;
      },
      // deprecated
      update: function() {
        return e.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead."), this.clear(), this.viewer.world.draw(), this;
      },
      /**
       * @returns {Boolean} True if rotation is supported.
       */
      canRotate: function() {
        return this.useCanvas;
      },
      /**
       * Destroy the drawer (unload current loaded tiles)
       */
      destroy: function() {
        this.canvas.width = 1, this.canvas.height = 1, this.sketchCanvas = null, this.sketchContext = null;
      },
      /**
       * Clears the Drawer so it's ready to draw another frame.
       */
      clear: function() {
        if (this.canvas.innerHTML = "", this.useCanvas) {
          var t = this._calculateCanvasSize();
          if ((this.canvas.width !== t.x || this.canvas.height !== t.y) && (this.canvas.width = t.x, this.canvas.height = t.y, this._updateImageSmoothingEnabled(this.context), this.sketchCanvas !== null)) {
            var i = this._calculateSketchCanvasSize();
            this.sketchCanvas.width = i.x, this.sketchCanvas.height = i.y, this._updateImageSmoothingEnabled(this.sketchContext);
          }
          this._clear();
        }
      },
      _clear: function(t, i) {
        if (this.useCanvas) {
          var o = this._getContext(t);
          if (i)
            o.clearRect(i.x, i.y, i.width, i.height);
          else {
            var h = o.canvas;
            o.clearRect(0, 0, h.width, h.height);
          }
        }
      },
      /**
       * Scale from OpenSeadragon viewer rectangle to drawer rectangle
       * (ignoring rotation)
       * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
       * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
       */
      viewportToDrawerRectangle: function(t) {
        var i = this.viewport.pixelFromPointNoRotate(t.getTopLeft(), !0), o = this.viewport.deltaPixelsFromPointsNoRotate(t.getSize(), !0);
        return new e.Rect(
          i.x * e.pixelDensityRatio,
          i.y * e.pixelDensityRatio,
          o.x * e.pixelDensityRatio,
          o.y * e.pixelDensityRatio
        );
      },
      /**
       * Draws the given tile.
       * @param {OpenSeadragon.Tile} tile - The tile to draw.
       * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
       * drawingHandler({context, tile, rendered})
       * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
       * where <code>rendered</code> is the context with the pre-drawn image.
       * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
       * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
       * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
       * position and size of tiles supporting alpha channel in non-transparency
       * context.
       * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
       */
      drawTile: function(t, i, o, h, n, r, s) {
        if (e.console.assert(t, "[Drawer.drawTile] tile is required"), e.console.assert(i, "[Drawer.drawTile] drawingHandler is required"), this.useCanvas) {
          var l = this._getContext(o);
          h = h || 1, t.drawCanvas(l, i, h, n, r, s);
        } else
          t.drawHTML(this.canvas);
      },
      _getContext: function(t) {
        var i = this.context;
        if (t) {
          if (this.sketchCanvas === null) {
            this.sketchCanvas = document.createElement("canvas");
            var o = this._calculateSketchCanvasSize();
            if (this.sketchCanvas.width = o.x, this.sketchCanvas.height = o.y, this.sketchContext = this.sketchCanvas.getContext("2d"), this.viewport.getRotation() === 0) {
              var h = this;
              this.viewer.addHandler("rotate", function n() {
                if (h.viewport.getRotation() !== 0) {
                  h.viewer.removeHandler("rotate", n);
                  var r = h._calculateSketchCanvasSize();
                  h.sketchCanvas.width = r.x, h.sketchCanvas.height = r.y;
                }
              });
            }
            this._updateImageSmoothingEnabled(this.sketchContext);
          }
          i = this.sketchContext;
        }
        return i;
      },
      // private
      saveContext: function(t) {
        this.useCanvas && this._getContext(t).save();
      },
      // private
      restoreContext: function(t) {
        this.useCanvas && this._getContext(t).restore();
      },
      // private
      setClip: function(t, i) {
        if (this.useCanvas) {
          var o = this._getContext(i);
          o.beginPath(), o.rect(t.x, t.y, t.width, t.height), o.clip();
        }
      },
      // private
      drawRectangle: function(t, i, o) {
        if (this.useCanvas) {
          var h = this._getContext(o);
          h.save(), h.fillStyle = i, h.fillRect(t.x, t.y, t.width, t.height), h.restore();
        }
      },
      /**
       * Blends the sketch canvas in the main canvas.
       * @param {Object} options The options
       * @param {Float} options.opacity The opacity of the blending.
       * @param {Float} [options.scale=1] The scale at which tiles were drawn on
       * the sketch. Default is 1.
       * Use scale to draw at a lower scale and then enlarge onto the main canvas.
       * @param {OpenSeadragon.Point} [options.translate] A translation vector
       * that was used to draw the tiles
       * @param {String} [options.compositeOperation] - How the image is
       * composited onto other images; see compositeOperation in
       * {@link OpenSeadragon.Options} for possible values.
       * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
       * canvas to blend in the main canvas. If specified, options.scale and
       * options.translate get ignored.
       */
      blendSketch: function(t, i, o, h) {
        var n = t;
        if (e.isPlainObject(n) || (n = {
          opacity: t,
          scale: i,
          translate: o,
          compositeOperation: h
        }), !(!this.useCanvas || !this.sketchCanvas)) {
          t = n.opacity, h = n.compositeOperation;
          var r = n.bounds;
          if (this.context.save(), this.context.globalAlpha = t, h && (this.context.globalCompositeOperation = h), r)
            r.x < 0 && (r.width += r.x, r.x = 0), r.x + r.width > this.canvas.width && (r.width = this.canvas.width - r.x), r.y < 0 && (r.height += r.y, r.y = 0), r.y + r.height > this.canvas.height && (r.height = this.canvas.height - r.y), this.context.drawImage(
              this.sketchCanvas,
              r.x,
              r.y,
              r.width,
              r.height,
              r.x,
              r.y,
              r.width,
              r.height
            );
          else {
            i = n.scale || 1, o = n.translate;
            var s = o instanceof e.Point ? o : new e.Point(0, 0), l = 0, d = 0;
            if (o) {
              var f = this.sketchCanvas.width - this.canvas.width, v = this.sketchCanvas.height - this.canvas.height;
              l = Math.round(f / 2), d = Math.round(v / 2);
            }
            this.context.drawImage(
              this.sketchCanvas,
              s.x - l * i,
              s.y - d * i,
              (this.canvas.width + 2 * l) * i,
              (this.canvas.height + 2 * d) * i,
              -l,
              -d,
              this.canvas.width + 2 * l,
              this.canvas.height + 2 * d
            );
          }
          this.context.restore();
        }
      },
      // private
      drawDebugInfo: function(t, i, o, h) {
        if (this.useCanvas) {
          var n = this.viewer.world.getIndexOfItem(h) % this.debugGridColor.length, r = this.context;
          r.save(), r.lineWidth = 2 * e.pixelDensityRatio, r.font = "small-caps bold " + 13 * e.pixelDensityRatio + "px arial", r.strokeStyle = this.debugGridColor[n], r.fillStyle = this.debugGridColor[n], this.viewport.getRotation(!0) % 360 !== 0 && this._offsetForRotation({ degrees: this.viewport.getRotation(!0) }), h.getRotation(!0) % 360 !== 0 && this._offsetForRotation({
            degrees: h.getRotation(!0),
            point: h.viewport.pixelFromPointNoRotate(
              h._getRotationPoint(!0),
              !0
            )
          }), h.viewport.getRotation(!0) % 360 === 0 && h.getRotation(!0) % 360 === 0 && h._drawer.viewer.viewport.getFlip() && h._drawer._flip(), r.strokeRect(
            t.position.x * e.pixelDensityRatio,
            t.position.y * e.pixelDensityRatio,
            t.size.x * e.pixelDensityRatio,
            t.size.y * e.pixelDensityRatio
          );
          var s = (t.position.x + t.size.x / 2) * e.pixelDensityRatio, l = (t.position.y + t.size.y / 2) * e.pixelDensityRatio;
          r.translate(s, l), r.rotate(Math.PI / 180 * -this.viewport.getRotation(!0)), r.translate(-s, -l), t.x === 0 && t.y === 0 && (r.fillText(
            "Zoom: " + this.viewport.getZoom(),
            t.position.x * e.pixelDensityRatio,
            (t.position.y - 30) * e.pixelDensityRatio
          ), r.fillText(
            "Pan: " + this.viewport.getBounds().toString(),
            t.position.x * e.pixelDensityRatio,
            (t.position.y - 20) * e.pixelDensityRatio
          )), r.fillText(
            "Level: " + t.level,
            (t.position.x + 10) * e.pixelDensityRatio,
            (t.position.y + 20) * e.pixelDensityRatio
          ), r.fillText(
            "Column: " + t.x,
            (t.position.x + 10) * e.pixelDensityRatio,
            (t.position.y + 30) * e.pixelDensityRatio
          ), r.fillText(
            "Row: " + t.y,
            (t.position.x + 10) * e.pixelDensityRatio,
            (t.position.y + 40) * e.pixelDensityRatio
          ), r.fillText(
            "Order: " + o + " of " + i,
            (t.position.x + 10) * e.pixelDensityRatio,
            (t.position.y + 50) * e.pixelDensityRatio
          ), r.fillText(
            "Size: " + t.size.toString(),
            (t.position.x + 10) * e.pixelDensityRatio,
            (t.position.y + 60) * e.pixelDensityRatio
          ), r.fillText(
            "Position: " + t.position.toString(),
            (t.position.x + 10) * e.pixelDensityRatio,
            (t.position.y + 70) * e.pixelDensityRatio
          ), this.viewport.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), h.getRotation(!0) % 360 !== 0 && this._restoreRotationChanges(), h.viewport.getRotation(!0) % 360 === 0 && h.getRotation(!0) % 360 === 0 && h._drawer.viewer.viewport.getFlip() && h._drawer._flip(), r.restore();
        }
      },
      // private
      debugRect: function(t) {
        if (this.useCanvas) {
          var i = this.context;
          i.save(), i.lineWidth = 2 * e.pixelDensityRatio, i.strokeStyle = this.debugGridColor[0], i.fillStyle = this.debugGridColor[0], i.strokeRect(
            t.x * e.pixelDensityRatio,
            t.y * e.pixelDensityRatio,
            t.width * e.pixelDensityRatio,
            t.height * e.pixelDensityRatio
          ), i.restore();
        }
      },
      /**
       * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
       *
       * @function
       * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
       * drawn smoothly on the canvas; see imageSmoothingEnabled in
       * {@link OpenSeadragon.Options} for more explanation.
       */
      setImageSmoothingEnabled: function(t) {
        this.useCanvas && (this._imageSmoothingEnabled = t, this._updateImageSmoothingEnabled(this.context), this.viewer.forceRedraw());
      },
      // private
      _updateImageSmoothingEnabled: function(t) {
        t.msImageSmoothingEnabled = this._imageSmoothingEnabled, t.imageSmoothingEnabled = this._imageSmoothingEnabled;
      },
      /**
       * Get the canvas size
       * @param {Boolean} sketch If set to true return the size of the sketch canvas
       * @returns {OpenSeadragon.Point} The size of the canvas
       */
      getCanvasSize: function(t) {
        var i = this._getContext(t).canvas;
        return new e.Point(i.width, i.height);
      },
      getCanvasCenter: function() {
        return new e.Point(this.canvas.width / 2, this.canvas.height / 2);
      },
      // private
      _offsetForRotation: function(t) {
        var i = t.point ? t.point.times(e.pixelDensityRatio) : this.getCanvasCenter(), o = this._getContext(t.useSketch);
        o.save(), o.translate(i.x, i.y), this.viewer.viewport.flipped ? (o.rotate(Math.PI / 180 * -t.degrees), o.scale(-1, 1)) : o.rotate(Math.PI / 180 * t.degrees), o.translate(-i.x, -i.y);
      },
      // private
      _flip: function(t) {
        t = t || {};
        var i = t.point ? t.point.times(e.pixelDensityRatio) : this.getCanvasCenter(), o = this._getContext(t.useSketch);
        o.translate(i.x, 0), o.scale(-1, 1), o.translate(-i.x, 0);
      },
      // private
      _restoreRotationChanges: function(t) {
        var i = this._getContext(t);
        i.restore();
      },
      // private
      _calculateCanvasSize: function() {
        var t = e.pixelDensityRatio, i = this.viewport.getContainerSize();
        return {
          // canvas width and height are integers
          x: Math.round(i.x * t),
          y: Math.round(i.y * t)
        };
      },
      // private
      _calculateSketchCanvasSize: function() {
        var t = this._calculateCanvasSize();
        if (this.viewport.getRotation() === 0)
          return t;
        var i = Math.ceil(Math.sqrt(
          t.x * t.x + t.y * t.y
        ));
        return {
          x: i,
          y: i
        };
      }
    };
  }(D), function(e) {
    e.Viewport = function(t) {
      var i = arguments;
      i.length && i[0] instanceof e.Point && (t = {
        containerSize: i[0],
        contentSize: i[1],
        config: i[2]
      }), t.config && (e.extend(!0, t, t.config), delete t.config), this._margins = e.extend({
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      }, t.margins || {}), delete t.margins, t.initialDegrees = t.degrees, delete t.degrees, e.extend(!0, this, {
        //required settings
        containerSize: null,
        contentSize: null,
        //internal state properties
        zoomPoint: null,
        rotationPivot: null,
        viewer: null,
        //configurable options
        springStiffness: e.DEFAULT_SETTINGS.springStiffness,
        animationTime: e.DEFAULT_SETTINGS.animationTime,
        minZoomImageRatio: e.DEFAULT_SETTINGS.minZoomImageRatio,
        maxZoomPixelRatio: e.DEFAULT_SETTINGS.maxZoomPixelRatio,
        visibilityRatio: e.DEFAULT_SETTINGS.visibilityRatio,
        wrapHorizontal: e.DEFAULT_SETTINGS.wrapHorizontal,
        wrapVertical: e.DEFAULT_SETTINGS.wrapVertical,
        defaultZoomLevel: e.DEFAULT_SETTINGS.defaultZoomLevel,
        minZoomLevel: e.DEFAULT_SETTINGS.minZoomLevel,
        maxZoomLevel: e.DEFAULT_SETTINGS.maxZoomLevel,
        initialDegrees: e.DEFAULT_SETTINGS.degrees,
        flipped: e.DEFAULT_SETTINGS.flipped,
        homeFillsViewer: e.DEFAULT_SETTINGS.homeFillsViewer,
        silenceMultiImageWarnings: e.DEFAULT_SETTINGS.silenceMultiImageWarnings
      }, t), this._updateContainerInnerSize(), this.centerSpringX = new e.Spring({
        initial: 0,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this.centerSpringY = new e.Spring({
        initial: 0,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this.zoomSpring = new e.Spring({
        exponential: !0,
        initial: 1,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this.degreesSpring = new e.Spring({
        initial: t.initialDegrees,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value, this._setContentBounds(new e.Rect(0, 0, 1, 1), 1), this.goHome(!0), this.update();
    }, e.Viewport.prototype = {
      // deprecated
      get degrees() {
        return e.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead."), this.getRotation();
      },
      // deprecated
      set degrees(t) {
        e.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead."), this.rotateTo(t);
      },
      /**
       * Updates the viewport's home bounds and constraints for the given content size.
       * @function
       * @param {OpenSeadragon.Point} contentSize - size of the content in content units
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:reset-size
       */
      resetContentSize: function(t) {
        return e.console.assert(t, "[Viewport.resetContentSize] contentSize is required"), e.console.assert(t instanceof e.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point"), e.console.assert(t.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0"), e.console.assert(t.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0"), this._setContentBounds(new e.Rect(0, 0, 1, t.y / t.x), t.x), this;
      },
      // deprecated
      setHomeBounds: function(t, i) {
        e.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually."), this._setContentBounds(t, i);
      },
      // Set the viewport's content bounds
      // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
      // without rotation
      // @param {Number} contentFactor - how many content units per viewport unit
      // @fires OpenSeadragon.Viewer.event:reset-size
      // @private
      _setContentBounds: function(t, i) {
        e.console.assert(t, "[Viewport._setContentBounds] bounds is required"), e.console.assert(t instanceof e.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect"), e.console.assert(t.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0"), e.console.assert(t.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0"), this._contentBoundsNoRotate = t.clone(), this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
          i
        ), this._contentBounds = t.rotate(this.getRotation()).getBoundingBox(), this._contentSize = this._contentBounds.getSize().times(i), this._contentAspectRatio = this._contentSize.x / this._contentSize.y, this.viewer && this.viewer.raiseEvent("reset-size", {
          contentSize: this._contentSizeNoRotate.clone(),
          contentFactor: i,
          homeBounds: this._contentBoundsNoRotate.clone(),
          contentBounds: this._contentBounds.clone()
        });
      },
      /**
       * Returns the home zoom in "viewport zoom" value.
       * @function
       * @returns {Number} The home zoom in "viewport zoom".
       */
      getHomeZoom: function() {
        if (this.defaultZoomLevel)
          return this.defaultZoomLevel;
        var t = this._contentAspectRatio / this.getAspectRatio(), i;
        return this.homeFillsViewer ? i = t >= 1 ? t : 1 : i = t >= 1 ? 1 : t, i / this._contentBounds.width;
      },
      /**
       * Returns the home bounds in viewport coordinates.
       * @function
       * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
       */
      getHomeBounds: function() {
        return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
      },
      /**
       * Returns the home bounds in viewport coordinates.
       * This method ignores the viewport rotation. Use
       * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
       * @function
       * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
       */
      getHomeBoundsNoRotate: function() {
        var t = this._contentBounds.getCenter(), i = 1 / this.getHomeZoom(), o = i / this.getAspectRatio();
        return new e.Rect(
          t.x - i / 2,
          t.y - o / 2,
          i,
          o
        );
      },
      /**
       * @function
       * @param {Boolean} immediately
       * @fires OpenSeadragon.Viewer.event:home
       */
      goHome: function(t) {
        return this.viewer && this.viewer.raiseEvent("home", {
          immediately: t
        }), this.fitBounds(this.getHomeBounds(), t);
      },
      /**
       * @function
       */
      getMinZoom: function() {
        var t = this.getHomeZoom(), i = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * t;
        return i;
      },
      /**
       * @function
       */
      getMaxZoom: function() {
        var t = this.maxZoomLevel;
        return t || (t = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x, t /= this._contentBounds.width), Math.max(t, this.getHomeZoom());
      },
      /**
       * @function
       */
      getAspectRatio: function() {
        return this._containerInnerSize.x / this._containerInnerSize.y;
      },
      /**
       * @function
       * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
       */
      getContainerSize: function() {
        return new e.Point(
          this.containerSize.x,
          this.containerSize.y
        );
      },
      /**
       * The margins push the "home" region in from the sides by the specified amounts.
       * @function
       * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
       */
      getMargins: function() {
        return e.extend({}, this._margins);
      },
      /**
       * The margins push the "home" region in from the sides by the specified amounts.
       * @function
       * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
       */
      setMargins: function(t) {
        e.console.assert(e.type(t) === "object", "[Viewport.setMargins] margins must be an object"), this._margins = e.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, t), this._updateContainerInnerSize(), this.viewer && this.viewer.forceRedraw();
      },
      /**
       * Returns the bounds of the visible area in viewport coordinates.
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
       */
      getBounds: function(t) {
        return this.getBoundsNoRotate(t).rotate(-this.getRotation(t));
      },
      /**
       * Returns the bounds of the visible area in viewport coordinates.
       * This method ignores the viewport rotation. Use
       * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
       */
      getBoundsNoRotate: function(t) {
        var i = this.getCenter(t), o = 1 / this.getZoom(t), h = o / this.getAspectRatio();
        return new e.Rect(
          i.x - o / 2,
          i.y - h / 2,
          o,
          h
        );
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
       * including the space taken by margins, in viewport coordinates.
       */
      getBoundsWithMargins: function(t) {
        return this.getBoundsNoRotateWithMargins(t).rotate(
          -this.getRotation(t),
          this.getCenter(t)
        );
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
       * including the space taken by margins, in viewport coordinates.
       */
      getBoundsNoRotateWithMargins: function(t) {
        var i = this.getBoundsNoRotate(t), o = this._containerInnerSize.x * this.getZoom(t);
        return i.x -= this._margins.left / o, i.y -= this._margins.top / o, i.width += (this._margins.left + this._margins.right) / o, i.height += (this._margins.top + this._margins.bottom) / o, i;
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       */
      getCenter: function(t) {
        var i = new e.Point(
          this.centerSpringX.current.value,
          this.centerSpringY.current.value
        ), o = new e.Point(
          this.centerSpringX.target.value,
          this.centerSpringY.target.value
        ), h, n, r, s, l, d, f, v;
        return t ? i : this.zoomPoint ? (h = this.pixelFromPoint(this.zoomPoint, !0), n = this.getZoom(), r = 1 / n, s = r / this.getAspectRatio(), l = new e.Rect(
          i.x - r / 2,
          i.y - s / 2,
          r,
          s
        ), d = this._pixelFromPoint(this.zoomPoint, l), f = d.minus(h).rotate(-this.getRotation(!0)), v = f.divide(this._containerInnerSize.x * n), o.plus(v)) : o;
      },
      /**
       * @function
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       */
      getZoom: function(t) {
        return t ? this.zoomSpring.current.value : this.zoomSpring.target.value;
      },
      // private
      _applyZoomConstraints: function(t) {
        return Math.max(
          Math.min(t, this.getMaxZoom()),
          this.getMinZoom()
        );
      },
      /**
       * @function
       * @private
       * @param {OpenSeadragon.Rect} bounds
       * @returns {OpenSeadragon.Rect} constrained bounds.
       */
      _applyBoundaryConstraints: function(t) {
        var i = this.viewportToViewerElementRectangle(t).getBoundingBox(), o = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox(), h = !1, n = !1;
        if (!this.wrapHorizontal) {
          var r = i.x + i.width, s = o.x + o.width, l, d, f;
          i.width > o.width ? l = this.visibilityRatio * o.width : l = this.visibilityRatio * i.width, d = o.x - r + l, f = s - i.x - l, l > o.width ? (i.x += (d + f) / 2, h = !0) : f < 0 ? (i.x += f, h = !0) : d > 0 && (i.x += d, h = !0);
        }
        if (!this.wrapVertical) {
          var v = i.y + i.height, y = o.y + o.height, T, w, x;
          i.height > o.height ? T = this.visibilityRatio * o.height : T = this.visibilityRatio * i.height, w = o.y - v + T, x = y - i.y - T, T > o.height ? (i.y += (w + x) / 2, n = !0) : x < 0 ? (i.y += x, n = !0) : w > 0 && (i.y += w, n = !0);
        }
        var P = h || n, C = P ? this.viewerElementToViewportRectangle(i) : t.clone();
        return C.xConstrained = h, C.yConstrained = n, C.constraintApplied = P, C;
      },
      /**
       * @function
       * @private
       * @param {Boolean} [immediately=false] - whether the function that triggered this event was
       * called with the "immediately" flag
       */
      _raiseConstraintsEvent: function(t) {
        this.viewer && this.viewer.raiseEvent("constrain", {
          immediately: t
        });
      },
      /**
       * Enforces the minZoom, maxZoom and visibilityRatio constraints by
       * zooming and panning to the closest acceptable zoom and location.
       * @function
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
       */
      applyConstraints: function(t) {
        var i = this.getZoom(), o = this._applyZoomConstraints(i);
        i !== o && this.zoomTo(o, this.zoomPoint, t);
        var h = this.getConstrainedBounds(!1);
        return h.constraintApplied && (this.fitBounds(h, t), this._raiseConstraintsEvent(t)), this;
      },
      /**
       * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
       * @function
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:constrain
       */
      ensureVisible: function(t) {
        return this.applyConstraints(t);
      },
      /**
       * @function
       * @private
       * @param {OpenSeadragon.Rect} bounds
       * @param {Object} options (immediately=false, constraints=false)
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      _fitBounds: function(t, i) {
        i = i || {};
        var o = i.immediately || !1, h = i.constraints || !1, n = this.getAspectRatio(), r = t.getCenter(), s = new e.Rect(
          t.x,
          t.y,
          t.width,
          t.height,
          t.degrees + this.getRotation()
        ).getBoundingBox();
        s.getAspectRatio() >= n ? s.height = s.width / n : s.width = s.height * n, s.x = r.x - s.width / 2, s.y = r.y - s.height / 2;
        var l = 1 / s.width;
        if (o)
          return this.panTo(r, !0), this.zoomTo(l, null, !0), h && this.applyConstraints(!0), this;
        var d = this.getCenter(!0), f = this.getZoom(!0);
        this.panTo(d, !0), this.zoomTo(f, null, !0);
        var v = this.getBounds(), y = this.getZoom();
        if (y === 0 || Math.abs(l / y - 1) < 1e-8)
          return this.zoomTo(l, null, !0), this.panTo(r, o), h && this.applyConstraints(!1), this;
        if (h) {
          this.panTo(r, !1), l = this._applyZoomConstraints(l), this.zoomTo(l, null, !1);
          var T = this.getConstrainedBounds();
          this.panTo(d, !0), this.zoomTo(f, null, !0), this.fitBounds(T);
        } else {
          var w = s.rotate(-this.getRotation()), x = w.getTopLeft().times(l).minus(v.getTopLeft().times(y)).divide(l - y);
          this.zoomTo(l, x, o);
        }
        return this;
      },
      /**
       * Makes the viewport zoom and pan so that the specified bounds take
       * as much space as possible in the viewport.
       * Note: this method ignores the constraints (minZoom, maxZoom and
       * visibilityRatio).
       * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
       * them.
       * @function
       * @param {OpenSeadragon.Rect} bounds
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitBounds: function(t, i) {
        return this._fitBounds(t, {
          immediately: i,
          constraints: !1
        });
      },
      /**
       * Makes the viewport zoom and pan so that the specified bounds take
       * as much space as possible in the viewport while enforcing the constraints
       * (minZoom, maxZoom and visibilityRatio).
       * Note: because this method enforces the constraints, part of the
       * provided bounds may end up outside of the viewport.
       * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
       * @function
       * @param {OpenSeadragon.Rect} bounds
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitBoundsWithConstraints: function(t, i) {
        return this._fitBounds(t, {
          immediately: i,
          constraints: !0
        });
      },
      /**
       * Zooms so the image just fills the viewer vertically.
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitVertically: function(t) {
        var i = new e.Rect(
          this._contentBounds.x + this._contentBounds.width / 2,
          this._contentBounds.y,
          0,
          this._contentBounds.height
        );
        return this.fitBounds(i, t);
      },
      /**
       * Zooms so the image just fills the viewer horizontally.
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      fitHorizontally: function(t) {
        var i = new e.Rect(
          this._contentBounds.x,
          this._contentBounds.y + this._contentBounds.height / 2,
          this._contentBounds.width,
          0
        );
        return this.fitBounds(i, t);
      },
      /**
       * Returns bounds taking constraints into account
       * Added to improve constrained panning
       * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
       * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
       *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
       *                               These flags indicate whether the viewport bounds were modified by the constraints
       *                               of the viewer rectangle, and in which dimension(s).
       */
      getConstrainedBounds: function(t) {
        var i, o;
        return i = this.getBounds(t), o = this._applyBoundaryConstraints(i), o;
      },
      /**
       * @function
       * @param {OpenSeadragon.Point} delta
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:pan
       */
      panBy: function(t, i) {
        var o = new e.Point(
          this.centerSpringX.target.value,
          this.centerSpringY.target.value
        );
        return this.panTo(o.plus(t), i);
      },
      /**
       * @function
       * @param {OpenSeadragon.Point} center
       * @param {Boolean} immediately
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:pan
       */
      panTo: function(t, i) {
        return i ? (this.centerSpringX.resetTo(t.x), this.centerSpringY.resetTo(t.y)) : (this.centerSpringX.springTo(t.x), this.centerSpringY.springTo(t.y)), this.viewer && this.viewer.raiseEvent("pan", {
          center: t,
          immediately: i
        }), this;
      },
      /**
       * @function
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:zoom
       */
      zoomBy: function(t, i, o) {
        return this.zoomTo(
          this.zoomSpring.target.value * t,
          i,
          o
        );
      },
      /**
       * Zooms to the specified zoom level
       * @function
       * @param {Number} zoom The zoom level to zoom to.
       * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
       * the same screen location. Defaults to the viewport center.
       * @param {Boolean} [immediately=false]
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:zoom
       */
      zoomTo: function(t, i, o) {
        var h = this;
        return this.zoomPoint = i instanceof e.Point && !isNaN(i.x) && !isNaN(i.y) ? i : null, o ? this._adjustCenterSpringsForZoomPoint(function() {
          h.zoomSpring.resetTo(t);
        }) : this.zoomSpring.springTo(t), this.viewer && this.viewer.raiseEvent("zoom", {
          zoom: t,
          refPoint: i,
          immediately: o
        }), this;
      },
      /**
       * Rotates this viewport to the angle specified.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * * @returns {OpenSeadragon.Viewport} Chainable.
       */
      setRotation: function(t, i) {
        return this.rotateTo(t, null, i);
      },
      /**
       * Gets the current rotation in degrees.
       * @function
       * @param {Boolean} [current=false] True for current rotation, false for target.
       * @returns {Number} The current rotation in degrees.
       */
      getRotation: function(t) {
        return t ? this.degreesSpring.current.value : this.degreesSpring.target.value;
      },
      /**
       * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
       * around which the rotation should be performed. Defaults to the center of the viewport.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * * @returns {OpenSeadragon.Viewport} Chainable.
       */
      setRotationWithPivot: function(t, i, o) {
        return this.rotateTo(t, i, o);
      },
      /**
       * Rotates this viewport to the angle specified.
       * @function
       * @param {Number} degrees The degrees to set the rotation to.
       * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
       * around which the rotation should be performed. Defaults to the center of the viewport.
       * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      rotateTo: function(t, i, o) {
        if (!this.viewer || !this.viewer.drawer.canRotate())
          return this;
        if (this.degreesSpring.target.value === t && this.degreesSpring.isAtTargetValue())
          return this;
        if (this.rotationPivot = i instanceof e.Point && !isNaN(i.x) && !isNaN(i.y) ? i : null, o)
          if (this.rotationPivot) {
            var h = t - this._oldDegrees;
            if (!h)
              return this.rotationPivot = null, this;
            this._rotateAboutPivot(t);
          } else
            this.degreesSpring.resetTo(t);
        else {
          var n = e.positiveModulo(this.degreesSpring.current.value, 360), r = e.positiveModulo(t, 360), s = r - n;
          s > 180 ? r -= 360 : s < -180 && (r += 360);
          var l = n - r;
          this.degreesSpring.resetTo(t + l), this.degreesSpring.springTo(t);
        }
        return this._setContentBounds(
          this.viewer.world.getHomeBounds(),
          this.viewer.world.getContentFactor()
        ), this.viewer.forceRedraw(), this.viewer.raiseEvent("rotate", { degrees: t, immediately: !!o, pivot: this.rotationPivot || this.getCenter() }), this;
      },
      /**
       * Rotates this viewport by the angle specified.
       * @function
       * @param {Number} degrees The degrees by which to rotate the viewport.
       * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
       * around which the rotation should be performed. Defaults to the center of the viewport.
       * * @param {Boolean} [immediately=false] Whether to animate to the new angle
       * or rotate immediately.
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      rotateBy: function(t, i, o) {
        return this.rotateTo(this.degreesSpring.target.value + t, i, o);
      },
      /**
       * @function
       * @returns {OpenSeadragon.Viewport} Chainable.
       * @fires OpenSeadragon.Viewer.event:resize
       */
      resize: function(t, i) {
        var o = this.getBoundsNoRotate(), h = o, n;
        this.containerSize.x = t.x, this.containerSize.y = t.y, this._updateContainerInnerSize(), i && (n = t.x / this.containerSize.x, h.width = o.width * n, h.height = h.width / this.getAspectRatio()), this.viewer && this.viewer.raiseEvent("resize", {
          newContainerSize: t,
          maintain: i
        });
        var r = this.fitBounds(h, !0);
        return this.viewer && this.viewer.raiseEvent("after-resize", {
          newContainerSize: t,
          maintain: i
        }), r;
      },
      // private
      _updateContainerInnerSize: function() {
        this._containerInnerSize = new e.Point(
          Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
          Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
        );
      },
      /**
       * Update the zoom, degrees, and center (X and Y) springs.
       * @function
       * @returns {Boolean} True if any change has been made, false otherwise.
       */
      update: function() {
        var t = this;
        this._adjustCenterSpringsForZoomPoint(function() {
          t.zoomSpring.update();
        }), this.degreesSpring.isAtTargetValue() && (this.rotationPivot = null), this.centerSpringX.update(), this.centerSpringY.update(), this.rotationPivot ? this._rotateAboutPivot(!0) : this.degreesSpring.update();
        var i = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
        return this._oldCenterX = this.centerSpringX.current.value, this._oldCenterY = this.centerSpringY.current.value, this._oldZoom = this.zoomSpring.current.value, this._oldDegrees = this.degreesSpring.current.value, i;
      },
      // private - pass true to use spring, or a number for degrees for immediate rotation
      _rotateAboutPivot: function(t) {
        var i = t === !0, o = this.rotationPivot.minus(this.getCenter());
        this.centerSpringX.shiftBy(o.x), this.centerSpringY.shiftBy(o.y), i ? this.degreesSpring.update() : this.degreesSpring.resetTo(t);
        var h = this.degreesSpring.current.value - this._oldDegrees, n = o.rotate(h * -1).times(-1);
        this.centerSpringX.shiftBy(n.x), this.centerSpringY.shiftBy(n.y);
      },
      // private
      _adjustCenterSpringsForZoomPoint: function(t) {
        if (this.zoomPoint) {
          var i = this.pixelFromPoint(this.zoomPoint, !0);
          t();
          var o = this.pixelFromPoint(this.zoomPoint, !0), h = o.minus(i), n = this.deltaPointsFromPixels(
            h,
            !0
          );
          this.centerSpringX.shiftBy(n.x), this.centerSpringY.shiftBy(n.y), this.zoomSpring.isAtTargetValue() && (this.zoomPoint = null);
        } else
          t();
      },
      /**
       * Convert a delta (translation vector) from viewport coordinates to pixels
       * coordinates. This method does not take rotation into account.
       * Consider using deltaPixelsFromPoints if you need to account for rotation.
       * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPixelsFromPointsNoRotate: function(t, i) {
        return t.times(
          this._containerInnerSize.x * this.getZoom(i)
        );
      },
      /**
       * Convert a delta (translation vector) from viewport coordinates to pixels
       * coordinates.
       * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPixelsFromPoints: function(t, i) {
        return this.deltaPixelsFromPointsNoRotate(
          t.rotate(this.getRotation(i)),
          i
        );
      },
      /**
       * Convert a delta (translation vector) from pixels coordinates to viewport
       * coordinates. This method does not take rotation into account.
       * Consider using deltaPointsFromPixels if you need to account for rotation.
       * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPointsFromPixelsNoRotate: function(t, i) {
        return t.divide(
          this._containerInnerSize.x * this.getZoom(i)
        );
      },
      /**
       * Convert a delta (translation vector) from pixels coordinates to viewport
       * coordinates.
       * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      deltaPointsFromPixels: function(t, i) {
        return this.deltaPointsFromPixelsNoRotate(t, i).rotate(-this.getRotation(i));
      },
      /**
       * Convert viewport coordinates to pixels coordinates.
       * This method does not take rotation into account.
       * Consider using pixelFromPoint if you need to account for rotation.
       * @param {OpenSeadragon.Point} point the viewport coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pixelFromPointNoRotate: function(t, i) {
        return this._pixelFromPointNoRotate(
          t,
          this.getBoundsNoRotate(i)
        );
      },
      /**
       * Convert viewport coordinates to pixel coordinates.
       * @param {OpenSeadragon.Point} point the viewport coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pixelFromPoint: function(t, i) {
        return this._pixelFromPoint(t, this.getBoundsNoRotate(i));
      },
      // private
      _pixelFromPointNoRotate: function(t, i) {
        return t.minus(
          i.getTopLeft()
        ).times(
          this._containerInnerSize.x / i.width
        ).plus(
          new e.Point(this._margins.left, this._margins.top)
        );
      },
      // private
      _pixelFromPoint: function(t, i) {
        return this._pixelFromPointNoRotate(
          t.rotate(this.getRotation(!0), this.getCenter(!0)),
          i
        );
      },
      /**
       * Convert pixel coordinates to viewport coordinates.
       * This method does not take rotation into account.
       * Consider using pointFromPixel if you need to account for rotation.
       * @param {OpenSeadragon.Point} pixel Pixel coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pointFromPixelNoRotate: function(t, i) {
        var o = this.getBoundsNoRotate(i);
        return t.minus(
          new e.Point(this._margins.left, this._margins.top)
        ).divide(
          this._containerInnerSize.x / o.width
        ).plus(
          o.getTopLeft()
        );
      },
      /**
       * Convert pixel coordinates to viewport coordinates.
       * @param {OpenSeadragon.Point} pixel Pixel coordinates
       * @param {Boolean} [current=false] - Pass true for the current location;
       * defaults to false (target location).
       * @returns {OpenSeadragon.Point}
       */
      pointFromPixel: function(t, i) {
        return this.pointFromPixelNoRotate(t, i).rotate(
          -this.getRotation(i),
          this.getCenter(i)
        );
      },
      // private
      _viewportToImageDelta: function(t, i) {
        var o = this._contentBoundsNoRotate.width;
        return new e.Point(
          t * this._contentSizeNoRotate.x / o,
          i * this._contentSizeNoRotate.x / o
        );
      },
      /**
       * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
       * This method can be called either by passing X,Y coordinates or an
       * OpenSeadragon.Point
       * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
       * @function
       * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
       * coordinate in viewport coordinate system.
       * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
       * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
       */
      viewportToImageCoordinates: function(t, i) {
        if (t instanceof e.Point)
          return this.viewportToImageCoordinates(t.x, t.y);
        if (this.viewer) {
          var o = this.viewer.world.getItemCount();
          if (o > 1)
            this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
          else if (o === 1) {
            var h = this.viewer.world.getItemAt(0);
            return h.viewportToImageCoordinates(t, i, !0);
          }
        }
        return this._viewportToImageDelta(
          t - this._contentBoundsNoRotate.x,
          i - this._contentBoundsNoRotate.y
        );
      },
      // private
      _imageToViewportDelta: function(t, i) {
        var o = this._contentBoundsNoRotate.width;
        return new e.Point(
          t / this._contentSizeNoRotate.x * o,
          i / this._contentSizeNoRotate.x * o
        );
      },
      /**
       * Translates from image coordinate system to OpenSeadragon viewer coordinate system
       * This method can be called either by passing X,Y coordinates or an
       * OpenSeadragon.Point
       * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
       * @function
       * @param {(OpenSeadragon.Point | Number)} imageX the point or the
       * X coordinate in image coordinate system.
       * @param {Number} [imageY] Y coordinate in image coordinate system.
       * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
       */
      imageToViewportCoordinates: function(t, i) {
        if (t instanceof e.Point)
          return this.imageToViewportCoordinates(t.x, t.y);
        if (this.viewer) {
          var o = this.viewer.world.getItemCount();
          if (o > 1)
            this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
          else if (o === 1) {
            var h = this.viewer.world.getItemAt(0);
            return h.imageToViewportCoordinates(t, i, !0);
          }
        }
        var n = this._imageToViewportDelta(t, i);
        return n.x += this._contentBoundsNoRotate.x, n.y += this._contentBoundsNoRotate.y, n;
      },
      /**
       * Translates from a rectangle which describes a portion of the image in
       * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an
       * OpenSeadragon.Rect
       * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
       * @function
       * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
       * coordinate of the top left corner of the rectangle in image coordinate system.
       * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
       * in image coordinate system.
       * @param {Number} [pixelWidth] the width in pixel of the rectangle.
       * @param {Number} [pixelHeight] the height in pixel of the rectangle.
       * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
       */
      imageToViewportRectangle: function(t, i, o, h) {
        var n = t;
        if (n instanceof e.Rect || (n = new e.Rect(t, i, o, h)), this.viewer) {
          var r = this.viewer.world.getItemCount();
          if (r > 1)
            this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
          else if (r === 1) {
            var s = this.viewer.world.getItemAt(0);
            return s.imageToViewportRectangle(
              t,
              i,
              o,
              h,
              !0
            );
          }
        }
        var l = this.imageToViewportCoordinates(n.x, n.y), d = this._imageToViewportDelta(n.width, n.height);
        return new e.Rect(
          l.x,
          l.y,
          d.x,
          d.y,
          n.degrees
        );
      },
      /**
       * Translates from a rectangle which describes a portion of
       * the viewport in point coordinates to image rectangle coordinates.
       * This method can be called either by passing X,Y,width,height or an
       * OpenSeadragon.Rect
       * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
       * @function
       * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
       * the X coordinate of the top left corner of the rectangle in viewport
       * coordinate system.
       * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
       * in viewport coordinate system.
       * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
       * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
       */
      viewportToImageRectangle: function(t, i, o, h) {
        var n = t;
        if (n instanceof e.Rect || (n = new e.Rect(t, i, o, h)), this.viewer) {
          var r = this.viewer.world.getItemCount();
          if (r > 1)
            this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
          else if (r === 1) {
            var s = this.viewer.world.getItemAt(0);
            return s.viewportToImageRectangle(
              t,
              i,
              o,
              h,
              !0
            );
          }
        }
        var l = this.viewportToImageCoordinates(n.x, n.y), d = this._viewportToImageDelta(n.width, n.height);
        return new e.Rect(
          l.x,
          l.y,
          d.x,
          d.y,
          n.degrees
        );
      },
      /**
       * Convert pixel coordinates relative to the viewer element to image
       * coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToImageCoordinates: function(t) {
        var i = this.pointFromPixel(t, !0);
        return this.viewportToImageCoordinates(i);
      },
      /**
       * Convert pixel coordinates relative to the image to
       * viewer element coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToViewerElementCoordinates: function(t) {
        var i = this.imageToViewportCoordinates(t);
        return this.pixelFromPoint(i, !0);
      },
      /**
       * Convert pixel coordinates relative to the window to image coordinates.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToImageCoordinates: function(t) {
        e.console.assert(
          this.viewer,
          "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
        );
        var i = t.minus(
          e.getElementPosition(this.viewer.element)
        );
        return this.viewerElementToImageCoordinates(i);
      },
      /**
       * Convert image coordinates to pixel coordinates relative to the window.
       * Note: not accurate with multi-image.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      imageToWindowCoordinates: function(t) {
        e.console.assert(
          this.viewer,
          "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
        );
        var i = this.imageToViewerElementCoordinates(t);
        return i.plus(
          e.getElementPosition(this.viewer.element)
        );
      },
      /**
       * Convert pixel coordinates relative to the viewer element to viewport
       * coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      viewerElementToViewportCoordinates: function(t) {
        return this.pointFromPixel(t, !0);
      },
      /**
       * Convert viewport coordinates to pixel coordinates relative to the
       * viewer element.
       * @param {OpenSeadragon.Point} point
       * @returns {OpenSeadragon.Point}
       */
      viewportToViewerElementCoordinates: function(t) {
        return this.pixelFromPoint(t, !0);
      },
      /**
       * Convert a rectangle in pixel coordinates relative to the viewer element
       * to viewport coordinates.
       * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
       * @returns {OpenSeadragon.Rect} the converted rectangle
       */
      viewerElementToViewportRectangle: function(t) {
        return e.Rect.fromSummits(
          this.pointFromPixel(t.getTopLeft(), !0),
          this.pointFromPixel(t.getTopRight(), !0),
          this.pointFromPixel(t.getBottomLeft(), !0)
        );
      },
      /**
       * Convert a rectangle in viewport coordinates to pixel coordinates relative
       * to the viewer element.
       * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
       * @returns {OpenSeadragon.Rect} the converted rectangle
       */
      viewportToViewerElementRectangle: function(t) {
        return e.Rect.fromSummits(
          this.pixelFromPoint(t.getTopLeft(), !0),
          this.pixelFromPoint(t.getTopRight(), !0),
          this.pixelFromPoint(t.getBottomLeft(), !0)
        );
      },
      /**
       * Convert pixel coordinates relative to the window to viewport coordinates.
       * @param {OpenSeadragon.Point} pixel
       * @returns {OpenSeadragon.Point}
       */
      windowToViewportCoordinates: function(t) {
        e.console.assert(
          this.viewer,
          "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
        );
        var i = t.minus(
          e.getElementPosition(this.viewer.element)
        );
        return this.viewerElementToViewportCoordinates(i);
      },
      /**
       * Convert viewport coordinates to pixel coordinates relative to the window.
       * @param {OpenSeadragon.Point} point
       * @returns {OpenSeadragon.Point}
       */
      viewportToWindowCoordinates: function(t) {
        e.console.assert(
          this.viewer,
          "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
        );
        var i = this.viewportToViewerElementCoordinates(t);
        return i.plus(
          e.getElementPosition(this.viewer.element)
        );
      },
      /**
       * Convert a viewport zoom to an image zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} viewportZoom The viewport zoom
       * target zoom.
       * @returns {Number} imageZoom The image zoom
       */
      viewportToImageZoom: function(t) {
        if (this.viewer) {
          var i = this.viewer.world.getItemCount();
          if (i > 1)
            this.silenceMultiImageWarnings || e.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
          else if (i === 1) {
            var o = this.viewer.world.getItemAt(0);
            return o.viewportToImageZoom(t);
          }
        }
        var h = this._contentSizeNoRotate.x, n = this._containerInnerSize.x, r = this._contentBoundsNoRotate.width, s = n / h * r;
        return t * s;
      },
      /**
       * Convert an image zoom to a viewport zoom.
       * Image zoom: ratio of the original image size to displayed image size.
       * 1 means original image size, 0.5 half size...
       * Viewport zoom: ratio of the displayed image's width to viewport's width.
       * 1 means identical width, 2 means image's width is twice the viewport's width...
       * Note: not accurate with multi-image.
       * @function
       * @param {Number} imageZoom The image zoom
       * target zoom.
       * @returns {Number} viewportZoom The viewport zoom
       */
      imageToViewportZoom: function(t) {
        if (this.viewer) {
          var i = this.viewer.world.getItemCount();
          if (i > 1)
            this.silenceMultiImageWarnings || e.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
          else if (i === 1) {
            var o = this.viewer.world.getItemAt(0);
            return o.imageToViewportZoom(t);
          }
        }
        var h = this._contentSizeNoRotate.x, n = this._containerInnerSize.x, r = this._contentBoundsNoRotate.width, s = h / n / r;
        return t * s;
      },
      /**
       * Toggles flip state and demands a new drawing on navigator and viewer objects.
       * @function
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      toggleFlip: function() {
        return this.setFlip(!this.getFlip()), this;
      },
      /**
       * Get flip state stored on viewport.
       * @function
       * @returns {Boolean} Flip state.
       */
      getFlip: function() {
        return this.flipped;
      },
      /**
       * Sets flip state according to the state input argument.
       * @function
       * @param {Boolean} state - Flip state to set.
       * @returns {OpenSeadragon.Viewport} Chainable.
       */
      setFlip: function(t) {
        return this.flipped === t ? this : (this.flipped = t, this.viewer.navigator && this.viewer.navigator.setFlip(this.getFlip()), this.viewer.forceRedraw(), this.viewer.raiseEvent("flip", { flipped: t }), this);
      }
    };
  }(D), function(e) {
    e.TiledImage = function(n) {
      var r = this;
      e.console.assert(n.tileCache, "[TiledImage] options.tileCache is required"), e.console.assert(n.drawer, "[TiledImage] options.drawer is required"), e.console.assert(n.viewer, "[TiledImage] options.viewer is required"), e.console.assert(n.imageLoader, "[TiledImage] options.imageLoader is required"), e.console.assert(n.source, "[TiledImage] options.source is required"), e.console.assert(
        !n.clip || n.clip instanceof e.Rect,
        "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
      ), e.EventSource.call(this), this._tileCache = n.tileCache, delete n.tileCache, this._drawer = n.drawer, delete n.drawer, this._imageLoader = n.imageLoader, delete n.imageLoader, n.clip instanceof e.Rect && (this._clip = n.clip.clone()), delete n.clip;
      var s = n.x || 0;
      delete n.x;
      var l = n.y || 0;
      delete n.y, this.normHeight = n.source.dimensions.y / n.source.dimensions.x, this.contentAspectX = n.source.dimensions.x / n.source.dimensions.y;
      var d = 1;
      n.width ? (d = n.width, delete n.width, n.height && (e.console.error("specifying both width and height to a tiledImage is not supported"), delete n.height)) : n.height && (d = n.height / this.normHeight, delete n.height);
      var f = n.fitBounds;
      delete n.fitBounds;
      var v = n.fitBoundsPlacement || D.Placement.CENTER;
      delete n.fitBoundsPlacement;
      var y = n.degrees || 0;
      delete n.degrees;
      var T = n.ajaxHeaders;
      delete n.ajaxHeaders, e.extend(!0, this, {
        //internal state properties
        viewer: null,
        tilesMatrix: {},
        // A '3d' dictionary [level][x][y] --> Tile.
        coverage: {},
        // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
        loadingCoverage: {},
        // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
        lastDrawn: [],
        // An unordered list of Tiles drawn last frame.
        lastResetTime: 0,
        // Last time for which the tiledImage was reset.
        _midDraw: !1,
        // Is the tiledImage currently updating the viewport?
        _needsDraw: !0,
        // Does the tiledImage need to update the viewport again?
        _hasOpaqueTile: !1,
        // Do we have even one fully opaque tile?
        _tilesLoading: 0,
        // The number of pending tile requests.
        //configurable settings
        springStiffness: e.DEFAULT_SETTINGS.springStiffness,
        animationTime: e.DEFAULT_SETTINGS.animationTime,
        minZoomImageRatio: e.DEFAULT_SETTINGS.minZoomImageRatio,
        wrapHorizontal: e.DEFAULT_SETTINGS.wrapHorizontal,
        wrapVertical: e.DEFAULT_SETTINGS.wrapVertical,
        immediateRender: e.DEFAULT_SETTINGS.immediateRender,
        blendTime: e.DEFAULT_SETTINGS.blendTime,
        alwaysBlend: e.DEFAULT_SETTINGS.alwaysBlend,
        minPixelRatio: e.DEFAULT_SETTINGS.minPixelRatio,
        smoothTileEdgesMinZoom: e.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
        iOSDevice: e.DEFAULT_SETTINGS.iOSDevice,
        debugMode: e.DEFAULT_SETTINGS.debugMode,
        crossOriginPolicy: e.DEFAULT_SETTINGS.crossOriginPolicy,
        ajaxWithCredentials: e.DEFAULT_SETTINGS.ajaxWithCredentials,
        placeholderFillStyle: e.DEFAULT_SETTINGS.placeholderFillStyle,
        opacity: e.DEFAULT_SETTINGS.opacity,
        preload: e.DEFAULT_SETTINGS.preload,
        compositeOperation: e.DEFAULT_SETTINGS.compositeOperation,
        subPixelRoundingForTransparency: e.DEFAULT_SETTINGS.subPixelRoundingForTransparency
      }, n), this._preload = this.preload, delete this.preload, this._fullyLoaded = !1, this._xSpring = new e.Spring({
        initial: s,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this._ySpring = new e.Spring({
        initial: l,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this._scaleSpring = new e.Spring({
        initial: d,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this._degreesSpring = new e.Spring({
        initial: y,
        springStiffness: this.springStiffness,
        animationTime: this.animationTime
      }), this._updateForScale(), f && this.fitBounds(f, v, !0), this._drawingHandler = function(w) {
        r.viewer.raiseEvent("tile-drawing", e.extend({
          tiledImage: r
        }, w));
      }, this._ownAjaxHeaders = {}, this.setAjaxHeaders(T, !1);
    }, e.extend(
      e.TiledImage.prototype,
      e.EventSource.prototype,
      /** @lends OpenSeadragon.TiledImage.prototype */
      {
        /**
         * @returns {Boolean} Whether the TiledImage needs to be drawn.
         */
        needsDraw: function() {
          return this._needsDraw;
        },
        /**
         * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
         */
        getFullyLoaded: function() {
          return this._fullyLoaded;
        },
        // private
        _setFullyLoaded: function(n) {
          n !== this._fullyLoaded && (this._fullyLoaded = n, this.raiseEvent("fully-loaded-change", {
            fullyLoaded: this._fullyLoaded
          }));
        },
        /**
         * Clears all tiles and triggers an update on the next call to
         * {@link OpenSeadragon.TiledImage#update}.
         */
        reset: function() {
          this._tileCache.clearTilesFor(this), this.lastResetTime = e.now(), this._needsDraw = !0;
        },
        /**
         * Updates the TiledImage's bounds, animating if needed.
         * @returns {Boolean} Whether the TiledImage animated.
         */
        update: function() {
          var n = this._xSpring.update(), r = this._ySpring.update(), s = this._scaleSpring.update(), l = this._degreesSpring.update();
          return n || r || s || l ? (this._updateForScale(), this._needsDraw = !0, !0) : !1;
        },
        /**
         * Draws the TiledImage to its Drawer.
         */
        draw: function() {
          this.opacity !== 0 || this._preload ? (this._midDraw = !0, this._updateViewport(), this._midDraw = !1) : this._needsDraw = !1;
        },
        /**
         * Destroy the TiledImage (unload current loaded tiles).
         */
        destroy: function() {
          this.reset(), this.source.destroy && this.source.destroy();
        },
        /**
         * Get this TiledImage's bounds in viewport coordinates.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * false for target location.
         * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
         */
        getBounds: function(n) {
          return this.getBoundsNoRotate(n).rotate(this.getRotation(n), this._getRotationPoint(n));
        },
        /**
         * Get this TiledImage's bounds in viewport coordinates without taking
         * rotation into account.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * false for target location.
         * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
         */
        getBoundsNoRotate: function(n) {
          return n ? new e.Rect(
            this._xSpring.current.value,
            this._ySpring.current.value,
            this._worldWidthCurrent,
            this._worldHeightCurrent
          ) : new e.Rect(
            this._xSpring.target.value,
            this._ySpring.target.value,
            this._worldWidthTarget,
            this._worldHeightTarget
          );
        },
        // deprecated
        getWorldBounds: function() {
          return e.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead"), this.getBounds();
        },
        /**
         * Get the bounds of the displayed part of the tiled image.
         * @param {Boolean} [current=false] Pass true for the current location,
         * false for the target location.
         * @returns {$.Rect} The clipped bounds in viewport coordinates.
         */
        getClippedBounds: function(n) {
          var r = this.getBoundsNoRotate(n);
          if (this._clip) {
            var s = n ? this._worldWidthCurrent : this._worldWidthTarget, l = s / this.source.dimensions.x, d = this._clip.times(l);
            r = new e.Rect(
              r.x + d.x,
              r.y + d.y,
              d.width,
              d.height
            );
          }
          return r.rotate(this.getRotation(n), this._getRotationPoint(n));
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
         */
        getTileBounds: function(n, r, s) {
          var l = this.source.getNumTiles(n), d = (l.x + r % l.x) % l.x, f = (l.y + s % l.y) % l.y, v = this.source.getTileBounds(n, d, f);
          return this.getFlip() && (v.x = 1 - v.x - v.width), v.x += (r - d) / l.x, v.y += this._worldHeightCurrent / this._worldWidthCurrent * ((s - f) / l.y), v;
        },
        /**
         * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
         */
        getContentSize: function() {
          return new e.Point(this.source.dimensions.x, this.source.dimensions.y);
        },
        /**
         * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
         */
        getSizeInWindowCoordinates: function() {
          var n = this.imageToWindowCoordinates(new e.Point(0, 0)), r = this.imageToWindowCoordinates(this.getContentSize());
          return new e.Point(r.x - n.x, r.y - n.y);
        },
        // private
        _viewportToImageDelta: function(n, r, s) {
          var l = s ? this._scaleSpring.current.value : this._scaleSpring.target.value;
          return new e.Point(
            n * (this.source.dimensions.x / l),
            r * (this.source.dimensions.y * this.contentAspectX / l)
          );
        },
        /**
         * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
         * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
         * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
         * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
         */
        viewportToImageCoordinates: function(n, r, s) {
          var l;
          return n instanceof e.Point ? (s = r, l = n) : l = new e.Point(n, r), l = l.rotate(-this.getRotation(s), this._getRotationPoint(s)), s ? this._viewportToImageDelta(
            l.x - this._xSpring.current.value,
            l.y - this._ySpring.current.value
          ) : this._viewportToImageDelta(
            l.x - this._xSpring.target.value,
            l.y - this._ySpring.target.value
          );
        },
        // private
        _imageToViewportDelta: function(n, r, s) {
          var l = s ? this._scaleSpring.current.value : this._scaleSpring.target.value;
          return new e.Point(
            n / this.source.dimensions.x * l,
            r / this.source.dimensions.y / this.contentAspectX * l
          );
        },
        /**
         * Translates from image coordinate system to OpenSeadragon viewer coordinate system
         * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
         * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
         * @param {Number} [imageY] - The Y coordinate in image coordinate system.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
         */
        imageToViewportCoordinates: function(n, r, s) {
          n instanceof e.Point && (s = r, r = n.y, n = n.x);
          var l = this._imageToViewportDelta(n, r);
          return s ? (l.x += this._xSpring.current.value, l.y += this._ySpring.current.value) : (l.x += this._xSpring.target.value, l.y += this._ySpring.target.value), l.rotate(this.getRotation(s), this._getRotationPoint(s));
        },
        /**
         * Translates from a rectangle which describes a portion of the image in
         * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
         * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
         * @param {Number} [imageY] - The top coordinate in image coordinate system.
         * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
         * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
         */
        imageToViewportRectangle: function(n, r, s, l, d) {
          var f = n;
          f instanceof e.Rect ? d = r : f = new e.Rect(n, r, s, l);
          var v = this.imageToViewportCoordinates(f.getTopLeft(), d), y = this._imageToViewportDelta(f.width, f.height, d);
          return new e.Rect(
            v.x,
            v.y,
            y.x,
            y.y,
            f.degrees + this.getRotation(d)
          );
        },
        /**
         * Translates from a rectangle which describes a portion of
         * the viewport in point coordinates to image rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
         * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
         * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
         * @param {Number} [pointWidth] - The width in viewport coordinate system.
         * @param {Number} [pointHeight] - The height in viewport coordinate system.
         * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
         * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
         */
        viewportToImageRectangle: function(n, r, s, l, d) {
          var f = n;
          n instanceof e.Rect ? d = r : f = new e.Rect(n, r, s, l);
          var v = this.viewportToImageCoordinates(f.getTopLeft(), d), y = this._viewportToImageDelta(f.width, f.height, d);
          return new e.Rect(
            v.x,
            v.y,
            y.x,
            y.y,
            f.degrees - this.getRotation(d)
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to image
         * coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToImageCoordinates: function(n) {
          var r = this.viewport.pointFromPixel(n, !0);
          return this.viewportToImageCoordinates(r);
        },
        /**
         * Convert pixel coordinates relative to the image to
         * viewer element coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToViewerElementCoordinates: function(n) {
          var r = this.imageToViewportCoordinates(n);
          return this.viewport.pixelFromPoint(r, !0);
        },
        /**
         * Convert pixel coordinates relative to the window to image coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToImageCoordinates: function(n) {
          var r = n.minus(
            D.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToImageCoordinates(r);
        },
        /**
         * Convert image coordinates to pixel coordinates relative to the window.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToWindowCoordinates: function(n) {
          var r = this.imageToViewerElementCoordinates(n);
          return r.plus(
            D.getElementPosition(this.viewer.element)
          );
        },
        // private
        // Convert rectangle in viewport coordinates to this tiled image point
        // coordinates (x in [0, 1] and y in [0, aspectRatio])
        _viewportToTiledImageRectangle: function(n) {
          var r = this._scaleSpring.current.value;
          return n = n.rotate(-this.getRotation(!0), this._getRotationPoint(!0)), new e.Rect(
            (n.x - this._xSpring.current.value) / r,
            (n.y - this._ySpring.current.value) / r,
            n.width / r,
            n.height / r,
            n.degrees
          );
        },
        /**
         * Convert a viewport zoom to an image zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * @function
         * @param {Number} viewportZoom The viewport zoom
         * @returns {Number} imageZoom The image zoom
         */
        viewportToImageZoom: function(n) {
          var r = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
          return r * n;
        },
        /**
         * Convert an image zoom to a viewport zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} imageZoom The image zoom
         * @returns {Number} viewportZoom The viewport zoom
         */
        imageToViewportZoom: function(n) {
          var r = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
          return n / r;
        },
        /**
         * Sets the TiledImage's position in the world.
         * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
         * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setPosition: function(n, r) {
          var s = this._xSpring.target.value === n.x && this._ySpring.target.value === n.y;
          if (r) {
            if (s && this._xSpring.current.value === n.x && this._ySpring.current.value === n.y)
              return;
            this._xSpring.resetTo(n.x), this._ySpring.resetTo(n.y), this._needsDraw = !0;
          } else {
            if (s)
              return;
            this._xSpring.springTo(n.x), this._ySpring.springTo(n.y), this._needsDraw = !0;
          }
          s || this._raiseBoundsChange();
        },
        /**
         * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
         * @param {Number} width - The new width, in viewport coordinates.
         * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setWidth: function(n, r) {
          this._setScale(n, r);
        },
        /**
         * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
         * @param {Number} height - The new height, in viewport coordinates.
         * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setHeight: function(n, r) {
          this._setScale(n / this.normHeight, r);
        },
        /**
         * Sets an array of polygons to crop the TiledImage during draw tiles.
         * The render function will use the default non-zero winding rule.
         * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
         * Example format: [
         *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
         *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
         *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
         * ]
         */
        setCroppingPolygons: function(n) {
          var r = function(l) {
            return l instanceof e.Point || typeof l.x == "number" && typeof l.y == "number";
          }, s = function(l) {
            return l.map(function(d) {
              try {
                if (r(d))
                  return { x: d.x, y: d.y };
                throw new Error();
              } catch {
                throw new Error("A Provided cropping polygon point is not supported");
              }
            });
          };
          try {
            if (!e.isArray(n))
              throw new Error("Provided cropping polygon is not an array");
            this._croppingPolygons = n.map(function(l) {
              return s(l);
            });
          } catch (l) {
            e.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported"), e.console.error(l), this._croppingPolygons = null;
          }
        },
        /**
         * Resets the cropping polygons, thus next render will remove all cropping
         * polygon effects.
         */
        resetCroppingPolygons: function() {
          this._croppingPolygons = null;
        },
        /**
         * Positions and scales the TiledImage to fit in the specified bounds.
         * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
         * twice
         * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
         * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
         * How to anchor the image in the bounds.
         * @param {Boolean} [immediately=false] Whether to animate to the new size
         * or snap immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        fitBounds: function(n, r, s) {
          r = r || e.Placement.CENTER;
          var l = e.Placement.properties[r], d = this.contentAspectX, f = 0, v = 0, y = 1, T = 1;
          if (this._clip && (d = this._clip.getAspectRatio(), y = this._clip.width / this.source.dimensions.x, T = this._clip.height / this.source.dimensions.y, n.getAspectRatio() > d ? (f = this._clip.x / this._clip.height * n.height, v = this._clip.y / this._clip.height * n.height) : (f = this._clip.x / this._clip.width * n.width, v = this._clip.y / this._clip.width * n.width)), n.getAspectRatio() > d) {
            var w = n.height / T, x = 0;
            l.isHorizontallyCentered ? x = (n.width - n.height * d) / 2 : l.isRight && (x = n.width - n.height * d), this.setPosition(
              new e.Point(n.x - f + x, n.y - v),
              s
            ), this.setHeight(w, s);
          } else {
            var P = n.width / y, C = 0;
            l.isVerticallyCentered ? C = (n.height - n.width / d) / 2 : l.isBottom && (C = n.height - n.width / d), this.setPosition(
              new e.Point(n.x - f, n.y - v + C),
              s
            ), this.setWidth(P, s);
          }
        },
        /**
         * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
         * in image pixels, or null if none.
         */
        getClip: function() {
          return this._clip ? this._clip.clone() : null;
        },
        /**
         * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
         * (portions of the image outside of this area will not be visible). Only works on
         * browsers that support the HTML5 canvas.
         * @fires OpenSeadragon.TiledImage.event:clip-change
         */
        setClip: function(n) {
          e.console.assert(
            !n || n instanceof e.Rect,
            "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
          ), n instanceof e.Rect ? this._clip = n.clone() : this._clip = null, this._needsDraw = !0, this.raiseEvent("clip-change");
        },
        /**
         * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
         */
        getFlip: function() {
          return !!this.flipped;
        },
        /**
         * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setFlip: function(n) {
          this.flipped = !!n, this._needsDraw = !0, this._raiseBoundsChange();
        },
        /**
         * @returns {Number} The TiledImage's current opacity.
         */
        getOpacity: function() {
          return this.opacity;
        },
        /**
         * @param {Number} opacity Opacity the tiled image should be drawn at.
         * @fires OpenSeadragon.TiledImage.event:opacity-change
         */
        setOpacity: function(n) {
          n !== this.opacity && (this.opacity = n, this._needsDraw = !0, this.raiseEvent("opacity-change", {
            opacity: this.opacity
          }));
        },
        /**
         * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
         */
        getPreload: function() {
          return this._preload;
        },
        /**
         * Set true to load even when hidden. Set false to block loading when hidden.
         */
        setPreload: function(n) {
          this._preload = !!n, this._needsDraw = !0;
        },
        /**
         * Get the rotation of this tiled image in degrees.
         * @param {Boolean} [current=false] True for current rotation, false for target.
         * @returns {Number} the rotation of this tiled image in degrees.
         */
        getRotation: function(n) {
          return n ? this._degreesSpring.current.value : this._degreesSpring.target.value;
        },
        /**
         * Set the current rotation of this tiled image in degrees.
         * @param {Number} degrees the rotation in degrees.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @fires OpenSeadragon.TiledImage.event:bounds-change
         */
        setRotation: function(n, r) {
          this._degreesSpring.target.value === n && this._degreesSpring.isAtTargetValue() || (r ? this._degreesSpring.resetTo(n) : this._degreesSpring.springTo(n), this._needsDraw = !0, this._raiseBoundsChange());
        },
        /**
         * Get the point around which this tiled image is rotated
         * @private
         * @param {Boolean} current True for current rotation point, false for target.
         * @returns {OpenSeadragon.Point}
         */
        _getRotationPoint: function(n) {
          return this.getBoundsNoRotate(n).getCenter();
        },
        /**
         * @returns {String} The TiledImage's current compositeOperation.
         */
        getCompositeOperation: function() {
          return this.compositeOperation;
        },
        /**
         * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
         * @fires OpenSeadragon.TiledImage.event:composite-operation-change
         */
        setCompositeOperation: function(n) {
          n !== this.compositeOperation && (this.compositeOperation = n, this._needsDraw = !0, this.raiseEvent("composite-operation-change", {
            compositeOperation: this.compositeOperation
          }));
        },
        /**
         * Update headers to include when making AJAX requests.
         *
         * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
         * the updated headers are propagated to all tiles and queued image loader jobs.
         *
         * Note that the rules for merging headers still apply, i.e. headers returned by
         * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
         * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
         *
         * @function
         * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
         * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
         */
        setAjaxHeaders: function(n, r) {
          if (n === null && (n = {}), !e.isPlainObject(n)) {
            console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
            return;
          }
          this._ownAjaxHeaders = n, this._updateAjaxHeaders(r);
        },
        /**
         * Update headers to include when making AJAX requests.
         *
         * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
         * except that the headers for this tiled image do not change. This is especially useful
         * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
         * to existing tiles.
         *
         * @private
         * @function
         * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
         */
        _updateAjaxHeaders: function(n) {
          if (n === void 0 && (n = !0), e.isPlainObject(this.viewer.ajaxHeaders) ? this.ajaxHeaders = e.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders) : this.ajaxHeaders = this._ownAjaxHeaders, n) {
            var r, s, l, d;
            for (var f in this.tilesMatrix) {
              r = this.source.getNumTiles(f);
              for (var v in this.tilesMatrix[f]) {
                s = (r.x + v % r.x) % r.x;
                for (var y in this.tilesMatrix[f][v])
                  if (l = (r.y + y % r.y) % r.y, d = this.tilesMatrix[f][v][y], d.loadWithAjax = this.loadTilesWithAjax, d.loadWithAjax) {
                    var T = this.source.getTileAjaxHeaders(f, s, l);
                    d.ajaxHeaders = e.extend({}, this.ajaxHeaders, T);
                  } else
                    d.ajaxHeaders = null;
              }
            }
            for (var w = 0; w < this._imageLoader.jobQueue.length; w++) {
              var x = this._imageLoader.jobQueue[w];
              x.loadWithAjax = x.tile.loadWithAjax, x.ajaxHeaders = x.tile.loadWithAjax ? x.tile.ajaxHeaders : null;
            }
          }
        },
        // private
        _setScale: function(n, r) {
          var s = this._scaleSpring.target.value === n;
          if (r) {
            if (s && this._scaleSpring.current.value === n)
              return;
            this._scaleSpring.resetTo(n), this._updateForScale(), this._needsDraw = !0;
          } else {
            if (s)
              return;
            this._scaleSpring.springTo(n), this._updateForScale(), this._needsDraw = !0;
          }
          s || this._raiseBoundsChange();
        },
        // private
        _updateForScale: function() {
          this._worldWidthTarget = this._scaleSpring.target.value, this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value, this._worldWidthCurrent = this._scaleSpring.current.value, this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
        },
        // private
        _raiseBoundsChange: function() {
          this.raiseEvent("bounds-change");
        },
        // private
        _isBottomItem: function() {
          return this.viewer.world.getItemAt(0) === this;
        },
        // private
        _getLevelsInterval: function() {
          var n = Math.max(
            this.source.minLevel,
            Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
          ), r = this.viewport.deltaPixelsFromPointsNoRotate(
            this.source.getPixelRatio(0),
            !0
          ).x * this._scaleSpring.current.value, s = Math.min(
            Math.abs(this.source.maxLevel),
            Math.abs(Math.floor(
              Math.log(r / this.minPixelRatio) / Math.log(2)
            ))
          );
          return s = Math.max(s, this.source.minLevel || 0), n = Math.min(n, s), {
            lowestLevel: n,
            highestLevel: s
          };
        },
        /**
         * @private
         * @inner
         * Pretty much every other line in this needs to be documented so it's clear
         * how each piece of this routine contributes to the drawing process.  That's
         * why there are so many TODO's inside this function.
         */
        _updateViewport: function() {
          for (this._needsDraw = !1, this._tilesLoading = 0, this.loadingCoverage = {}; this.lastDrawn.length > 0; ) {
            var n = this.lastDrawn.pop();
            n.beingDrawn = !1;
          }
          var r = this.viewport, s = this._viewportToTiledImageRectangle(
            r.getBoundsWithMargins(!0)
          );
          if (!this.wrapHorizontal && !this.wrapVertical) {
            var l = this._viewportToTiledImageRectangle(
              this.getClippedBounds(!0)
            );
            if (s = s.intersection(l), s === null)
              return;
          }
          for (var d = this._getLevelsInterval(), f = d.lowestLevel, v = d.highestLevel, y = null, T = !1, w = e.now(), x = v; x >= f; x--) {
            var P = !1, C = r.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(x),
              !0
            ).x * this._scaleSpring.current.value;
            if (x === f || !T && C >= this.minPixelRatio)
              P = !0, T = !0;
            else if (!T)
              continue;
            var A = r.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(x),
              !1
            ).x * this._scaleSpring.current.value, W = r.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(
                Math.max(
                  this.source.getClosestLevel(),
                  0
                )
              ),
              !1
            ).x * this._scaleSpring.current.value, k = this.immediateRender ? 1 : W, U = Math.min(1, (C - 0.5) / 0.5), H = k / Math.abs(
              k - A
            );
            if (y = this._updateLevel(
              T,
              P,
              x,
              U,
              H,
              s,
              w,
              y
            ), this._providesCoverage(this.coverage, x))
              break;
          }
          this._drawTiles(this.lastDrawn), y && !y.context2D ? (this._loadTile(y, w), this._needsDraw = !0, this._setFullyLoaded(!1)) : this._setFullyLoaded(this._tilesLoading === 0);
        },
        // private
        _getCornerTiles: function(n, r, s) {
          var l, d;
          this.wrapHorizontal ? (l = e.positiveModulo(r.x, 1), d = e.positiveModulo(s.x, 1)) : (l = Math.max(0, r.x), d = Math.min(1, s.x));
          var f, v, y = 1 / this.source.aspectRatio;
          this.wrapVertical ? (f = e.positiveModulo(r.y, y), v = e.positiveModulo(s.y, y)) : (f = Math.max(0, r.y), v = Math.min(y, s.y));
          var T = this.source.getTileAtPoint(n, new e.Point(l, f)), w = this.source.getTileAtPoint(n, new e.Point(d, v)), x = this.source.getNumTiles(n);
          return this.wrapHorizontal && (T.x += x.x * Math.floor(r.x), w.x += x.x * Math.floor(s.x)), this.wrapVertical && (T.y += x.y * Math.floor(r.y / y), w.y += x.y * Math.floor(s.y / y)), {
            topLeft: T,
            bottomRight: w
          };
        },
        /**
         * Updates all tiles at a given resolution level.
         * @private
         * @param {Boolean} haveDrawn
         * @param {Boolean} drawLevel
         * @param {Number} level
         * @param {Number} levelOpacity
         * @param {Number} levelVisibility
         * @param {OpenSeadragon.Rect} drawArea
         * @param {Number} currentTime
         * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
         */
        _updateLevel: function(n, r, s, l, d, f, v, y) {
          var T = f.getBoundingBox().getTopLeft(), w = f.getBoundingBox().getBottomRight();
          this.viewer && this.viewer.raiseEvent("update-level", {
            tiledImage: this,
            havedrawn: n,
            level: s,
            opacity: l,
            visibility: d,
            drawArea: f,
            topleft: T,
            bottomright: w,
            currenttime: v,
            best: y
          }), this._resetCoverage(this.coverage, s), this._resetCoverage(this.loadingCoverage, s);
          var x = this._getCornerTiles(s, T, w), P = x.topLeft, C = x.bottomRight, A = this.source.getNumTiles(s), W = this.viewport.pixelFromPoint(this.viewport.getCenter());
          this.getFlip() && (C.x += 1, this.wrapHorizontal || (C.x = Math.min(C.x, A.x - 1)));
          for (var k = P.x; k <= C.x; k++)
            for (var U = P.y; U <= C.y; U++) {
              var H;
              if (this.getFlip()) {
                var M = (A.x + k % A.x) % A.x;
                H = k + A.x - M - M - 1;
              } else
                H = k;
              f.intersection(this.getTileBounds(s, H, U)) !== null && (y = this._updateTile(
                r,
                n,
                H,
                U,
                s,
                l,
                d,
                W,
                A,
                v,
                y
              ));
            }
          return y;
        },
        /**
         * @private
         * @inner
         * Update a single tile at a particular resolution level.
         * @param {Boolean} haveDrawn
         * @param {Boolean} drawLevel
         * @param {Number} x
         * @param {Number} y
         * @param {Number} level
         * @param {Number} levelOpacity
         * @param {Number} levelVisibility
         * @param {OpenSeadragon.Point} viewportCenter
         * @param {Number} numberOfTiles
         * @param {Number} currentTime
         * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
         */
        _updateTile: function(n, r, s, l, d, f, v, y, T, w, x) {
          var P = this._getTile(
            s,
            l,
            d,
            w,
            T,
            this._worldWidthCurrent,
            this._worldHeightCurrent
          ), C = r;
          this.viewer && this.viewer.raiseEvent("update-tile", {
            tiledImage: this,
            tile: P
          }), this._setCoverage(this.coverage, d, s, l, !1);
          var A = P.loaded || P.loading || this._isCovered(this.loadingCoverage, d, s, l);
          if (this._setCoverage(this.loadingCoverage, d, s, l, A), !P.exists || (n && !C && (this._isCovered(this.coverage, d, s, l) ? this._setCoverage(this.coverage, d, s, l, !0) : C = !0), !C))
            return x;
          if (this._positionTile(
            P,
            this.source.tileOverlap,
            this.viewport,
            y,
            v
          ), !P.loaded)
            if (P.context2D)
              this._setTileLoaded(P);
            else {
              var W = this._tileCache.getImageRecord(P.cacheKey);
              W && this._setTileLoaded(P, W.getData());
            }
          if (P.loaded) {
            var k = this._blendTile(
              P,
              s,
              l,
              d,
              f,
              w
            );
            k && (this._needsDraw = !0);
          } else
            P.loading ? this._tilesLoading++ : A || (x = this._compareTiles(x, P));
          return x;
        },
        /**
         * @private
         * @inner
         * Obtains a tile at the given location.
         * @param {Number} x
         * @param {Number} y
         * @param {Number} level
         * @param {Number} time
         * @param {Number} numTiles
         * @param {Number} worldWidth
         * @param {Number} worldHeight
         * @returns {OpenSeadragon.Tile}
         */
        _getTile: function(n, r, s, l, d, f, v) {
          var y, T, w, x, P, C, A, W, k, U, H = this.tilesMatrix, M = this.source;
          return H[s] || (H[s] = {}), H[s][n] || (H[s][n] = {}), (!H[s][n][r] || !H[s][n][r].flipped != !this.flipped) && (y = (d.x + n % d.x) % d.x, T = (d.y + r % d.y) % d.y, w = this.getTileBounds(s, n, r), x = M.getTileBounds(s, y, T, !0), P = M.tileExists(s, y, T), C = M.getTileUrl(s, y, T), A = M.getTilePostData(s, y, T), this.loadTilesWithAjax ? (W = M.getTileAjaxHeaders(s, y, T), e.isPlainObject(this.ajaxHeaders) && (W = e.extend({}, this.ajaxHeaders, W))) : W = null, k = M.getContext2D ? M.getContext2D(s, y, T) : void 0, U = new e.Tile(
            s,
            n,
            r,
            w,
            P,
            C,
            k,
            this.loadTilesWithAjax,
            W,
            x,
            A,
            M.getTileHashKey(s, y, T, C, W, A)
          ), this.getFlip() ? y === 0 && (U.isRightMost = !0) : y === d.x - 1 && (U.isRightMost = !0), T === d.y - 1 && (U.isBottomMost = !0), U.flipped = this.flipped, H[s][n][r] = U), U = H[s][n][r], U.lastTouchTime = l, U;
        },
        /**
         * @private
         * @inner
         * Dispatch a job to the ImageLoader to load the Image for a Tile.
         * @param {OpenSeadragon.Tile} tile
         * @param {Number} time
         */
        _loadTile: function(n, r) {
          var s = this;
          n.loading = !0, this._imageLoader.addJob({
            src: n.getUrl(),
            tile: n,
            source: this.source,
            postData: n.postData,
            loadWithAjax: n.loadWithAjax,
            ajaxHeaders: n.ajaxHeaders,
            crossOriginPolicy: this.crossOriginPolicy,
            ajaxWithCredentials: this.ajaxWithCredentials,
            callback: function(l, d, f) {
              s._onTileLoad(n, r, l, d, f);
            },
            abort: function() {
              n.loading = !1;
            }
          });
        },
        /**
         * @private
         * @inner
         * Callback fired when a Tile's Image finished downloading.
         * @param {OpenSeadragon.Tile} tile
         * @param {Number} time
         * @param {*} data image data
         * @param {String} errorMsg
         * @param {XMLHttpRequest} tileRequest
         */
        _onTileLoad: function(n, r, s, l, d) {
          if (s)
            n.exists = !0;
          else {
            e.console.error("Tile %s failed to load: %s - error: %s", n, n.getUrl(), l), this.viewer.raiseEvent("tile-load-failed", {
              tile: n,
              tiledImage: this,
              time: r,
              message: l,
              tileRequest: d
            }), n.loading = !1, n.exists = !1;
            return;
          }
          if (r < this.lastResetTime) {
            e.console.warn("Ignoring tile %s loaded before reset: %s", n, n.getUrl()), n.loading = !1;
            return;
          }
          var f = this, v = function() {
            var y = f.source, T = y.getClosestLevel();
            f._setTileLoaded(n, s, T, d);
          };
          this._midDraw ? window.setTimeout(v, 1) : v();
        },
        /**
         * @private
         * @inner
         * @param {OpenSeadragon.Tile} tile
         * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
         * @param {Number|undefined} cutoff
         * @param {XMLHttpRequest|undefined} tileRequest
         */
        _setTileLoaded: function(n, r, s, l) {
          var d = 0, f = !1, v = this;
          function y() {
            return f && e.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. Its return value should be called asynchronously."), d++, T;
          }
          function T() {
            d--, d === 0 && (n.loading = !1, n.loaded = !0, n.hasTransparency = v.source.hasTransparency(
              n.context2D,
              n.getUrl(),
              n.ajaxHeaders,
              n.postData
            ), n.context2D || v._tileCache.cacheTile({
              data: r,
              tile: n,
              cutoff: s,
              tiledImage: v
            }), v._needsDraw = !0);
          }
          var w = y();
          this.viewer.raiseEvent("tile-loaded", {
            tile: n,
            tiledImage: this,
            tileRequest: l,
            get image() {
              return e.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead."), r;
            },
            data: r,
            getCompletionCallback: y
          }), f = !0, w();
        },
        /**
         * @private
         * @inner
         * @param {OpenSeadragon.Tile} tile
         * @param {Boolean} overlap
         * @param {OpenSeadragon.Viewport} viewport
         * @param {OpenSeadragon.Point} viewportCenter
         * @param {Number} levelVisibility
         */
        _positionTile: function(n, r, s, l, d) {
          var f = n.bounds.getTopLeft();
          f.x *= this._scaleSpring.current.value, f.y *= this._scaleSpring.current.value, f.x += this._xSpring.current.value, f.y += this._ySpring.current.value;
          var v = n.bounds.getSize();
          v.x *= this._scaleSpring.current.value, v.y *= this._scaleSpring.current.value;
          var y = s.pixelFromPointNoRotate(f, !0), T = s.pixelFromPointNoRotate(f, !1), w = s.deltaPixelsFromPointsNoRotate(v, !0), x = s.deltaPixelsFromPointsNoRotate(v, !1), P = T.plus(x.divide(2)), C = l.squaredDistanceTo(P);
          r || (w = w.plus(new e.Point(1, 1))), n.isRightMost && this.wrapHorizontal && (w.x += 0.75), n.isBottomMost && this.wrapVertical && (w.y += 0.75), n.position = y, n.size = w, n.squaredDistance = C, n.visibility = d;
        },
        /**
         * @private
         * @inner
         * Updates the opacity of a tile according to the time it has been on screen
         * to perform a fade-in.
         * Updates coverage once a tile is fully opaque.
         * Returns whether the fade-in has completed.
         *
         * @param {OpenSeadragon.Tile} tile
         * @param {Number} x
         * @param {Number} y
         * @param {Number} level
         * @param {Number} levelOpacity
         * @param {Number} currentTime
         * @returns {Boolean}
         */
        _blendTile: function(n, r, s, l, d, f) {
          var v = 1e3 * this.blendTime, y, T;
          if (n.blendStart || (n.blendStart = f), y = f - n.blendStart, T = v ? Math.min(1, y / v) : 1, this.alwaysBlend && (T *= d), n.opacity = T, this.lastDrawn.push(n), T === 1)
            this._setCoverage(this.coverage, l, r, s, !0), this._hasOpaqueTile = !0;
          else if (y < v)
            return !0;
          return !1;
        },
        /**
         * @private
         * @inner
         * Determines whether the 'last best' tile for the area is better than the
         * tile in question.
         *
         * @param {OpenSeadragon.Tile} previousBest
         * @param {OpenSeadragon.Tile} tile
         * @returns {OpenSeadragon.Tile} The new best tile.
         */
        _compareTiles: function(n, r) {
          return !n || r.visibility > n.visibility || r.visibility === n.visibility && r.squaredDistance < n.squaredDistance ? r : n;
        },
        /**
         * @private
         * @inner
         * Draws a TiledImage.
         * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
         */
        _drawTiles: function(n) {
          if (!(this.opacity === 0 || n.length === 0 && !this.placeholderFillStyle)) {
            var r = n[0], s;
            r && (s = this.opacity < 1 || this.compositeOperation && this.compositeOperation !== "source-over" || !this._isBottomItem() && this.source.hasTransparency(r.context2D, r.getUrl(), r.ajaxHeaders, r.postData));
            var l, d, f = this.viewport.getZoom(!0), v = this.viewportToImageZoom(f);
            n.length > 1 && v > this.smoothTileEdgesMinZoom && !this.iOSDevice && this.getRotation(!0) % 360 === 0 && // TODO: support tile edge smoothing with tiled image rotation.
            e.supportsCanvas && this.viewer.useCanvas && (s = !0, l = r.getScaleForEdgeSmoothing(), d = r.getTranslationForEdgeSmoothing(
              l,
              this._drawer.getCanvasSize(!1),
              this._drawer.getCanvasSize(!0)
            ));
            var y;
            s && (l || (y = this.viewport.viewportToViewerElementRectangle(
              this.getClippedBounds(!0)
            ).getIntegerBoundingBox(), this._drawer.viewer.viewport.getFlip() && (this.viewport.getRotation(!0) % 360 !== 0 || this.getRotation(!0) % 360 !== 0) && (y.x = this._drawer.viewer.container.clientWidth - (y.x + y.width)), y = y.times(e.pixelDensityRatio)), this._drawer._clear(!0, y)), l || (this.viewport.getRotation(!0) % 360 !== 0 && this._drawer._offsetForRotation({
              degrees: this.viewport.getRotation(!0),
              useSketch: s
            }), this.getRotation(!0) % 360 !== 0 && this._drawer._offsetForRotation({
              degrees: this.getRotation(!0),
              point: this.viewport.pixelFromPointNoRotate(
                this._getRotationPoint(!0),
                !0
              ),
              useSketch: s
            }), this.viewport.getRotation(!0) % 360 === 0 && this.getRotation(!0) % 360 === 0 && this._drawer.viewer.viewport.getFlip() && this._drawer._flip());
            var T = !1;
            if (this._clip) {
              this._drawer.saveContext(s);
              var w = this.imageToViewportRectangle(this._clip, !0);
              w = w.rotate(-this.getRotation(!0), this._getRotationPoint(!0));
              var x = this._drawer.viewportToDrawerRectangle(w);
              l && (x = x.times(l)), d && (x = x.translate(d)), this._drawer.setClip(x, s), T = !0;
            }
            if (this._croppingPolygons) {
              var P = this;
              this._drawer.saveContext(s);
              try {
                var C = this._croppingPolygons.map(function(X) {
                  return X.map(function(Z) {
                    var Y = P.imageToViewportCoordinates(Z.x, Z.y, !0).rotate(-P.getRotation(!0), P._getRotationPoint(!0)), $ = P._drawer.viewportCoordToDrawerCoord(Y);
                    return l && ($ = $.times(l)), d && ($ = $.plus(d)), $;
                  });
                });
                this._drawer.clipWithPolygons(C, s);
              } catch (X) {
                e.console.error(X);
              }
              T = !0;
            }
            if (this.placeholderFillStyle && this._hasOpaqueTile === !1) {
              var A = this._drawer.viewportToDrawerRectangle(this.getBounds(!0));
              l && (A = A.times(l)), d && (A = A.translate(d));
              var W = null;
              typeof this.placeholderFillStyle == "function" ? W = this.placeholderFillStyle(this, this._drawer.context) : W = this.placeholderFillStyle, this._drawer.drawRectangle(A, W, s);
            }
            var k = h(this.subPixelRoundingForTransparency), U = !1;
            if (k === e.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS)
              U = !0;
            else if (k === e.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
              var H = this.viewer && this.viewer.isAnimating();
              U = !H;
            }
            for (var M = n.length - 1; M >= 0; M--)
              r = n[M], this._drawer.drawTile(
                r,
                this._drawingHandler,
                s,
                l,
                d,
                U,
                this.source
              ), r.beingDrawn = !0, this.viewer && this.viewer.raiseEvent("tile-drawn", {
                tiledImage: this,
                tile: r
              });
            T && this._drawer.restoreContext(s), l || (this.getRotation(!0) % 360 !== 0 && this._drawer._restoreRotationChanges(s), this.viewport.getRotation(!0) % 360 !== 0 && this._drawer._restoreRotationChanges(s)), s && (l && (this.viewport.getRotation(!0) % 360 !== 0 && this._drawer._offsetForRotation({
              degrees: this.viewport.getRotation(!0),
              useSketch: !1
            }), this.getRotation(!0) % 360 !== 0 && this._drawer._offsetForRotation({
              degrees: this.getRotation(!0),
              point: this.viewport.pixelFromPointNoRotate(
                this._getRotationPoint(!0),
                !0
              ),
              useSketch: !1
            })), this._drawer.blendSketch({
              opacity: this.opacity,
              scale: l,
              translate: d,
              compositeOperation: this.compositeOperation,
              bounds: y
            }), l && (this.getRotation(!0) % 360 !== 0 && this._drawer._restoreRotationChanges(!1), this.viewport.getRotation(!0) % 360 !== 0 && this._drawer._restoreRotationChanges(!1))), l || this.viewport.getRotation(!0) % 360 === 0 && this.getRotation(!0) % 360 === 0 && this._drawer.viewer.viewport.getFlip() && this._drawer._flip(), this._drawDebugInfo(n);
          }
        },
        /**
         * @private
         * @inner
         * Draws special debug information for a TiledImage if in debug mode.
         * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
         */
        _drawDebugInfo: function(n) {
          if (this.debugMode)
            for (var r = n.length - 1; r >= 0; r--) {
              var s = n[r];
              try {
                this._drawer.drawDebugInfo(s, n.length, r, this);
              } catch (l) {
                e.console.error(l);
              }
            }
        },
        /**
         * @private
         * @inner
         * Returns true if the given tile provides coverage to lower-level tiles of
         * lower resolution representing the same content. If neither x nor y is
         * given, returns true if the entire visible level provides coverage.
         *
         * Note that out-of-bounds tiles provide coverage in this sense, since
         * there's no content that they would need to cover. Tiles at non-existent
         * levels that are within the image bounds, however, do not.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of the tile.
         * @param {Number} x - The X position of the tile.
         * @param {Number} y - The Y position of the tile.
         * @returns {Boolean}
         */
        _providesCoverage: function(n, r, s, l) {
          var d, f, v, y;
          if (!n[r])
            return !1;
          if (s === void 0 || l === void 0) {
            d = n[r];
            for (v in d)
              if (Object.prototype.hasOwnProperty.call(d, v)) {
                f = d[v];
                for (y in f)
                  if (Object.prototype.hasOwnProperty.call(f, y) && !f[y])
                    return !1;
              }
            return !0;
          }
          return n[r][s] === void 0 || n[r][s][l] === void 0 || n[r][s][l] === !0;
        },
        /**
         * @private
         * @inner
         * Returns true if the given tile is completely covered by higher-level
         * tiles of higher resolution representing the same content. If neither x
         * nor y is given, returns true if the entire visible level is covered.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of the tile.
         * @param {Number} x - The X position of the tile.
         * @param {Number} y - The Y position of the tile.
         * @returns {Boolean}
         */
        _isCovered: function(n, r, s, l) {
          return s === void 0 || l === void 0 ? this._providesCoverage(n, r + 1) : this._providesCoverage(n, r + 1, 2 * s, 2 * l) && this._providesCoverage(n, r + 1, 2 * s, 2 * l + 1) && this._providesCoverage(n, r + 1, 2 * s + 1, 2 * l) && this._providesCoverage(n, r + 1, 2 * s + 1, 2 * l + 1);
        },
        /**
         * @private
         * @inner
         * Sets whether the given tile provides coverage or not.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of the tile.
         * @param {Number} x - The X position of the tile.
         * @param {Number} y - The Y position of the tile.
         * @param {Boolean} covers - Whether the tile provides coverage.
         */
        _setCoverage: function(n, r, s, l, d) {
          if (!n[r]) {
            e.console.warn(
              "Setting coverage for a tile before its level's coverage has been reset: %s",
              r
            );
            return;
          }
          n[r][s] || (n[r][s] = {}), n[r][s][l] = d;
        },
        /**
         * @private
         * @inner
         * Resets coverage information for the given level. This should be called
         * after every draw routine. Note that at the beginning of the next draw
         * routine, coverage for every visible tile should be explicitly set.
         *
         * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
         * @param {Number} level - The resolution level of tiles to completely reset.
         */
        _resetCoverage: function(n, r) {
          n[r] = {};
        }
      }
    );
    var t = e.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    function i(n) {
      return n !== e.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && n !== e.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && n !== e.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
    }
    function o(n) {
      return i(n) ? t : n;
    }
    function h(n) {
      if (typeof n == "number")
        return o(n);
      if (!n || !e.Browser)
        return t;
      var r = n[e.Browser.vendor];
      return i(r) && (r = n["*"]), o(r);
    }
  }(D), function(e) {
    var t = function(o) {
      e.console.assert(o, "[TileCache.cacheTile] options is required"), e.console.assert(o.tile, "[TileCache.cacheTile] options.tile is required"), e.console.assert(o.tiledImage, "[TileCache.cacheTile] options.tiledImage is required"), this.tile = o.tile, this.tiledImage = o.tiledImage;
    }, i = function(o) {
      e.console.assert(o, "[ImageRecord] options is required"), e.console.assert(o.data, "[ImageRecord] options.data is required"), this._tiles = [], o.create.apply(null, [this, o.data, o.ownerTile]), this._destroyImplementation = o.destroy.bind(null, this), this.getImage = o.getImage.bind(null, this), this.getData = o.getData.bind(null, this), this.getRenderedContext = o.getRenderedContext.bind(null, this);
    };
    i.prototype = {
      destroy: function() {
        this._destroyImplementation(), this._tiles = null;
      },
      addTile: function(o) {
        e.console.assert(o, "[ImageRecord.addTile] tile is required"), this._tiles.push(o);
      },
      removeTile: function(o) {
        for (var h = 0; h < this._tiles.length; h++)
          if (this._tiles[h] === o) {
            this._tiles.splice(h, 1);
            return;
          }
        e.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", o);
      },
      getTileCount: function() {
        return this._tiles.length;
      }
    }, e.TileCache = function(o) {
      o = o || {}, this._maxImageCacheCount = o.maxImageCacheCount || e.DEFAULT_SETTINGS.maxImageCacheCount, this._tilesLoaded = [], this._imagesLoaded = [], this._imagesLoadedCount = 0;
    }, e.TileCache.prototype = {
      /**
       * @returns {Number} The total number of tiles that have been loaded by
       * this TileCache.
       */
      numTilesLoaded: function() {
        return this._tilesLoaded.length;
      },
      /**
       * Caches the specified tile, removing an old tile if necessary to stay under the
       * maxImageCacheCount specified on construction. Note that if multiple tiles reference
       * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
       * the number of images below that number. Note, as well, that even the number of images
       * may temporarily surpass that number, but should eventually come back down to the max specified.
       * @param {Object} options - Tile info.
       * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
       * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
       * @param {Image} options.image - The image of the tile to cache.
       * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
       * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
       * function will release an old tile. The cutoff option specifies a tile level at or below which
       * tiles will not be released.
       */
      cacheTile: function(o) {
        e.console.assert(o, "[TileCache.cacheTile] options is required"), e.console.assert(o.tile, "[TileCache.cacheTile] options.tile is required"), e.console.assert(o.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required"), e.console.assert(o.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
        var h = o.cutoff || 0, n = this._tilesLoaded.length, r = this._imagesLoaded[o.tile.cacheKey];
        if (r || (o.data || (e.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute has been deprecated and will be removed in the future."), o.data = o.image), e.console.assert(o.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord"), r = this._imagesLoaded[o.tile.cacheKey] = new i({
          data: o.data,
          ownerTile: o.tile,
          create: o.tiledImage.source.createTileCache,
          destroy: o.tiledImage.source.destroyTileCache,
          getImage: o.tiledImage.source.getTileCacheDataAsImage,
          getData: o.tiledImage.source.getTileCacheData,
          getRenderedContext: o.tiledImage.source.getTileCacheDataAsContext2D
        }), this._imagesLoadedCount++), r.addTile(o.tile), o.tile.cacheImageRecord = r, this._imagesLoadedCount > this._maxImageCacheCount) {
          for (var s = null, l = -1, d = null, f, v, y, T, w, x, P = this._tilesLoaded.length - 1; P >= 0; P--)
            if (x = this._tilesLoaded[P], f = x.tile, !(f.level <= h || f.beingDrawn)) {
              if (!s) {
                s = f, l = P, d = x;
                continue;
              }
              T = f.lastTouchTime, v = s.lastTouchTime, w = f.level, y = s.level, (T < v || T === v && w > y) && (s = f, l = P, d = x);
            }
          s && l >= 0 && (this._unloadTile(d), n = l);
        }
        this._tilesLoaded[n] = new t({
          tile: o.tile,
          tiledImage: o.tiledImage
        });
      },
      /**
       * Clears all tiles associated with the specified tiledImage.
       * @param {OpenSeadragon.TiledImage} tiledImage
       */
      clearTilesFor: function(o) {
        e.console.assert(o, "[TileCache.clearTilesFor] tiledImage is required");
        for (var h, n = 0; n < this._tilesLoaded.length; ++n)
          h = this._tilesLoaded[n], h.tiledImage === o && (this._unloadTile(h), this._tilesLoaded.splice(n, 1), n--);
      },
      // private
      getImageRecord: function(o) {
        return e.console.assert(o, "[TileCache.getImageRecord] cacheKey is required"), this._imagesLoaded[o];
      },
      // private
      _unloadTile: function(o) {
        e.console.assert(o, "[TileCache._unloadTile] tileRecord is required");
        var h = o.tile, n = o.tiledImage;
        h.unload(), h.cacheImageRecord = null;
        var r = this._imagesLoaded[h.cacheKey];
        r.removeTile(h), r.getTileCount() || (r.destroy(), delete this._imagesLoaded[h.cacheKey], this._imagesLoadedCount--), n.viewer.raiseEvent("tile-unloaded", {
          tile: h,
          tiledImage: n
        });
      }
    };
  }(D), function(e) {
    e.World = function(t) {
      var i = this;
      e.console.assert(t.viewer, "[World] options.viewer is required"), e.EventSource.call(this), this.viewer = t.viewer, this._items = [], this._needsDraw = !1, this._autoRefigureSizes = !0, this._needsSizesFigured = !1, this._delegatedFigureSizes = function(o) {
        i._autoRefigureSizes ? i._figureSizes() : i._needsSizesFigured = !0;
      }, this._figureSizes();
    }, e.extend(
      e.World.prototype,
      e.EventSource.prototype,
      /** @lends OpenSeadragon.World.prototype */
      {
        /**
         * Add the specified item.
         * @param {OpenSeadragon.TiledImage} item - The item to add.
         * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
         * @fires OpenSeadragon.World.event:add-item
         * @fires OpenSeadragon.World.event:metrics-change
         */
        addItem: function(t, i) {
          if (e.console.assert(t, "[World.addItem] item is required"), e.console.assert(t instanceof e.TiledImage, "[World.addItem] only TiledImages supported at this time"), i = i || {}, i.index !== void 0) {
            var o = Math.max(0, Math.min(this._items.length, i.index));
            this._items.splice(o, 0, t);
          } else
            this._items.push(t);
          this._autoRefigureSizes ? this._figureSizes() : this._needsSizesFigured = !0, this._needsDraw = !0, t.addHandler("bounds-change", this._delegatedFigureSizes), t.addHandler("clip-change", this._delegatedFigureSizes), this.raiseEvent("add-item", {
            item: t
          });
        },
        /**
         * Get the item at the specified index.
         * @param {Number} index - The item's index.
         * @returns {OpenSeadragon.TiledImage} The item at the specified index.
         */
        getItemAt: function(t) {
          return e.console.assert(t !== void 0, "[World.getItemAt] index is required"), this._items[t];
        },
        /**
         * Get the index of the given item or -1 if not present.
         * @param {OpenSeadragon.TiledImage} item - The item.
         * @returns {Number} The index of the item or -1 if not present.
         */
        getIndexOfItem: function(t) {
          return e.console.assert(t, "[World.getIndexOfItem] item is required"), e.indexOf(this._items, t);
        },
        /**
         * @returns {Number} The number of items used.
         */
        getItemCount: function() {
          return this._items.length;
        },
        /**
         * Change the index of a item so that it appears over or under others.
         * @param {OpenSeadragon.TiledImage} item - The item to move.
         * @param {Number} index - The new index.
         * @fires OpenSeadragon.World.event:item-index-change
         */
        setItemIndex: function(t, i) {
          e.console.assert(t, "[World.setItemIndex] item is required"), e.console.assert(i !== void 0, "[World.setItemIndex] index is required");
          var o = this.getIndexOfItem(t);
          if (i >= this._items.length)
            throw new Error("Index bigger than number of layers.");
          i === o || o === -1 || (this._items.splice(o, 1), this._items.splice(i, 0, t), this._needsDraw = !0, this.raiseEvent("item-index-change", {
            item: t,
            previousIndex: o,
            newIndex: i
          }));
        },
        /**
         * Remove an item.
         * @param {OpenSeadragon.TiledImage} item - The item to remove.
         * @fires OpenSeadragon.World.event:remove-item
         * @fires OpenSeadragon.World.event:metrics-change
         */
        removeItem: function(t) {
          e.console.assert(t, "[World.removeItem] item is required");
          var i = e.indexOf(this._items, t);
          i !== -1 && (t.removeHandler("bounds-change", this._delegatedFigureSizes), t.removeHandler("clip-change", this._delegatedFigureSizes), t.destroy(), this._items.splice(i, 1), this._figureSizes(), this._needsDraw = !0, this._raiseRemoveItem(t));
        },
        /**
         * Remove all items.
         * @fires OpenSeadragon.World.event:remove-item
         * @fires OpenSeadragon.World.event:metrics-change
         */
        removeAll: function() {
          this.viewer._cancelPendingImages();
          var t, i;
          for (i = 0; i < this._items.length; i++)
            t = this._items[i], t.removeHandler("bounds-change", this._delegatedFigureSizes), t.removeHandler("clip-change", this._delegatedFigureSizes), t.destroy();
          var o = this._items;
          for (this._items = [], this._figureSizes(), this._needsDraw = !0, i = 0; i < o.length; i++)
            t = o[i], this._raiseRemoveItem(t);
        },
        /**
         * Clears all tiles and triggers updates for all items.
         */
        resetItems: function() {
          for (var t = 0; t < this._items.length; t++)
            this._items[t].reset();
        },
        /**
         * Updates (i.e. animates bounds of) all items.
         */
        update: function() {
          for (var t = !1, i = 0; i < this._items.length; i++)
            t = this._items[i].update() || t;
          return t;
        },
        /**
         * Draws all items.
         */
        draw: function() {
          for (var t = 0; t < this._items.length; t++)
            this._items[t].draw();
          this._needsDraw = !1;
        },
        /**
         * @returns {Boolean} true if any items need updating.
         */
        needsDraw: function() {
          for (var t = 0; t < this._items.length; t++)
            if (this._items[t].needsDraw())
              return !0;
          return this._needsDraw;
        },
        /**
         * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
         */
        getHomeBounds: function() {
          return this._homeBounds.clone();
        },
        /**
         * To facilitate zoom constraints, we keep track of the pixel density of the
         * densest item in the World (i.e. the item whose content size to viewport size
         * ratio is the highest) and save it as this "content factor".
         * @returns {Number} the number of content units per viewport unit.
         */
        getContentFactor: function() {
          return this._contentFactor;
        },
        /**
         * As a performance optimization, setting this flag to false allows the bounds-change event handler
         * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
         * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
         * or the system may behave oddly.
         * @param {Boolean} [value] The value to which to set the flag.
         */
        setAutoRefigureSizes: function(t) {
          this._autoRefigureSizes = t, t & this._needsSizesFigured && (this._figureSizes(), this._needsSizesFigured = !1);
        },
        /**
         * Arranges all of the TiledImages with the specified settings.
         * @param {Object} options - Specifies how to arrange.
         * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
         * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
         * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
         * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
         * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
         * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
         * @fires OpenSeadragon.World.event:metrics-change
         */
        arrange: function(t) {
          t = t || {};
          var i = t.immediately || !1, o = t.layout || e.DEFAULT_SETTINGS.collectionLayout, h = t.rows || e.DEFAULT_SETTINGS.collectionRows, n = t.columns || e.DEFAULT_SETTINGS.collectionColumns, r = t.tileSize || e.DEFAULT_SETTINGS.collectionTileSize, s = t.tileMargin || e.DEFAULT_SETTINGS.collectionTileMargin, l = r + s, d;
          !t.rows && n ? d = n : d = Math.ceil(this._items.length / h);
          var f = 0, v = 0, y, T, w, x, P;
          this.setAutoRefigureSizes(!1);
          for (var C = 0; C < this._items.length; C++)
            C && C % d === 0 && (o === "horizontal" ? (v += l, f = 0) : (f += l, v = 0)), y = this._items[C], T = y.getBounds(), T.width > T.height ? w = r : w = r * (T.width / T.height), x = w * (T.height / T.width), P = new e.Point(
              f + (r - w) / 2,
              v + (r - x) / 2
            ), y.setPosition(P, i), y.setWidth(w, i), o === "horizontal" ? f += l : v += l;
          this.setAutoRefigureSizes(!0);
        },
        // private
        _figureSizes: function() {
          var t = this._homeBounds ? this._homeBounds.clone() : null, i = this._contentSize ? this._contentSize.clone() : null, o = this._contentFactor || 0;
          if (!this._items.length)
            this._homeBounds = new e.Rect(0, 0, 1, 1), this._contentSize = new e.Point(1, 1), this._contentFactor = 1;
          else {
            var h = this._items[0], n = h.getBounds();
            this._contentFactor = h.getContentSize().x / n.width;
            for (var r = h.getClippedBounds().getBoundingBox(), s = r.x, l = r.y, d = r.x + r.width, f = r.y + r.height, v = 1; v < this._items.length; v++)
              h = this._items[v], n = h.getBounds(), this._contentFactor = Math.max(
                this._contentFactor,
                h.getContentSize().x / n.width
              ), r = h.getClippedBounds().getBoundingBox(), s = Math.min(s, r.x), l = Math.min(l, r.y), d = Math.max(d, r.x + r.width), f = Math.max(f, r.y + r.height);
            this._homeBounds = new e.Rect(s, l, d - s, f - l), this._contentSize = new e.Point(
              this._homeBounds.width * this._contentFactor,
              this._homeBounds.height * this._contentFactor
            );
          }
          (this._contentFactor !== o || !this._homeBounds.equals(t) || !this._contentSize.equals(i)) && this.raiseEvent("metrics-change", {});
        },
        // private
        _raiseRemoveItem: function(t) {
          this.raiseEvent("remove-item", { item: t });
        }
      }
    );
  }(D);
})(Ie);
var Ge = Ie.exports;
const Be = /* @__PURE__ */ Ne(Ge), De = (B) => {
  var D, e, t, i, o;
  let h = {
    id: typeof B == "string" ? B : B.source
  };
  if (typeof B == "string") {
    if (B.includes("#xywh=")) {
      const n = B.split("#xywh=");
      if (n && n[1]) {
        const [r, s, l, d] = n[1].split(",").map((f) => Number(f));
        h = {
          id: n[0],
          rect: {
            x: r,
            y: s,
            w: l,
            h: d
          }
        };
      }
    } else if (B.includes("#t=")) {
      const n = B.split("#t=");
      n && n[1] && (h = {
        id: n[0],
        t: n[1]
      });
    }
  } else if (typeof B == "object") {
    if (((D = B.selector) == null ? void 0 : D.type) === "PointSelector")
      h = {
        id: B.source,
        point: {
          x: B.selector.x,
          y: B.selector.y
        }
      };
    else if (((e = B.selector) == null ? void 0 : e.type) === "SvgSelector")
      h = {
        id: B.source,
        svg: B.selector.value
      };
    else if (((t = B.selector) == null ? void 0 : t.type) === "FragmentSelector" && (i = B.selector) != null && i.value.includes("xywh=") && B.source.type == "Canvas" && B.source.id) {
      const n = (o = B.selector) == null ? void 0 : o.value.split("xywh=");
      if (n && n[1]) {
        const [r, s, l, d] = n[1].split(",").map((f) => Number(f));
        h = {
          id: B.source.id,
          rect: {
            x: r,
            y: s,
            w: l,
            h: d
          }
        };
      }
    }
  }
  return h;
};
let ae = window.OpenSeadragon;
if (!ae && (ae = Be, !ae))
  throw new Error("OpenSeadragon is missing.");
const Oe = "http://www.w3.org/2000/svg";
ae.Viewer && (ae.Viewer.prototype.svgOverlay = function() {
  return this._svgOverlayInfo ? this._svgOverlayInfo : (this._svgOverlayInfo = new Le(this), this._svgOverlayInfo);
});
const Le = function(B) {
  const D = this;
  this._viewer = B, this._containerWidth = 0, this._containerHeight = 0, this._svg = document.createElementNS(Oe, "svg"), this._svg.style.position = "absolute", this._svg.style.left = 0, this._svg.style.top = 0, this._svg.style.width = "100%", this._svg.style.height = "100%", this._viewer.canvas.appendChild(this._svg), this._node = document.createElementNS(Oe, "g"), this._svg.appendChild(this._node), this._viewer.addHandler("animation", function() {
    D.resize();
  }), this._viewer.addHandler("open", function() {
    D.resize();
  }), this._viewer.addHandler("rotate", function() {
    D.resize();
  }), this._viewer.addHandler("flip", function() {
    D.resize();
  }), this._viewer.addHandler("resize", function() {
    D.resize();
  }), this.resize();
};
Le.prototype = {
  // ----------
  node: function() {
    return this._node;
  },
  // ----------
  resize: function() {
    this._containerWidth !== this._viewer.container.clientWidth && (this._containerWidth = this._viewer.container.clientWidth, this._svg.setAttribute("width", this._containerWidth)), this._containerHeight !== this._viewer.container.clientHeight && (this._containerHeight = this._viewer.container.clientHeight, this._svg.setAttribute("height", this._containerHeight));
    const B = this._viewer.viewport.pixelFromPoint(new ae.Point(0, 0), !0), D = this._viewer.viewport.getZoom(!0), e = this._viewer.viewport.getRotation(), t = this._viewer.viewport.getFlip(), i = this._viewer.viewport._containerInnerSize.x;
    let o = i * D;
    const h = o;
    t && (o = -o, B.x = -B.x + i), this._node.setAttribute(
      "transform",
      "translate(" + B.x + "," + B.y + ") scale(" + o + "," + h + ") rotate(" + e + ")"
    );
  },
  // ----------
  onClick: function(B, D) {
    new ae.MouseTracker({
      element: B,
      clickHandler: D
    }).setTracking(!0);
  }
};
function He(B, D, e) {
  let t, i, o = 40, h = 40;
  D.rect && (t = D.rect.x, i = D.rect.y, o = D.rect.w, h = D.rect.h), D.point && (t = D.point.x, i = D.point.y);
  const n = 1 / B.width;
  return new Be.Rect(
    t * n - o * n / 2 * (e - 1),
    i * n - h * n / 2 * (e - 1),
    o * n * e,
    h * n * e
  );
}
const Ke = ({
  annotation: B,
  canvas: D,
  useViewerDispatch: e,
  setActiveTarget: t,
  activeTarget: i,
  useViewerState: o,
  annotationServer: h,
  downloadUrl: n,
  token: r
}) => {
  const s = e(), l = o(), { OSDImageLoaded: d, openSeadragonViewer: f, activeManifest: v } = l, y = ke(), { zoomLevel: T, annotorious: w } = y, x = We();
  Me(() => {
    if (!d || !f || !B.target || B.target != i)
      return;
    const H = De(B.target), { rect: M, id: X } = H;
    if (M && D.id === X) {
      const Z = He(
        D,
        H,
        T
      );
      f == null || f.viewport.fitBounds(Z), W(B), t(void 0);
    }
  }, [f.id, d]);
  function P() {
    if (!B.target)
      return;
    const H = Array.isArray(B.target) ? B.target[0] : B.target, M = De(H), { rect: X, id: Z } = M;
    if (X)
      if (D.id === Z) {
        const Y = He(
          D,
          M,
          T
        );
        f == null || f.viewport.fitBounds(Y), W(B);
      } else
        s({
          type: "updateOSDImageLoaded",
          OSDImageLoaded: !1
        }), s({
          type: "updateActiveCanvas",
          canvasId: Z
        }), t(H);
  }
  function C() {
    B.target && Ue(
      be(B, "pixel"),
      v,
      D.id,
      "pixel",
      r,
      h
    ).then(() => {
      x({
        type: "annotationsUpdatedAt",
        annotationsUpdatedAt: (/* @__PURE__ */ new Date()).getTime()
      }), w.clearAnnotations();
    });
  }
  function A() {
    if (!B.target)
      return;
    const H = be(B, "pixel");
    window.location.href = n + "/annotation_id/" + H.id;
  }
  function W(H) {
    const M = document.querySelectorAll(".a9s-annotation");
    M && M.forEach((Z) => Z.classList.remove("selected"));
    const X = document.querySelector(`[data-id='${H.id}']`);
    X && X.classList.add("selected");
  }
  function k(H, M) {
    if (typeof H == "string")
      return /* @__PURE__ */ ne("div", { className: "clipping-text", children: H }, M);
    if (H.type === "Image")
      return /* @__PURE__ */ ne("img", { src: H.value, className: "clipping-image" }, M);
    if (H.type === "TextualBody")
      return /* @__PURE__ */ ne("div", { className: "clipping-text", children: H.value }, M);
  }
  function U(H) {
    return Array.isArray(H) ? H.map((M, X) => k(M, X)) : k(H, 0);
  }
  return B.body ? /* @__PURE__ */ Fe("div", { className: "clipping", style: { position: "relative" }, children: [
    /* @__PURE__ */ ne("button", { onClick: P, children: U(B.body) }),
    /* @__PURE__ */ ne("button", { onClick: C, style: { position: "absolute", right: "5px", bottom: "5px", width: "24px" }, children: /* @__PURE__ */ ne("i", { className: "fas fa-trash-alt" }) }),
    /* @__PURE__ */ ne("button", { onClick: A, style: { position: "absolute", right: "5px", top: "5px", width: "24px" }, children: /* @__PURE__ */ ne("i", { className: "fas fa-download" }) })
  ] }) : /* @__PURE__ */ ne(ze, {});
};
export {
  Ke as default
};
