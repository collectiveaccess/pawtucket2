var iu = Object.defineProperty;
var au = (e, t, n) => t in e ? iu(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var se = (e, t, n) => (au(e, typeof t != "symbol" ? t + "" : t, n), n);
import { saveAnnotation as On, deleteAnnotation as An, updateAnnotation as _n, fetchAnnotations as lr, convertWebAnnotationToIIIFAnnotation as fr, convertIIIFAnnotationToWebAnnotation as pr } from "./annotation-utils.js";
import { a as cu, c as qr, g as uu } from "../../_commonjsHelpers-CT_km90n.js";
function He(e, t, n) {
  const o = typeof e;
  if (!n.includes(o))
    throw new TypeError(`${t} value must be ${n.join(" or ")}, received "${o}"`);
}
function oo(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
function lu(e) {
  return e === Object.prototype || e === Function.prototype || e === RegExp.prototype;
}
function Wn(e) {
  return Object.prototype.toString.apply(e).slice(8, -1);
}
function fu(e, t) {
  const n = typeof t == "function" ? t : (o) => t.add(o);
  Object.getOwnPropertyNames(e).forEach(n), Object.getOwnPropertySymbols(e).forEach(n);
}
function Mi(e) {
  const t = /* @__PURE__ */ new Set();
  return lu(e) ? [] : (fu(e, t), Array.from(t));
}
const Pi = { forceWritable: !1 };
function jo(e, t = Pi) {
  return zr(e, /* @__PURE__ */ new WeakMap(), t);
}
function zr(e, t, n = Pi) {
  let o, r;
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    for (r = Array(o = e.length), t.set(e, r); o--; )
      r[o] = zr(e[o], t, n);
    return r;
  }
  if (Object.prototype.toString.call(e) === "[object Object]") {
    r = Object.create(Object.getPrototypeOf(e)), t.set(e, r);
    const s = Mi(e);
    for (const i of s) {
      const a = Object.getOwnPropertyDescriptor(e, i);
      if (!a)
        continue;
      const c = zr(e[i], t, n);
      "get" in a ? Object.defineProperty(r, i, {
        ...a,
        get() {
          return c;
        }
      }) : Object.defineProperty(r, i, {
        ...a,
        writable: n.forceWritable ? !0 : a.writable,
        value: c
      });
    }
    return r;
  }
  return e;
}
function pu(e, t, n = void 0) {
  const o = t.replace(/\[(\d+)\]/g, ".$1").split(".");
  let r = e;
  for (const s of o)
    if (r = Object(r)[s], r === void 0)
      return n;
  return r;
}
function ko() {
  let e = null, t = null;
  const n = new Promise((o, r) => {
    e = o, t = r;
  });
  return n.resolve = e, n.reject = t, n;
}
var gt = {}, so = { exports: {} };
so.exports;
(function(e) {
  const n = (s = 0) => (i) => `\x1B[${38 + s};5;${i}m`, o = (s = 0) => (i, a, c) => `\x1B[${38 + s};2;${i};${a};${c}m`;
  function r() {
    const s = /* @__PURE__ */ new Map(), i = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    i.color.gray = i.color.blackBright, i.bgColor.bgGray = i.bgColor.bgBlackBright, i.color.grey = i.color.blackBright, i.bgColor.bgGrey = i.bgColor.bgBlackBright;
    for (const [a, c] of Object.entries(i)) {
      for (const [l, f] of Object.entries(c))
        i[l] = {
          open: `\x1B[${f[0]}m`,
          close: `\x1B[${f[1]}m`
        }, c[l] = i[l], s.set(f[0], f[1]);
      Object.defineProperty(i, a, {
        value: c,
        enumerable: !1
      });
    }
    return Object.defineProperty(i, "codes", {
      value: s,
      enumerable: !1
    }), i.color.close = "\x1B[39m", i.bgColor.close = "\x1B[49m", i.color.ansi256 = n(), i.color.ansi16m = o(), i.bgColor.ansi256 = n(10), i.bgColor.ansi16m = o(10), Object.defineProperties(i, {
      rgbToAnsi256: {
        value: (a, c, l) => a === c && c === l ? a < 8 ? 16 : a > 248 ? 231 : Math.round((a - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(a / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(l / 255 * 5),
        enumerable: !1
      },
      hexToRgb: {
        value: (a) => {
          const c = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(a.toString(16));
          if (!c)
            return [0, 0, 0];
          let { colorString: l } = c.groups;
          l.length === 3 && (l = l.split("").map((u) => u + u).join(""));
          const f = Number.parseInt(l, 16);
          return [
            f >> 16 & 255,
            f >> 8 & 255,
            f & 255
          ];
        },
        enumerable: !1
      },
      hexToAnsi256: {
        value: (a) => i.rgbToAnsi256(...i.hexToRgb(a)),
        enumerable: !1
      }
    }), i;
  }
  Object.defineProperty(e, "exports", {
    enumerable: !0,
    get: r
  });
})(so);
var hu = so.exports, et = {};
Object.defineProperty(et, "__esModule", {
  value: !0
});
et.printIteratorEntries = du;
et.printIteratorValues = yu;
et.printListItems = gu;
et.printObjectProperties = bu;
const mu = (e, t) => {
  const n = Object.keys(e), o = t !== null ? n.sort(t) : n;
  return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach((r) => {
    Object.getOwnPropertyDescriptor(e, r).enumerable && o.push(r);
  }), o;
};
function du(e, t, n, o, r, s, i = ": ") {
  let a = "", c = 0, l = e.next();
  if (!l.done) {
    a += t.spacingOuter;
    const f = n + t.indent;
    for (; !l.done; ) {
      if (a += f, c++ === t.maxWidth) {
        a += "…";
        break;
      }
      const u = s(
        l.value[0],
        t,
        f,
        o,
        r
      ), p = s(
        l.value[1],
        t,
        f,
        o,
        r
      );
      a += u + i + p, l = e.next(), l.done ? t.min || (a += ",") : a += `,${t.spacingInner}`;
    }
    a += t.spacingOuter + n;
  }
  return a;
}
function yu(e, t, n, o, r, s) {
  let i = "", a = 0, c = e.next();
  if (!c.done) {
    i += t.spacingOuter;
    const l = n + t.indent;
    for (; !c.done; ) {
      if (i += l, a++ === t.maxWidth) {
        i += "…";
        break;
      }
      i += s(c.value, t, l, o, r), c = e.next(), c.done ? t.min || (i += ",") : i += `,${t.spacingInner}`;
    }
    i += t.spacingOuter + n;
  }
  return i;
}
function gu(e, t, n, o, r, s) {
  let i = "";
  if (e.length) {
    i += t.spacingOuter;
    const a = n + t.indent;
    for (let c = 0; c < e.length; c++) {
      if (i += a, c === t.maxWidth) {
        i += "…";
        break;
      }
      c in e && (i += s(e[c], t, a, o, r)), c < e.length - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + n;
  }
  return i;
}
function bu(e, t, n, o, r, s) {
  let i = "";
  const a = mu(e, t.compareKeys);
  if (a.length) {
    i += t.spacingOuter;
    const c = n + t.indent;
    for (let l = 0; l < a.length; l++) {
      const f = a[l], u = s(f, t, c, o, r), p = s(e[f], t, c, o, r);
      i += `${c + u}: ${p}`, l < a.length - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + n;
  }
  return i;
}
var st = {};
Object.defineProperty(st, "__esModule", {
  value: !0
});
st.test = st.serialize = st.default = void 0;
var Ro = et, hr = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
const wu = typeof hr == "function" && hr.for ? hr.for("jest.asymmetricMatcher") : 1267621, Mn = " ", Ii = (e, t, n, o, r, s) => {
  const i = e.toString();
  if (i === "ArrayContaining" || i === "ArrayNotContaining")
    return ++o > t.maxDepth ? `[${i}]` : `${i + Mn}[${(0, Ro.printListItems)(
      e.sample,
      t,
      n,
      o,
      r,
      s
    )}]`;
  if (i === "ObjectContaining" || i === "ObjectNotContaining")
    return ++o > t.maxDepth ? `[${i}]` : `${i + Mn}{${(0, Ro.printObjectProperties)(
      e.sample,
      t,
      n,
      o,
      r,
      s
    )}}`;
  if (i === "StringMatching" || i === "StringNotMatching" || i === "StringContaining" || i === "StringNotContaining")
    return i + Mn + s(e.sample, t, n, o, r);
  if (typeof e.toAsymmetricMatcher != "function")
    throw new Error(
      `Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`
    );
  return e.toAsymmetricMatcher();
};
st.serialize = Ii;
const Ci = (e) => e && e.$$typeof === wu;
st.test = Ci;
const vu = {
  serialize: Ii,
  test: Ci
};
var Eu = vu;
st.default = Eu;
var it = {};
Object.defineProperty(it, "__esModule", {
  value: !0
});
it.test = it.serialize = it.default = void 0;
var Fo = et;
const Su = " ", Ni = ["DOMStringMap", "NamedNodeMap"], Tu = /^(HTML\w*Collection|NodeList)$/, xu = (e) => Ni.indexOf(e) !== -1 || Tu.test(e), ji = (e) => e && e.constructor && !!e.constructor.name && xu(e.constructor.name);
it.test = ji;
const $u = (e) => e.constructor.name === "NamedNodeMap", ki = (e, t, n, o, r, s) => {
  const i = e.constructor.name;
  return ++o > t.maxDepth ? `[${i}]` : (t.min ? "" : i + Su) + (Ni.indexOf(i) !== -1 ? `{${(0, Fo.printObjectProperties)(
    $u(e) ? Array.from(e).reduce((a, c) => (a[c.name] = c.value, a), {}) : {
      ...e
    },
    t,
    n,
    o,
    r,
    s
  )}}` : `[${(0, Fo.printListItems)(
    Array.from(e),
    t,
    n,
    o,
    r,
    s
  )}]`);
};
it.serialize = ki;
const Ou = {
  serialize: ki,
  test: ji
};
var Au = Ou;
it.default = Au;
var at = {}, ke = {}, io = {};
Object.defineProperty(io, "__esModule", {
  value: !0
});
io.default = _u;
function _u(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
Object.defineProperty(ke, "__esModule", {
  value: !0
});
ke.printText = ke.printProps = ke.printElementAsLeaf = ke.printElement = ke.printComment = ke.printChildren = void 0;
var Ri = Mu(io);
function Mu(e) {
  return e && e.__esModule ? e : { default: e };
}
const Pu = (e, t, n, o, r, s, i) => {
  const a = o + n.indent, c = n.colors;
  return e.map((l) => {
    const f = t[l];
    let u = i(f, n, a, r, s);
    return typeof f != "string" && (u.indexOf(`
`) !== -1 && (u = n.spacingOuter + a + u + n.spacingOuter + o), u = `{${u}}`), `${n.spacingInner + o + c.prop.open + l + c.prop.close}=${c.value.open}${u}${c.value.close}`;
  }).join("");
};
ke.printProps = Pu;
const Iu = (e, t, n, o, r, s) => e.map(
  (i) => t.spacingOuter + n + (typeof i == "string" ? Fi(i, t) : s(i, t, n, o, r))
).join("");
ke.printChildren = Iu;
const Fi = (e, t) => {
  const n = t.colors.content;
  return n.open + (0, Ri.default)(e) + n.close;
};
ke.printText = Fi;
const Cu = (e, t) => {
  const n = t.colors.comment;
  return `${n.open}<!--${(0, Ri.default)(e)}-->${n.close}`;
};
ke.printComment = Cu;
const Nu = (e, t, n, o, r) => {
  const s = o.colors.tag;
  return `${s.open}<${e}${t && s.close + t + o.spacingOuter + r + s.open}${n ? `>${s.close}${n}${o.spacingOuter}${r}${s.open}</${e}` : `${t && !o.min ? "" : " "}/`}>${s.close}`;
};
ke.printElement = Nu;
const ju = (e, t) => {
  const n = t.colors.tag;
  return `${n.open}<${e}${n.close} …${n.open} />${n.close}`;
};
ke.printElementAsLeaf = ju;
Object.defineProperty(at, "__esModule", {
  value: !0
});
at.test = at.serialize = at.default = void 0;
var jt = ke;
const ku = 1, Di = 3, Bi = 8, Li = 11, Ru = /^((HTML|SVG)\w*)?Element$/, Fu = (e) => {
  try {
    return typeof e.hasAttribute == "function" && e.hasAttribute("is");
  } catch {
    return !1;
  }
}, Du = (e) => {
  const t = e.constructor.name, { nodeType: n, tagName: o } = e, r = typeof o == "string" && o.includes("-") || Fu(e);
  return n === ku && (Ru.test(t) || r) || n === Di && t === "Text" || n === Bi && t === "Comment" || n === Li && t === "DocumentFragment";
}, qi = (e) => {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) && Du(e);
};
at.test = qi;
function Bu(e) {
  return e.nodeType === Di;
}
function Lu(e) {
  return e.nodeType === Bi;
}
function mr(e) {
  return e.nodeType === Li;
}
const zi = (e, t, n, o, r, s) => {
  if (Bu(e))
    return (0, jt.printText)(e.data, t);
  if (Lu(e))
    return (0, jt.printComment)(e.data, t);
  const i = mr(e) ? "DocumentFragment" : e.tagName.toLowerCase();
  return ++o > t.maxDepth ? (0, jt.printElementAsLeaf)(i, t) : (0, jt.printElement)(
    i,
    (0, jt.printProps)(
      mr(e) ? [] : Array.from(e.attributes, (a) => a.name).sort(),
      mr(e) ? {} : Array.from(e.attributes).reduce((a, c) => (a[c.name] = c.value, a), {}),
      t,
      n + t.indent,
      o,
      r,
      s
    ),
    (0, jt.printChildren)(
      Array.prototype.slice.call(e.childNodes || e.children),
      t,
      n + t.indent,
      o,
      r,
      s
    ),
    t,
    n
  );
};
at.serialize = zi;
const qu = {
  serialize: zi,
  test: qi
};
var zu = qu;
at.default = zu;
var ct = {};
Object.defineProperty(ct, "__esModule", {
  value: !0
});
ct.test = ct.serialize = ct.default = void 0;
var hn = et;
const Wu = "@@__IMMUTABLE_ITERABLE__@@", Vu = "@@__IMMUTABLE_LIST__@@", Uu = "@@__IMMUTABLE_KEYED__@@", Ku = "@@__IMMUTABLE_MAP__@@", Do = "@@__IMMUTABLE_ORDERED__@@", Gu = "@@__IMMUTABLE_RECORD__@@", Ju = "@@__IMMUTABLE_SEQ__@@", Yu = "@@__IMMUTABLE_SET__@@", Hu = "@@__IMMUTABLE_STACK__@@", zt = (e) => `Immutable.${e}`, Xn = (e) => `[${e}]`, mn = " ", Bo = "…", Xu = (e, t, n, o, r, s, i) => ++o > t.maxDepth ? Xn(zt(i)) : `${zt(i) + mn}{${(0, hn.printIteratorEntries)(
  e.entries(),
  t,
  n,
  o,
  r,
  s
)}}`;
function Qu(e) {
  let t = 0;
  return {
    next() {
      if (t < e._keys.length) {
        const n = e._keys[t++];
        return {
          done: !1,
          value: [n, e.get(n)]
        };
      }
      return {
        done: !0,
        value: void 0
      };
    }
  };
}
const Zu = (e, t, n, o, r, s) => {
  const i = zt(e._name || "Record");
  return ++o > t.maxDepth ? Xn(i) : `${i + mn}{${(0, hn.printIteratorEntries)(
    Qu(e),
    t,
    n,
    o,
    r,
    s
  )}}`;
}, el = (e, t, n, o, r, s) => {
  const i = zt("Seq");
  return ++o > t.maxDepth ? Xn(i) : e[Uu] ? `${i + mn}{${// from Immutable collection of entries or from ECMAScript object
  e._iter || e._object ? (0, hn.printIteratorEntries)(
    e.entries(),
    t,
    n,
    o,
    r,
    s
  ) : Bo}}` : `${i + mn}[${e._iter || // from Immutable collection of values
  e._array || // from ECMAScript array
  e._collection || // from ECMAScript collection in immutable v4
  e._iterable ? (0, hn.printIteratorValues)(
    e.values(),
    t,
    n,
    o,
    r,
    s
  ) : Bo}]`;
}, dr = (e, t, n, o, r, s, i) => ++o > t.maxDepth ? Xn(zt(i)) : `${zt(i) + mn}[${(0, hn.printIteratorValues)(
  e.values(),
  t,
  n,
  o,
  r,
  s
)}]`, Wi = (e, t, n, o, r, s) => e[Ku] ? Xu(
  e,
  t,
  n,
  o,
  r,
  s,
  e[Do] ? "OrderedMap" : "Map"
) : e[Vu] ? dr(
  e,
  t,
  n,
  o,
  r,
  s,
  "List"
) : e[Yu] ? dr(
  e,
  t,
  n,
  o,
  r,
  s,
  e[Do] ? "OrderedSet" : "Set"
) : e[Hu] ? dr(
  e,
  t,
  n,
  o,
  r,
  s,
  "Stack"
) : e[Ju] ? el(e, t, n, o, r, s) : Zu(e, t, n, o, r, s);
ct.serialize = Wi;
const Vi = (e) => e && (e[Wu] === !0 || e[Gu] === !0);
ct.test = Vi;
const tl = {
  serialize: Wi,
  test: Vi
};
var nl = tl;
ct.default = nl;
var ut = {}, Wr = { exports: {} }, ue = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lo;
function rl() {
  if (Lo)
    return ue;
  Lo = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), i = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), b;
  b = Symbol.for("react.module.reference");
  function v(h) {
    if (typeof h == "object" && h !== null) {
      var A = h.$$typeof;
      switch (A) {
        case e:
          switch (h = h.type, h) {
            case n:
            case r:
            case o:
            case l:
            case f:
              return h;
            default:
              switch (h = h && h.$$typeof, h) {
                case a:
                case i:
                case c:
                case p:
                case u:
                case s:
                  return h;
                default:
                  return A;
              }
          }
        case t:
          return A;
      }
    }
  }
  return ue.ContextConsumer = i, ue.ContextProvider = s, ue.Element = e, ue.ForwardRef = c, ue.Fragment = n, ue.Lazy = p, ue.Memo = u, ue.Portal = t, ue.Profiler = r, ue.StrictMode = o, ue.Suspense = l, ue.SuspenseList = f, ue.isAsyncMode = function() {
    return !1;
  }, ue.isConcurrentMode = function() {
    return !1;
  }, ue.isContextConsumer = function(h) {
    return v(h) === i;
  }, ue.isContextProvider = function(h) {
    return v(h) === s;
  }, ue.isElement = function(h) {
    return typeof h == "object" && h !== null && h.$$typeof === e;
  }, ue.isForwardRef = function(h) {
    return v(h) === c;
  }, ue.isFragment = function(h) {
    return v(h) === n;
  }, ue.isLazy = function(h) {
    return v(h) === p;
  }, ue.isMemo = function(h) {
    return v(h) === u;
  }, ue.isPortal = function(h) {
    return v(h) === t;
  }, ue.isProfiler = function(h) {
    return v(h) === r;
  }, ue.isStrictMode = function(h) {
    return v(h) === o;
  }, ue.isSuspense = function(h) {
    return v(h) === l;
  }, ue.isSuspenseList = function(h) {
    return v(h) === f;
  }, ue.isValidElementType = function(h) {
    return typeof h == "string" || typeof h == "function" || h === n || h === r || h === o || h === l || h === f || h === w || typeof h == "object" && h !== null && (h.$$typeof === p || h.$$typeof === u || h.$$typeof === s || h.$$typeof === i || h.$$typeof === c || h.$$typeof === b || h.getModuleId !== void 0);
  }, ue.typeOf = v, ue;
}
var le = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qo;
function ol() {
  return qo || (qo = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), i = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), b = !1, v = !1, h = !1, A = !1, M = !1, F;
    F = Symbol.for("react.module.reference");
    function k(O) {
      return !!(typeof O == "string" || typeof O == "function" || O === n || O === r || M || O === o || O === l || O === f || A || O === w || b || v || h || typeof O == "object" && O !== null && (O.$$typeof === p || O.$$typeof === u || O.$$typeof === s || O.$$typeof === i || O.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      O.$$typeof === F || O.getModuleId !== void 0));
    }
    function N(O) {
      if (typeof O == "object" && O !== null) {
        var ce = O.$$typeof;
        switch (ce) {
          case e:
            var oe = O.type;
            switch (oe) {
              case n:
              case r:
              case o:
              case l:
              case f:
                return oe;
              default:
                var ye = oe && oe.$$typeof;
                switch (ye) {
                  case a:
                  case i:
                  case c:
                  case p:
                  case u:
                  case s:
                    return ye;
                  default:
                    return ce;
                }
            }
          case t:
            return ce;
        }
      }
    }
    var U = i, B = s, G = e, ae = c, V = n, Ee = p, be = u, Se = t, Me = r, Fe = o, Pe = l, Ne = f, De = !1, m = !1;
    function T(O) {
      return De || (De = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function x(O) {
      return m || (m = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function P(O) {
      return N(O) === i;
    }
    function j(O) {
      return N(O) === s;
    }
    function D(O) {
      return typeof O == "object" && O !== null && O.$$typeof === e;
    }
    function I(O) {
      return N(O) === c;
    }
    function $(O) {
      return N(O) === n;
    }
    function q(O) {
      return N(O) === p;
    }
    function K(O) {
      return N(O) === u;
    }
    function J(O) {
      return N(O) === t;
    }
    function ne(O) {
      return N(O) === r;
    }
    function Z(O) {
      return N(O) === o;
    }
    function H(O) {
      return N(O) === l;
    }
    function re(O) {
      return N(O) === f;
    }
    le.ContextConsumer = U, le.ContextProvider = B, le.Element = G, le.ForwardRef = ae, le.Fragment = V, le.Lazy = Ee, le.Memo = be, le.Portal = Se, le.Profiler = Me, le.StrictMode = Fe, le.Suspense = Pe, le.SuspenseList = Ne, le.isAsyncMode = T, le.isConcurrentMode = x, le.isContextConsumer = P, le.isContextProvider = j, le.isElement = D, le.isForwardRef = I, le.isFragment = $, le.isLazy = q, le.isMemo = K, le.isPortal = J, le.isProfiler = ne, le.isStrictMode = Z, le.isSuspense = H, le.isSuspenseList = re, le.isValidElementType = k, le.typeOf = N;
  }()), le;
}
process.env.NODE_ENV === "production" ? Wr.exports = rl() : Wr.exports = ol();
var sl = Wr.exports;
Object.defineProperty(ut, "__esModule", {
  value: !0
});
ut.test = ut.serialize = ut.default = void 0;
var xt = il(sl), Pn = ke;
function Ui(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (Ui = function(o) {
    return o ? n : t;
  })(e);
}
function il(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = Ui(t);
  if (n && n.has(e))
    return n.get(e);
  var o = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var i = r ? Object.getOwnPropertyDescriptor(e, s) : null;
      i && (i.get || i.set) ? Object.defineProperty(o, s, i) : o[s] = e[s];
    }
  return o.default = e, n && n.set(e, o), o;
}
const Ki = (e, t = []) => (Array.isArray(e) ? e.forEach((n) => {
  Ki(n, t);
}) : e != null && e !== !1 && t.push(e), t), zo = (e) => {
  const t = e.type;
  if (typeof t == "string")
    return t;
  if (typeof t == "function")
    return t.displayName || t.name || "Unknown";
  if (xt.isFragment(e))
    return "React.Fragment";
  if (xt.isSuspense(e))
    return "React.Suspense";
  if (typeof t == "object" && t !== null) {
    if (xt.isContextProvider(e))
      return "Context.Provider";
    if (xt.isContextConsumer(e))
      return "Context.Consumer";
    if (xt.isForwardRef(e)) {
      if (t.displayName)
        return t.displayName;
      const n = t.render.displayName || t.render.name || "";
      return n !== "" ? `ForwardRef(${n})` : "ForwardRef";
    }
    if (xt.isMemo(e)) {
      const n = t.displayName || t.type.displayName || t.type.name || "";
      return n !== "" ? `Memo(${n})` : "Memo";
    }
  }
  return "UNDEFINED";
}, al = (e) => {
  const { props: t } = e;
  return Object.keys(t).filter((n) => n !== "children" && t[n] !== void 0).sort();
}, Gi = (e, t, n, o, r, s) => ++o > t.maxDepth ? (0, Pn.printElementAsLeaf)(zo(e), t) : (0, Pn.printElement)(
  zo(e),
  (0, Pn.printProps)(
    al(e),
    e.props,
    t,
    n + t.indent,
    o,
    r,
    s
  ),
  (0, Pn.printChildren)(
    Ki(e.props.children),
    t,
    n + t.indent,
    o,
    r,
    s
  ),
  t,
  n
);
ut.serialize = Gi;
const Ji = (e) => e != null && xt.isElement(e);
ut.test = Ji;
const cl = {
  serialize: Gi,
  test: Ji
};
var ul = cl;
ut.default = ul;
var lt = {};
Object.defineProperty(lt, "__esModule", {
  value: !0
});
lt.test = lt.serialize = lt.default = void 0;
var In = ke, yr = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
const ll = typeof yr == "function" && yr.for ? yr.for("react.test.json") : 245830487, fl = (e) => {
  const { props: t } = e;
  return t ? Object.keys(t).filter((n) => t[n] !== void 0).sort() : [];
}, Yi = (e, t, n, o, r, s) => ++o > t.maxDepth ? (0, In.printElementAsLeaf)(e.type, t) : (0, In.printElement)(
  e.type,
  e.props ? (0, In.printProps)(
    fl(e),
    e.props,
    t,
    n + t.indent,
    o,
    r,
    s
  ) : "",
  e.children ? (0, In.printChildren)(
    e.children,
    t,
    n + t.indent,
    o,
    r,
    s
  ) : "",
  t,
  n
);
lt.serialize = Yi;
const Hi = (e) => e && e.$$typeof === ll;
lt.test = Hi;
const pl = {
  serialize: Yi,
  test: Hi
};
var hl = pl;
lt.default = hl;
Object.defineProperty(gt, "__esModule", {
  value: !0
});
gt.default = gt.DEFAULT_OPTIONS = void 0;
var Xe = gt.format = aa, ao = gt.plugins = void 0, ml = _t(hu), tn = et, dl = _t(
  st
), yl = _t(it), gl = _t(at), bl = _t(ct), wl = _t(ut), vl = _t(
  lt
);
function _t(e) {
  return e && e.__esModule ? e : { default: e };
}
const Xi = Object.prototype.toString, El = Date.prototype.toISOString, Sl = Error.prototype.toString, Wo = RegExp.prototype.toString, gr = (e) => typeof e.constructor == "function" && e.constructor.name || "Object", Tl = (e) => typeof window < "u" && e === window, xl = /^Symbol\((.*)\)(.*)$/, $l = /\n/gi;
let Qi = class extends Error {
  constructor(t, n) {
    super(t), this.stack = n, this.name = this.constructor.name;
  }
};
function Ol(e) {
  return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
}
function Al(e) {
  return Object.is(e, -0) ? "-0" : String(e);
}
function _l(e) {
  return `${e}n`;
}
function Vo(e, t) {
  return t ? `[Function ${e.name || "anonymous"}]` : "[Function]";
}
function Uo(e) {
  return String(e).replace(xl, "Symbol($1)");
}
function Ko(e) {
  return `[${Sl.call(e)}]`;
}
function Zi(e, t, n, o) {
  if (e === !0 || e === !1)
    return `${e}`;
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const r = typeof e;
  if (r === "number")
    return Al(e);
  if (r === "bigint")
    return _l(e);
  if (r === "string")
    return o ? `"${e.replace(/"|\\/g, "\\$&")}"` : `"${e}"`;
  if (r === "function")
    return Vo(e, t);
  if (r === "symbol")
    return Uo(e);
  const s = Xi.call(e);
  return s === "[object WeakMap]" ? "WeakMap {}" : s === "[object WeakSet]" ? "WeakSet {}" : s === "[object Function]" || s === "[object GeneratorFunction]" ? Vo(e, t) : s === "[object Symbol]" ? Uo(e) : s === "[object Date]" ? isNaN(+e) ? "Date { NaN }" : El.call(e) : s === "[object Error]" ? Ko(e) : s === "[object RegExp]" ? n ? Wo.call(e).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : Wo.call(e) : e instanceof Error ? Ko(e) : null;
}
function ea(e, t, n, o, r, s) {
  if (r.indexOf(e) !== -1)
    return "[Circular]";
  r = r.slice(), r.push(e);
  const i = ++o > t.maxDepth, a = t.min;
  if (t.callToJSON && !i && e.toJSON && typeof e.toJSON == "function" && !s)
    return rt(e.toJSON(), t, n, o, r, !0);
  const c = Xi.call(e);
  return c === "[object Arguments]" ? i ? "[Arguments]" : `${a ? "" : "Arguments "}[${(0, tn.printListItems)(
    e,
    t,
    n,
    o,
    r,
    rt
  )}]` : Ol(c) ? i ? `[${e.constructor.name}]` : `${a || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : `${e.constructor.name} `}[${(0, tn.printListItems)(
    e,
    t,
    n,
    o,
    r,
    rt
  )}]` : c === "[object Map]" ? i ? "[Map]" : `Map {${(0, tn.printIteratorEntries)(
    e.entries(),
    t,
    n,
    o,
    r,
    rt,
    " => "
  )}}` : c === "[object Set]" ? i ? "[Set]" : `Set {${(0, tn.printIteratorValues)(
    e.values(),
    t,
    n,
    o,
    r,
    rt
  )}}` : i || Tl(e) ? `[${gr(e)}]` : `${a || !t.printBasicPrototype && gr(e) === "Object" ? "" : `${gr(e)} `}{${(0, tn.printObjectProperties)(
    e,
    t,
    n,
    o,
    r,
    rt
  )}}`;
}
function Ml(e) {
  return e.serialize != null;
}
function ta(e, t, n, o, r, s) {
  let i;
  try {
    i = Ml(e) ? e.serialize(t, n, o, r, s, rt) : e.print(
      t,
      (a) => rt(a, n, o, r, s),
      (a) => {
        const c = o + n.indent;
        return c + a.replace($l, `
${c}`);
      },
      {
        edgeSpacing: n.spacingOuter,
        min: n.min,
        spacing: n.spacingInner
      },
      n.colors
    );
  } catch (a) {
    throw new Qi(a.message, a.stack);
  }
  if (typeof i != "string")
    throw new Error(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof i}".`
    );
  return i;
}
function na(e, t) {
  for (let n = 0; n < e.length; n++)
    try {
      if (e[n].test(t))
        return e[n];
    } catch (o) {
      throw new Qi(o.message, o.stack);
    }
  return null;
}
function rt(e, t, n, o, r, s) {
  const i = na(t.plugins, e);
  if (i !== null)
    return ta(i, e, t, n, o, r);
  const a = Zi(
    e,
    t.printFunctionName,
    t.escapeRegex,
    t.escapeString
  );
  return a !== null ? a : ea(
    e,
    t,
    n,
    o,
    r,
    s
  );
}
const co = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, ra = Object.keys(co), Pl = (e) => e, Ve = Pl({
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: 1 / 0,
  maxWidth: 1 / 0,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: co
});
gt.DEFAULT_OPTIONS = Ve;
function Il(e) {
  if (Object.keys(e).forEach((t) => {
    if (!Object.prototype.hasOwnProperty.call(Ve, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  }), e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error(
      'pretty-format: Options "min" and "indent" cannot be used together.'
    );
  if (e.theme !== void 0) {
    if (e.theme === null)
      throw new Error('pretty-format: Option "theme" must not be null.');
    if (typeof e.theme != "object")
      throw new Error(
        `pretty-format: Option "theme" must be of type "object" but instead received "${typeof e.theme}".`
      );
  }
}
const Cl = (e) => ra.reduce((t, n) => {
  const o = e.theme && e.theme[n] !== void 0 ? e.theme[n] : co[n], r = o && ml.default[o];
  if (r && typeof r.close == "string" && typeof r.open == "string")
    t[n] = r;
  else
    throw new Error(
      `pretty-format: Option "theme" has a key "${n}" whose value "${o}" is undefined in ansi-styles.`
    );
  return t;
}, /* @__PURE__ */ Object.create(null)), Nl = () => ra.reduce((e, t) => (e[t] = {
  close: "",
  open: ""
}, e), /* @__PURE__ */ Object.create(null)), oa = (e) => (e == null ? void 0 : e.printFunctionName) ?? Ve.printFunctionName, sa = (e) => (e == null ? void 0 : e.escapeRegex) ?? Ve.escapeRegex, ia = (e) => (e == null ? void 0 : e.escapeString) ?? Ve.escapeString, Go = (e) => ({
  callToJSON: (e == null ? void 0 : e.callToJSON) ?? Ve.callToJSON,
  colors: e != null && e.highlight ? Cl(e) : Nl(),
  compareKeys: typeof (e == null ? void 0 : e.compareKeys) == "function" || (e == null ? void 0 : e.compareKeys) === null ? e.compareKeys : Ve.compareKeys,
  escapeRegex: sa(e),
  escapeString: ia(e),
  indent: e != null && e.min ? "" : jl((e == null ? void 0 : e.indent) ?? Ve.indent),
  maxDepth: (e == null ? void 0 : e.maxDepth) ?? Ve.maxDepth,
  maxWidth: (e == null ? void 0 : e.maxWidth) ?? Ve.maxWidth,
  min: (e == null ? void 0 : e.min) ?? Ve.min,
  plugins: (e == null ? void 0 : e.plugins) ?? Ve.plugins,
  printBasicPrototype: (e == null ? void 0 : e.printBasicPrototype) ?? !0,
  printFunctionName: oa(e),
  spacingInner: e != null && e.min ? " " : `
`,
  spacingOuter: e != null && e.min ? "" : `
`
});
function jl(e) {
  return new Array(e + 1).join(" ");
}
function aa(e, t) {
  if (t && (Il(t), t.plugins)) {
    const o = na(t.plugins, e);
    if (o !== null)
      return ta(o, e, Go(t), "", 0, []);
  }
  const n = Zi(
    e,
    oa(t),
    sa(t),
    ia(t)
  );
  return n !== null ? n : ea(e, Go(t), "", 0, []);
}
const kl = {
  AsymmetricMatcher: dl.default,
  DOMCollection: yl.default,
  DOMElement: gl.default,
  Immutable: bl.default,
  ReactElement: wl.default,
  ReactTestComponent: vl.default
};
ao = gt.plugins = kl;
var Rl = aa;
gt.default = Rl;
var Vr = { exports: {} };
const Fl = {}, Dl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Fl
}, Symbol.toStringTag, { value: "Module" })), Bl = /* @__PURE__ */ cu(Dl);
(function(e, t) {
  (function(n, o) {
    o(t);
  })(qr, function(n) {
    function o(d) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? o = function(g) {
        return typeof g;
      } : o = function(g) {
        return g && typeof Symbol == "function" && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
      }, o(d);
    }
    function r(d, g) {
      return s(d) || i(d, g) || a(d, g) || l();
    }
    function s(d) {
      if (Array.isArray(d))
        return d;
    }
    function i(d, g) {
      if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(d)))) {
        var _ = [], L = !0, z = !1, ee = void 0;
        try {
          for (var ie = d[Symbol.iterator](), me; !(L = (me = ie.next()).done) && (_.push(me.value), !(g && _.length === g)); L = !0)
            ;
        } catch (Ie) {
          z = !0, ee = Ie;
        } finally {
          try {
            !L && ie.return != null && ie.return();
          } finally {
            if (z)
              throw ee;
          }
        }
        return _;
      }
    }
    function a(d, g) {
      if (d) {
        if (typeof d == "string")
          return c(d, g);
        var _ = Object.prototype.toString.call(d).slice(8, -1);
        if (_ === "Object" && d.constructor && (_ = d.constructor.name), _ === "Map" || _ === "Set")
          return Array.from(d);
        if (_ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_))
          return c(d, g);
      }
    }
    function c(d, g) {
      (g == null || g > d.length) && (g = d.length);
      for (var _ = 0, L = new Array(g); _ < g; _++)
        L[_] = d[_];
      return L;
    }
    function l() {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var f = {
      bold: ["1", "22"],
      dim: ["2", "22"],
      italic: ["3", "23"],
      underline: ["4", "24"],
      // 5 & 6 are blinking
      inverse: ["7", "27"],
      hidden: ["8", "28"],
      strike: ["9", "29"],
      // 10-20 are fonts
      // 21-29 are resets for 1-9
      black: ["30", "39"],
      red: ["31", "39"],
      green: ["32", "39"],
      yellow: ["33", "39"],
      blue: ["34", "39"],
      magenta: ["35", "39"],
      cyan: ["36", "39"],
      white: ["37", "39"],
      brightblack: ["30;1", "39"],
      brightred: ["31;1", "39"],
      brightgreen: ["32;1", "39"],
      brightyellow: ["33;1", "39"],
      brightblue: ["34;1", "39"],
      brightmagenta: ["35;1", "39"],
      brightcyan: ["36;1", "39"],
      brightwhite: ["37;1", "39"],
      grey: ["90", "39"]
    }, u = {
      special: "cyan",
      number: "yellow",
      bigint: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      symbol: "green",
      date: "magenta",
      regexp: "red"
    }, p = "…";
    function w(d, g) {
      var _ = f[u[g]] || f[g];
      return _ ? "\x1B[".concat(_[0], "m").concat(String(d), "\x1B[").concat(_[1], "m") : String(d);
    }
    function b() {
      var d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = d.showHidden, _ = g === void 0 ? !1 : g, L = d.depth, z = L === void 0 ? 2 : L, ee = d.colors, ie = ee === void 0 ? !1 : ee, me = d.customInspect, Ie = me === void 0 ? !0 : me, Te = d.showProxy, We = Te === void 0 ? !1 : Te, St = d.maxArrayLength, cr = St === void 0 ? 1 / 0 : St, Zt = d.breakLength, Nt = Zt === void 0 ? 1 / 0 : Zt, en = d.seen, ru = en === void 0 ? [] : en, Co = d.truncate, ou = Co === void 0 ? 1 / 0 : Co, No = d.stylize, su = No === void 0 ? String : No, ur = {
        showHidden: !!_,
        depth: Number(z),
        colors: !!ie,
        customInspect: !!Ie,
        showProxy: !!We,
        maxArrayLength: Number(cr),
        breakLength: Number(Nt),
        truncate: Number(ou),
        seen: ru,
        stylize: su
      };
      return ur.colors && (ur.stylize = w), ur;
    }
    function v(d, g) {
      var _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : p;
      d = String(d);
      var L = _.length, z = d.length;
      return L > g && z > L ? _ : z > g && z > L ? "".concat(d.slice(0, g - L)).concat(_) : d;
    }
    function h(d, g, _) {
      var L = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ", ";
      _ = _ || g.inspect;
      var z = d.length;
      if (z === 0)
        return "";
      for (var ee = g.truncate, ie = "", me = "", Ie = "", Te = 0; Te < z; Te += 1) {
        var We = Te + 1 === d.length, St = Te + 2 === d.length;
        Ie = "".concat(p, "(").concat(d.length - Te, ")");
        var cr = d[Te];
        g.truncate = ee - ie.length - (We ? 0 : L.length);
        var Zt = me || _(cr, g) + (We ? "" : L), Nt = ie.length + Zt.length, en = Nt + Ie.length;
        if (We && Nt > ee && ie.length + Ie.length <= ee || !We && !St && en > ee || (me = We ? "" : _(d[Te + 1], g) + (St ? "" : L), !We && St && en > ee && Nt + me.length > ee))
          break;
        if (ie += Zt, !We && !St && Nt + me.length >= ee) {
          Ie = "".concat(p, "(").concat(d.length - Te - 1, ")");
          break;
        }
        Ie = "";
      }
      return "".concat(ie).concat(Ie);
    }
    function A(d) {
      return d.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/) ? d : JSON.stringify(d).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
    }
    function M(d, g) {
      var _ = r(d, 2), L = _[0], z = _[1];
      return g.truncate -= 2, typeof L == "string" ? L = A(L) : typeof L != "number" && (L = "[".concat(g.inspect(L, g), "]")), g.truncate -= L.length, z = g.inspect(z, g), "".concat(L, ": ").concat(z);
    }
    function F(d, g) {
      var _ = Object.keys(d).slice(d.length);
      if (!d.length && !_.length)
        return "[]";
      g.truncate -= 4;
      var L = h(d, g);
      g.truncate -= L.length;
      var z = "";
      return _.length && (z = h(_.map(function(ee) {
        return [ee, d[ee]];
      }), g, M)), "[ ".concat(L).concat(z ? ", ".concat(z) : "", " ]");
    }
    var k = Function.prototype.toString, N = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/, U = 512;
    function B(d) {
      if (typeof d != "function")
        return null;
      var g = "";
      if (typeof Function.prototype.name > "u" && typeof d.name > "u") {
        var _ = k.call(d);
        if (_.indexOf("(") > U)
          return g;
        var L = _.match(N);
        L && (g = L[1]);
      } else
        g = d.name;
      return g;
    }
    var G = B, ae = function(g) {
      return typeof Buffer == "function" && g instanceof Buffer ? "Buffer" : g[Symbol.toStringTag] ? g[Symbol.toStringTag] : G(g.constructor);
    };
    function V(d, g) {
      var _ = ae(d);
      g.truncate -= _.length + 4;
      var L = Object.keys(d).slice(d.length);
      if (!d.length && !L.length)
        return "".concat(_, "[]");
      for (var z = "", ee = 0; ee < d.length; ee++) {
        var ie = "".concat(g.stylize(v(d[ee], g.truncate), "number")).concat(ee === d.length - 1 ? "" : ", ");
        if (g.truncate -= ie.length, d[ee] !== d.length && g.truncate <= 3) {
          z += "".concat(p, "(").concat(d.length - d[ee] + 1, ")");
          break;
        }
        z += ie;
      }
      var me = "";
      return L.length && (me = h(L.map(function(Ie) {
        return [Ie, d[Ie]];
      }), g, M)), "".concat(_, "[ ").concat(z).concat(me ? ", ".concat(me) : "", " ]");
    }
    function Ee(d, g) {
      var _ = d.toJSON();
      if (_ === null)
        return "Invalid Date";
      var L = _.split("T"), z = L[0];
      return g.stylize("".concat(z, "T").concat(v(L[1], g.truncate - z.length - 1)), "date");
    }
    function be(d, g) {
      var _ = G(d);
      return _ ? g.stylize("[Function ".concat(v(_, g.truncate - 11), "]"), "special") : g.stylize("[Function]", "special");
    }
    function Se(d, g) {
      var _ = r(d, 2), L = _[0], z = _[1];
      return g.truncate -= 4, L = g.inspect(L, g), g.truncate -= L.length, z = g.inspect(z, g), "".concat(L, " => ").concat(z);
    }
    function Me(d) {
      var g = [];
      return d.forEach(function(_, L) {
        g.push([L, _]);
      }), g;
    }
    function Fe(d, g) {
      var _ = d.size - 1;
      return _ <= 0 ? "Map{}" : (g.truncate -= 7, "Map{ ".concat(h(Me(d), g, Se), " }"));
    }
    var Pe = Number.isNaN || function(d) {
      return d !== d;
    };
    function Ne(d, g) {
      return Pe(d) ? g.stylize("NaN", "number") : d === 1 / 0 ? g.stylize("Infinity", "number") : d === -1 / 0 ? g.stylize("-Infinity", "number") : d === 0 ? g.stylize(1 / d === 1 / 0 ? "+0" : "-0", "number") : g.stylize(v(d, g.truncate), "number");
    }
    function De(d, g) {
      var _ = v(d.toString(), g.truncate - 1);
      return _ !== p && (_ += "n"), g.stylize(_, "bigint");
    }
    function m(d, g) {
      var _ = d.toString().split("/")[2], L = g.truncate - (2 + _.length), z = d.source;
      return g.stylize("/".concat(v(z, L), "/").concat(_), "regexp");
    }
    function T(d) {
      var g = [];
      return d.forEach(function(_) {
        g.push(_);
      }), g;
    }
    function x(d, g) {
      return d.size === 0 ? "Set{}" : (g.truncate -= 7, "Set{ ".concat(h(T(d), g), " }"));
    }
    var P = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g"), j = {
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      "'": "\\'",
      "\\": "\\\\"
    }, D = 16, I = 4;
    function $(d) {
      return j[d] || "\\u".concat("0000".concat(d.charCodeAt(0).toString(D)).slice(-I));
    }
    function q(d, g) {
      return P.test(d) && (d = d.replace(P, $)), g.stylize("'".concat(v(d, g.truncate - 2), "'"), "string");
    }
    function K(d) {
      return "description" in Symbol.prototype ? d.description ? "Symbol(".concat(d.description, ")") : "Symbol()" : d.toString();
    }
    var J = function() {
      return "Promise{…}";
    };
    try {
      var ne = process.binding("util"), Z = ne.getPromiseDetails, H = ne.kPending, re = ne.kRejected;
      Array.isArray(Z(Promise.resolve())) && (J = function(g, _) {
        var L = Z(g), z = r(L, 2), ee = z[0], ie = z[1];
        return ee === H ? "Promise{<pending>}" : "Promise".concat(ee === re ? "!" : "", "{").concat(_.inspect(ie, _), "}");
      });
    } catch {
    }
    var O = J;
    function ce(d, g) {
      var _ = Object.getOwnPropertyNames(d), L = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(d) : [];
      if (_.length === 0 && L.length === 0)
        return "{}";
      if (g.truncate -= 4, g.seen = g.seen || [], g.seen.indexOf(d) >= 0)
        return "[Circular]";
      g.seen.push(d);
      var z = h(_.map(function(me) {
        return [me, d[me]];
      }), g, M), ee = h(L.map(function(me) {
        return [me, d[me]];
      }), g, M);
      g.seen.pop();
      var ie = "";
      return z && ee && (ie = ", "), "{ ".concat(z).concat(ie).concat(ee, " }");
    }
    var oe = typeof Symbol < "u" && Symbol.toStringTag ? Symbol.toStringTag : !1;
    function ye(d, g) {
      var _ = "";
      return oe && oe in d && (_ = d[oe]), _ = _ || G(d.constructor), (!_ || _ === "_class") && (_ = "<Anonymous Class>"), g.truncate -= _.length, "".concat(_).concat(ce(d, g));
    }
    function qe(d, g) {
      return d.length === 0 ? "Arguments[]" : (g.truncate -= 13, "Arguments[ ".concat(h(d, g), " ]"));
    }
    var ar = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description"];
    function E(d, g) {
      var _ = Object.getOwnPropertyNames(d).filter(function(ie) {
        return ar.indexOf(ie) === -1;
      }), L = d.name;
      g.truncate -= L.length;
      var z = "";
      typeof d.message == "string" ? z = v(d.message, g.truncate) : _.unshift("message"), z = z ? ": ".concat(z) : "", g.truncate -= z.length + 5;
      var ee = h(_.map(function(ie) {
        return [ie, d[ie]];
      }), g, M);
      return "".concat(L).concat(z).concat(ee ? " { ".concat(ee, " }") : "");
    }
    function S(d, g) {
      var _ = r(d, 2), L = _[0], z = _[1];
      return g.truncate -= 3, z ? "".concat(g.stylize(L, "yellow"), "=").concat(g.stylize('"'.concat(z, '"'), "string")) : "".concat(g.stylize(L, "yellow"));
    }
    function C(d, g) {
      return h(d, g, R, `
`);
    }
    function R(d, g) {
      var _ = d.getAttributeNames(), L = d.tagName.toLowerCase(), z = g.stylize("<".concat(L), "special"), ee = g.stylize(">", "special"), ie = g.stylize("</".concat(L, ">"), "special");
      g.truncate -= L.length * 2 + 5;
      var me = "";
      _.length > 0 && (me += " ", me += h(_.map(function(We) {
        return [We, d.getAttribute(We)];
      }), g, S, " ")), g.truncate -= me.length;
      var Ie = g.truncate, Te = C(d.children, g);
      return Te && Te.length > Ie && (Te = "".concat(p, "(").concat(d.children.length, ")")), "".concat(z).concat(me).concat(ee).concat(Te).concat(ie);
    }
    var y = typeof Symbol == "function" && typeof Symbol.for == "function", X = y ? Symbol.for("chai/inspect") : "@@chai/inspect", we = !1;
    try {
      var ve = Bl;
      we = ve.inspect ? ve.inspect.custom : !1;
    } catch {
      we = !1;
    }
    function Be() {
      this.key = "chai/loupe__" + Math.random() + Date.now();
    }
    Be.prototype = {
      // eslint-disable-next-line object-shorthand
      get: function(g) {
        return g[this.key];
      },
      // eslint-disable-next-line object-shorthand
      has: function(g) {
        return this.key in g;
      },
      // eslint-disable-next-line object-shorthand
      set: function(g, _) {
        Object.isExtensible(g) && Object.defineProperty(g, this.key, {
          // eslint-disable-next-line object-shorthand
          value: _,
          configurable: !0
        });
      }
    };
    var Y = new (typeof WeakMap == "function" ? WeakMap : Be)(), W = {}, Q = {
      undefined: function(g, _) {
        return _.stylize("undefined", "undefined");
      },
      null: function(g, _) {
        return _.stylize(null, "null");
      },
      boolean: function(g, _) {
        return _.stylize(g, "boolean");
      },
      Boolean: function(g, _) {
        return _.stylize(g, "boolean");
      },
      number: Ne,
      Number: Ne,
      bigint: De,
      BigInt: De,
      string: q,
      String: q,
      function: be,
      Function: be,
      symbol: K,
      // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
      Symbol: K,
      Array: F,
      Date: Ee,
      Map: Fe,
      Set: x,
      RegExp: m,
      Promise: O,
      // WeakSet, WeakMap are totally opaque to us
      WeakSet: function(g, _) {
        return _.stylize("WeakSet{…}", "special");
      },
      WeakMap: function(g, _) {
        return _.stylize("WeakMap{…}", "special");
      },
      Arguments: qe,
      Int8Array: V,
      Uint8Array: V,
      Uint8ClampedArray: V,
      Int16Array: V,
      Uint16Array: V,
      Int32Array: V,
      Uint32Array: V,
      Float32Array: V,
      Float64Array: V,
      Generator: function() {
        return "";
      },
      DataView: function() {
        return "";
      },
      ArrayBuffer: function() {
        return "";
      },
      Error: E,
      HTMLCollection: C,
      NodeList: C
    }, te = function(g, _, L) {
      return X in g && typeof g[X] == "function" ? g[X](_) : we && we in g && typeof g[we] == "function" ? g[we](_.depth, _) : "inspect" in g && typeof g.inspect == "function" ? g.inspect(_.depth, _) : "constructor" in g && Y.has(g.constructor) ? Y.get(g.constructor)(g, _) : W[L] ? W[L](g, _) : "";
    }, ge = Object.prototype.toString;
    function $e(d, g) {
      g = b(g), g.inspect = $e;
      var _ = g, L = _.customInspect, z = d === null ? "null" : o(d);
      if (z === "object" && (z = ge.call(d).slice(8, -1)), Q[z])
        return Q[z](d, g);
      if (L && d) {
        var ee = te(d, g, z);
        if (ee)
          return typeof ee == "string" ? ee : $e(ee, g);
      }
      var ie = d ? Object.getPrototypeOf(d) : !1;
      return ie === Object.prototype || ie === null ? ce(d, g) : d && typeof HTMLElement == "function" && d instanceof HTMLElement ? R(d, g) : "constructor" in d ? d.constructor !== Object ? ye(d, g) : ce(d, g) : d === Object(d) ? ce(d, g) : g.stylize(String(d), z);
    }
    function nt(d, g) {
      return Y.has(d) ? !1 : (Y.set(d, g), !0);
    }
    function Ct(d, g) {
      return d in W ? !1 : (W[d] = g, !0);
    }
    var ze = X;
    n.custom = ze, n.default = $e, n.inspect = $e, n.registerConstructor = nt, n.registerStringTag = Ct, Object.defineProperty(n, "__esModule", { value: !0 });
  });
})(Vr, Vr.exports);
var ca = Vr.exports;
const {
  AsymmetricMatcher: Ll,
  DOMCollection: ql,
  DOMElement: zl,
  Immutable: Wl,
  ReactElement: Vl,
  ReactTestComponent: Ul
} = ao, Jo = [
  Ul,
  Vl,
  zl,
  ql,
  Wl,
  Ll
];
function Qe(e, t = 10, { maxLength: n, ...o } = {}) {
  const r = n ?? 1e4;
  let s;
  try {
    s = Xe(e, {
      maxDepth: t,
      escapeString: !1,
      // min: true,
      plugins: Jo,
      ...o
    });
  } catch {
    s = Xe(e, {
      callToJSON: !1,
      maxDepth: t,
      escapeString: !1,
      // min: true,
      plugins: Jo,
      ...o
    });
  }
  return s.length >= r && t > 1 ? Qe(e, Math.floor(t / 2)) : s;
}
const Kl = /%[sdjifoOcj%]/g;
function ua(...e) {
  if (typeof e[0] != "string") {
    const s = [];
    for (let i = 0; i < e.length; i++)
      s.push(Rt(e[i], { depth: 0, colors: !1, compact: 3 }));
    return s.join(" ");
  }
  const t = e.length;
  let n = 1;
  const o = e[0];
  let r = String(o).replace(Kl, (s) => {
    if (s === "%%")
      return "%";
    if (n >= t)
      return s;
    switch (s) {
      case "%s": {
        const i = e[n++];
        return typeof i == "bigint" ? `${i.toString()}n` : typeof i == "number" && i === 0 && 1 / i < 0 ? "-0" : typeof i == "object" && i !== null ? Rt(i, { depth: 0, colors: !1, compact: 3 }) : String(i);
      }
      case "%d": {
        const i = e[n++];
        return typeof i == "bigint" ? `${i.toString()}n` : Number(i).toString();
      }
      case "%i": {
        const i = e[n++];
        return typeof i == "bigint" ? `${i.toString()}n` : Number.parseInt(String(i)).toString();
      }
      case "%f":
        return Number.parseFloat(String(e[n++])).toString();
      case "%o":
        return Rt(e[n++], { showHidden: !0, showProxy: !0 });
      case "%O":
        return Rt(e[n++]);
      case "%c":
        return n++, "";
      case "%j":
        try {
          return JSON.stringify(e[n++]);
        } catch (i) {
          const a = i.message;
          if (
            // chromium
            a.includes("circular structure") || a.includes("cyclic structures") || a.includes("cyclic object")
          )
            return "[Circular]";
          throw i;
        }
      default:
        return s;
    }
  });
  for (let s = e[n]; n < t; s = e[++n])
    s === null || typeof s != "object" ? r += ` ${s}` : r += ` ${Rt(s)}`;
  return r;
}
function Rt(e, t = {}) {
  return t.truncate === 0 && (t.truncate = Number.POSITIVE_INFINITY), ca.inspect(e, t);
}
function Gl(e, t = {}) {
  typeof t.truncate > "u" && (t.truncate = 40);
  const n = Rt(e, t), o = Object.prototype.toString.call(e);
  if (t.truncate && n.length >= t.truncate)
    if (o === "[object Function]") {
      const r = e;
      return !r.name || r.name === "" ? "[Function]" : `[Function: ${r.name}]`;
    } else {
      if (o === "[object Array]")
        return `[ Array(${e.length}) ]`;
      if (o === "[object Object]") {
        const r = Object.keys(e);
        return `{ Object (${r.length > 2 ? `${r.splice(0, 2).join(", ")}, ...` : r.join(", ")}) }`;
      } else
        return n;
    }
  return n;
}
const Yo = Symbol("vitest:SAFE_TIMERS"), Jl = Symbol("vitest:SAFE_COLORS"), Yl = {
  bold: ["\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"],
  dim: ["\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"],
  italic: ["\x1B[3m", "\x1B[23m"],
  underline: ["\x1B[4m", "\x1B[24m"],
  inverse: ["\x1B[7m", "\x1B[27m"],
  hidden: ["\x1B[8m", "\x1B[28m"],
  strikethrough: ["\x1B[9m", "\x1B[29m"],
  black: ["\x1B[30m", "\x1B[39m"],
  red: ["\x1B[31m", "\x1B[39m"],
  green: ["\x1B[32m", "\x1B[39m"],
  yellow: ["\x1B[33m", "\x1B[39m"],
  blue: ["\x1B[34m", "\x1B[39m"],
  magenta: ["\x1B[35m", "\x1B[39m"],
  cyan: ["\x1B[36m", "\x1B[39m"],
  white: ["\x1B[37m", "\x1B[39m"],
  gray: ["\x1B[90m", "\x1B[39m"],
  bgBlack: ["\x1B[40m", "\x1B[49m"],
  bgRed: ["\x1B[41m", "\x1B[49m"],
  bgGreen: ["\x1B[42m", "\x1B[49m"],
  bgYellow: ["\x1B[43m", "\x1B[49m"],
  bgBlue: ["\x1B[44m", "\x1B[49m"],
  bgMagenta: ["\x1B[45m", "\x1B[49m"],
  bgCyan: ["\x1B[46m", "\x1B[49m"],
  bgWhite: ["\x1B[47m", "\x1B[49m"]
}, Hl = Object.entries(Yl);
function uo(e) {
  return String(e);
}
uo.open = "";
uo.close = "";
const Xl = /* @__PURE__ */ Hl.reduce((e, [t]) => (e[t] = uo, e), { isColorSupported: !1 });
function lo() {
  return globalThis[Jl] || Xl;
}
function Qn() {
  const {
    setTimeout: e,
    setInterval: t,
    clearInterval: n,
    clearTimeout: o,
    setImmediate: r,
    clearImmediate: s
  } = globalThis[Yo] || globalThis, {
    nextTick: i
  } = globalThis[Yo] || globalThis.process || { nextTick: (a) => a() };
  return {
    nextTick: i,
    setTimeout: e,
    setInterval: t,
    clearInterval: n,
    clearTimeout: o,
    setImmediate: r,
    clearImmediate: s
  };
}
function Ql(e) {
  const { message: t = "error", stackTraceLimit: n = 1 } = e || {}, o = Error.stackTraceLimit, r = Error.prepareStackTrace;
  Error.stackTraceLimit = n, Error.prepareStackTrace = (a) => a.stack;
  const i = new Error(t).stack || "";
  return Error.prepareStackTrace = r, Error.stackTraceLimit = o, i;
}
var la;
la = /\r?\n|[\r\u2028\u2029]/y;
RegExp(la.source);
var fa = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(fa.keyword);
new Set(fa.strict);
var pa = {};
Object.defineProperty(pa, "__esModule", {
  value: !0
});
var Ho = pa.default = nf;
const un = "diff-sequences", je = 0, dn = (e, t, n, o, r) => {
  let s = 0;
  for (; e < t && n < o && r(e, n); )
    e += 1, n += 1, s += 1;
  return s;
}, yn = (e, t, n, o, r) => {
  let s = 0;
  for (; e <= t && n <= o && r(t, o); )
    t -= 1, o -= 1, s += 1;
  return s;
}, br = (e, t, n, o, r, s, i) => {
  let a = 0, c = -e, l = s[a], f = l;
  s[a] += dn(
    l + 1,
    t,
    o + l - c + 1,
    n,
    r
  );
  const u = e < i ? e : i;
  for (a += 1, c += 2; a <= u; a += 1, c += 2) {
    if (a !== e && f < s[a])
      l = s[a];
    else if (l = f + 1, t <= l)
      return a - 1;
    f = s[a], s[a] = l + dn(l + 1, t, o + l - c + 1, n, r);
  }
  return i;
}, Xo = (e, t, n, o, r, s, i) => {
  let a = 0, c = e, l = s[a], f = l;
  s[a] -= yn(
    t,
    l - 1,
    n,
    o + l - c - 1,
    r
  );
  const u = e < i ? e : i;
  for (a += 1, c -= 2; a <= u; a += 1, c -= 2) {
    if (a !== e && s[a] < f)
      l = s[a];
    else if (l = f - 1, l < t)
      return a - 1;
    f = s[a], s[a] = l - yn(
      t,
      l - 1,
      n,
      o + l - c - 1,
      r
    );
  }
  return i;
}, Zl = (e, t, n, o, r, s, i, a, c, l, f) => {
  const u = o - t, p = n - t, b = r - o - p, v = -b - (e - 1), h = -b + (e - 1);
  let A = je;
  const M = e < a ? e : a;
  for (let F = 0, k = -e; F <= M; F += 1, k += 2) {
    const N = F === 0 || F !== e && A < i[F], U = N ? i[F] : A, B = N ? U : U + 1, G = u + B - k, ae = dn(
      B + 1,
      n,
      G + 1,
      r,
      s
    ), V = B + ae;
    if (A = i[F], i[F] = V, v <= k && k <= h) {
      const Ee = (e - 1 - (k + b)) / 2;
      if (Ee <= l && c[Ee] - 1 <= V) {
        const be = u + U - (N ? k + 1 : k - 1), Se = yn(
          t,
          U,
          o,
          be,
          s
        ), Me = U - Se, Fe = be - Se, Pe = Me + 1, Ne = Fe + 1;
        f.nChangePreceding = e - 1, e - 1 === Pe + Ne - t - o ? (f.aEndPreceding = t, f.bEndPreceding = o) : (f.aEndPreceding = Pe, f.bEndPreceding = Ne), f.nCommonPreceding = Se, Se !== 0 && (f.aCommonPreceding = Pe, f.bCommonPreceding = Ne), f.nCommonFollowing = ae, ae !== 0 && (f.aCommonFollowing = B + 1, f.bCommonFollowing = G + 1);
        const De = V + 1, m = G + ae + 1;
        return f.nChangeFollowing = e - 1, e - 1 === n + r - De - m ? (f.aStartFollowing = n, f.bStartFollowing = r) : (f.aStartFollowing = De, f.bStartFollowing = m), !0;
      }
    }
  }
  return !1;
}, ef = (e, t, n, o, r, s, i, a, c, l, f) => {
  const u = r - n, p = n - t, b = r - o - p, v = b - e, h = b + e;
  let A = je;
  const M = e < l ? e : l;
  for (let F = 0, k = e; F <= M; F += 1, k -= 2) {
    const N = F === 0 || F !== e && c[F] < A, U = N ? c[F] : A, B = N ? U : U - 1, G = u + B - k, ae = yn(
      t,
      B - 1,
      o,
      G - 1,
      s
    ), V = B - ae;
    if (A = c[F], c[F] = V, v <= k && k <= h) {
      const Ee = (e + (k - b)) / 2;
      if (Ee <= a && V - 1 <= i[Ee]) {
        const be = G - ae;
        if (f.nChangePreceding = e, e === V + be - t - o ? (f.aEndPreceding = t, f.bEndPreceding = o) : (f.aEndPreceding = V, f.bEndPreceding = be), f.nCommonPreceding = ae, ae !== 0 && (f.aCommonPreceding = V, f.bCommonPreceding = be), f.nChangeFollowing = e - 1, e === 1)
          f.nCommonFollowing = 0, f.aStartFollowing = n, f.bStartFollowing = r;
        else {
          const Se = u + U - (N ? k - 1 : k + 1), Me = dn(
            U,
            n,
            Se,
            r,
            s
          );
          f.nCommonFollowing = Me, Me !== 0 && (f.aCommonFollowing = U, f.bCommonFollowing = Se);
          const Fe = U + Me, Pe = Se + Me;
          e - 1 === n + r - Fe - Pe ? (f.aStartFollowing = n, f.bStartFollowing = r) : (f.aStartFollowing = Fe, f.bStartFollowing = Pe);
        }
        return !0;
      }
    }
  }
  return !1;
}, tf = (e, t, n, o, r, s, i, a, c) => {
  const l = o - t, f = r - n, u = n - t, p = r - o, w = p - u;
  let b = u, v = u;
  if (i[0] = t - 1, a[0] = n, w % 2 === 0) {
    const h = (e || w) / 2, A = (u + p) / 2;
    for (let M = 1; M <= A; M += 1)
      if (b = br(M, n, r, l, s, i, b), M < h)
        v = Xo(M, t, o, f, s, a, v);
      else if (
        // If a reverse path overlaps a forward path in the same diagonal,
        // return a division of the index intervals at the middle change.
        ef(
          M,
          t,
          n,
          o,
          r,
          s,
          i,
          b,
          a,
          v,
          c
        )
      )
        return;
  } else {
    const h = ((e || w) + 1) / 2, A = (u + p + 1) / 2;
    let M = 1;
    for (b = br(M, n, r, l, s, i, b), M += 1; M <= A; M += 1)
      if (v = Xo(
        M - 1,
        t,
        o,
        f,
        s,
        a,
        v
      ), M < h)
        b = br(M, n, r, l, s, i, b);
      else if (
        // If a forward path overlaps a reverse path in the same diagonal,
        // return a division of the index intervals at the middle change.
        Zl(
          M,
          t,
          n,
          o,
          r,
          s,
          i,
          b,
          a,
          v,
          c
        )
      )
        return;
  }
  throw new Error(
    `${un}: no overlap aStart=${t} aEnd=${n} bStart=${o} bEnd=${r}`
  );
}, Ur = (e, t, n, o, r, s, i, a, c, l) => {
  if (r - o < n - t) {
    if (s = !s, s && i.length === 1) {
      const { foundSubsequence: V, isCommon: Ee } = i[0];
      i[1] = {
        foundSubsequence: (be, Se, Me) => {
          V(be, Me, Se);
        },
        isCommon: (be, Se) => Ee(Se, be)
      };
    }
    const G = t, ae = n;
    t = o, n = r, o = G, r = ae;
  }
  const { foundSubsequence: f, isCommon: u } = i[s ? 1 : 0];
  tf(
    e,
    t,
    n,
    o,
    r,
    u,
    a,
    c,
    l
  );
  const {
    nChangePreceding: p,
    aEndPreceding: w,
    bEndPreceding: b,
    nCommonPreceding: v,
    aCommonPreceding: h,
    bCommonPreceding: A,
    nCommonFollowing: M,
    aCommonFollowing: F,
    bCommonFollowing: k,
    nChangeFollowing: N,
    aStartFollowing: U,
    bStartFollowing: B
  } = l;
  t < w && o < b && Ur(
    p,
    t,
    w,
    o,
    b,
    s,
    i,
    a,
    c,
    l
  ), v !== 0 && f(v, h, A), M !== 0 && f(M, F, k), U < n && B < r && Ur(
    N,
    U,
    n,
    B,
    r,
    s,
    i,
    a,
    c,
    l
  );
}, Qo = (e, t) => {
  if (typeof t != "number")
    throw new TypeError(`${un}: ${e} typeof ${typeof t} is not a number`);
  if (!Number.isSafeInteger(t))
    throw new RangeError(`${un}: ${e} value ${t} is not a safe integer`);
  if (t < 0)
    throw new RangeError(`${un}: ${e} value ${t} is a negative integer`);
}, Zo = (e, t) => {
  const n = typeof t;
  if (n !== "function")
    throw new TypeError(`${un}: ${e} typeof ${n} is not a function`);
};
function nf(e, t, n, o) {
  Qo("aLength", e), Qo("bLength", t), Zo("isCommon", n), Zo("foundSubsequence", o);
  const r = dn(0, e, 0, t, n);
  if (r !== 0 && o(r, 0, 0), e !== r || t !== r) {
    const s = r, i = r, a = yn(
      s,
      e - 1,
      i,
      t - 1,
      n
    ), c = e - a, l = t - a, f = r + a;
    e !== f && t !== f && Ur(
      0,
      s,
      c,
      i,
      l,
      !1,
      [
        {
          foundSubsequence: o,
          isCommon: n
        }
      ],
      [je],
      [je],
      {
        aCommonFollowing: je,
        aCommonPreceding: je,
        aEndPreceding: je,
        aStartFollowing: je,
        bCommonFollowing: je,
        bCommonPreceding: je,
        bEndPreceding: je,
        bStartFollowing: je,
        nChangeFollowing: je,
        nChangePreceding: je,
        nCommonFollowing: je,
        nCommonPreceding: je
      }
    ), a !== 0 && o(a, c, l);
  }
}
function es(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  if (Array.isArray(e))
    return "array";
  if (typeof e == "boolean")
    return "boolean";
  if (typeof e == "function")
    return "function";
  if (typeof e == "number")
    return "number";
  if (typeof e == "string")
    return "string";
  if (typeof e == "bigint")
    return "bigint";
  if (typeof e == "object") {
    if (e != null) {
      if (e.constructor === RegExp)
        return "regexp";
      if (e.constructor === Map)
        return "map";
      if (e.constructor === Set)
        return "set";
      if (e.constructor === Date)
        return "date";
    }
    return "object";
  } else if (typeof e == "symbol")
    return "symbol";
  throw new Error(`value of unknown type: ${e}`);
}
const Wt = -1, Vt = 1, Dn = 0;
class nn {
  constructor(t, n) {
    se(this, 0);
    se(this, 1);
    this[0] = t, this[1] = n;
  }
}
const ha = "Compared values have no visual difference.", rf = "Compared values serialize to the same structure.\nPrinting internal object structure without calling `toJSON` instead.";
function of(e, t) {
  return e.replace(/\s+$/, (n) => t(n));
}
function fo(e, t, n, o, r, s) {
  return e.length !== 0 ? n(
    `${o} ${of(e, r)}`
  ) : o !== " " ? n(o) : t && s.length !== 0 ? n(`${o} ${s}`) : "";
}
function ma(e, t, {
  aColor: n,
  aIndicator: o,
  changeLineTrailingSpaceColor: r,
  emptyFirstOrLastLinePlaceholder: s
}) {
  return fo(
    e,
    t,
    n,
    o,
    r,
    s
  );
}
function da(e, t, {
  bColor: n,
  bIndicator: o,
  changeLineTrailingSpaceColor: r,
  emptyFirstOrLastLinePlaceholder: s
}) {
  return fo(
    e,
    t,
    n,
    o,
    r,
    s
  );
}
function ya(e, t, {
  commonColor: n,
  commonIndicator: o,
  commonLineTrailingSpaceColor: r,
  emptyFirstOrLastLinePlaceholder: s
}) {
  return fo(
    e,
    t,
    n,
    o,
    r,
    s
  );
}
function ts(e, t, n, o, { patchColor: r }) {
  return r(
    `@@ -${e + 1},${t - e} +${n + 1},${o - n} @@`
  );
}
function sf(e, t) {
  const n = e.length, o = t.contextLines, r = o + o;
  let s = n, i = !1, a = 0, c = 0;
  for (; c !== n; ) {
    const k = c;
    for (; c !== n && e[c][0] === Dn; )
      c += 1;
    if (k !== c)
      if (k === 0)
        c > o && (s -= c - o, i = !0);
      else if (c === n) {
        const N = c - k;
        N > o && (s -= N - o, i = !0);
      } else {
        const N = c - k;
        N > r && (s -= N - r, a += 1);
      }
    for (; c !== n && e[c][0] !== Dn; )
      c += 1;
  }
  const l = a !== 0 || i;
  a !== 0 ? s += a + 1 : i && (s += 1);
  const f = s - 1, u = [];
  let p = 0;
  l && u.push("");
  let w = 0, b = 0, v = 0, h = 0;
  const A = (k) => {
    const N = u.length;
    u.push(ya(k, N === 0 || N === f, t)), v += 1, h += 1;
  }, M = (k) => {
    const N = u.length;
    u.push(ma(k, N === 0 || N === f, t)), v += 1;
  }, F = (k) => {
    const N = u.length;
    u.push(da(k, N === 0 || N === f, t)), h += 1;
  };
  for (c = 0; c !== n; ) {
    let k = c;
    for (; c !== n && e[c][0] === Dn; )
      c += 1;
    if (k !== c)
      if (k === 0) {
        c > o && (k = c - o, w = k, b = k, v = w, h = b);
        for (let N = k; N !== c; N += 1)
          A(e[N][1]);
      } else if (c === n) {
        const N = c - k > o ? k + o : c;
        for (let U = k; U !== N; U += 1)
          A(e[U][1]);
      } else {
        const N = c - k;
        if (N > r) {
          const U = k + o;
          for (let G = k; G !== U; G += 1)
            A(e[G][1]);
          u[p] = ts(
            w,
            v,
            b,
            h,
            t
          ), p = u.length, u.push("");
          const B = N - r;
          w = v + B, b = h + B, v = w, h = b;
          for (let G = c - o; G !== c; G += 1)
            A(e[G][1]);
        } else
          for (let U = k; U !== c; U += 1)
            A(e[U][1]);
      }
    for (; c !== n && e[c][0] === Wt; )
      M(e[c][1]), c += 1;
    for (; c !== n && e[c][0] === Vt; )
      F(e[c][1]), c += 1;
  }
  return l && (u[p] = ts(w, v, b, h, t)), u.join(`
`);
}
function af(e, t) {
  return e.map((n, o, r) => {
    const s = n[1], i = o === 0 || o === r.length - 1;
    switch (n[0]) {
      case Wt:
        return ma(s, i, t);
      case Vt:
        return da(s, i, t);
      default:
        return ya(s, i, t);
    }
  }).join(`
`);
}
const ns = (e) => e, ga = 5;
function cf() {
  const e = lo();
  return {
    aAnnotation: "Expected",
    aColor: e.green,
    aIndicator: "-",
    bAnnotation: "Received",
    bColor: e.red,
    bIndicator: "+",
    changeColor: e.inverse,
    changeLineTrailingSpaceColor: ns,
    commonColor: e.dim,
    commonIndicator: " ",
    commonLineTrailingSpaceColor: ns,
    compareKeys: void 0,
    contextLines: ga,
    emptyFirstOrLastLinePlaceholder: "",
    expand: !0,
    includeChangeCounts: !1,
    omitAnnotationLines: !1,
    patchColor: e.yellow
  };
}
function uf(e) {
  return e && typeof e == "function" ? e : void 0;
}
function lf(e) {
  return typeof e == "number" && Number.isSafeInteger(e) && e >= 0 ? e : ga;
}
function En(e = {}) {
  return {
    ...cf(),
    ...e,
    compareKeys: uf(e.compareKeys),
    contextLines: lf(e.contextLines)
  };
}
function Dt(e) {
  return e.length === 1 && e[0].length === 0;
}
function ff(e) {
  let t = 0, n = 0;
  return e.forEach((o) => {
    switch (o[0]) {
      case Wt:
        t += 1;
        break;
      case Vt:
        n += 1;
        break;
    }
  }), { a: t, b: n };
}
function pf({
  aAnnotation: e,
  aColor: t,
  aIndicator: n,
  bAnnotation: o,
  bColor: r,
  bIndicator: s,
  includeChangeCounts: i,
  omitAnnotationLines: a
}, c) {
  if (a)
    return "";
  let l = "", f = "";
  if (i) {
    const w = String(c.a), b = String(c.b), v = o.length - e.length, h = " ".repeat(Math.max(0, v)), A = " ".repeat(Math.max(0, -v)), M = b.length - w.length, F = " ".repeat(Math.max(0, M)), k = " ".repeat(Math.max(0, -M));
    l = `${h}  ${n} ${F}${w}`, f = `${A}  ${s} ${k}${b}`;
  }
  const u = `${n} ${e}${l}`, p = `${s} ${o}${f}`;
  return `${t(u)}
${r(p)}

`;
}
function ba(e, t) {
  return pf(t, ff(e)) + (t.expand ? af(e, t) : sf(e, t));
}
function po(e, t, n) {
  return ba(
    wa(
      Dt(e) ? [] : e,
      Dt(t) ? [] : t
    ),
    En(n)
  );
}
function hf(e, t, n, o, r) {
  if (Dt(e) && Dt(n) && (e = [], n = []), Dt(t) && Dt(o) && (t = [], o = []), e.length !== n.length || t.length !== o.length)
    return po(e, t, r);
  const s = wa(n, o);
  let i = 0, a = 0;
  return s.forEach((c) => {
    switch (c[0]) {
      case Wt:
        c[1] = e[i], i += 1;
        break;
      case Vt:
        c[1] = t[a], a += 1;
        break;
      default:
        c[1] = t[a], i += 1, a += 1;
    }
  }), ba(s, En(r));
}
function wa(e, t) {
  const n = e.length, o = t.length, r = (f, u) => e[f] === t[u], s = [];
  let i = 0, a = 0;
  const c = (f, u, p) => {
    for (; i !== u; i += 1)
      s.push(new nn(Wt, e[i]));
    for (; a !== p; a += 1)
      s.push(new nn(Vt, t[a]));
    for (; f !== 0; f -= 1, i += 1, a += 1)
      s.push(new nn(Dn, t[a]));
  };
  for ((Ho.default || Ho)(n, o, r, c); i !== n; i += 1)
    s.push(new nn(Wt, e[i]));
  for (; a !== o; a += 1)
    s.push(new nn(Vt, t[a]));
  return s;
}
function Kr(e, t) {
  const { commonColor: n } = En(t);
  return n(e);
}
const {
  AsymmetricMatcher: mf,
  DOMCollection: df,
  DOMElement: yf,
  Immutable: gf,
  ReactElement: bf,
  ReactTestComponent: wf
} = ao, va = [
  wf,
  bf,
  yf,
  df,
  gf,
  mf
], Gr = {
  plugins: va
}, Ea = {
  callToJSON: !1,
  maxDepth: 10,
  plugins: va
};
function gn(e, t, n) {
  if (Object.is(e, t))
    return "";
  const o = es(e);
  let r = o, s = !1;
  if (o === "object" && typeof e.asymmetricMatch == "function") {
    if (e.$$typeof !== Symbol.for("jest.asymmetricMatcher") || typeof e.getExpectedType != "function")
      return null;
    r = e.getExpectedType(), s = r === "string";
  }
  if (r !== es(t)) {
    const { aAnnotation: i, aColor: a, aIndicator: c, bAnnotation: l, bColor: f, bIndicator: u } = En(n), p = Jr(Ea, n), w = Xe(e, p), b = Xe(t, p), v = `${a(`${c} ${i}:`)} 
${w}`, h = `${f(`${u} ${l}:`)} 
${b}`;
    return `${v}

${h}`;
  }
  if (s)
    return null;
  switch (o) {
    case "string":
      return po(e.split(`
`), t.split(`
`), n);
    case "boolean":
    case "number":
      return vf(e, t, n);
    case "map":
      return wr(rs(e), rs(t), n);
    case "set":
      return wr(os(e), os(t), n);
    default:
      return wr(e, t, n);
  }
}
function vf(e, t, n) {
  const o = Xe(e, Gr), r = Xe(t, Gr);
  return o === r ? "" : po(o.split(`
`), r.split(`
`), n);
}
function rs(e) {
  return new Map(Array.from(e.entries()).sort());
}
function os(e) {
  return new Set(Array.from(e.values()).sort());
}
function wr(e, t, n) {
  let o, r = !1;
  try {
    const i = Jr(Gr, n);
    o = ss(e, t, i, n);
  } catch {
    r = !0;
  }
  const s = Kr(ha, n);
  if (o === void 0 || o === s) {
    const i = Jr(Ea, n);
    o = ss(e, t, i, n), o !== s && !r && (o = `${Kr(
      rf,
      n
    )}

${o}`);
  }
  return o;
}
function Jr(e, t) {
  const { compareKeys: n } = En(t);
  return {
    ...e,
    compareKeys: n
  };
}
function ss(e, t, n, o) {
  const r = { ...n, indent: 0 }, s = Xe(e, r), i = Xe(t, r);
  if (s === i)
    return Kr(ha, o);
  {
    const a = Xe(e, n), c = Xe(t, n);
    return hf(
      a.split(`
`),
      c.split(`
`),
      s.split(`
`),
      i.split(`
`),
      o
    );
  }
}
const Ef = "@@__IMMUTABLE_RECORD__@@", Sf = "@@__IMMUTABLE_ITERABLE__@@";
function Tf(e) {
  return e && (e[Sf] || e[Ef]);
}
const xf = Object.getPrototypeOf({});
function is(e) {
  return e instanceof Error ? `<unserializable>: ${e.message}` : typeof e == "string" ? `<unserializable>: ${e}` : "<unserializable>";
}
function ln(e, t = /* @__PURE__ */ new WeakMap()) {
  if (!e || typeof e == "string")
    return e;
  if (typeof e == "function")
    return `Function<${e.name || "anonymous"}>`;
  if (typeof e == "symbol")
    return e.toString();
  if (typeof e != "object")
    return e;
  if (Tf(e))
    return ln(e.toJSON(), t);
  if (e instanceof Promise || e.constructor && e.constructor.prototype === "AsyncFunction")
    return "Promise";
  if (typeof Element < "u" && e instanceof Element)
    return e.tagName;
  if (typeof e.asymmetricMatch == "function")
    return `${e.toString()} ${ua(e.sample)}`;
  if (t.has(e))
    return t.get(e);
  if (Array.isArray(e)) {
    const n = new Array(e.length);
    return t.set(e, n), e.forEach((o, r) => {
      try {
        n[r] = ln(o, t);
      } catch (s) {
        n[r] = is(s);
      }
    }), n;
  } else {
    const n = /* @__PURE__ */ Object.create(null);
    t.set(e, n);
    let o = e;
    for (; o && o !== xf; )
      Object.getOwnPropertyNames(o).forEach((r) => {
        if (!(r in n))
          try {
            n[r] = ln(e[r], t);
          } catch (s) {
            delete n[r], n[r] = is(s);
          }
      }), o = Object.getPrototypeOf(o);
    return n;
  }
}
function as(e) {
  return e.replace(/__(vite_ssr_import|vi_import)_\d+__\./g, "");
}
function $f(e, t) {
  if (!e || typeof e != "object")
    return { message: e };
  if (e.stack && (e.stackStr = String(e.stack)), e.name && (e.nameStr = String(e.name)), e.showDiff || e.showDiff === void 0 && e.expected !== void 0 && e.actual !== void 0) {
    const n = jo(e.actual, { forceWritable: !0 }), o = jo(e.expected, { forceWritable: !0 }), { replacedActual: r, replacedExpected: s } = Sa(n, o);
    e.diff = gn(s, r, { ...t, ...e.diffOptions });
  }
  typeof e.expected != "string" && (e.expected = Qe(e.expected, 10)), typeof e.actual != "string" && (e.actual = Qe(e.actual, 10));
  try {
    typeof e.message == "string" && (e.message = as(e.message)), typeof e.cause == "object" && typeof e.cause.message == "string" && (e.cause.message = as(e.cause.message));
  } catch {
  }
  try {
    return ln(e);
  } catch (n) {
    return ln(new Error(`Failed to fully serialize error: ${n == null ? void 0 : n.message}
Inner error message: ${e == null ? void 0 : e.message}`));
  }
}
function cs(e) {
  return Wn(e) === "Object" && typeof e.asymmetricMatch == "function";
}
function us(e, t) {
  const n = Wn(e), o = Wn(t);
  return n === o && (n === "Object" || n === "Array");
}
function Sa(e, t, n = /* @__PURE__ */ new WeakSet(), o = /* @__PURE__ */ new WeakSet()) {
  return us(e, t) ? n.has(e) || o.has(t) ? { replacedActual: e, replacedExpected: t } : (n.add(e), o.add(t), Mi(t).forEach((r) => {
    const s = t[r], i = e[r];
    if (cs(s))
      s.asymmetricMatch(i) && (e[r] = s);
    else if (cs(i))
      i.asymmetricMatch(s) && (t[r] = i);
    else if (us(i, s)) {
      const a = Sa(
        i,
        s,
        n,
        o
      );
      e[r] = a.replacedActual, t[r] = a.replacedExpected;
    }
  }), {
    replacedActual: e,
    replacedExpected: t
  }) : { replacedActual: e, replacedExpected: t };
}
function Ta(e, t) {
  function n(r) {
    const s = function(...i) {
      return t.apply(r, i);
    };
    Object.assign(s, t), s.withContext = () => s.bind(r), s.setContext = (i, a) => {
      r[i] = a;
    }, s.mergeContext = (i) => {
      Object.assign(r, i);
    };
    for (const i of e)
      Object.defineProperty(s, i, {
        get() {
          return n({ ...r, [i]: !0 });
        }
      });
    return s;
  }
  const o = n({});
  return o.fn = t, o;
}
function xa(e) {
  const t = [e.name];
  let n = e;
  for (; n != null && n.suite || n != null && n.file; )
    n = n.suite || n.file, n != null && n.name && t.unshift(n.name);
  return t;
}
const Of = /^[A-Za-z]:\//;
function Af(e = "") {
  return e && e.replace(/\\/g, "/").replace(Of, (t) => t.toUpperCase());
}
const _f = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function Mf() {
  return typeof process < "u" && typeof process.cwd == "function" ? process.cwd().replace(/\\/g, "/") : "/";
}
const Pf = function(...e) {
  e = e.map((o) => Af(o));
  let t = "", n = !1;
  for (let o = e.length - 1; o >= -1 && !n; o--) {
    const r = o >= 0 ? e[o] : Mf();
    !r || r.length === 0 || (t = `${r}/${t}`, n = ls(r));
  }
  return t = If(t, !n), n && !ls(t) ? `/${t}` : t.length > 0 ? t : ".";
};
function If(e, t) {
  let n = "", o = 0, r = -1, s = 0, i = null;
  for (let a = 0; a <= e.length; ++a) {
    if (a < e.length)
      i = e[a];
    else {
      if (i === "/")
        break;
      i = "/";
    }
    if (i === "/") {
      if (!(r === a - 1 || s === 1))
        if (s === 2) {
          if (n.length < 2 || o !== 2 || n[n.length - 1] !== "." || n[n.length - 2] !== ".") {
            if (n.length > 2) {
              const c = n.lastIndexOf("/");
              c === -1 ? (n = "", o = 0) : (n = n.slice(0, c), o = n.length - 1 - n.lastIndexOf("/")), r = a, s = 0;
              continue;
            } else if (n.length > 0) {
              n = "", o = 0, r = a, s = 0;
              continue;
            }
          }
          t && (n += n.length > 0 ? "/.." : "..", o = 2);
        } else
          n.length > 0 ? n += `/${e.slice(r + 1, a)}` : n = e.slice(r + 1, a), o = a - r - 1;
      r = a, s = 0;
    } else
      i === "." && s !== -1 ? ++s : s = -1;
  }
  return n;
}
const ls = function(e) {
  return _f.test(e);
}, Cf = /* @__PURE__ */ new WeakMap(), $a = /* @__PURE__ */ new WeakMap(), Oa = /* @__PURE__ */ new WeakMap();
function Nf(e, t) {
  Cf.set(e, t);
}
function jf(e, t) {
  $a.set(e, t);
}
function kf(e) {
  return $a.get(e);
}
function Rf(e, t) {
  Oa.set(e, t);
}
function Ff(e) {
  return Oa.get(e);
}
class Df extends Error {
  constructor(n, o) {
    super(n);
    se(this, "code", "VITEST_PENDING");
    se(this, "taskId");
    this.message = n, this.taskId = o.id;
  }
}
const fn = {
  tasks: [],
  currentSuite: null
};
function Bf(e) {
  var t;
  (t = fn.currentSuite) == null || t.tasks.push(e);
}
async function Lf(e, t) {
  const n = fn.currentSuite;
  fn.currentSuite = e, await t(), fn.currentSuite = n;
}
function Aa(e, t, n = !1) {
  if (t <= 0 || t === Number.POSITIVE_INFINITY)
    return e;
  const { setTimeout: o, clearTimeout: r } = Qn();
  return (...s) => Promise.race([e(...s), new Promise((i, a) => {
    var c;
    const l = o(() => {
      r(l), a(new Error(zf(n, t)));
    }, t);
    (c = l.unref) == null || c.call(l);
  })]);
}
function qf(e, t) {
  var n;
  const o = function() {
    throw new Error("done() callback is deprecated, use promise instead");
  };
  return o.task = e, o.skip = () => {
    throw e.pending = !0, new Df("test is skipped; abort execution", e);
  }, o.onTestFailed = (r) => {
    e.onFailed || (e.onFailed = []), e.onFailed.push(r);
  }, o.onTestFinished = (r) => {
    e.onFinished || (e.onFinished = []), e.onFinished.push(r);
  }, ((n = t.extendTaskContext) == null ? void 0 : n.call(t, o)) || o;
}
function zf(e, t) {
  return `${e ? "Hook" : "Test"} timed out in ${t}ms.
If this is a long-running ${e ? "hook" : "test"}, pass a timeout value as the last argument or configure it globally with "${e ? "hookTimeout" : "testTimeout"}".`;
}
function Wf(e, t = {}) {
  const n = ["auto"], o = Object.entries(e).map(([r, s]) => {
    const i = { value: s };
    return Array.isArray(s) && s.length >= 2 && oo(s[1]) && Object.keys(s[1]).some((a) => n.includes(a)) && (Object.assign(i, s[1]), i.value = s[0]), i.prop = r, i.isFn = typeof i.value == "function", i;
  });
  return Array.isArray(t.fixtures) ? t.fixtures = t.fixtures.concat(o) : t.fixtures = o, o.forEach((r) => {
    if (r.isFn) {
      const s = Pa(r.value);
      s.length && (r.deps = t.fixtures.filter(({ prop: i }) => i !== r.prop && s.includes(i)));
    }
  }), t;
}
const vr = /* @__PURE__ */ new Map(), Er = /* @__PURE__ */ new Map();
function _a(e, t) {
  return (n) => {
    const o = n || t;
    if (!o)
      return e({});
    const r = kf(o);
    if (!(r != null && r.length))
      return e(o);
    const s = Pa(e), i = r.some(({ auto: p }) => p);
    if (!s.length && !i)
      return e(o);
    vr.get(o) || vr.set(o, /* @__PURE__ */ new Map());
    const a = vr.get(o);
    Er.has(o) || Er.set(o, []);
    const c = Er.get(o), l = r.filter(({ prop: p, auto: w }) => w || s.includes(p)), f = Ma(l);
    if (!f.length)
      return e(o);
    async function u() {
      for (const p of f) {
        if (a.has(p))
          continue;
        const w = p.isFn ? await Vf(p.value, o, c) : p.value;
        o[p.prop] = w, a.set(p, w), c.unshift(() => {
          a.delete(p);
        });
      }
    }
    return u().then(() => e(o));
  };
}
async function Vf(e, t, n) {
  const o = ko();
  let r = !1;
  const s = e(t, async (i) => {
    r = !0, o.resolve(i);
    const a = ko();
    n.push(async () => {
      a.resolve(), await s;
    }), await a;
  }).catch((i) => {
    if (!r) {
      o.reject(i);
      return;
    }
    throw i;
  });
  return o;
}
function Ma(e, t = /* @__PURE__ */ new Set(), n = []) {
  return e.forEach((o) => {
    if (!n.includes(o)) {
      if (!o.isFn || !o.deps) {
        n.push(o);
        return;
      }
      if (t.has(o))
        throw new Error(`Circular fixture dependency detected: ${o.prop} <- ${[...t].reverse().map((r) => r.prop).join(" <- ")}`);
      t.add(o), Ma(o.deps, t, n), n.push(o), t.clear();
    }
  }), n;
}
function Pa(e) {
  const t = e.toString().match(/[^(]*\(([^)]*)/);
  if (!t)
    return [];
  const n = fs(t[1]);
  if (!n.length)
    return [];
  const o = n[0];
  if (!(o.startsWith("{") && o.endsWith("}")))
    throw new Error(`The first argument inside a fixture must use object destructuring pattern, e.g. ({ test } => {}). Instead, received "${o}".`);
  const r = o.slice(1, -1).replace(/\s/g, ""), s = fs(r).map((a) => a.replace(/\:.*|\=.*/g, "")), i = s.at(-1);
  if (i && i.startsWith("..."))
    throw new Error(`Rest parameters are not supported in fixtures, received "${i}".`);
  return s;
}
function fs(e) {
  const t = [], n = [];
  let o = 0;
  for (let s = 0; s < e.length; s++)
    if (e[s] === "{" || e[s] === "[")
      n.push(e[s] === "{" ? "}" : "]");
    else if (e[s] === n[n.length - 1])
      n.pop();
    else if (!n.length && e[s] === ",") {
      const i = e.substring(o, s).trim();
      i && t.push(i), o = s + 1;
    }
  const r = e.substring(o).trim();
  return r && t.push(r), t;
}
let Uf;
function Kf() {
  return Uf;
}
const an = Qf(), Gf = ho(
  function(e, t, n) {
    Zn().test.fn.call(this, Ut(e), t, n);
  }
), Ht = an, _e = Gf;
let cn, Jf;
function Yf() {
  return cn;
}
function Zn() {
  return fn.currentSuite || Jf;
}
function Hf() {
  return {
    beforeAll: [],
    afterAll: [],
    beforeEach: [],
    afterEach: []
  };
}
function Vn(e, t) {
  let n = {}, o = () => {
  };
  if (typeof t == "object") {
    if (typeof e == "object")
      throw new TypeError("Cannot use two objects as arguments. Please provide options and a function callback in that order.");
    n = t;
  } else
    typeof t == "number" ? n = { timeout: t } : typeof e == "object" && (n = e);
  if (typeof e == "function") {
    if (typeof t == "function")
      throw new TypeError("Cannot use two functions as arguments. Please use the second argument for options.");
    o = e;
  } else
    typeof t == "function" && (o = t);
  return {
    options: n,
    handler: o
  };
}
function Xf(e, t = () => {
}, n, o, r, s) {
  const i = [], a = [];
  let c;
  w();
  const l = function(h = "", A = {}) {
    const M = {
      id: "",
      name: h,
      suite: void 0,
      each: A.each,
      fails: A.fails,
      context: void 0,
      type: "custom",
      retry: A.retry ?? cn.config.retry,
      repeats: A.repeats,
      mode: A.only ? "only" : A.skip ? "skip" : A.todo ? "todo" : "run",
      meta: A.meta ?? /* @__PURE__ */ Object.create(null)
    }, F = A.handler;
    (A.concurrent || !A.sequential && cn.config.sequence.concurrent) && (M.concurrent = !0), o && (M.shuffle = !0);
    const k = qf(M, cn);
    return Object.defineProperty(M, "context", {
      value: k,
      enumerable: !1
    }), jf(k, A.fixtures), F && Nf(M, Aa(
      _a(F, k),
      (A == null ? void 0 : A.timeout) ?? cn.config.testTimeout
    )), i.push(M), M;
  }, f = ho(function(h, A, M) {
    let { options: F, handler: k } = Vn(
      A,
      M
    );
    typeof s == "object" && (F = Object.assign({}, s, F)), F.concurrent = this.concurrent || !this.sequential && (F == null ? void 0 : F.concurrent), F.sequential = this.sequential || !this.concurrent && (F == null ? void 0 : F.sequential);
    const N = l(
      Ut(h),
      { ...this, ...F, handler: k }
    );
    N.type = "test";
  }), u = {
    type: "collector",
    name: e,
    mode: n,
    options: s,
    test: f,
    tasks: i,
    collect: v,
    task: l,
    clear: b,
    on: p
  };
  function p(h, ...A) {
    Ff(c)[h].push(...A);
  }
  function w() {
    typeof s == "number" && (s = { timeout: s }), c = {
      id: "",
      type: "suite",
      name: e,
      mode: n,
      each: r,
      shuffle: o,
      tasks: [],
      meta: /* @__PURE__ */ Object.create(null),
      projectName: ""
    }, Rf(c, Hf());
  }
  function b() {
    i.length = 0, a.length = 0, w();
  }
  async function v(h) {
    a.length = 0, t && await Lf(u, () => t(f));
    const A = [];
    for (const M of [...a, ...i])
      A.push(M.type === "collector" ? await M.collect(h) : M);
    return c.file = h, c.tasks = A, A.forEach((M) => {
      M.suite = c, h && (M.file = h);
    }), c;
  }
  return Bf(u), u;
}
function Qf() {
  function e(t, n, o = {}) {
    const r = this.only ? "only" : this.skip ? "skip" : this.todo ? "todo" : "run", s = Zn();
    let { options: i, handler: a } = Vn(
      n,
      o
    );
    return s != null && s.options && (i = { ...s.options, ...i }), i.concurrent = this.concurrent || !this.sequential && (i == null ? void 0 : i.concurrent), i.sequential = this.sequential || !this.concurrent && (i == null ? void 0 : i.sequential), Xf(Ut(t), a, r, this.shuffle, this.each, i);
  }
  return e.each = function(t, ...n) {
    const o = this.withContext();
    return this.setContext("each", !0), Array.isArray(t) && n.length && (t = Ia(t, n)), (r, s, i) => {
      const a = Ut(r), c = t.every(Array.isArray), { options: l, handler: f } = Vn(
        s,
        i
      );
      t.forEach((u, p) => {
        const w = Array.isArray(u) ? u : [u];
        c ? o(Un(a, w, p), l, () => f(...w)) : o(Un(a, w, p), l, () => f(u));
      }), this.setContext("each", void 0);
    };
  }, e.skipIf = (t) => t ? an.skip : an, e.runIf = (t) => t ? an : an.skip, Ta(
    ["concurrent", "sequential", "shuffle", "skip", "only", "todo"],
    e
  );
}
function Zf(e, t) {
  const n = e;
  n.each = function(r, ...s) {
    const i = this.withContext();
    return this.setContext("each", !0), Array.isArray(r) && s.length && (r = Ia(r, s)), (a, c, l) => {
      const f = Ut(a), u = r.every(Array.isArray), { options: p, handler: w } = Vn(
        c,
        l
      );
      r.forEach((b, v) => {
        const h = Array.isArray(b) ? b : [b];
        u ? i(Un(f, h, v), p, () => w(...h)) : i(Un(f, h, v), p, () => w(b));
      }), this.setContext("each", void 0);
    };
  }, n.skipIf = function(r) {
    return r ? this.skip : this;
  }, n.runIf = function(r) {
    return r ? this : this.skip;
  }, n.extend = function(r) {
    const s = Wf(r, t);
    return ho(function(a, c, l) {
      Zn().test.fn.call(this, Ut(a), c, l);
    }, s);
  };
  const o = Ta(
    ["concurrent", "sequential", "skip", "only", "todo", "fails"],
    n
  );
  return t && o.mergeContext(t), o;
}
function ho(e, t) {
  return Zf(e, t);
}
function Ut(e) {
  return typeof e == "string" ? e : e instanceof Function ? e.name || "<anonymous>" : String(e);
}
function Un(e, t, n) {
  e.includes("%#") && (e = e.replace(/%%/g, "__vitest_escaped_%__").replace(/%#/g, `${n}`).replace(/__vitest_escaped_%__/g, "%%"));
  const o = e.split("%").length - 1;
  let r = ua(e, ...t.slice(0, o));
  return oo(t[0]) && (r = r.replace(
    /\$([$\w_.]+)/g,
    // https://github.com/chaijs/chai/pull/1490
    (s, i) => {
      var a, c;
      return Gl(pu(t[0], i), { truncate: (c = (a = void 0) == null ? void 0 : a.chaiConfig) == null ? void 0 : c.truncateThreshold });
    }
  )), r;
}
function Ia(e, t) {
  const n = e.join("").trim().replace(/ /g, "").split(`
`).map((r) => r.split("|"))[0], o = [];
  for (let r = 0; r < Math.floor(t.length / n.length); r++) {
    const s = {};
    for (let i = 0; i < n.length; i++)
      s[n[i]] = t[r * n.length + i];
    o.push(s);
  }
  return o;
}
function ep() {
  return Yf().config.hookTimeout;
}
function mo(e, t) {
  return Zn().on("afterEach", Aa(_a(e), t ?? ep(), !0));
}
function yo() {
  const e = globalThis.__vitest_worker__;
  if (!e) {
    const t = `Vitest failed to access its internal state.

One of the following is possible:
- "vitest" is imported directly without running "vitest" command
- "vitest" is imported inside "globalSetup" (to fix this, use "setupFiles" instead, because "globalSetup" runs in a different context)
- Otherwise, it might be a Vitest bug. Please report it to https://github.com/vitest-dev/vitest/issues
`;
    throw new Error(t);
  }
  return e;
}
function tp() {
  const e = yo();
  return e == null ? void 0 : e.environment.name;
}
var Sr = {};
/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */
/*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */
function Ca() {
  var e = [].slice.call(arguments);
  function t(n, o) {
    Object.keys(o).forEach(function(r) {
      ~e.indexOf(r) || (n[r] = o[r]);
    });
  }
  return function() {
    for (var o = [].slice.call(arguments), r = 0, s = {}; r < o.length; r++)
      t(s, o[r]);
    return s;
  };
}
/*!
 * Primary Exports
 */
var Na = At;
function At(e, t, n) {
  var o = Ca("name", "message", "stack", "constructor", "toJSON"), r = o(t || {});
  this.message = e || "Unspecified AssertionError", this.showDiff = !1;
  for (var s in r)
    this[s] = r[s];
  if (n = n || At, Error.captureStackTrace)
    Error.captureStackTrace(this, n);
  else
    try {
      throw new Error();
    } catch (i) {
      this.stack = i.stack;
    }
}
/*!
 * Inherit from Error.prototype
 */
At.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */
At.prototype.name = "AssertionError";
/*!
 * Ensure correct constructor
 */
At.prototype.constructor = At;
At.prototype.toJSON = function(e) {
  var t = Ca("constructor", "toJSON", "stack"), n = t({ name: this.name }, this);
  return e !== !1 && this.stack && (n.stack = this.stack), n;
};
var fe = {};
function ja(e, t) {
  return typeof e > "u" || e === null ? !1 : t in Object(e);
}
function ka(e) {
  var t = e.replace(/([^\\])\[/g, "$1.["), n = t.match(/(\\\.|[^.]+?)+/g);
  return n.map(function(r) {
    if (r === "constructor" || r === "__proto__" || r === "prototype")
      return {};
    var s = /^\[(\d+)\]$/, i = s.exec(r), a = null;
    return i ? a = { i: parseFloat(i[1]) } : a = { p: r.replace(/\\([.[\]])/g, "$1") }, a;
  });
}
function ps(e, t, n) {
  var o = e, r = null;
  n = typeof n > "u" ? t.length : n;
  for (var s = 0; s < n; s++) {
    var i = t[s];
    o && (typeof i.p > "u" ? o = o[i.i] : o = o[i.p], s === n - 1 && (r = o));
  }
  return r;
}
function np(e, t, n) {
  for (var o = e, r = n.length, s = null, i = 0; i < r; i++) {
    var a = null, c = null;
    if (s = n[i], i === r - 1)
      a = typeof s.p > "u" ? s.i : s.p, o[a] = t;
    else if (typeof s.p < "u" && o[s.p])
      o = o[s.p];
    else if (typeof s.i < "u" && o[s.i])
      o = o[s.i];
    else {
      var l = n[i + 1];
      a = typeof s.p > "u" ? s.i : s.p, c = typeof l.p > "u" ? [] : {}, o[a] = c, o = o[a];
    }
  }
}
function Ra(e, t) {
  var n = ka(t), o = n[n.length - 1], r = {
    parent: n.length > 1 ? ps(e, n, n.length - 1) : e,
    name: o.p || o.i,
    value: ps(e, n)
  };
  return r.exists = ja(r.parent, r.name), r;
}
function rp(e, t) {
  var n = Ra(e, t);
  return n.value;
}
function op(e, t, n) {
  var o = ka(t);
  return np(e, n, o), e;
}
var sp = {
  hasProperty: ja,
  getPathInfo: Ra,
  getPathValue: rp,
  setPathValue: op
};
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Ye = function(t, n, o) {
  var r = t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null));
  if (arguments.length === 3)
    r[n] = o;
  else
    return r[n];
};
/*!
 * Chai - test utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var ip = Ye, ap = function(t, n) {
  var o = ip(t, "negate"), r = n[0];
  return o ? !r : r;
}, Fa = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(qr, function() {
    var n = typeof Promise == "function", o = typeof self == "object" ? self : qr, r = typeof Symbol < "u", s = typeof Map < "u", i = typeof Set < "u", a = typeof WeakMap < "u", c = typeof WeakSet < "u", l = typeof DataView < "u", f = r && typeof Symbol.iterator < "u", u = r && typeof Symbol.toStringTag < "u", p = i && typeof Set.prototype.entries == "function", w = s && typeof Map.prototype.entries == "function", b = p && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries()), v = w && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries()), h = f && typeof Array.prototype[Symbol.iterator] == "function", A = h && Object.getPrototypeOf([][Symbol.iterator]()), M = f && typeof String.prototype[Symbol.iterator] == "function", F = M && Object.getPrototypeOf(""[Symbol.iterator]()), k = 8, N = -1;
    function U(B) {
      var G = typeof B;
      if (G !== "object")
        return G;
      if (B === null)
        return "null";
      if (B === o)
        return "global";
      if (Array.isArray(B) && (u === !1 || !(Symbol.toStringTag in B)))
        return "Array";
      if (typeof window == "object" && window !== null) {
        if (typeof window.location == "object" && B === window.location)
          return "Location";
        if (typeof window.document == "object" && B === window.document)
          return "Document";
        if (typeof window.navigator == "object") {
          if (typeof window.navigator.mimeTypes == "object" && B === window.navigator.mimeTypes)
            return "MimeTypeArray";
          if (typeof window.navigator.plugins == "object" && B === window.navigator.plugins)
            return "PluginArray";
        }
        if ((typeof window.HTMLElement == "function" || typeof window.HTMLElement == "object") && B instanceof window.HTMLElement) {
          if (B.tagName === "BLOCKQUOTE")
            return "HTMLQuoteElement";
          if (B.tagName === "TD")
            return "HTMLTableDataCellElement";
          if (B.tagName === "TH")
            return "HTMLTableHeaderCellElement";
        }
      }
      var ae = u && B[Symbol.toStringTag];
      if (typeof ae == "string")
        return ae;
      var V = Object.getPrototypeOf(B);
      return V === RegExp.prototype ? "RegExp" : V === Date.prototype ? "Date" : n && V === Promise.prototype ? "Promise" : i && V === Set.prototype ? "Set" : s && V === Map.prototype ? "Map" : c && V === WeakSet.prototype ? "WeakSet" : a && V === WeakMap.prototype ? "WeakMap" : l && V === DataView.prototype ? "DataView" : s && V === v ? "Map Iterator" : i && V === b ? "Set Iterator" : h && V === A ? "Array Iterator" : M && V === F ? "String Iterator" : V === null ? "Object" : Object.prototype.toString.call(B).slice(k, N);
    }
    return U;
  });
})(Fa);
var er = Fa.exports;
/*!
 * Chai - expectTypes utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var cp = Na, Tr = Ye, up = er, lp = function(t, n) {
  var o = Tr(t, "message"), r = Tr(t, "ssfi");
  o = o ? o + ": " : "", t = Tr(t, "object"), n = n.map(function(a) {
    return a.toLowerCase();
  }), n.sort();
  var s = n.map(function(a, c) {
    var l = ~["a", "e", "i", "o", "u"].indexOf(a.charAt(0)) ? "an" : "a", f = n.length > 1 && c === n.length - 1 ? "or " : "";
    return f + l + " " + a;
  }).join(", "), i = up(t).toLowerCase();
  if (!n.some(function(a) {
    return i === a;
  }))
    throw new cp(
      o + "object tested must be " + s + ", but " + i + " given",
      void 0,
      r
    );
};
/*!
 * Chai - getActual utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Da = function(t, n) {
  return n.length > 4 ? n[4] : t._obj;
}, fp = Function.prototype.toString, pp = /\s*function(?:\s|\s*\/\*[^(?:*\/)]+\*\/\s*)*([^\s\(\/]+)/, hp = 512;
function mp(e) {
  if (typeof e != "function")
    return null;
  var t = "";
  if (typeof Function.prototype.name > "u" && typeof e.name > "u") {
    var n = fp.call(e);
    if (n.indexOf("(") > hp)
      return t;
    var o = n.match(pp);
    o && (t = o[1]);
  } else
    t = e.name;
  return t;
}
var Ba = mp, Xt = {
  /**
   * ### config.includeStack
   *
   * User configurable property, influences whether stack trace
   * is included in Assertion error message. Default of false
   * suppresses stack trace in the error message.
   *
   *     chai.config.includeStack = true;  // enable stack on error
   *
   * @param {Boolean}
   * @api public
   */
  includeStack: !1,
  /**
   * ### config.showDiff
   *
   * User configurable property, influences whether or not
   * the `showDiff` flag should be included in the thrown
   * AssertionErrors. `false` will always be `false`; `true`
   * will be true when the assertion has requested a diff
   * be shown.
   *
   * @param {Boolean}
   * @api public
   */
  showDiff: !0,
  /**
   * ### config.truncateThreshold
   *
   * User configurable property, sets length threshold for actual and
   * expected values in assertion errors. If this threshold is exceeded, for
   * example for large data structures, the value is replaced with something
   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.
   *
   * Set it to zero if you want to disable truncating altogether.
   *
   * This is especially userful when doing assertions on arrays: having this
   * set to a reasonable large value makes the failure messages readily
   * inspectable.
   *
   *     chai.config.truncateThreshold = 0;  // disable truncating
   *
   * @param {Number}
   * @api public
   */
  truncateThreshold: 40,
  /**
   * ### config.useProxy
   *
   * User configurable property, defines if chai will use a Proxy to throw
   * an error when a non-existent property is read, which protects users
   * from typos when using property-based assertions.
   *
   * Set it to false if you want to disable this feature.
   *
   *     chai.config.useProxy = false;  // disable use of Proxy
   *
   * This feature is automatically disabled regardless of this config value
   * in environments that don't support proxies.
   *
   * @param {Boolean}
   * @api public
   */
  useProxy: !0,
  /**
   * ### config.proxyExcludedKeys
   *
   * User configurable property, defines which properties should be ignored
   * instead of throwing an error if they do not exist on the assertion.
   * This is only applied if the environment Chai is running in supports proxies and
   * if the `useProxy` configuration setting is enabled.
   * By default, `then` and `inspect` will not throw an error if they do not exist on the
   * assertion object because the `.inspect` property is read by `util.inspect` (for example, when
   * using `console.log` on the assertion object) and `.then` is necessary for promise type-checking.
   *
   *     // By default these keys will not throw an error if they do not exist on the assertion object
   *     chai.config.proxyExcludedKeys = ['then', 'inspect'];
   *
   * @param {Array}
   * @api public
   */
  proxyExcludedKeys: ["then", "catch", "inspect", "toJSON"],
  /**
   * ### config.deepEqual
   *
   * User configurable property, defines which a custom function to use for deepEqual
   * comparisons.
   * By default, the function used is the one from the `deep-eql` package without custom comparator.
   *
   *     // use a custom comparator
   *     chai.config.deepEqual = (expected, actual) => {
   *        return chai.util.eql(expected, actual, {
   *           comparator: (expected, actual) => {
   *              // for non number comparison, use the default behavior
   *              if(typeof expected !== 'number') return null;
   *              // allow a difference of 10 between compared numbers
   *              return typeof actual === 'number' && Math.abs(actual - expected) < 10
   *           }
   *        })
   *     };
   *
   * @param {Function}
   * @api public
   */
  deepEqual: null
}, dp = ca, hs = Xt, go = yp;
function yp(e, t, n, o) {
  var r = {
    colors: o,
    depth: typeof n > "u" ? 2 : n,
    showHidden: t,
    truncate: hs.truncateThreshold ? hs.truncateThreshold : 1 / 0
  };
  return dp.inspect(e, r);
}
/*!
 * Chai - flag utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var gp = go, ms = Xt, La = function(t) {
  var n = gp(t), o = Object.prototype.toString.call(t);
  if (ms.truncateThreshold && n.length >= ms.truncateThreshold) {
    if (o === "[object Function]")
      return !t.name || t.name === "" ? "[Function]" : "[Function: " + t.name + "]";
    if (o === "[object Array]")
      return "[ Array(" + t.length + ") ]";
    if (o === "[object Object]") {
      var r = Object.keys(t), s = r.length > 2 ? r.splice(0, 2).join(", ") + ", ..." : r.join(", ");
      return "{ Object (" + s + ") }";
    } else
      return n;
  } else
    return n;
};
/*!
 * Chai - message composition utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var xr = Ye, bp = Da, $r = La, wp = function(t, n) {
  var o = xr(t, "negate"), r = xr(t, "object"), s = n[3], i = bp(t, n), a = o ? n[2] : n[1], c = xr(t, "message");
  return typeof a == "function" && (a = a()), a = a || "", a = a.replace(/#\{this\}/g, function() {
    return $r(r);
  }).replace(/#\{act\}/g, function() {
    return $r(i);
  }).replace(/#\{exp\}/g, function() {
    return $r(s);
  }), c ? c + ": " + a : a;
};
/*!
 * Chai - transferFlags utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Mt = function(t, n, o) {
  var r = t.__flags || (t.__flags = /* @__PURE__ */ Object.create(null));
  n.__flags || (n.__flags = /* @__PURE__ */ Object.create(null)), o = arguments.length === 3 ? o : !0;
  for (var s in r)
    (o || s !== "object" && s !== "ssfi" && s !== "lockSsfi" && s != "message") && (n.__flags[s] = r[s]);
}, bo = { exports: {} };
/*!
 * deep-eql
 * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var ds = er;
function qa() {
  this._key = "chai/deep-eql__" + Math.random() + Date.now();
}
qa.prototype = {
  get: function(t) {
    return t[this._key];
  },
  set: function(t, n) {
    Object.isExtensible(t) && Object.defineProperty(t, this._key, {
      value: n,
      configurable: !0
    });
  }
};
var wo = typeof WeakMap == "function" ? WeakMap : qa;
/*!
 * Check to see if the MemoizeMap has recorded a result of the two operands
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @returns {Boolean|null} result
*/
function ys(e, t, n) {
  if (!n || Kt(e) || Kt(t))
    return null;
  var o = n.get(e);
  if (o) {
    var r = o.get(t);
    if (typeof r == "boolean")
      return r;
  }
  return null;
}
/*!
 * Set the result of the equality into the MemoizeMap
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {MemoizeMap} memoizeMap
 * @param {Boolean} result
*/
function Cn(e, t, n, o) {
  if (!(!n || Kt(e) || Kt(t))) {
    var r = n.get(e);
    r ? r.set(t, o) : (r = new wo(), r.set(t, o), n.set(e, r));
  }
}
/*!
 * Primary Export
 */
bo.exports = tr;
bo.exports.MemoizeMap = wo;
function tr(e, t, n) {
  if (n && n.comparator)
    return gs(e, t, n);
  var o = za(e, t);
  return o !== null ? o : gs(e, t, n);
}
function za(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && // eslint-disable-line no-self-compare
  t !== t ? !0 : Kt(e) || Kt(t) ? !1 : null;
}
/*!
 * The main logic of the `deepEqual` function.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (optional) Additional options
 * @param {Array} [options.comparator] (optional) Override default algorithm, determining custom equality.
 * @param {Array} [options.memoize] (optional) Provide a custom memoization object which will cache the results of
    complex objects for a speed boost. By passing `false` you can disable memoization, but this will cause circular
    references to blow the stack.
 * @return {Boolean} equal match
*/
function gs(e, t, n) {
  n = n || {}, n.memoize = n.memoize === !1 ? !1 : n.memoize || new wo();
  var o = n && n.comparator, r = ys(e, t, n.memoize);
  if (r !== null)
    return r;
  var s = ys(t, e, n.memoize);
  if (s !== null)
    return s;
  if (o) {
    var i = o(e, t);
    if (i === !1 || i === !0)
      return Cn(e, t, n.memoize, i), i;
    var a = za(e, t);
    if (a !== null)
      return a;
  }
  var c = ds(e);
  if (c !== ds(t))
    return Cn(e, t, n.memoize, !1), !1;
  Cn(e, t, n.memoize, !0);
  var l = vp(e, t, c, n);
  return Cn(e, t, n.memoize, l), l;
}
function vp(e, t, n, o) {
  switch (n) {
    case "String":
    case "Number":
    case "Boolean":
    case "Date":
      return tr(e.valueOf(), t.valueOf());
    case "Promise":
    case "Symbol":
    case "function":
    case "WeakMap":
    case "WeakSet":
      return e === t;
    case "Error":
      return Wa(e, t, ["name", "message", "code"], o);
    case "Arguments":
    case "Int8Array":
    case "Uint8Array":
    case "Uint8ClampedArray":
    case "Int16Array":
    case "Uint16Array":
    case "Int32Array":
    case "Uint32Array":
    case "Float32Array":
    case "Float64Array":
    case "Array":
      return Ot(e, t, o);
    case "RegExp":
      return Ep(e, t);
    case "Generator":
      return Sp(e, t, o);
    case "DataView":
      return Ot(new Uint8Array(e.buffer), new Uint8Array(t.buffer), o);
    case "ArrayBuffer":
      return Ot(new Uint8Array(e), new Uint8Array(t), o);
    case "Set":
      return bs(e, t, o);
    case "Map":
      return bs(e, t, o);
    case "Temporal.PlainDate":
    case "Temporal.PlainTime":
    case "Temporal.PlainDateTime":
    case "Temporal.Instant":
    case "Temporal.ZonedDateTime":
    case "Temporal.PlainYearMonth":
    case "Temporal.PlainMonthDay":
      return e.equals(t);
    case "Temporal.Duration":
      return e.total("nanoseconds") === t.total("nanoseconds");
    case "Temporal.TimeZone":
    case "Temporal.Calendar":
      return e.toString() === t.toString();
    default:
      return xp(e, t, o);
  }
}
/*!
 * Compare two Regular Expressions for equality.
 *
 * @param {RegExp} leftHandOperand
 * @param {RegExp} rightHandOperand
 * @return {Boolean} result
 */
function Ep(e, t) {
  return e.toString() === t.toString();
}
/*!
 * Compare two Sets/Maps for equality. Faster than other equality functions.
 *
 * @param {Set} leftHandOperand
 * @param {Set} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function bs(e, t, n) {
  if (e.size !== t.size)
    return !1;
  if (e.size === 0)
    return !0;
  var o = [], r = [];
  return e.forEach(function(i, a) {
    o.push([i, a]);
  }), t.forEach(function(i, a) {
    r.push([i, a]);
  }), Ot(o.sort(), r.sort(), n);
}
/*!
 * Simple equality for flat iterable objects such as Arrays, TypedArrays or Node.js buffers.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function Ot(e, t, n) {
  var o = e.length;
  if (o !== t.length)
    return !1;
  if (o === 0)
    return !0;
  for (var r = -1; ++r < o; )
    if (tr(e[r], t[r], n) === !1)
      return !1;
  return !0;
}
/*!
 * Simple equality for generator objects such as those returned by generator functions.
 *
 * @param {Iterable} leftHandOperand
 * @param {Iterable} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function Sp(e, t, n) {
  return Ot(Yr(e), Yr(t), n);
}
/*!
 * Determine if the given object has an @@iterator function.
 *
 * @param {Object} target
 * @return {Boolean} `true` if the object has an @@iterator function.
 */
function Tp(e) {
  return typeof Symbol < "u" && typeof e == "object" && typeof Symbol.iterator < "u" && typeof e[Symbol.iterator] == "function";
}
/*!
 * Gets all iterator entries from the given Object. If the Object has no @@iterator function, returns an empty array.
 * This will consume the iterator - which could have side effects depending on the @@iterator implementation.
 *
 * @param {Object} target
 * @returns {Array} an array of entries from the @@iterator function
 */
function ws(e) {
  if (Tp(e))
    try {
      return Yr(e[Symbol.iterator]());
    } catch {
      return [];
    }
  return [];
}
/*!
 * Gets all entries from a Generator. This will consume the generator - which could have side effects.
 *
 * @param {Generator} target
 * @returns {Array} an array of entries from the Generator.
 */
function Yr(e) {
  for (var t = e.next(), n = [t.value]; t.done === !1; )
    t = e.next(), n.push(t.value);
  return n;
}
/*!
 * Gets all own and inherited enumerable keys from a target.
 *
 * @param {Object} target
 * @returns {Array} an array of own and inherited enumerable keys from the target.
 */
function vs(e) {
  var t = [];
  for (var n in e)
    t.push(n);
  return t;
}
function Es(e) {
  for (var t = [], n = Object.getOwnPropertySymbols(e), o = 0; o < n.length; o += 1) {
    var r = n[o];
    Object.getOwnPropertyDescriptor(e, r).enumerable && t.push(r);
  }
  return t;
}
/*!
 * Determines if two objects have matching values, given a set of keys. Defers to deepEqual for the equality check of
 * each key. If any value of the given key is not equal, the function will return false (early).
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Array} keys An array of keys to compare the values of leftHandOperand and rightHandOperand against
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function Wa(e, t, n, o) {
  var r = n.length;
  if (r === 0)
    return !0;
  for (var s = 0; s < r; s += 1)
    if (tr(e[n[s]], t[n[s]], o) === !1)
      return !1;
  return !0;
}
/*!
 * Recursively check the equality of two Objects. Once basic sameness has been established it will defer to `deepEqual`
 * for each enumerable key in the object.
 *
 * @param {Mixed} leftHandOperand
 * @param {Mixed} rightHandOperand
 * @param {Object} [options] (Optional)
 * @return {Boolean} result
 */
function xp(e, t, n) {
  var o = vs(e), r = vs(t), s = Es(e), i = Es(t);
  if (o = o.concat(s), r = r.concat(i), o.length && o.length === r.length)
    return Ot(Ss(o).sort(), Ss(r).sort()) === !1 ? !1 : Wa(e, t, o, n);
  var a = ws(e), c = ws(t);
  return a.length && a.length === c.length ? (a.sort(), c.sort(), Ot(a, c, n)) : o.length === 0 && a.length === 0 && r.length === 0 && c.length === 0;
}
/*!
 * Returns true if the argument is a primitive.
 *
 * This intentionally returns true for all objects that can be compared by reference,
 * including functions and symbols.
 *
 * @param {Mixed} value
 * @return {Boolean} result
 */
function Kt(e) {
  return e === null || typeof e != "object";
}
function Ss(e) {
  return e.map(function(n) {
    return typeof n == "symbol" ? n.toString() : n;
  });
}
var $p = bo.exports, Op = Xt;
/*!
 * Chai - isProxyEnabled helper
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var nr = function() {
  return Op.useProxy && typeof Proxy < "u" && typeof Reflect < "u";
};
/*!
 * Chai - addProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Or, Ts;
function Ap() {
  if (Ts)
    return Or;
  Ts = 1;
  var e = Pt(), t = Ye, n = nr, o = Mt;
  return Or = function(s, i, a) {
    a = a === void 0 ? function() {
    } : a, Object.defineProperty(
      s,
      i,
      {
        get: function c() {
          !n() && !t(this, "lockSsfi") && t(this, "ssfi", c);
          var l = a.call(this);
          if (l !== void 0)
            return l;
          var f = new e.Assertion();
          return o(this, f), f;
        },
        configurable: !0
      }
    );
  }, Or;
}
var _p = Object.getOwnPropertyDescriptor(function() {
}, "length");
/*!
 * Chai - addLengthGuard utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var rr = function(t, n, o) {
  return _p.configurable && Object.defineProperty(t, "length", {
    get: function() {
      throw Error(o ? "Invalid Chai property: " + n + '.length. Due to a compatibility issue, "length" cannot directly follow "' + n + '". Use "' + n + '.lengthOf" instead.' : "Invalid Chai property: " + n + '.length. See docs for proper usage of "' + n + '".');
    }
  }), t;
};
/*!
 * Chai - getProperties utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Mp = function(t) {
  var n = Object.getOwnPropertyNames(t);
  function o(s) {
    n.indexOf(s) === -1 && n.push(s);
  }
  for (var r = Object.getPrototypeOf(t); r !== null; )
    Object.getOwnPropertyNames(r).forEach(o), r = Object.getPrototypeOf(r);
  return n;
}, Pp = Xt, xs = Ye, Ip = Mp, Cp = nr;
/*!
 * Chai - proxify utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var $s = ["__flags", "__methods", "_obj", "assert"], or = function(t, n) {
  return Cp() ? new Proxy(t, {
    get: function o(r, s) {
      if (typeof s == "string" && Pp.proxyExcludedKeys.indexOf(s) === -1 && !Reflect.has(r, s)) {
        if (n)
          throw Error("Invalid Chai property: " + n + "." + s + '. See docs for proper usage of "' + n + '".');
        var i = null, a = 4;
        throw Ip(r).forEach(function(c) {
          if (!Object.prototype.hasOwnProperty(c) && $s.indexOf(c) === -1) {
            var l = Np(
              s,
              c,
              a
            );
            l < a && (i = c, a = l);
          }
        }), Error(i !== null ? "Invalid Chai property: " + s + '. Did you mean "' + i + '"?' : "Invalid Chai property: " + s);
      }
      return $s.indexOf(s) === -1 && !xs(r, "lockSsfi") && xs(r, "ssfi", o), Reflect.get(r, s);
    }
  }) : t;
};
function Np(e, t, n) {
  if (Math.abs(e.length - t.length) >= n)
    return n;
  for (var o = [], r = 0; r <= e.length; r++)
    o[r] = Array(t.length + 1).fill(0), o[r][0] = r;
  for (var s = 0; s < t.length; s++)
    o[0][s] = s;
  for (var r = 1; r <= e.length; r++)
    for (var i = e.charCodeAt(r - 1), s = 1; s <= t.length; s++) {
      if (Math.abs(r - s) >= n) {
        o[r][s] = n;
        continue;
      }
      o[r][s] = Math.min(
        o[r - 1][s] + 1,
        o[r][s - 1] + 1,
        o[r - 1][s - 1] + (i === t.charCodeAt(s - 1) ? 0 : 1)
      );
    }
  return o[e.length][t.length];
}
/*!
 * Chai - addMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Ar, Os;
function jp() {
  if (Os)
    return Ar;
  Os = 1;
  var e = rr, t = Pt(), n = Ye, o = or, r = Mt;
  return Ar = function(i, a, c) {
    var l = function() {
      n(this, "lockSsfi") || n(this, "ssfi", l);
      var f = c.apply(this, arguments);
      if (f !== void 0)
        return f;
      var u = new t.Assertion();
      return r(this, u), u;
    };
    e(l, a, !1), i[a] = o(l, a);
  }, Ar;
}
/*!
 * Chai - overwriteProperty utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var _r, As;
function kp() {
  if (As)
    return _r;
  As = 1;
  var e = Pt(), t = Ye, n = nr, o = Mt;
  return _r = function(s, i, a) {
    var c = Object.getOwnPropertyDescriptor(s, i), l = function() {
    };
    c && typeof c.get == "function" && (l = c.get), Object.defineProperty(
      s,
      i,
      {
        get: function f() {
          !n() && !t(this, "lockSsfi") && t(this, "ssfi", f);
          var u = t(this, "lockSsfi");
          t(this, "lockSsfi", !0);
          var p = a(l).call(this);
          if (t(this, "lockSsfi", u), p !== void 0)
            return p;
          var w = new e.Assertion();
          return o(this, w), w;
        },
        configurable: !0
      }
    );
  }, _r;
}
/*!
 * Chai - overwriteMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Mr, _s;
function Rp() {
  if (_s)
    return Mr;
  _s = 1;
  var e = rr, t = Pt(), n = Ye, o = or, r = Mt;
  return Mr = function(i, a, c) {
    var l = i[a], f = function() {
      throw new Error(a + " is not a function");
    };
    l && typeof l == "function" && (f = l);
    var u = function() {
      n(this, "lockSsfi") || n(this, "ssfi", u);
      var p = n(this, "lockSsfi");
      n(this, "lockSsfi", !0);
      var w = c(f).apply(this, arguments);
      if (n(this, "lockSsfi", p), w !== void 0)
        return w;
      var b = new t.Assertion();
      return r(this, b), b;
    };
    e(u, a, !1), i[a] = o(u, a);
  }, Mr;
}
/*!
 * Chai - addChainingMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Pr, Ms;
function Fp() {
  if (Ms)
    return Pr;
  Ms = 1;
  /*!
   * Module dependencies
   */
  var e = rr, t = Pt(), n = Ye, o = or, r = Mt;
  /*!
   * Module variables
   */
  var s = typeof Object.setPrototypeOf == "function", i = function() {
  }, a = Object.getOwnPropertyNames(i).filter(function(f) {
    var u = Object.getOwnPropertyDescriptor(i, f);
    return typeof u != "object" ? !0 : !u.configurable;
  }), c = Function.prototype.call, l = Function.prototype.apply;
  return Pr = function(u, p, w, b) {
    typeof b != "function" && (b = function() {
    });
    var v = {
      method: w,
      chainingBehavior: b
    };
    u.__methods || (u.__methods = {}), u.__methods[p] = v, Object.defineProperty(
      u,
      p,
      {
        get: function() {
          v.chainingBehavior.call(this);
          var A = function() {
            n(this, "lockSsfi") || n(this, "ssfi", A);
            var k = v.method.apply(this, arguments);
            if (k !== void 0)
              return k;
            var N = new t.Assertion();
            return r(this, N), N;
          };
          if (e(A, p, !0), s) {
            var M = Object.create(this);
            M.call = c, M.apply = l, Object.setPrototypeOf(A, M);
          } else {
            var F = Object.getOwnPropertyNames(u);
            F.forEach(function(k) {
              if (a.indexOf(k) === -1) {
                var N = Object.getOwnPropertyDescriptor(u, k);
                Object.defineProperty(A, k, N);
              }
            });
          }
          return r(this, A), o(A);
        },
        configurable: !0
      }
    );
  }, Pr;
}
/*!
 * Chai - overwriteChainableMethod utility
 * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Ir, Ps;
function Dp() {
  if (Ps)
    return Ir;
  Ps = 1;
  var e = Pt(), t = Mt;
  return Ir = function(o, r, s, i) {
    var a = o.__methods[r], c = a.chainingBehavior;
    a.chainingBehavior = function() {
      var u = i(c).call(this);
      if (u !== void 0)
        return u;
      var p = new e.Assertion();
      return t(this, p), p;
    };
    var l = a.method;
    a.method = function() {
      var u = s(l).apply(this, arguments);
      if (u !== void 0)
        return u;
      var p = new e.Assertion();
      return t(this, p), p;
    };
  }, Ir;
}
/*!
 * Chai - compareByInspect utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var Is = go, Bp = function(t, n) {
  return Is(t) < Is(n) ? -1 : 1;
};
/*!
 * Chai - getOwnEnumerablePropertySymbols utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Va = function(t) {
  return typeof Object.getOwnPropertySymbols != "function" ? [] : Object.getOwnPropertySymbols(t).filter(function(n) {
    return Object.getOwnPropertyDescriptor(t, n).enumerable;
  });
};
/*!
 * Chai - getOwnEnumerableProperties utility
 * Copyright(c) 2011-2016 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
/*!
 * Module dependencies
 */
var Lp = Va, qp = function(t) {
  return Object.keys(t).concat(Lp(t));
}, Cr = Ba;
function zp(e, t) {
  return t instanceof Error && e === t;
}
function Wp(e, t) {
  return t instanceof Error ? e.constructor === t.constructor || e instanceof t.constructor : t.prototype instanceof Error || t === Error ? e.constructor === t || e instanceof t : !1;
}
function Vp(e, t) {
  var n = typeof e == "string" ? e : e.message;
  return t instanceof RegExp ? t.test(n) : typeof t == "string" ? n.indexOf(t) !== -1 : !1;
}
function Up(e) {
  var t = e;
  if (e instanceof Error)
    t = Cr(e.constructor);
  else if (typeof e == "function" && (t = Cr(e), t === "")) {
    var n = Cr(new e());
    t = n || t;
  }
  return t;
}
function Kp(e) {
  var t = "";
  return e && e.message ? t = e.message : typeof e == "string" && (t = e), t;
}
var Gp = {
  compatibleInstance: zp,
  compatibleConstructor: Wp,
  compatibleMessage: Vp,
  getMessage: Kp,
  getConstructorName: Up
};
/*!
 * Chai - isNaN utility
 * Copyright(c) 2012-2015 Sakthipriyan Vairamani <thechargingvolcano@gmail.com>
 * MIT Licensed
 */
function Jp(e) {
  return e !== e;
}
var Yp = Number.isNaN || Jp, Hp = er, Cs = Ye;
function Xp(e) {
  var t = Hp(e), n = ["Array", "Object", "function"];
  return n.indexOf(t) !== -1;
}
var Qp = function(t, n) {
  var o = Cs(t, "operator"), r = Cs(t, "negate"), s = n[3], i = r ? n[2] : n[1];
  if (o)
    return o;
  if (typeof i == "function" && (i = i()), i = i || "", !!i && !/\shave\s/.test(i)) {
    var a = Xp(s);
    return /\snot\s/.test(i) ? a ? "notDeepStrictEqual" : "notStrictEqual" : a ? "deepStrictEqual" : "strictEqual";
  }
};
/*!
 * chai
 * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Ns;
function Zp() {
  if (Ns)
    return fe;
  Ns = 1;
  /*!
   * Dependencies that are used for multiple exports are required here only once
   */
  var e = sp;
  /*!
   * test utility
   */
  fe.test = ap;
  /*!
   * type utility
   */
  fe.type = er;
  /*!
   * expectTypes utility
   */
  fe.expectTypes = lp;
  /*!
   * message utility
   */
  fe.getMessage = wp;
  /*!
   * actual utility
   */
  fe.getActual = Da;
  /*!
   * Inspect util
   */
  fe.inspect = go;
  /*!
   * Object Display util
   */
  fe.objDisplay = La;
  /*!
   * Flag utility
   */
  fe.flag = Ye;
  /*!
   * Flag transferring utility
   */
  fe.transferFlags = Mt;
  /*!
   * Deep equal utility
   */
  fe.eql = $p;
  /*!
   * Deep path info
   */
  fe.getPathInfo = e.getPathInfo;
  /*!
   * Check if a property exists
   */
  fe.hasProperty = e.hasProperty;
  /*!
   * Function name
   */
  fe.getName = Ba;
  /*!
   * add Property
   */
  fe.addProperty = Ap();
  /*!
   * add Method
   */
  fe.addMethod = jp();
  /*!
   * overwrite Property
   */
  fe.overwriteProperty = kp();
  /*!
   * overwrite Method
   */
  fe.overwriteMethod = Rp();
  /*!
   * Add a chainable method
   */
  fe.addChainableMethod = Fp();
  /*!
   * Overwrite chainable method
   */
  fe.overwriteChainableMethod = Dp();
  /*!
   * Compare by inspect method
   */
  fe.compareByInspect = Bp;
  /*!
   * Get own enumerable property symbols method
   */
  fe.getOwnEnumerablePropertySymbols = Va;
  /*!
   * Get own enumerable properties method
   */
  fe.getOwnEnumerableProperties = qp;
  /*!
   * Checks error against a given set of criteria
   */
  fe.checkError = Gp;
  /*!
   * Proxify util
   */
  fe.proxify = or;
  /*!
   * addLengthGuard util
   */
  fe.addLengthGuard = rr;
  /*!
   * isProxyEnabled helper
   */
  fe.isProxyEnabled = nr;
  /*!
   * isNaN method
   */
  fe.isNaN = Yp;
  /*!
   * getOperator method
   */
  return fe.getOperator = Qp, fe;
}
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var Tt = Xt, eh = function(e, t) {
  /*!
   * Module dependencies.
   */
  var n = e.AssertionError, o = t.flag;
  /*!
   * Module export.
   */
  e.Assertion = r;
  /*!
   * Assertion Constructor
   *
   * Creates object for chaining.
   *
   * `Assertion` objects contain metadata in the form of flags. Three flags can
   * be assigned during instantiation by passing arguments to this constructor:
   *
   * - `object`: This flag contains the target of the assertion. For example, in
   *   the assertion `expect(numKittens).to.equal(7);`, the `object` flag will
   *   contain `numKittens` so that the `equal` assertion can reference it when
   *   needed.
   *
   * - `message`: This flag contains an optional custom error message to be
   *   prepended to the error message that's generated by the assertion when it
   *   fails.
   *
   * - `ssfi`: This flag stands for "start stack function indicator". It
   *   contains a function reference that serves as the starting point for
   *   removing frames from the stack trace of the error that's created by the
   *   assertion when it fails. The goal is to provide a cleaner stack trace to
   *   end users by removing Chai's internal functions. Note that it only works
   *   in environments that support `Error.captureStackTrace`, and only when
   *   `Chai.config.includeStack` hasn't been set to `false`.
   *
   * - `lockSsfi`: This flag controls whether or not the given `ssfi` flag
   *   should retain its current value, even as assertions are chained off of
   *   this object. This is usually set to `true` when creating a new assertion
   *   from within another assertion. It's also temporarily set to `true` before
   *   an overwritten assertion gets called by the overwriting assertion.
   *
   * - `eql`: This flag contains the deepEqual function to be used by the assertion.
   *
   * @param {Mixed} obj target of the assertion
   * @param {String} msg (optional) custom error message
   * @param {Function} ssfi (optional) starting point for removing stack frames
   * @param {Boolean} lockSsfi (optional) whether or not the ssfi flag is locked
   * @api private
   */
  function r(s, i, a, c) {
    return o(this, "ssfi", a || r), o(this, "lockSsfi", c), o(this, "object", s), o(this, "message", i), o(this, "eql", Tt.deepEqual || t.eql), t.proxify(this);
  }
  Object.defineProperty(r, "includeStack", {
    get: function() {
      return console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), Tt.includeStack;
    },
    set: function(s) {
      console.warn("Assertion.includeStack is deprecated, use chai.config.includeStack instead."), Tt.includeStack = s;
    }
  }), Object.defineProperty(r, "showDiff", {
    get: function() {
      return console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), Tt.showDiff;
    },
    set: function(s) {
      console.warn("Assertion.showDiff is deprecated, use chai.config.showDiff instead."), Tt.showDiff = s;
    }
  }), r.addProperty = function(s, i) {
    t.addProperty(this.prototype, s, i);
  }, r.addMethod = function(s, i) {
    t.addMethod(this.prototype, s, i);
  }, r.addChainableMethod = function(s, i, a) {
    t.addChainableMethod(this.prototype, s, i, a);
  }, r.overwriteProperty = function(s, i) {
    t.overwriteProperty(this.prototype, s, i);
  }, r.overwriteMethod = function(s, i) {
    t.overwriteMethod(this.prototype, s, i);
  }, r.overwriteChainableMethod = function(s, i, a) {
    t.overwriteChainableMethod(this.prototype, s, i, a);
  }, r.prototype.assert = function(s, i, a, c, l, f) {
    var u = t.test(this, arguments);
    if (f !== !1 && (f = !0), c === void 0 && l === void 0 && (f = !1), Tt.showDiff !== !0 && (f = !1), !u) {
      i = t.getMessage(this, arguments);
      var p = t.getActual(this, arguments), w = {
        actual: p,
        expected: c,
        showDiff: f
      }, b = t.getOperator(this, arguments);
      throw b && (w.operator = b), new n(
        i,
        w,
        Tt.includeStack ? this.assert : o(this, "ssfi")
      );
    }
  };
  /*!
   * ### ._obj
   *
   * Quick reference to stored `actual` value for plugin developers.
   *
   * @api private
   */
  Object.defineProperty(
    r.prototype,
    "_obj",
    {
      get: function() {
        return o(this, "object");
      },
      set: function(s) {
        o(this, "object", s);
      }
    }
  );
};
/*!
 * chai
 * http://chaijs.com
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var th = function(e, t) {
  var n = e.Assertion, o = e.AssertionError, r = t.flag;
  [
    "to",
    "be",
    "been",
    "is",
    "and",
    "has",
    "have",
    "with",
    "that",
    "which",
    "at",
    "of",
    "same",
    "but",
    "does",
    "still",
    "also"
  ].forEach(function(m) {
    n.addProperty(m);
  }), n.addProperty("not", function() {
    r(this, "negate", !0);
  }), n.addProperty("deep", function() {
    r(this, "deep", !0);
  }), n.addProperty("nested", function() {
    r(this, "nested", !0);
  }), n.addProperty("own", function() {
    r(this, "own", !0);
  }), n.addProperty("ordered", function() {
    r(this, "ordered", !0);
  }), n.addProperty("any", function() {
    r(this, "any", !0), r(this, "all", !1);
  }), n.addProperty("all", function() {
    r(this, "all", !0), r(this, "any", !1);
  });
  function s(m, T) {
    T && r(this, "message", T), m = m.toLowerCase();
    var x = r(this, "object"), P = ~["a", "e", "i", "o", "u"].indexOf(m.charAt(0)) ? "an " : "a ";
    this.assert(
      m === t.type(x).toLowerCase(),
      "expected #{this} to be " + P + m,
      "expected #{this} not to be " + P + m
    );
  }
  n.addChainableMethod("an", s), n.addChainableMethod("a", s);
  function i(m, T) {
    return t.isNaN(m) && t.isNaN(T) || m === T;
  }
  function a() {
    r(this, "contains", !0);
  }
  function c(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = t.type(x).toLowerCase(), j = r(this, "message"), D = r(this, "negate"), I = r(this, "ssfi"), $ = r(this, "deep"), q = $ ? "deep " : "", K = $ ? r(this, "eql") : i;
    j = j ? j + ": " : "";
    var J = !1;
    switch (P) {
      case "string":
        J = x.indexOf(m) !== -1;
        break;
      case "weakset":
        if ($)
          throw new o(
            j + "unable to use .deep.include with WeakSet",
            void 0,
            I
          );
        J = x.has(m);
        break;
      case "map":
        x.forEach(function(re) {
          J = J || K(re, m);
        });
        break;
      case "set":
        $ ? x.forEach(function(re) {
          J = J || K(re, m);
        }) : J = x.has(m);
        break;
      case "array":
        $ ? J = x.some(function(re) {
          return K(re, m);
        }) : J = x.indexOf(m) !== -1;
        break;
      default:
        if (m !== Object(m))
          throw new o(
            j + "the given combination of arguments (" + P + " and " + t.type(m).toLowerCase() + ") is invalid for this assertion. You can use an array, a map, an object, a set, a string, or a weakset instead of a " + t.type(m).toLowerCase(),
            void 0,
            I
          );
        var ne = Object.keys(m), Z = null, H = 0;
        if (ne.forEach(function(re) {
          var O = new n(x);
          if (t.transferFlags(this, O, !0), r(O, "lockSsfi", !0), !D || ne.length === 1) {
            O.property(re, m[re]);
            return;
          }
          try {
            O.property(re, m[re]);
          } catch (ce) {
            if (!t.checkError.compatibleConstructor(ce, o))
              throw ce;
            Z === null && (Z = ce), H++;
          }
        }, this), D && ne.length > 1 && H === ne.length)
          throw Z;
        return;
    }
    this.assert(
      J,
      "expected #{this} to " + q + "include " + t.inspect(m),
      "expected #{this} to not " + q + "include " + t.inspect(m)
    );
  }
  n.addChainableMethod("include", c, a), n.addChainableMethod("contain", c, a), n.addChainableMethod("contains", c, a), n.addChainableMethod("includes", c, a), n.addProperty("ok", function() {
    this.assert(
      r(this, "object"),
      "expected #{this} to be truthy",
      "expected #{this} to be falsy"
    );
  }), n.addProperty("true", function() {
    this.assert(
      r(this, "object") === !0,
      "expected #{this} to be true",
      "expected #{this} to be false",
      !r(this, "negate")
    );
  }), n.addProperty("false", function() {
    this.assert(
      r(this, "object") === !1,
      "expected #{this} to be false",
      "expected #{this} to be true",
      !!r(this, "negate")
    );
  }), n.addProperty("null", function() {
    this.assert(
      r(this, "object") === null,
      "expected #{this} to be null",
      "expected #{this} not to be null"
    );
  }), n.addProperty("undefined", function() {
    this.assert(
      r(this, "object") === void 0,
      "expected #{this} to be undefined",
      "expected #{this} not to be undefined"
    );
  }), n.addProperty("NaN", function() {
    this.assert(
      t.isNaN(r(this, "object")),
      "expected #{this} to be NaN",
      "expected #{this} not to be NaN"
    );
  });
  function l() {
    var m = r(this, "object");
    this.assert(
      m != null,
      "expected #{this} to exist",
      "expected #{this} to not exist"
    );
  }
  n.addProperty("exist", l), n.addProperty("exists", l), n.addProperty("empty", function() {
    var m = r(this, "object"), T = r(this, "ssfi"), x = r(this, "message"), P;
    switch (x = x ? x + ": " : "", t.type(m).toLowerCase()) {
      case "array":
      case "string":
        P = m.length;
        break;
      case "map":
      case "set":
        P = m.size;
        break;
      case "weakmap":
      case "weakset":
        throw new o(
          x + ".empty was passed a weak collection",
          void 0,
          T
        );
      case "function":
        var j = x + ".empty was passed a function " + t.getName(m);
        throw new o(j.trim(), void 0, T);
      default:
        if (m !== Object(m))
          throw new o(
            x + ".empty was passed non-string primitive " + t.inspect(m),
            void 0,
            T
          );
        P = Object.keys(m).length;
    }
    this.assert(
      P === 0,
      "expected #{this} to be empty",
      "expected #{this} not to be empty"
    );
  });
  function f() {
    var m = r(this, "object"), T = t.type(m);
    this.assert(
      T === "Arguments",
      "expected #{this} to be arguments but got " + T,
      "expected #{this} to not be arguments"
    );
  }
  n.addProperty("arguments", f), n.addProperty("Arguments", f);
  function u(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object");
    if (r(this, "deep")) {
      var P = r(this, "lockSsfi");
      r(this, "lockSsfi", !0), this.eql(m), r(this, "lockSsfi", P);
    } else
      this.assert(
        m === x,
        "expected #{this} to equal #{exp}",
        "expected #{this} to not equal #{exp}",
        m,
        this._obj,
        !0
      );
  }
  n.addMethod("equal", u), n.addMethod("equals", u), n.addMethod("eq", u);
  function p(m, T) {
    T && r(this, "message", T);
    var x = r(this, "eql");
    this.assert(
      x(m, r(this, "object")),
      "expected #{this} to deeply equal #{exp}",
      "expected #{this} to not deeply equal #{exp}",
      m,
      this._obj,
      !0
    );
  }
  n.addMethod("eql", p), n.addMethod("eqls", p);
  function w(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "doLength"), j = r(this, "message"), D = j ? j + ": " : "", I = r(this, "ssfi"), $ = t.type(x).toLowerCase(), q = t.type(m).toLowerCase(), K, J = !0;
    if (P && $ !== "map" && $ !== "set" && new n(x, j, I, !0).to.have.property("length"), !P && $ === "date" && q !== "date")
      K = D + "the argument to above must be a date";
    else if (q !== "number" && (P || $ === "number"))
      K = D + "the argument to above must be a number";
    else if (!P && $ !== "date" && $ !== "number") {
      var ne = $ === "string" ? "'" + x + "'" : x;
      K = D + "expected " + ne + " to be a number or a date";
    } else
      J = !1;
    if (J)
      throw new o(K, void 0, I);
    if (P) {
      var Z = "length", H;
      $ === "map" || $ === "set" ? (Z = "size", H = x.size) : H = x.length, this.assert(
        H > m,
        "expected #{this} to have a " + Z + " above #{exp} but got #{act}",
        "expected #{this} to not have a " + Z + " above #{exp}",
        m,
        H
      );
    } else
      this.assert(
        x > m,
        "expected #{this} to be above #{exp}",
        "expected #{this} to be at most #{exp}",
        m
      );
  }
  n.addMethod("above", w), n.addMethod("gt", w), n.addMethod("greaterThan", w);
  function b(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "doLength"), j = r(this, "message"), D = j ? j + ": " : "", I = r(this, "ssfi"), $ = t.type(x).toLowerCase(), q = t.type(m).toLowerCase(), K, J = !0;
    if (P && $ !== "map" && $ !== "set" && new n(x, j, I, !0).to.have.property("length"), !P && $ === "date" && q !== "date")
      K = D + "the argument to least must be a date";
    else if (q !== "number" && (P || $ === "number"))
      K = D + "the argument to least must be a number";
    else if (!P && $ !== "date" && $ !== "number") {
      var ne = $ === "string" ? "'" + x + "'" : x;
      K = D + "expected " + ne + " to be a number or a date";
    } else
      J = !1;
    if (J)
      throw new o(K, void 0, I);
    if (P) {
      var Z = "length", H;
      $ === "map" || $ === "set" ? (Z = "size", H = x.size) : H = x.length, this.assert(
        H >= m,
        "expected #{this} to have a " + Z + " at least #{exp} but got #{act}",
        "expected #{this} to have a " + Z + " below #{exp}",
        m,
        H
      );
    } else
      this.assert(
        x >= m,
        "expected #{this} to be at least #{exp}",
        "expected #{this} to be below #{exp}",
        m
      );
  }
  n.addMethod("least", b), n.addMethod("gte", b), n.addMethod("greaterThanOrEqual", b);
  function v(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "doLength"), j = r(this, "message"), D = j ? j + ": " : "", I = r(this, "ssfi"), $ = t.type(x).toLowerCase(), q = t.type(m).toLowerCase(), K, J = !0;
    if (P && $ !== "map" && $ !== "set" && new n(x, j, I, !0).to.have.property("length"), !P && $ === "date" && q !== "date")
      K = D + "the argument to below must be a date";
    else if (q !== "number" && (P || $ === "number"))
      K = D + "the argument to below must be a number";
    else if (!P && $ !== "date" && $ !== "number") {
      var ne = $ === "string" ? "'" + x + "'" : x;
      K = D + "expected " + ne + " to be a number or a date";
    } else
      J = !1;
    if (J)
      throw new o(K, void 0, I);
    if (P) {
      var Z = "length", H;
      $ === "map" || $ === "set" ? (Z = "size", H = x.size) : H = x.length, this.assert(
        H < m,
        "expected #{this} to have a " + Z + " below #{exp} but got #{act}",
        "expected #{this} to not have a " + Z + " below #{exp}",
        m,
        H
      );
    } else
      this.assert(
        x < m,
        "expected #{this} to be below #{exp}",
        "expected #{this} to be at least #{exp}",
        m
      );
  }
  n.addMethod("below", v), n.addMethod("lt", v), n.addMethod("lessThan", v);
  function h(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "doLength"), j = r(this, "message"), D = j ? j + ": " : "", I = r(this, "ssfi"), $ = t.type(x).toLowerCase(), q = t.type(m).toLowerCase(), K, J = !0;
    if (P && $ !== "map" && $ !== "set" && new n(x, j, I, !0).to.have.property("length"), !P && $ === "date" && q !== "date")
      K = D + "the argument to most must be a date";
    else if (q !== "number" && (P || $ === "number"))
      K = D + "the argument to most must be a number";
    else if (!P && $ !== "date" && $ !== "number") {
      var ne = $ === "string" ? "'" + x + "'" : x;
      K = D + "expected " + ne + " to be a number or a date";
    } else
      J = !1;
    if (J)
      throw new o(K, void 0, I);
    if (P) {
      var Z = "length", H;
      $ === "map" || $ === "set" ? (Z = "size", H = x.size) : H = x.length, this.assert(
        H <= m,
        "expected #{this} to have a " + Z + " at most #{exp} but got #{act}",
        "expected #{this} to have a " + Z + " above #{exp}",
        m,
        H
      );
    } else
      this.assert(
        x <= m,
        "expected #{this} to be at most #{exp}",
        "expected #{this} to be above #{exp}",
        m
      );
  }
  n.addMethod("most", h), n.addMethod("lte", h), n.addMethod("lessThanOrEqual", h), n.addMethod("within", function(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "object"), j = r(this, "doLength"), D = r(this, "message"), I = D ? D + ": " : "", $ = r(this, "ssfi"), q = t.type(P).toLowerCase(), K = t.type(m).toLowerCase(), J = t.type(T).toLowerCase(), ne, Z = !0, H = K === "date" && J === "date" ? m.toISOString() + ".." + T.toISOString() : m + ".." + T;
    if (j && q !== "map" && q !== "set" && new n(P, D, $, !0).to.have.property("length"), !j && q === "date" && (K !== "date" || J !== "date"))
      ne = I + "the arguments to within must be dates";
    else if ((K !== "number" || J !== "number") && (j || q === "number"))
      ne = I + "the arguments to within must be numbers";
    else if (!j && q !== "date" && q !== "number") {
      var re = q === "string" ? "'" + P + "'" : P;
      ne = I + "expected " + re + " to be a number or a date";
    } else
      Z = !1;
    if (Z)
      throw new o(ne, void 0, $);
    if (j) {
      var O = "length", ce;
      q === "map" || q === "set" ? (O = "size", ce = P.size) : ce = P.length, this.assert(
        ce >= m && ce <= T,
        "expected #{this} to have a " + O + " within " + H,
        "expected #{this} to not have a " + O + " within " + H
      );
    } else
      this.assert(
        P >= m && P <= T,
        "expected #{this} to be within " + H,
        "expected #{this} to not be within " + H
      );
  });
  function A(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "ssfi"), j = r(this, "message");
    try {
      var D = x instanceof m;
    } catch ($) {
      throw $ instanceof TypeError ? (j = j ? j + ": " : "", new o(
        j + "The instanceof assertion needs a constructor but " + t.type(m) + " was given.",
        void 0,
        P
      )) : $;
    }
    var I = t.getName(m);
    I === null && (I = "an unnamed constructor"), this.assert(
      D,
      "expected #{this} to be an instance of " + I,
      "expected #{this} to not be an instance of " + I
    );
  }
  n.addMethod("instanceof", A), n.addMethod("instanceOf", A);
  function M(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "nested"), j = r(this, "own"), D = r(this, "message"), I = r(this, "object"), $ = r(this, "ssfi"), q = typeof m;
    if (D = D ? D + ": " : "", P) {
      if (q !== "string")
        throw new o(
          D + "the argument to property must be a string when using nested syntax",
          void 0,
          $
        );
    } else if (q !== "string" && q !== "number" && q !== "symbol")
      throw new o(
        D + "the argument to property must be a string, number, or symbol",
        void 0,
        $
      );
    if (P && j)
      throw new o(
        D + 'The "nested" and "own" flags cannot be combined.',
        void 0,
        $
      );
    if (I == null)
      throw new o(
        D + "Target cannot be null or undefined.",
        void 0,
        $
      );
    var K = r(this, "deep"), J = r(this, "negate"), ne = P ? t.getPathInfo(I, m) : null, Z = P ? ne.value : I[m], H = K ? r(this, "eql") : (ce, oe) => ce === oe, re = "";
    K && (re += "deep "), j && (re += "own "), P && (re += "nested "), re += "property ";
    var O;
    j ? O = Object.prototype.hasOwnProperty.call(I, m) : P ? O = ne.exists : O = t.hasProperty(I, m), (!J || arguments.length === 1) && this.assert(
      O,
      "expected #{this} to have " + re + t.inspect(m),
      "expected #{this} to not have " + re + t.inspect(m)
    ), arguments.length > 1 && this.assert(
      O && H(T, Z),
      "expected #{this} to have " + re + t.inspect(m) + " of #{exp}, but got #{act}",
      "expected #{this} to not have " + re + t.inspect(m) + " of #{act}",
      T,
      Z
    ), r(this, "object", Z);
  }
  n.addMethod("property", M);
  function F(m, T, x) {
    r(this, "own", !0), M.apply(this, arguments);
  }
  n.addMethod("ownProperty", F), n.addMethod("haveOwnProperty", F);
  function k(m, T, x) {
    typeof T == "string" && (x = T, T = null), x && r(this, "message", x);
    var P = r(this, "object"), j = Object.getOwnPropertyDescriptor(Object(P), m), D = r(this, "eql");
    j && T ? this.assert(
      D(T, j),
      "expected the own property descriptor for " + t.inspect(m) + " on #{this} to match " + t.inspect(T) + ", got " + t.inspect(j),
      "expected the own property descriptor for " + t.inspect(m) + " on #{this} to not match " + t.inspect(T),
      T,
      j,
      !0
    ) : this.assert(
      j,
      "expected #{this} to have an own property descriptor for " + t.inspect(m),
      "expected #{this} to not have an own property descriptor for " + t.inspect(m)
    ), r(this, "object", j);
  }
  n.addMethod("ownPropertyDescriptor", k), n.addMethod("haveOwnPropertyDescriptor", k);
  function N() {
    r(this, "doLength", !0);
  }
  function U(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = t.type(x).toLowerCase(), j = r(this, "message"), D = r(this, "ssfi"), I = "length", $;
    switch (P) {
      case "map":
      case "set":
        I = "size", $ = x.size;
        break;
      default:
        new n(x, j, D, !0).to.have.property("length"), $ = x.length;
    }
    this.assert(
      $ == m,
      "expected #{this} to have a " + I + " of #{exp} but got #{act}",
      "expected #{this} to not have a " + I + " of #{act}",
      m,
      $
    );
  }
  n.addChainableMethod("length", U, N), n.addChainableMethod("lengthOf", U, N);
  function B(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object");
    this.assert(
      m.exec(x),
      "expected #{this} to match " + m,
      "expected #{this} not to match " + m
    );
  }
  n.addMethod("match", B), n.addMethod("matches", B), n.addMethod("string", function(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "message"), j = r(this, "ssfi");
    new n(x, P, j, !0).is.a("string"), this.assert(
      ~x.indexOf(m),
      "expected #{this} to contain " + t.inspect(m),
      "expected #{this} to not contain " + t.inspect(m)
    );
  });
  function G(m) {
    var T = r(this, "object"), x = t.type(T), P = t.type(m), j = r(this, "ssfi"), D = r(this, "deep"), I, $ = "", q, K = !0, J = r(this, "message");
    J = J ? J + ": " : "";
    var ne = J + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments";
    if (x === "Map" || x === "Set")
      $ = D ? "deeply " : "", q = [], T.forEach(function(ye, qe) {
        q.push(qe);
      }), P !== "Array" && (m = Array.prototype.slice.call(arguments));
    else {
      switch (q = t.getOwnEnumerableProperties(T), P) {
        case "Array":
          if (arguments.length > 1)
            throw new o(ne, void 0, j);
          break;
        case "Object":
          if (arguments.length > 1)
            throw new o(ne, void 0, j);
          m = Object.keys(m);
          break;
        default:
          m = Array.prototype.slice.call(arguments);
      }
      m = m.map(function(ye) {
        return typeof ye == "symbol" ? ye : String(ye);
      });
    }
    if (!m.length)
      throw new o(J + "keys required", void 0, j);
    var Z = m.length, H = r(this, "any"), re = r(this, "all"), O = m, ce = D ? r(this, "eql") : (ye, qe) => ye === qe;
    if (!H && !re && (re = !0), H && (K = O.some(function(ye) {
      return q.some(function(qe) {
        return ce(ye, qe);
      });
    })), re && (K = O.every(function(ye) {
      return q.some(function(qe) {
        return ce(ye, qe);
      });
    }), r(this, "contains") || (K = K && m.length == q.length)), Z > 1) {
      m = m.map(function(ye) {
        return t.inspect(ye);
      });
      var oe = m.pop();
      re && (I = m.join(", ") + ", and " + oe), H && (I = m.join(", ") + ", or " + oe);
    } else
      I = t.inspect(m[0]);
    I = (Z > 1 ? "keys " : "key ") + I, I = (r(this, "contains") ? "contain " : "have ") + I, this.assert(
      K,
      "expected #{this} to " + $ + I,
      "expected #{this} to not " + $ + I,
      O.slice(0).sort(t.compareByInspect),
      q.sort(t.compareByInspect),
      !0
    );
  }
  n.addMethod("keys", G), n.addMethod("key", G);
  function ae(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "object"), j = r(this, "ssfi"), D = r(this, "message"), I = r(this, "negate") || !1;
    new n(P, D, j, !0).is.a("function"), (m instanceof RegExp || typeof m == "string") && (T = m, m = null);
    var $;
    try {
      P();
    } catch (oe) {
      $ = oe;
    }
    var q = m === void 0 && T === void 0, K = !!(m && T), J = !1, ne = !1;
    if (q || !q && !I) {
      var Z = "an error";
      m instanceof Error ? Z = "#{exp}" : m && (Z = t.checkError.getConstructorName(m)), this.assert(
        $,
        "expected #{this} to throw " + Z,
        "expected #{this} to not throw an error but #{act} was thrown",
        m && m.toString(),
        $ instanceof Error ? $.toString() : typeof $ == "string" ? $ : $ && t.checkError.getConstructorName($)
      );
    }
    if (m && $) {
      if (m instanceof Error) {
        var H = t.checkError.compatibleInstance($, m);
        H === I && (K && I ? J = !0 : this.assert(
          I,
          "expected #{this} to throw #{exp} but #{act} was thrown",
          "expected #{this} to not throw #{exp}" + ($ && !I ? " but #{act} was thrown" : ""),
          m.toString(),
          $.toString()
        ));
      }
      var re = t.checkError.compatibleConstructor($, m);
      re === I && (K && I ? J = !0 : this.assert(
        I,
        "expected #{this} to throw #{exp} but #{act} was thrown",
        "expected #{this} to not throw #{exp}" + ($ ? " but #{act} was thrown" : ""),
        m instanceof Error ? m.toString() : m && t.checkError.getConstructorName(m),
        $ instanceof Error ? $.toString() : $ && t.checkError.getConstructorName($)
      ));
    }
    if ($ && T !== void 0 && T !== null) {
      var O = "including";
      T instanceof RegExp && (O = "matching");
      var ce = t.checkError.compatibleMessage($, T);
      ce === I && (K && I ? ne = !0 : this.assert(
        I,
        "expected #{this} to throw error " + O + " #{exp} but got #{act}",
        "expected #{this} to throw error not " + O + " #{exp}",
        T,
        t.checkError.getMessage($)
      ));
    }
    J && ne && this.assert(
      I,
      "expected #{this} to throw #{exp} but #{act} was thrown",
      "expected #{this} to not throw #{exp}" + ($ ? " but #{act} was thrown" : ""),
      m instanceof Error ? m.toString() : m && t.checkError.getConstructorName(m),
      $ instanceof Error ? $.toString() : $ && t.checkError.getConstructorName($)
    ), r(this, "object", $);
  }
  n.addMethod("throw", ae), n.addMethod("throws", ae), n.addMethod("Throw", ae);
  function V(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "itself"), j = typeof x == "function" && !P ? x.prototype[m] : x[m];
    this.assert(
      typeof j == "function",
      "expected #{this} to respond to " + t.inspect(m),
      "expected #{this} to not respond to " + t.inspect(m)
    );
  }
  n.addMethod("respondTo", V), n.addMethod("respondsTo", V), n.addProperty("itself", function() {
    r(this, "itself", !0);
  });
  function Ee(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = m(x);
    this.assert(
      P,
      "expected #{this} to satisfy " + t.objDisplay(m),
      "expected #{this} to not satisfy" + t.objDisplay(m),
      !r(this, "negate"),
      P
    );
  }
  n.addMethod("satisfy", Ee), n.addMethod("satisfies", Ee);
  function be(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "object"), j = r(this, "message"), D = r(this, "ssfi");
    if (new n(P, j, D, !0).is.a("number"), typeof m != "number" || typeof T != "number") {
      j = j ? j + ": " : "";
      var I = T === void 0 ? ", and a delta is required" : "";
      throw new o(
        j + "the arguments to closeTo or approximately must be numbers" + I,
        void 0,
        D
      );
    }
    this.assert(
      Math.abs(P - m) <= T,
      "expected #{this} to be close to " + m + " +/- " + T,
      "expected #{this} not to be close to " + m + " +/- " + T
    );
  }
  n.addMethod("closeTo", be), n.addMethod("approximately", be);
  function Se(m, T, x, P, j) {
    if (!P) {
      if (m.length !== T.length)
        return !1;
      T = T.slice();
    }
    return m.every(function(D, I) {
      if (j)
        return x ? x(D, T[I]) : D === T[I];
      if (!x) {
        var $ = T.indexOf(D);
        return $ === -1 ? !1 : (P || T.splice($, 1), !0);
      }
      return T.some(function(q, K) {
        return x(D, q) ? (P || T.splice(K, 1), !0) : !1;
      });
    });
  }
  n.addMethod("members", function(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "message"), j = r(this, "ssfi");
    new n(x, P, j, !0).to.be.an("array"), new n(m, P, j, !0).to.be.an("array");
    var D = r(this, "contains"), I = r(this, "ordered"), $, q, K;
    D ? ($ = I ? "an ordered superset" : "a superset", q = "expected #{this} to be " + $ + " of #{exp}", K = "expected #{this} to not be " + $ + " of #{exp}") : ($ = I ? "ordered members" : "members", q = "expected #{this} to have the same " + $ + " as #{exp}", K = "expected #{this} to not have the same " + $ + " as #{exp}");
    var J = r(this, "deep") ? r(this, "eql") : void 0;
    this.assert(
      Se(m, x, J, D, I),
      q,
      K,
      m,
      x,
      !0
    );
  });
  function Me(m, T) {
    T && r(this, "message", T);
    var x = r(this, "object"), P = r(this, "message"), j = r(this, "ssfi"), D = r(this, "contains"), I = r(this, "deep"), $ = r(this, "eql");
    new n(m, P, j, !0).to.be.an("array"), D ? this.assert(
      m.some(function(q) {
        return x.indexOf(q) > -1;
      }),
      "expected #{this} to contain one of #{exp}",
      "expected #{this} to not contain one of #{exp}",
      m,
      x
    ) : I ? this.assert(
      m.some(function(q) {
        return $(x, q);
      }),
      "expected #{this} to deeply equal one of #{exp}",
      "expected #{this} to deeply equal one of #{exp}",
      m,
      x
    ) : this.assert(
      m.indexOf(x) > -1,
      "expected #{this} to be one of #{exp}",
      "expected #{this} to not be one of #{exp}",
      m,
      x
    );
  }
  n.addMethod("oneOf", Me);
  function Fe(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "object"), j = r(this, "message"), D = r(this, "ssfi");
    new n(P, j, D, !0).is.a("function");
    var I;
    T ? (new n(m, j, D, !0).to.have.property(T), I = m[T]) : (new n(m, j, D, !0).is.a("function"), I = m()), P();
    var $ = T == null ? m() : m[T], q = T == null ? I : "." + T;
    r(this, "deltaMsgObj", q), r(this, "initialDeltaValue", I), r(this, "finalDeltaValue", $), r(this, "deltaBehavior", "change"), r(this, "realDelta", $ !== I), this.assert(
      I !== $,
      "expected " + q + " to change",
      "expected " + q + " to not change"
    );
  }
  n.addMethod("change", Fe), n.addMethod("changes", Fe);
  function Pe(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "object"), j = r(this, "message"), D = r(this, "ssfi");
    new n(P, j, D, !0).is.a("function");
    var I;
    T ? (new n(m, j, D, !0).to.have.property(T), I = m[T]) : (new n(m, j, D, !0).is.a("function"), I = m()), new n(I, j, D, !0).is.a("number"), P();
    var $ = T == null ? m() : m[T], q = T == null ? I : "." + T;
    r(this, "deltaMsgObj", q), r(this, "initialDeltaValue", I), r(this, "finalDeltaValue", $), r(this, "deltaBehavior", "increase"), r(this, "realDelta", $ - I), this.assert(
      $ - I > 0,
      "expected " + q + " to increase",
      "expected " + q + " to not increase"
    );
  }
  n.addMethod("increase", Pe), n.addMethod("increases", Pe);
  function Ne(m, T, x) {
    x && r(this, "message", x);
    var P = r(this, "object"), j = r(this, "message"), D = r(this, "ssfi");
    new n(P, j, D, !0).is.a("function");
    var I;
    T ? (new n(m, j, D, !0).to.have.property(T), I = m[T]) : (new n(m, j, D, !0).is.a("function"), I = m()), new n(I, j, D, !0).is.a("number"), P();
    var $ = T == null ? m() : m[T], q = T == null ? I : "." + T;
    r(this, "deltaMsgObj", q), r(this, "initialDeltaValue", I), r(this, "finalDeltaValue", $), r(this, "deltaBehavior", "decrease"), r(this, "realDelta", I - $), this.assert(
      $ - I < 0,
      "expected " + q + " to decrease",
      "expected " + q + " to not decrease"
    );
  }
  n.addMethod("decrease", Ne), n.addMethod("decreases", Ne);
  function De(m, T) {
    T && r(this, "message", T);
    var x = r(this, "deltaMsgObj"), P = r(this, "initialDeltaValue"), j = r(this, "finalDeltaValue"), D = r(this, "deltaBehavior"), I = r(this, "realDelta"), $;
    D === "change" ? $ = Math.abs(j - P) === Math.abs(m) : $ = I === Math.abs(m), this.assert(
      $,
      "expected " + x + " to " + D + " by " + m,
      "expected " + x + " to not " + D + " by " + m
    );
  }
  n.addMethod("by", De), n.addProperty("extensible", function() {
    var m = r(this, "object"), T = m === Object(m) && Object.isExtensible(m);
    this.assert(
      T,
      "expected #{this} to be extensible",
      "expected #{this} to not be extensible"
    );
  }), n.addProperty("sealed", function() {
    var m = r(this, "object"), T = m === Object(m) ? Object.isSealed(m) : !0;
    this.assert(
      T,
      "expected #{this} to be sealed",
      "expected #{this} to not be sealed"
    );
  }), n.addProperty("frozen", function() {
    var m = r(this, "object"), T = m === Object(m) ? Object.isFrozen(m) : !0;
    this.assert(
      T,
      "expected #{this} to be frozen",
      "expected #{this} to not be frozen"
    );
  }), n.addProperty("finite", function(m) {
    var T = r(this, "object");
    this.assert(
      typeof T == "number" && isFinite(T),
      "expected #{this} to be a finite number",
      "expected #{this} to not be a finite number"
    );
  });
};
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var nh = function(e, t) {
  e.expect = function(n, o) {
    return new e.Assertion(n, o);
  }, e.expect.fail = function(n, o, r, s) {
    throw arguments.length < 2 && (r = n, n = void 0), r = r || "expect.fail()", new e.AssertionError(r, {
      actual: n,
      expected: o,
      operator: s
    }, e.expect.fail);
  };
};
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var rh = function(e, t) {
  var n = e.Assertion;
  function o() {
    function r() {
      return this instanceof String || this instanceof Number || this instanceof Boolean || typeof Symbol == "function" && this instanceof Symbol || typeof BigInt == "function" && this instanceof BigInt ? new n(this.valueOf(), null, r) : new n(this, null, r);
    }
    function s(a) {
      Object.defineProperty(this, "should", {
        value: a,
        enumerable: !0,
        configurable: !0,
        writable: !0
      });
    }
    Object.defineProperty(Object.prototype, "should", {
      set: s,
      get: r,
      configurable: !0
    });
    var i = {};
    return i.fail = function(a, c, l, f) {
      throw arguments.length < 2 && (l = a, a = void 0), l = l || "should.fail()", new e.AssertionError(l, {
        actual: a,
        expected: c,
        operator: f
      }, i.fail);
    }, i.equal = function(a, c, l) {
      new n(a, l).to.equal(c);
    }, i.Throw = function(a, c, l, f) {
      new n(a, f).to.Throw(c, l);
    }, i.exist = function(a, c) {
      new n(a, c).to.exist;
    }, i.not = {}, i.not.equal = function(a, c, l) {
      new n(a, l).to.not.equal(c);
    }, i.not.Throw = function(a, c, l, f) {
      new n(a, f).to.not.Throw(c, l);
    }, i.not.exist = function(a, c) {
      new n(a, c).to.not.exist;
    }, i.throw = i.Throw, i.not.throw = i.not.Throw, i;
  }
  e.should = o, e.Should = o;
};
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var oh = function(e, t) {
  /*!
   * Chai dependencies.
   */
  var n = e.Assertion, o = t.flag;
  /*!
   * Module export.
   */
  var r = e.assert = function(s, i) {
    var a = new n(null, null, e.assert, !0);
    a.assert(
      s,
      i,
      "[ negation message unavailable ]"
    );
  };
  r.fail = function(s, i, a, c) {
    throw arguments.length < 2 && (a = s, s = void 0), a = a || "assert.fail()", new e.AssertionError(a, {
      actual: s,
      expected: i,
      operator: c
    }, r.fail);
  }, r.isOk = function(s, i) {
    new n(s, i, r.isOk, !0).is.ok;
  }, r.isNotOk = function(s, i) {
    new n(s, i, r.isNotOk, !0).is.not.ok;
  }, r.equal = function(s, i, a) {
    var c = new n(s, a, r.equal, !0);
    c.assert(
      i == o(c, "object"),
      "expected #{this} to equal #{exp}",
      "expected #{this} to not equal #{act}",
      i,
      s,
      !0
    );
  }, r.notEqual = function(s, i, a) {
    var c = new n(s, a, r.notEqual, !0);
    c.assert(
      i != o(c, "object"),
      "expected #{this} to not equal #{exp}",
      "expected #{this} to equal #{act}",
      i,
      s,
      !0
    );
  }, r.strictEqual = function(s, i, a) {
    new n(s, a, r.strictEqual, !0).to.equal(i);
  }, r.notStrictEqual = function(s, i, a) {
    new n(s, a, r.notStrictEqual, !0).to.not.equal(i);
  }, r.deepEqual = r.deepStrictEqual = function(s, i, a) {
    new n(s, a, r.deepEqual, !0).to.eql(i);
  }, r.notDeepEqual = function(s, i, a) {
    new n(s, a, r.notDeepEqual, !0).to.not.eql(i);
  }, r.isAbove = function(s, i, a) {
    new n(s, a, r.isAbove, !0).to.be.above(i);
  }, r.isAtLeast = function(s, i, a) {
    new n(s, a, r.isAtLeast, !0).to.be.least(i);
  }, r.isBelow = function(s, i, a) {
    new n(s, a, r.isBelow, !0).to.be.below(i);
  }, r.isAtMost = function(s, i, a) {
    new n(s, a, r.isAtMost, !0).to.be.most(i);
  }, r.isTrue = function(s, i) {
    new n(s, i, r.isTrue, !0).is.true;
  }, r.isNotTrue = function(s, i) {
    new n(s, i, r.isNotTrue, !0).to.not.equal(!0);
  }, r.isFalse = function(s, i) {
    new n(s, i, r.isFalse, !0).is.false;
  }, r.isNotFalse = function(s, i) {
    new n(s, i, r.isNotFalse, !0).to.not.equal(!1);
  }, r.isNull = function(s, i) {
    new n(s, i, r.isNull, !0).to.equal(null);
  }, r.isNotNull = function(s, i) {
    new n(s, i, r.isNotNull, !0).to.not.equal(null);
  }, r.isNaN = function(s, i) {
    new n(s, i, r.isNaN, !0).to.be.NaN;
  }, r.isNotNaN = function(s, i) {
    new n(s, i, r.isNotNaN, !0).not.to.be.NaN;
  }, r.exists = function(s, i) {
    new n(s, i, r.exists, !0).to.exist;
  }, r.notExists = function(s, i) {
    new n(s, i, r.notExists, !0).to.not.exist;
  }, r.isUndefined = function(s, i) {
    new n(s, i, r.isUndefined, !0).to.equal(void 0);
  }, r.isDefined = function(s, i) {
    new n(s, i, r.isDefined, !0).to.not.equal(void 0);
  }, r.isFunction = function(s, i) {
    new n(s, i, r.isFunction, !0).to.be.a("function");
  }, r.isNotFunction = function(s, i) {
    new n(s, i, r.isNotFunction, !0).to.not.be.a("function");
  }, r.isObject = function(s, i) {
    new n(s, i, r.isObject, !0).to.be.a("object");
  }, r.isNotObject = function(s, i) {
    new n(s, i, r.isNotObject, !0).to.not.be.a("object");
  }, r.isArray = function(s, i) {
    new n(s, i, r.isArray, !0).to.be.an("array");
  }, r.isNotArray = function(s, i) {
    new n(s, i, r.isNotArray, !0).to.not.be.an("array");
  }, r.isString = function(s, i) {
    new n(s, i, r.isString, !0).to.be.a("string");
  }, r.isNotString = function(s, i) {
    new n(s, i, r.isNotString, !0).to.not.be.a("string");
  }, r.isNumber = function(s, i) {
    new n(s, i, r.isNumber, !0).to.be.a("number");
  }, r.isNotNumber = function(s, i) {
    new n(s, i, r.isNotNumber, !0).to.not.be.a("number");
  }, r.isFinite = function(s, i) {
    new n(s, i, r.isFinite, !0).to.be.finite;
  }, r.isBoolean = function(s, i) {
    new n(s, i, r.isBoolean, !0).to.be.a("boolean");
  }, r.isNotBoolean = function(s, i) {
    new n(s, i, r.isNotBoolean, !0).to.not.be.a("boolean");
  }, r.typeOf = function(s, i, a) {
    new n(s, a, r.typeOf, !0).to.be.a(i);
  }, r.notTypeOf = function(s, i, a) {
    new n(s, a, r.notTypeOf, !0).to.not.be.a(i);
  }, r.instanceOf = function(s, i, a) {
    new n(s, a, r.instanceOf, !0).to.be.instanceOf(i);
  }, r.notInstanceOf = function(s, i, a) {
    new n(s, a, r.notInstanceOf, !0).to.not.be.instanceOf(i);
  }, r.include = function(s, i, a) {
    new n(s, a, r.include, !0).include(i);
  }, r.notInclude = function(s, i, a) {
    new n(s, a, r.notInclude, !0).not.include(i);
  }, r.deepInclude = function(s, i, a) {
    new n(s, a, r.deepInclude, !0).deep.include(i);
  }, r.notDeepInclude = function(s, i, a) {
    new n(s, a, r.notDeepInclude, !0).not.deep.include(i);
  }, r.nestedInclude = function(s, i, a) {
    new n(s, a, r.nestedInclude, !0).nested.include(i);
  }, r.notNestedInclude = function(s, i, a) {
    new n(s, a, r.notNestedInclude, !0).not.nested.include(i);
  }, r.deepNestedInclude = function(s, i, a) {
    new n(s, a, r.deepNestedInclude, !0).deep.nested.include(i);
  }, r.notDeepNestedInclude = function(s, i, a) {
    new n(s, a, r.notDeepNestedInclude, !0).not.deep.nested.include(i);
  }, r.ownInclude = function(s, i, a) {
    new n(s, a, r.ownInclude, !0).own.include(i);
  }, r.notOwnInclude = function(s, i, a) {
    new n(s, a, r.notOwnInclude, !0).not.own.include(i);
  }, r.deepOwnInclude = function(s, i, a) {
    new n(s, a, r.deepOwnInclude, !0).deep.own.include(i);
  }, r.notDeepOwnInclude = function(s, i, a) {
    new n(s, a, r.notDeepOwnInclude, !0).not.deep.own.include(i);
  }, r.match = function(s, i, a) {
    new n(s, a, r.match, !0).to.match(i);
  }, r.notMatch = function(s, i, a) {
    new n(s, a, r.notMatch, !0).to.not.match(i);
  }, r.property = function(s, i, a) {
    new n(s, a, r.property, !0).to.have.property(i);
  }, r.notProperty = function(s, i, a) {
    new n(s, a, r.notProperty, !0).to.not.have.property(i);
  }, r.propertyVal = function(s, i, a, c) {
    new n(s, c, r.propertyVal, !0).to.have.property(i, a);
  }, r.notPropertyVal = function(s, i, a, c) {
    new n(s, c, r.notPropertyVal, !0).to.not.have.property(i, a);
  }, r.deepPropertyVal = function(s, i, a, c) {
    new n(s, c, r.deepPropertyVal, !0).to.have.deep.property(i, a);
  }, r.notDeepPropertyVal = function(s, i, a, c) {
    new n(s, c, r.notDeepPropertyVal, !0).to.not.have.deep.property(i, a);
  }, r.ownProperty = function(s, i, a) {
    new n(s, a, r.ownProperty, !0).to.have.own.property(i);
  }, r.notOwnProperty = function(s, i, a) {
    new n(s, a, r.notOwnProperty, !0).to.not.have.own.property(i);
  }, r.ownPropertyVal = function(s, i, a, c) {
    new n(s, c, r.ownPropertyVal, !0).to.have.own.property(i, a);
  }, r.notOwnPropertyVal = function(s, i, a, c) {
    new n(s, c, r.notOwnPropertyVal, !0).to.not.have.own.property(i, a);
  }, r.deepOwnPropertyVal = function(s, i, a, c) {
    new n(s, c, r.deepOwnPropertyVal, !0).to.have.deep.own.property(i, a);
  }, r.notDeepOwnPropertyVal = function(s, i, a, c) {
    new n(s, c, r.notDeepOwnPropertyVal, !0).to.not.have.deep.own.property(i, a);
  }, r.nestedProperty = function(s, i, a) {
    new n(s, a, r.nestedProperty, !0).to.have.nested.property(i);
  }, r.notNestedProperty = function(s, i, a) {
    new n(s, a, r.notNestedProperty, !0).to.not.have.nested.property(i);
  }, r.nestedPropertyVal = function(s, i, a, c) {
    new n(s, c, r.nestedPropertyVal, !0).to.have.nested.property(i, a);
  }, r.notNestedPropertyVal = function(s, i, a, c) {
    new n(s, c, r.notNestedPropertyVal, !0).to.not.have.nested.property(i, a);
  }, r.deepNestedPropertyVal = function(s, i, a, c) {
    new n(s, c, r.deepNestedPropertyVal, !0).to.have.deep.nested.property(i, a);
  }, r.notDeepNestedPropertyVal = function(s, i, a, c) {
    new n(s, c, r.notDeepNestedPropertyVal, !0).to.not.have.deep.nested.property(i, a);
  }, r.lengthOf = function(s, i, a) {
    new n(s, a, r.lengthOf, !0).to.have.lengthOf(i);
  }, r.hasAnyKeys = function(s, i, a) {
    new n(s, a, r.hasAnyKeys, !0).to.have.any.keys(i);
  }, r.hasAllKeys = function(s, i, a) {
    new n(s, a, r.hasAllKeys, !0).to.have.all.keys(i);
  }, r.containsAllKeys = function(s, i, a) {
    new n(s, a, r.containsAllKeys, !0).to.contain.all.keys(i);
  }, r.doesNotHaveAnyKeys = function(s, i, a) {
    new n(s, a, r.doesNotHaveAnyKeys, !0).to.not.have.any.keys(i);
  }, r.doesNotHaveAllKeys = function(s, i, a) {
    new n(s, a, r.doesNotHaveAllKeys, !0).to.not.have.all.keys(i);
  }, r.hasAnyDeepKeys = function(s, i, a) {
    new n(s, a, r.hasAnyDeepKeys, !0).to.have.any.deep.keys(i);
  }, r.hasAllDeepKeys = function(s, i, a) {
    new n(s, a, r.hasAllDeepKeys, !0).to.have.all.deep.keys(i);
  }, r.containsAllDeepKeys = function(s, i, a) {
    new n(s, a, r.containsAllDeepKeys, !0).to.contain.all.deep.keys(i);
  }, r.doesNotHaveAnyDeepKeys = function(s, i, a) {
    new n(s, a, r.doesNotHaveAnyDeepKeys, !0).to.not.have.any.deep.keys(i);
  }, r.doesNotHaveAllDeepKeys = function(s, i, a) {
    new n(s, a, r.doesNotHaveAllDeepKeys, !0).to.not.have.all.deep.keys(i);
  }, r.throws = function(s, i, a, c) {
    (typeof i == "string" || i instanceof RegExp) && (a = i, i = null);
    var l = new n(s, c, r.throws, !0).to.throw(i, a);
    return o(l, "object");
  }, r.doesNotThrow = function(s, i, a, c) {
    (typeof i == "string" || i instanceof RegExp) && (a = i, i = null), new n(s, c, r.doesNotThrow, !0).to.not.throw(i, a);
  }, r.operator = function(s, i, a, c) {
    var l;
    switch (i) {
      case "==":
        l = s == a;
        break;
      case "===":
        l = s === a;
        break;
      case ">":
        l = s > a;
        break;
      case ">=":
        l = s >= a;
        break;
      case "<":
        l = s < a;
        break;
      case "<=":
        l = s <= a;
        break;
      case "!=":
        l = s != a;
        break;
      case "!==":
        l = s !== a;
        break;
      default:
        throw c = c && c + ": ", new e.AssertionError(
          c + 'Invalid operator "' + i + '"',
          void 0,
          r.operator
        );
    }
    var f = new n(l, c, r.operator, !0);
    f.assert(
      o(f, "object") === !0,
      "expected " + t.inspect(s) + " to be " + i + " " + t.inspect(a),
      "expected " + t.inspect(s) + " to not be " + i + " " + t.inspect(a)
    );
  }, r.closeTo = function(s, i, a, c) {
    new n(s, c, r.closeTo, !0).to.be.closeTo(i, a);
  }, r.approximately = function(s, i, a, c) {
    new n(s, c, r.approximately, !0).to.be.approximately(i, a);
  }, r.sameMembers = function(s, i, a) {
    new n(s, a, r.sameMembers, !0).to.have.same.members(i);
  }, r.notSameMembers = function(s, i, a) {
    new n(s, a, r.notSameMembers, !0).to.not.have.same.members(i);
  }, r.sameDeepMembers = function(s, i, a) {
    new n(s, a, r.sameDeepMembers, !0).to.have.same.deep.members(i);
  }, r.notSameDeepMembers = function(s, i, a) {
    new n(s, a, r.notSameDeepMembers, !0).to.not.have.same.deep.members(i);
  }, r.sameOrderedMembers = function(s, i, a) {
    new n(s, a, r.sameOrderedMembers, !0).to.have.same.ordered.members(i);
  }, r.notSameOrderedMembers = function(s, i, a) {
    new n(s, a, r.notSameOrderedMembers, !0).to.not.have.same.ordered.members(i);
  }, r.sameDeepOrderedMembers = function(s, i, a) {
    new n(s, a, r.sameDeepOrderedMembers, !0).to.have.same.deep.ordered.members(i);
  }, r.notSameDeepOrderedMembers = function(s, i, a) {
    new n(s, a, r.notSameDeepOrderedMembers, !0).to.not.have.same.deep.ordered.members(i);
  }, r.includeMembers = function(s, i, a) {
    new n(s, a, r.includeMembers, !0).to.include.members(i);
  }, r.notIncludeMembers = function(s, i, a) {
    new n(s, a, r.notIncludeMembers, !0).to.not.include.members(i);
  }, r.includeDeepMembers = function(s, i, a) {
    new n(s, a, r.includeDeepMembers, !0).to.include.deep.members(i);
  }, r.notIncludeDeepMembers = function(s, i, a) {
    new n(s, a, r.notIncludeDeepMembers, !0).to.not.include.deep.members(i);
  }, r.includeOrderedMembers = function(s, i, a) {
    new n(s, a, r.includeOrderedMembers, !0).to.include.ordered.members(i);
  }, r.notIncludeOrderedMembers = function(s, i, a) {
    new n(s, a, r.notIncludeOrderedMembers, !0).to.not.include.ordered.members(i);
  }, r.includeDeepOrderedMembers = function(s, i, a) {
    new n(s, a, r.includeDeepOrderedMembers, !0).to.include.deep.ordered.members(i);
  }, r.notIncludeDeepOrderedMembers = function(s, i, a) {
    new n(s, a, r.notIncludeDeepOrderedMembers, !0).to.not.include.deep.ordered.members(i);
  }, r.oneOf = function(s, i, a) {
    new n(s, a, r.oneOf, !0).to.be.oneOf(i);
  }, r.changes = function(s, i, a, c) {
    arguments.length === 3 && typeof i == "function" && (c = a, a = null), new n(s, c, r.changes, !0).to.change(i, a);
  }, r.changesBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    new n(s, l, r.changesBy, !0).to.change(i, a).by(c);
  }, r.doesNotChange = function(s, i, a, c) {
    return arguments.length === 3 && typeof i == "function" && (c = a, a = null), new n(s, c, r.doesNotChange, !0).to.not.change(i, a);
  }, r.changesButNotBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    new n(s, l, r.changesButNotBy, !0).to.change(i, a).but.not.by(c);
  }, r.increases = function(s, i, a, c) {
    return arguments.length === 3 && typeof i == "function" && (c = a, a = null), new n(s, c, r.increases, !0).to.increase(i, a);
  }, r.increasesBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    new n(s, l, r.increasesBy, !0).to.increase(i, a).by(c);
  }, r.doesNotIncrease = function(s, i, a, c) {
    return arguments.length === 3 && typeof i == "function" && (c = a, a = null), new n(s, c, r.doesNotIncrease, !0).to.not.increase(i, a);
  }, r.increasesButNotBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    new n(s, l, r.increasesButNotBy, !0).to.increase(i, a).but.not.by(c);
  }, r.decreases = function(s, i, a, c) {
    return arguments.length === 3 && typeof i == "function" && (c = a, a = null), new n(s, c, r.decreases, !0).to.decrease(i, a);
  }, r.decreasesBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    new n(s, l, r.decreasesBy, !0).to.decrease(i, a).by(c);
  }, r.doesNotDecrease = function(s, i, a, c) {
    return arguments.length === 3 && typeof i == "function" && (c = a, a = null), new n(s, c, r.doesNotDecrease, !0).to.not.decrease(i, a);
  }, r.doesNotDecreaseBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    return new n(s, l, r.doesNotDecreaseBy, !0).to.not.decrease(i, a).by(c);
  }, r.decreasesButNotBy = function(s, i, a, c, l) {
    if (arguments.length === 4 && typeof i == "function") {
      var f = c;
      c = a, l = f;
    } else
      arguments.length === 3 && (c = a, a = null);
    new n(s, l, r.decreasesButNotBy, !0).to.decrease(i, a).but.not.by(c);
  };
  /*!
   * ### .ifError(object)
   *
   * Asserts if value is not a false value, and throws if it is a true value.
   * This is added to allow for chai to be a drop-in replacement for Node's
   * assert class.
   *
   *     var err = new Error('I am a custom error');
   *     assert.ifError(err); // Rethrows err!
   *
   * @name ifError
   * @param {Object} object
   * @namespace Assert
   * @api public
   */
  r.ifError = function(s) {
    if (s)
      throw s;
  }, r.isExtensible = function(s, i) {
    new n(s, i, r.isExtensible, !0).to.be.extensible;
  }, r.isNotExtensible = function(s, i) {
    new n(s, i, r.isNotExtensible, !0).to.not.be.extensible;
  }, r.isSealed = function(s, i) {
    new n(s, i, r.isSealed, !0).to.be.sealed;
  }, r.isNotSealed = function(s, i) {
    new n(s, i, r.isNotSealed, !0).to.not.be.sealed;
  }, r.isFrozen = function(s, i) {
    new n(s, i, r.isFrozen, !0).to.be.frozen;
  }, r.isNotFrozen = function(s, i) {
    new n(s, i, r.isNotFrozen, !0).to.not.be.frozen;
  }, r.isEmpty = function(s, i) {
    new n(s, i, r.isEmpty, !0).to.be.empty;
  }, r.isNotEmpty = function(s, i) {
    new n(s, i, r.isNotEmpty, !0).to.not.be.empty;
  };
  /*!
   * Aliases.
   */
  (function s(i, a) {
    return r[a] = r[i], s;
  })("isOk", "ok")("isNotOk", "notOk")("throws", "throw")("throws", "Throw")("isExtensible", "extensible")("isNotExtensible", "notExtensible")("isSealed", "sealed")("isNotSealed", "notSealed")("isFrozen", "frozen")("isNotFrozen", "notFrozen")("isEmpty", "empty")("isNotEmpty", "notEmpty");
};
/*!
 * chai
 * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var js;
function Pt() {
  return js || (js = 1, function(e) {
    var t = [];
    /*!
     * Chai version
     */
    e.version = "4.3.8";
    /*!
     * Assertion Error
     */
    e.AssertionError = Na;
    /*!
     * Utils for plugins (not exported)
     */
    var n = Zp();
    e.use = function(l) {
      return ~t.indexOf(l) || (l(e, n), t.push(l)), e;
    };
    /*!
     * Utility Functions
     */
    e.util = n;
    /*!
     * Configuration
     */
    var o = Xt;
    e.config = o;
    /*!
     * Primary `Assertion` prototype
     */
    var r = eh;
    e.use(r);
    /*!
     * Core Assertions
     */
    var s = th;
    e.use(s);
    /*!
     * Expect interface
     */
    var i = nh;
    e.use(i);
    /*!
     * Should interface
     */
    var a = rh;
    e.use(a);
    /*!
     * Assert interface
     */
    var c = oh;
    e.use(c);
  }(Sr)), Sr;
}
var sh = Pt();
const Ze = /* @__PURE__ */ uu(sh), Nr = Ze.expect;
Ze.version;
Ze.Assertion;
Ze.AssertionError;
const Kn = Ze.util;
Ze.config;
const Sn = Ze.use;
Ze.should;
const ih = Ze.assert;
Ze.core;
var bn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ah(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function Bn(e, t) {
  if (!e)
    throw new Error(t);
}
function Bt(e, t) {
  return typeof t === e;
}
function ch(e) {
  return e instanceof Promise;
}
function Hr(e, t, n) {
  Object.defineProperty(e, t, n);
}
function Lt(e, t, n) {
  Object.defineProperty(e, t, { value: n });
}
var pn = Symbol.for("tinyspy:spy"), uh = /* @__PURE__ */ new Set(), lh = (e) => {
  e.called = !1, e.callCount = 0, e.calls = [], e.results = [], e.next = [];
}, fh = (e) => (Hr(e, pn, { value: { reset: () => lh(e[pn]) } }), e[pn]), Xr = (e) => e[pn] || fh(e);
function ph(e) {
  Bn(Bt("function", e) || Bt("undefined", e), "cannot spy on a non-function value");
  let t = function(...o) {
    let r = Xr(t);
    r.called = !0, r.callCount++, r.calls.push(o);
    let s = r.next.shift();
    if (s) {
      r.results.push(s);
      let [l, f] = s;
      if (l === "ok")
        return f;
      throw f;
    }
    let i, a = "ok";
    if (r.impl)
      try {
        new.target ? i = Reflect.construct(r.impl, o, new.target) : i = r.impl.apply(this, o), a = "ok";
      } catch (l) {
        throw i = l, a = "error", r.results.push([a, l]), l;
      }
    let c = [a, i];
    if (ch(i)) {
      let l = i.then((f) => c[1] = f).catch((f) => {
        throw c[0] = "error", c[1] = f, f;
      });
      Object.assign(l, i), i = l;
    }
    return r.results.push(c), i;
  };
  Lt(t, "_isMockFunction", !0), Lt(t, "length", e ? e.length : 0), Lt(t, "name", e && e.name || "spy");
  let n = Xr(t);
  return n.reset(), n.impl = e, t;
}
var ks = (e, t) => Object.getOwnPropertyDescriptor(e, t), Rs = (e, t) => {
  t != null && typeof t == "function" && t.prototype != null && Object.setPrototypeOf(e.prototype, t.prototype);
};
function Ua(e, t, n) {
  Bn(!Bt("undefined", e), "spyOn could not find an object to spy upon"), Bn(Bt("object", e) || Bt("function", e), "cannot spyOn on a primitive value");
  let [o, r] = (() => {
    if (!Bt("object", t))
      return [t, "value"];
    if ("getter" in t && "setter" in t)
      throw new Error("cannot spy on both getter and setter");
    if ("getter" in t)
      return [t.getter, "get"];
    if ("setter" in t)
      return [t.setter, "set"];
    throw new Error("specify getter or setter to spy on");
  })(), s = ks(e, o), i = Object.getPrototypeOf(e), a = i && ks(i, o), c = s || a;
  Bn(c || o in e, `${String(o)} does not exist`);
  let l = !1;
  r === "value" && c && !c.value && c.get && (r = "get", l = !0, n = c.get());
  let f;
  c ? f = c[r] : r !== "value" ? f = () => e[o] : f = e[o], n || (n = f);
  let u = ph(n);
  r === "value" && Rs(u, f);
  let p = (v) => {
    let { value: h, ...A } = c || {
      configurable: !0,
      writable: !0
    };
    r !== "value" && delete A.writable, A[r] = v, Hr(e, o, A);
  }, w = () => c ? Hr(e, o, c) : p(f), b = u[pn];
  return Lt(b, "restore", w), Lt(b, "getOriginal", () => l ? f() : f), Lt(b, "willCall", (v) => (b.impl = v, u)), p(l ? () => (Rs(u, n), u) : u), uh.add(u), u;
}
const Ln = /* @__PURE__ */ new Set();
function Ka(e) {
  return typeof e == "function" && "_isMockFunction" in e && e._isMockFunction;
}
function hh(e, t, n) {
  const r = n ? { [{
    get: "getter",
    set: "setter"
  }[n]]: t } : t, s = Ua(e, r);
  return Ga(s);
}
let mh = 0;
function Ga(e) {
  const t = e;
  let n, o = [], r = [];
  const s = Xr(e), i = {
    get calls() {
      return s.calls;
    },
    get instances() {
      return o;
    },
    get invocationCallOrder() {
      return r;
    },
    get results() {
      return s.results.map(([p, w]) => ({ type: p === "error" ? "throw" : "return", value: w }));
    },
    get lastCall() {
      return s.calls[s.calls.length - 1];
    }
  };
  let a = [], c = !1;
  function l(...p) {
    return o.push(this), r.push(++mh), (c ? n : a.shift() || n || s.getOriginal() || (() => {
    })).apply(this, p);
  }
  let f = t.name;
  t.getMockName = () => f || "vi.fn()", t.mockName = (p) => (f = p, t), t.mockClear = () => (s.reset(), o = [], r = [], t), t.mockReset = () => (t.mockClear(), n = () => {
  }, a = [], t), t.mockRestore = () => (t.mockReset(), s.restore(), n = void 0, t), t.getMockImplementation = () => n, t.mockImplementation = (p) => (n = p, s.willCall(l), t), t.mockImplementationOnce = (p) => (a.push(p), t);
  function u(p, w) {
    const b = n;
    n = p, s.willCall(l), c = !0;
    const v = () => {
      n = b, c = !1;
    }, h = w();
    return h instanceof Promise ? h.then(() => (v(), t)) : (v(), t);
  }
  return t.withImplementation = u, t.mockReturnThis = () => t.mockImplementation(function() {
    return this;
  }), t.mockReturnValue = (p) => t.mockImplementation(() => p), t.mockReturnValueOnce = (p) => t.mockImplementationOnce(() => p), t.mockResolvedValue = (p) => t.mockImplementation(() => Promise.resolve(p)), t.mockResolvedValueOnce = (p) => t.mockImplementationOnce(() => Promise.resolve(p)), t.mockRejectedValue = (p) => t.mockImplementation(() => Promise.reject(p)), t.mockRejectedValueOnce = (p) => t.mockImplementationOnce(() => Promise.reject(p)), Object.defineProperty(t, "mock", {
    get: () => i
  }), s.willCall(l), Ln.add(t), t;
}
function dh(e) {
  const t = Ga(Ua({ spy: e || (() => {
  }) }, "spy"));
  return e && t.mockImplementation(e), t;
}
const Gn = Symbol.for("matchers-object"), Tn = Symbol.for("$$jest-matchers-object"), xn = Symbol.for("expect-global"), vo = Symbol.for("asymmetric-matchers-object");
if (!Object.prototype.hasOwnProperty.call(globalThis, Gn)) {
  const e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ Object.create(null), n = [], o = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, Gn, {
    get: () => e
  }), Object.defineProperty(globalThis, Tn, {
    configurable: !0,
    get: () => ({
      state: e.get(globalThis[xn]),
      matchers: t,
      customEqualityTesters: n
    })
  }), Object.defineProperty(globalThis, vo, {
    get: () => o
  });
}
function qt(e) {
  return globalThis[Gn].get(e);
}
function jr(e, t) {
  const n = globalThis[Gn], o = n.get(t) || {};
  Object.assign(o, e), n.set(t, o);
}
function Ja() {
  const e = () => lo(), t = e().green, n = e().red, o = e().inverse, r = e().bold, s = e().dim;
  function i(u, p = "received", w = "expected", b = {}) {
    const {
      comment: v = "",
      isDirectExpectCall: h = !1,
      // seems redundant with received === ''
      isNot: A = !1,
      promise: M = "",
      secondArgument: F = "",
      expectedColor: k = t,
      receivedColor: N = n,
      secondArgumentColor: U = t
    } = b;
    let B = "", G = "expect";
    return !h && p !== "" && (B += s(`${G}(`) + N(p), G = ")"), M !== "" && (B += s(`${G}.`) + M, G = ""), A && (B += `${s(`${G}.`)}not`, G = ""), u.includes(".") ? G += u : (B += s(`${G}.`) + u, G = ""), w === "" ? G += "()" : (B += s(`${G}(`) + k(w), F && (B += s(", ") + U(F)), G = ")"), v !== "" && (G += ` // ${v}`), G !== "" && (B += s(G)), B;
  }
  const a = "·", c = (u) => u.replace(/\s+$/gm, (p) => a.repeat(p.length));
  return {
    EXPECTED_COLOR: t,
    RECEIVED_COLOR: n,
    INVERTED_COLOR: o,
    BOLD_WEIGHT: r,
    DIM_COLOR: s,
    matcherHint: i,
    printReceived: (u) => n(c(Qe(u))),
    printExpected: (u) => t(c(Qe(u)))
  };
}
function yh(e) {
  if (!Array.isArray(e))
    throw new TypeError(
      `expect.customEqualityTesters: Must be set to an array of Testers. Was given "${Wn(
        e
      )}"`
    );
  globalThis[Tn].customEqualityTesters.push(
    ...e
  );
}
function Eo() {
  return globalThis[Tn].customEqualityTesters;
}
function de(e, t, n, o) {
  return n = n || [], Ya(e, t, [], [], n, o ? Ha : bh);
}
function Fs(e) {
  return !!e && typeof e == "object" && "asymmetricMatch" in e && Je("Function", e.asymmetricMatch);
}
function gh(e, t) {
  const n = Fs(e), o = Fs(t);
  if (!(n && o)) {
    if (n)
      return e.asymmetricMatch(t);
    if (o)
      return t.asymmetricMatch(e);
  }
}
function Ya(e, t, n, o, r, s) {
  let i = !0;
  const a = gh(e, t);
  if (a !== void 0)
    return a;
  const c = { equals: de };
  for (let b = 0; b < r.length; b++) {
    const v = r[b].call(c, e, t, r);
    if (v !== void 0)
      return v;
  }
  if (e instanceof Error && t instanceof Error)
    return e.message === t.message;
  if (typeof URL == "function" && e instanceof URL && t instanceof URL)
    return e.href === t.href;
  if (Object.is(e, t))
    return !0;
  if (e === null || t === null)
    return e === t;
  const l = Object.prototype.toString.call(e);
  if (l !== Object.prototype.toString.call(t))
    return !1;
  switch (l) {
    case "[object Boolean]":
    case "[object String]":
    case "[object Number]":
      return typeof e != typeof t ? !1 : typeof e != "object" && typeof t != "object" ? Object.is(e, t) : Object.is(e.valueOf(), t.valueOf());
    case "[object Date]": {
      const b = +e, v = +t;
      return b === v || Number.isNaN(b) && Number.isNaN(v);
    }
    case "[object RegExp]":
      return e.source === t.source && e.flags === t.flags;
  }
  if (typeof e != "object" || typeof t != "object")
    return !1;
  if (Bs(e) && Bs(t))
    return e.isEqualNode(t);
  let f = n.length;
  for (; f--; ) {
    if (n[f] === e)
      return o[f] === t;
    if (o[f] === t)
      return !1;
  }
  if (n.push(e), o.push(t), l === "[object Array]" && e.length !== t.length)
    return !1;
  const u = Ds(e, s);
  let p, w = u.length;
  if (Ds(t, s).length !== w)
    return !1;
  for (; w--; )
    if (p = u[w], i = s(t, p) && Ya(e[p], t[p], n, o, r, s), !i)
      return !1;
  return n.pop(), o.pop(), i;
}
function Ds(e, t) {
  const n = [];
  for (const o in e)
    t(e, o) && n.push(o);
  return n.concat(
    Object.getOwnPropertySymbols(e).filter(
      (o) => Object.getOwnPropertyDescriptor(e, o).enumerable
    )
  );
}
function bh(e, t) {
  return Ha(e, t) && e[t] !== void 0;
}
function Ha(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Je(e, t) {
  return Object.prototype.toString.apply(t) === `[object ${e}]`;
}
function Bs(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && typeof e.nodeType == "number" && "nodeName" in e && typeof e.nodeName == "string" && "isEqualNode" in e && typeof e.isEqualNode == "function";
}
const wh = "@@__IMMUTABLE_KEYED__@@", vh = "@@__IMMUTABLE_SET__@@", Xa = "@@__IMMUTABLE_ORDERED__@@";
function Eh(e) {
  return !!(e && e[wh] && !e[Xa]);
}
function Sh(e) {
  return !!(e && e[vh] && !e[Xa]);
}
const Qa = Symbol.iterator;
function Ls(e) {
  return !!(e != null && e[Qa]);
}
function Le(e, t, n = [], o = [], r = []) {
  if (typeof e != "object" || typeof t != "object" || Array.isArray(e) || Array.isArray(t) || !Ls(e) || !Ls(t))
    return;
  if (e.constructor !== t.constructor)
    return !1;
  let s = o.length;
  for (; s--; )
    if (o[s] === e)
      return r[s] === t;
  o.push(e), r.push(t);
  const i = [
    ...n.filter((l) => l !== Le),
    a
  ];
  function a(l, f) {
    return Le(
      l,
      f,
      [...i],
      [...o],
      [...r]
    );
  }
  if (e.size !== void 0) {
    if (e.size !== t.size)
      return !1;
    if (Je("Set", e) || Sh(e)) {
      let l = !0;
      for (const f of e)
        if (!t.has(f)) {
          let u = !1;
          for (const p of t)
            de(f, p, i) === !0 && (u = !0);
          if (u === !1) {
            l = !1;
            break;
          }
        }
      return o.pop(), r.pop(), l;
    } else if (Je("Map", e) || Eh(e)) {
      let l = !0;
      for (const f of e)
        if (!t.has(f[0]) || !de(f[1], t.get(f[0]), i)) {
          let u = !1;
          for (const p of t) {
            const w = de(f[0], p[0], i);
            let b = !1;
            w === !0 && (b = de(f[1], p[1], i)), b === !0 && (u = !0);
          }
          if (u === !1) {
            l = !1;
            break;
          }
        }
      return o.pop(), r.pop(), l;
    }
  }
  const c = t[Qa]();
  for (const l of e) {
    const f = c.next();
    if (f.done || !de(l, f.value, i))
      return !1;
  }
  return c.next().done ? (o.pop(), r.pop(), !0) : !1;
}
function Za(e, t) {
  return !e || typeof e != "object" || e === Object.prototype ? !1 : Object.prototype.hasOwnProperty.call(e, t) || Za(Object.getPrototypeOf(e), t);
}
function qs(e) {
  return oo(e) && !(e instanceof Error) && !Array.isArray(e) && !(e instanceof Date);
}
function $n(e, t, n = []) {
  const o = n.filter((s) => s !== $n), r = (s = /* @__PURE__ */ new WeakMap()) => (i, a) => {
    if (qs(a))
      return Object.keys(a).every((c) => {
        if (qs(a[c])) {
          if (s.has(a[c]))
            return de(i[c], a[c], o);
          s.set(a[c], !0);
        }
        const l = i != null && Za(i, c) && de(i[c], a[c], [
          ...o,
          r(s)
        ]);
        return s.delete(a[c]), l;
      });
  };
  return r()(e, t);
}
function zs(e, t) {
  if (!(e == null || t == null || e.constructor === t.constructor))
    return !1;
}
function Ws(e, t) {
  let n = e, o = t;
  if (!(e instanceof DataView && t instanceof DataView)) {
    if (!(e instanceof ArrayBuffer) || !(t instanceof ArrayBuffer))
      return;
    try {
      n = new DataView(e), o = new DataView(t);
    } catch {
      return;
    }
  }
  if (n.byteLength !== o.byteLength)
    return !1;
  for (let r = 0; r < n.byteLength; r++)
    if (n.getUint8(r) !== o.getUint8(r))
      return !1;
  return !0;
}
function Qr(e, t, n = []) {
  if (!Array.isArray(e) || !Array.isArray(t))
    return;
  const o = Object.keys(e), r = Object.keys(t), s = n.filter((i) => i !== Qr);
  return de(e, t, s, !0) && de(o, r);
}
function Th(e, t = "#{this}", n = "#{exp}") {
  const o = `expected ${t} to be ${n} // Object.is equality`;
  return ["toStrictEqual", "toEqual"].includes(e) ? `${o}

If it should pass with deep equality, replace "toBe" with "${e}"

Expected: ${t}
Received: serializes to the same string
` : o;
}
function xh(e, t) {
  return `${t} ${e}${t === 1 ? "" : "s"}`;
}
let Et = class {
  constructor(t, n = !1) {
    // should have "jest" to be compatible with its ecosystem
    se(this, "$$typeof", Symbol.for("jest.asymmetricMatcher"));
    this.sample = t, this.inverse = n;
  }
  getMatcherContext(t) {
    return {
      ...qt(t || globalThis[xn]),
      equals: de,
      isNot: this.inverse,
      customTesters: Eo(),
      utils: {
        ...Ja(),
        diff: gn,
        stringify: Qe,
        iterableEquality: Le,
        subsetEquality: $n
      }
    };
  }
  // implement custom chai/loupe inspect for better AssertionError.message formatting
  // https://github.com/chaijs/loupe/blob/9b8a6deabcd50adc056a64fb705896194710c5c6/src/index.ts#L29
  [Symbol.for("chai/inspect")](t) {
    const n = Qe(this, t.depth, { min: !0 });
    return n.length <= t.truncate ? n : `${this.toString()}{…}`;
  }
};
class Vs extends Et {
  constructor(t, n = !1) {
    if (!Je("String", t))
      throw new Error("Expected is not a string");
    super(t, n);
  }
  asymmetricMatch(t) {
    const n = Je("String", t) && t.includes(this.sample);
    return this.inverse ? !n : n;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "string";
  }
}
class $h extends Et {
  asymmetricMatch(t) {
    return t != null;
  }
  toString() {
    return "Anything";
  }
  toAsymmetricMatcher() {
    return "Anything";
  }
}
class Us extends Et {
  constructor(t, n = !1) {
    super(t, n);
  }
  getPrototype(t) {
    return Object.getPrototypeOf ? Object.getPrototypeOf(t) : t.constructor.prototype === t ? null : t.constructor.prototype;
  }
  hasProperty(t, n) {
    return t ? Object.prototype.hasOwnProperty.call(t, n) ? !0 : this.hasProperty(this.getPrototype(t), n) : !1;
  }
  asymmetricMatch(t) {
    if (typeof this.sample != "object")
      throw new TypeError(
        `You must provide an object to ${this.toString()}, not '${typeof this.sample}'.`
      );
    let n = !0;
    const o = this.getMatcherContext();
    for (const r in this.sample)
      if (!this.hasProperty(t, r) || !de(this.sample[r], t[r], o.customTesters)) {
        n = !1;
        break;
      }
    return this.inverse ? !n : n;
  }
  toString() {
    return `Object${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "object";
  }
}
class Ks extends Et {
  constructor(t, n = !1) {
    super(t, n);
  }
  asymmetricMatch(t) {
    if (!Array.isArray(this.sample))
      throw new TypeError(
        `You must provide an array to ${this.toString()}, not '${typeof this.sample}'.`
      );
    const n = this.getMatcherContext(), o = this.sample.length === 0 || Array.isArray(t) && this.sample.every(
      (r) => t.some((s) => de(r, s, n.customTesters))
    );
    return this.inverse ? !o : o;
  }
  toString() {
    return `Array${this.inverse ? "Not" : ""}Containing`;
  }
  getExpectedType() {
    return "array";
  }
}
class Oh extends Et {
  constructor(t) {
    if (typeof t > "u")
      throw new TypeError(
        "any() expects to be passed a constructor function. Please pass one or use anything() to match any object."
      );
    super(t);
  }
  fnNameFor(t) {
    if (t.name)
      return t.name;
    const o = Function.prototype.toString.call(t).match(/^(?:async)?\s*function\s*\*?\s*([\w$]+)\s*\(/);
    return o ? o[1] : "<anonymous>";
  }
  asymmetricMatch(t) {
    return this.sample === String ? typeof t == "string" || t instanceof String : this.sample === Number ? typeof t == "number" || t instanceof Number : this.sample === Function ? typeof t == "function" || t instanceof Function : this.sample === Boolean ? typeof t == "boolean" || t instanceof Boolean : this.sample === BigInt ? typeof t == "bigint" || t instanceof BigInt : this.sample === Symbol ? typeof t == "symbol" || t instanceof Symbol : this.sample === Object ? typeof t == "object" : t instanceof this.sample;
  }
  toString() {
    return "Any";
  }
  getExpectedType() {
    return this.sample === String ? "string" : this.sample === Number ? "number" : this.sample === Function ? "function" : this.sample === Object ? "object" : this.sample === Boolean ? "boolean" : this.fnNameFor(this.sample);
  }
  toAsymmetricMatcher() {
    return `Any<${this.fnNameFor(this.sample)}>`;
  }
}
class Gs extends Et {
  constructor(t, n = !1) {
    if (!Je("String", t) && !Je("RegExp", t))
      throw new Error("Expected is not a String or a RegExp");
    super(new RegExp(t), n);
  }
  asymmetricMatch(t) {
    const n = Je("String", t) && this.sample.test(t);
    return this.inverse ? !n : n;
  }
  toString() {
    return `String${this.inverse ? "Not" : ""}Matching`;
  }
  getExpectedType() {
    return "string";
  }
}
class Js extends Et {
  constructor(n, o = 2, r = !1) {
    if (!Je("Number", n))
      throw new Error("Expected is not a Number");
    if (!Je("Number", o))
      throw new Error("Precision is not a Number");
    super(n);
    se(this, "precision");
    this.inverse = r, this.precision = o;
  }
  asymmetricMatch(n) {
    if (!Je("Number", n))
      return !1;
    let o = !1;
    return n === Number.POSITIVE_INFINITY && this.sample === Number.POSITIVE_INFINITY || n === Number.NEGATIVE_INFINITY && this.sample === Number.NEGATIVE_INFINITY ? o = !0 : o = Math.abs(this.sample - n) < 10 ** -this.precision / 2, this.inverse ? !o : o;
  }
  toString() {
    return `Number${this.inverse ? "Not" : ""}CloseTo`;
  }
  getExpectedType() {
    return "number";
  }
  toAsymmetricMatcher() {
    return [
      this.toString(),
      this.sample,
      `(${xh("digit", this.precision)})`
    ].join(" ");
  }
}
const Ah = (e, t) => {
  t.addMethod(
    e.expect,
    "anything",
    () => new $h()
  ), t.addMethod(
    e.expect,
    "any",
    (n) => new Oh(n)
  ), t.addMethod(
    e.expect,
    "stringContaining",
    (n) => new Vs(n)
  ), t.addMethod(
    e.expect,
    "objectContaining",
    (n) => new Us(n)
  ), t.addMethod(
    e.expect,
    "arrayContaining",
    (n) => new Ks(n)
  ), t.addMethod(
    e.expect,
    "stringMatching",
    (n) => new Gs(n)
  ), t.addMethod(
    e.expect,
    "closeTo",
    (n, o) => new Js(n, o)
  ), e.expect.not = {
    stringContaining: (n) => new Vs(n, !0),
    objectContaining: (n) => new Us(n, !0),
    arrayContaining: (n) => new Ks(n, !0),
    stringMatching: (n) => new Gs(n, !0),
    closeTo: (n, o) => new Js(n, o, !0)
  };
};
function Ys(e, t) {
  return e && t instanceof Promise && (t = t.finally(() => {
    const n = e.promises.indexOf(t);
    n !== -1 && e.promises.splice(n, 1);
  }), e.promises || (e.promises = []), e.promises.push(t)), t;
}
function ec(e, t) {
  return function(...n) {
    var o;
    const r = e.flag(this, "vitest-test");
    if (!(r != null && r.context._local ? r.context.expect.getState() : qt(globalThis[xn])).soft)
      return t.apply(this, n);
    if (!r)
      throw new Error("expect.soft() can only be used inside a test");
    try {
      return t.apply(this, n);
    } catch (i) {
      r.result || (r.result = { state: "fail" }), r.result.state = "fail", (o = r.result).errors || (o.errors = []), r.result.errors.push($f(i));
    }
  };
}
const _h = (e, t) => {
  const { AssertionError: n } = e, o = () => lo(), r = Eo();
  function s(u, p) {
    const w = (b) => {
      const v = ec(t, p);
      t.addMethod(e.Assertion.prototype, b, v), t.addMethod(globalThis[Tn].matchers, b, v);
    };
    Array.isArray(u) ? u.forEach((b) => w(b)) : w(u);
  }
  ["throw", "throws", "Throw"].forEach((u) => {
    t.overwriteMethod(e.Assertion.prototype, u, (p) => function(...w) {
      const b = t.flag(this, "promise"), v = t.flag(this, "object"), h = t.flag(this, "negate");
      if (b === "rejects")
        t.flag(this, "object", () => {
          throw v;
        });
      else if (b === "resolves" && typeof v != "function") {
        if (h)
          return;
        {
          const A = t.flag(this, "message") || "expected promise to throw an error, but it didn't", M = {
            showDiff: !1
          };
          throw new n(A, M, t.flag(this, "ssfi"));
        }
      }
      p.apply(this, w);
    });
  }), s("withTest", function(u) {
    return t.flag(this, "vitest-test", u), this;
  }), s("toEqual", function(u) {
    const p = t.flag(this, "object"), w = de(
      p,
      u,
      [...r, Le]
    );
    return this.assert(
      w,
      "expected #{this} to deeply equal #{exp}",
      "expected #{this} to not deeply equal #{exp}",
      u,
      p
    );
  }), s("toStrictEqual", function(u) {
    const p = t.flag(this, "object"), w = de(
      p,
      u,
      [
        ...r,
        Le,
        zs,
        Qr,
        Ws
      ],
      !0
    );
    return this.assert(
      w,
      "expected #{this} to strictly equal #{exp}",
      "expected #{this} to not strictly equal #{exp}",
      u,
      p
    );
  }), s("toBe", function(u) {
    const p = this._obj, w = Object.is(p, u);
    let b = "";
    return w || (de(
      p,
      u,
      [
        ...r,
        Le,
        zs,
        Qr,
        Ws
      ],
      !0
    ) ? b = "toStrictEqual" : de(
      p,
      u,
      [...r, Le]
    ) && (b = "toEqual")), this.assert(
      w,
      Th(b),
      "expected #{this} not to be #{exp} // Object.is equality",
      u,
      p
    );
  }), s("toMatchObject", function(u) {
    const p = this._obj;
    return this.assert(
      de(p, u, [...r, Le, $n]),
      "expected #{this} to match object #{exp}",
      "expected #{this} to not match object #{exp}",
      u,
      p
    );
  }), s("toMatch", function(u) {
    return typeof u == "string" ? this.include(u) : this.match(u);
  }), s("toContain", function(u) {
    const p = this._obj;
    if (typeof Node < "u" && p instanceof Node) {
      if (!(u instanceof Node))
        throw new TypeError(`toContain() expected a DOM node as the argument, but got ${typeof u}`);
      return this.assert(
        p.contains(u),
        "expected #{this} to contain element #{exp}",
        "expected #{this} not to contain element #{exp}",
        u,
        p
      );
    }
    if (typeof DOMTokenList < "u" && p instanceof DOMTokenList) {
      He(u, "class name", ["string"]);
      const b = t.flag(this, "negate") ? p.value.replace(u, "").trim() : `${p.value} ${u}`;
      return this.assert(
        p.contains(u),
        `expected "${p.value}" to contain "${u}"`,
        `expected "${p.value}" not to contain "${u}"`,
        b,
        p.value
      );
    }
    return p != null && typeof p != "string" && t.flag(this, "object", Array.from(p)), this.contain(u);
  }), s("toContainEqual", function(u) {
    const p = t.flag(this, "object"), w = Array.from(p).findIndex((b) => de(b, u, r));
    this.assert(
      w !== -1,
      "expected #{this} to deep equally contain #{exp}",
      "expected #{this} to not deep equally contain #{exp}",
      u
    );
  }), s("toBeTruthy", function() {
    const u = t.flag(this, "object");
    this.assert(
      !!u,
      "expected #{this} to be truthy",
      "expected #{this} to not be truthy",
      u,
      !1
    );
  }), s("toBeFalsy", function() {
    const u = t.flag(this, "object");
    this.assert(
      !u,
      "expected #{this} to be falsy",
      "expected #{this} to not be falsy",
      u,
      !1
    );
  }), s("toBeGreaterThan", function(u) {
    const p = this._obj;
    return He(p, "actual", ["number", "bigint"]), He(u, "expected", ["number", "bigint"]), this.assert(
      p > u,
      `expected ${p} to be greater than ${u}`,
      `expected ${p} to be not greater than ${u}`,
      p,
      u,
      !1
    );
  }), s("toBeGreaterThanOrEqual", function(u) {
    const p = this._obj;
    return He(p, "actual", ["number", "bigint"]), He(u, "expected", ["number", "bigint"]), this.assert(
      p >= u,
      `expected ${p} to be greater than or equal to ${u}`,
      `expected ${p} to be not greater than or equal to ${u}`,
      p,
      u,
      !1
    );
  }), s("toBeLessThan", function(u) {
    const p = this._obj;
    return He(p, "actual", ["number", "bigint"]), He(u, "expected", ["number", "bigint"]), this.assert(
      p < u,
      `expected ${p} to be less than ${u}`,
      `expected ${p} to be not less than ${u}`,
      p,
      u,
      !1
    );
  }), s("toBeLessThanOrEqual", function(u) {
    const p = this._obj;
    return He(p, "actual", ["number", "bigint"]), He(u, "expected", ["number", "bigint"]), this.assert(
      p <= u,
      `expected ${p} to be less than or equal to ${u}`,
      `expected ${p} to be not less than or equal to ${u}`,
      p,
      u,
      !1
    );
  }), s("toBeNaN", function() {
    return this.be.NaN;
  }), s("toBeUndefined", function() {
    return this.be.undefined;
  }), s("toBeNull", function() {
    return this.be.null;
  }), s("toBeDefined", function() {
    const u = t.flag(this, "negate");
    return t.flag(this, "negate", !1), u ? this.be.undefined : this.not.be.undefined;
  }), s("toBeTypeOf", function(u) {
    const p = typeof this._obj, w = u === p;
    return this.assert(
      w,
      "expected #{this} to be type of #{exp}",
      "expected #{this} not to be type of #{exp}",
      u,
      p
    );
  }), s("toBeInstanceOf", function(u) {
    return this.instanceOf(u);
  }), s("toHaveLength", function(u) {
    return this.have.length(u);
  }), s("toHaveProperty", function(...u) {
    Array.isArray(u[0]) && (u[0] = u[0].map((k) => String(k).replace(/([.[\]])/g, "\\$1")).join("."));
    const p = this._obj, [w, b] = u, v = () => Object.prototype.hasOwnProperty.call(p, w) ? { value: p[w], exists: !0 } : t.getPathInfo(p, w), { value: h, exists: A } = v(), M = A && (u.length === 1 || de(b, h, r)), F = u.length === 1 ? "" : ` with value ${t.objDisplay(b)}`;
    return this.assert(
      M,
      `expected #{this} to have property "${w}"${F}`,
      `expected #{this} to not have property "${w}"${F}`,
      b,
      A ? h : void 0
    );
  }), s("toBeCloseTo", function(u, p = 2) {
    const w = this._obj;
    let b = !1, v = 0, h = 0;
    return u === Number.POSITIVE_INFINITY && w === Number.POSITIVE_INFINITY || u === Number.NEGATIVE_INFINITY && w === Number.NEGATIVE_INFINITY ? b = !0 : (v = 10 ** -p / 2, h = Math.abs(w - u), b = h < v), this.assert(
      b,
      `expected #{this} to be close to #{exp}, received difference is ${h}, but expected ${v}`,
      `expected #{this} to not be close to #{exp}, received difference is ${h}, but expected ${v}`,
      u,
      w,
      !1
    );
  });
  const i = (u) => {
    if (!Ka(u._obj))
      throw new TypeError(`${t.inspect(u._obj)} is not a spy or a call to a spy!`);
  }, a = (u) => (i(u), u._obj), c = (u) => {
    const p = u % 10, w = u % 100;
    return p === 1 && w !== 11 ? `${u}st` : p === 2 && w !== 12 ? `${u}nd` : p === 3 && w !== 13 ? `${u}rd` : `${u}th`;
  }, l = (u, p, w) => (u.mock.calls && (p += o().gray(`

Received: 

${u.mock.calls.map((b, v) => {
    let h = o().bold(`  ${c(v + 1)} ${u.getMockName()} call:

`);
    return w ? h += gn(w, b, { omitAnnotationLines: !0 }) : h += Qe(b).split(`
`).map((A) => `    ${A}`).join(`
`), h += `
`, h;
  }).join(`
`)}`)), p += o().gray(`

Number of calls: ${o().bold(u.mock.calls.length)}
`), p), f = (u, p, w) => (p += o().gray(`

Received: 

${u.mock.results.map((b, v) => {
    let h = o().bold(`  ${c(v + 1)} ${u.getMockName()} call return:

`);
    return w ? h += gn(w, b.value, { omitAnnotationLines: !0 }) : h += Qe(b).split(`
`).map((A) => `    ${A}`).join(`
`), h += `
`, h;
  }).join(`
`)}`), p += o().gray(`

Number of calls: ${o().bold(u.mock.calls.length)}
`), p);
  s(["toHaveBeenCalledTimes", "toBeCalledTimes"], function(u) {
    const p = a(this), w = p.getMockName(), b = p.mock.calls.length;
    return this.assert(
      b === u,
      `expected "${w}" to be called #{exp} times, but got ${b} times`,
      `expected "${w}" to not be called #{exp} times`,
      u,
      b,
      !1
    );
  }), s("toHaveBeenCalledOnce", function() {
    const u = a(this), p = u.getMockName(), w = u.mock.calls.length;
    return this.assert(
      w === 1,
      `expected "${p}" to be called once, but got ${w} times`,
      `expected "${p}" to not be called once`,
      1,
      w,
      !1
    );
  }), s(["toHaveBeenCalled", "toBeCalled"], function() {
    const u = a(this), p = u.getMockName(), w = u.mock.calls.length, b = w > 0, v = t.flag(this, "negate");
    let h = t.getMessage(
      this,
      [
        b,
        `expected "${p}" to be called at least once`,
        `expected "${p}" to not be called at all, but actually been called ${w} times`,
        !0,
        b
      ]
    );
    if (b && v && (h = l(u, h)), b && v || !b && !v)
      throw new n(h);
  }), s(["toHaveBeenCalledWith", "toBeCalledWith"], function(...u) {
    const p = a(this), w = p.getMockName(), b = p.mock.calls.some((A) => de(A, u, [...r, Le])), v = t.flag(this, "negate"), h = t.getMessage(
      this,
      [
        b,
        `expected "${w}" to be called with arguments: #{exp}`,
        `expected "${w}" to not be called with arguments: #{exp}`,
        u
      ]
    );
    if (b && v || !b && !v)
      throw new n(l(p, h, u));
  }), s(["toHaveBeenNthCalledWith", "nthCalledWith"], function(u, ...p) {
    const w = a(this), b = w.getMockName(), v = w.mock.calls[u - 1];
    this.assert(
      de(v, p, [...r, Le]),
      `expected ${c(u)} "${b}" call to have been called with #{exp}`,
      `expected ${c(u)} "${b}" call to not have been called with #{exp}`,
      p,
      v
    );
  }), s(["toHaveBeenLastCalledWith", "lastCalledWith"], function(...u) {
    const p = a(this), w = p.getMockName(), b = p.mock.calls[p.mock.calls.length - 1];
    this.assert(
      de(b, u, [...r, Le]),
      `expected last "${w}" call to have been called with #{exp}`,
      `expected last "${w}" call to not have been called with #{exp}`,
      u,
      b
    );
  }), s(["toThrow", "toThrowError"], function(u) {
    if (typeof u == "string" || typeof u > "u" || u instanceof RegExp)
      return this.throws(u);
    const p = this._obj, w = t.flag(this, "promise"), b = t.flag(this, "negate");
    let v = null;
    if (w === "rejects")
      v = p;
    else if (w === "resolves" && typeof p != "function") {
      if (b)
        return;
      {
        const h = t.flag(this, "message") || "expected promise to throw an error, but it didn't", A = {
          showDiff: !1
        };
        throw new n(h, A, t.flag(this, "ssfi"));
      }
    } else {
      let h = !1;
      try {
        p();
      } catch (A) {
        h = !0, v = A;
      }
      if (!h && !b) {
        const A = t.flag(this, "message") || "expected function to throw an error, but it didn't", M = {
          showDiff: !1
        };
        throw new n(A, M, t.flag(this, "ssfi"));
      }
    }
    if (typeof u == "function") {
      const h = u.name || u.prototype.constructor.name;
      return this.assert(
        v && v instanceof u,
        `expected error to be instance of ${h}`,
        `expected error not to be instance of ${h}`,
        u,
        v
      );
    }
    if (u instanceof Error)
      return this.assert(
        v && u.message === v.message,
        `expected error to have message: ${u.message}`,
        `expected error not to have message: ${u.message}`,
        u.message,
        v && v.message
      );
    if (typeof u == "object" && "asymmetricMatch" in u && typeof u.asymmetricMatch == "function") {
      const h = u;
      return this.assert(
        v && h.asymmetricMatch(v),
        "expected error to match asymmetric matcher",
        "expected error not to match asymmetric matcher",
        h,
        v
      );
    }
    throw new Error(`"toThrow" expects string, RegExp, function, Error instance or asymmetric matcher, got "${typeof u}"`);
  }), s(["toHaveReturned", "toReturn"], function() {
    const u = a(this), p = u.getMockName(), w = u.mock.calls.length > 0 && u.mock.results.some(({ type: b }) => b !== "throw");
    this.assert(
      w,
      `expected "${p}" to be successfully called at least once`,
      `expected "${p}" to not be successfully called`,
      w,
      !w,
      !1
    );
  }), s(["toHaveReturnedTimes", "toReturnTimes"], function(u) {
    const p = a(this), w = p.getMockName(), b = p.mock.results.reduce((v, { type: h }) => h === "throw" ? v : ++v, 0);
    this.assert(
      b === u,
      `expected "${w}" to be successfully called ${u} times`,
      `expected "${w}" to not be successfully called ${u} times`,
      `expected number of returns: ${u}`,
      `received number of returns: ${b}`,
      !1
    );
  }), s(["toHaveReturnedWith", "toReturnWith"], function(u) {
    const p = a(this), w = p.getMockName(), b = p.mock.results.some(({ type: A, value: M }) => A === "return" && de(u, M)), v = t.flag(this, "negate"), h = t.getMessage(
      this,
      [
        b,
        `expected "${w}" to return with: #{exp} at least once`,
        `expected "${w}" to not return with: #{exp}`,
        u
      ]
    );
    if (b && v || !b && !v)
      throw new n(f(p, h, u));
  }), s(["toHaveLastReturnedWith", "lastReturnedWith"], function(u) {
    const p = a(this), w = p.getMockName(), { value: b } = p.mock.results[p.mock.results.length - 1], v = de(b, u);
    this.assert(
      v,
      `expected last "${w}" call to return #{exp}`,
      `expected last "${w}" call to not return #{exp}`,
      u,
      b
    );
  }), s(["toHaveNthReturnedWith", "nthReturnedWith"], function(u, p) {
    const w = a(this), b = w.getMockName(), v = t.flag(this, "negate"), { type: h, value: A } = w.mock.results[u - 1], M = `${c(u)} call`;
    !v && h === "throw" && e.assert.fail(`expected ${M} to return #{exp}, but instead it threw an error`);
    const F = de(A, p);
    this.assert(
      F,
      `expected ${M} "${b}" call to return #{exp}`,
      `expected ${M} "${b}" call to not return #{exp}`,
      p,
      A
    );
  }), s("toSatisfy", function(u, p) {
    return this.be.satisfy(u, p);
  }), t.addProperty(e.Assertion.prototype, "resolves", function() {
    const p = new Error("resolves");
    t.flag(this, "promise", "resolves"), t.flag(this, "error", p);
    const w = t.flag(this, "vitest-test"), b = t.flag(this, "object");
    if (typeof (b == null ? void 0 : b.then) != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .resolves, not '${typeof b}'.`);
    const v = new Proxy(this, {
      get: (h, A, M) => {
        const F = Reflect.get(h, A, M);
        return typeof F != "function" ? F instanceof e.Assertion ? v : F : async (...k) => {
          const N = b.then(
            (U) => (t.flag(this, "object", U), F.call(this, ...k)),
            (U) => {
              const B = new n(
                `promise rejected "${t.inspect(U)}" instead of resolving`,
                { showDiff: !1 }
              );
              throw B.cause = U, B.stack = p.stack.replace(p.message, B.message), B;
            }
          );
          return Ys(w, N);
        };
      }
    });
    return v;
  }), t.addProperty(e.Assertion.prototype, "rejects", function() {
    const p = new Error("rejects");
    t.flag(this, "promise", "rejects"), t.flag(this, "error", p);
    const w = t.flag(this, "vitest-test"), b = t.flag(this, "object"), v = typeof b == "function" ? b() : b;
    if (typeof (v == null ? void 0 : v.then) != "function")
      throw new TypeError(`You must provide a Promise to expect() when using .rejects, not '${typeof v}'.`);
    const h = new Proxy(this, {
      get: (A, M, F) => {
        const k = Reflect.get(A, M, F);
        return typeof k != "function" ? k instanceof e.Assertion ? h : k : async (...N) => {
          const U = v.then(
            (B) => {
              const G = new n(
                `promise resolved "${t.inspect(B)}" instead of rejecting`,
                { showDiff: !0, expected: new Error("rejected promise"), actual: B }
              );
              throw G.stack = p.stack.replace(p.message, G.message), G;
            },
            (B) => (t.flag(this, "object", B), k.call(this, ...N))
          );
          return Ys(w, U);
        };
      }
    });
    return h;
  });
};
function Mh(e, t) {
  const n = e._obj, o = Kn.flag(e, "negate"), r = Kn.flag(e, "promise") || "", s = {
    ...Ja(),
    diff: gn,
    stringify: Qe,
    iterableEquality: Le,
    subsetEquality: $n
  };
  return {
    state: {
      ...qt(t),
      customTesters: Eo(),
      isNot: o,
      utils: s,
      promise: r,
      equals: de,
      // needed for built-in jest-snapshots, but we don't use it
      suppressedErrors: []
    },
    isNot: o,
    obj: n
  };
}
class Hs extends Error {
  constructor(t, n, o) {
    super(t), this.actual = n, this.expected = o;
  }
}
function Ph(e, t) {
  return (n, o) => {
    Object.entries(t).forEach(([r, s]) => {
      function i(...f) {
        const { state: u, isNot: p, obj: w } = Mh(this, e), b = s.call(u, w, ...f);
        if (b && typeof b == "object" && b instanceof Promise)
          return b.then(({ pass: F, message: k, actual: N, expected: U }) => {
            if (F && p || !F && !p)
              throw new Hs(k(), N, U);
          });
        const { pass: v, message: h, actual: A, expected: M } = b;
        if (v && p || !v && !p)
          throw new Hs(h(), A, M);
      }
      const a = ec(o, i);
      o.addMethod(globalThis[Tn].matchers, r, a), o.addMethod(n.Assertion.prototype, r, a);
      class c extends Et {
        constructor(u = !1, ...p) {
          super(p, u);
        }
        asymmetricMatch(u) {
          const { pass: p } = s.call(
            this.getMatcherContext(e),
            u,
            ...this.sample
          );
          return this.inverse ? !p : p;
        }
        toString() {
          return `${this.inverse ? "not." : ""}${r}`;
        }
        getExpectedType() {
          return "any";
        }
        toAsymmetricMatcher() {
          return `${this.toString()}<${this.sample.map(String).join(", ")}>`;
        }
      }
      const l = (...f) => new c(!1, ...f);
      Object.defineProperty(e, r, {
        configurable: !0,
        enumerable: !0,
        value: l,
        writable: !0
      }), Object.defineProperty(e.not, r, {
        configurable: !0,
        enumerable: !0,
        value: (...f) => new c(!0, ...f),
        writable: !0
      }), Object.defineProperty(globalThis[vo], r, {
        configurable: !0,
        enumerable: !0,
        value: l,
        writable: !0
      });
    });
  };
}
const Ih = (e, t) => {
  t.addMethod(e.expect, "extend", (n, o) => {
    e.use(Ph(n, o));
  });
};
var bt = {}, So = { exports: {} };
So.exports;
(function(e) {
  const n = (s = 0) => (i) => `\x1B[${38 + s};5;${i}m`, o = (s = 0) => (i, a, c) => `\x1B[${38 + s};2;${i};${a};${c}m`;
  function r() {
    const s = /* @__PURE__ */ new Map(), i = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    i.color.gray = i.color.blackBright, i.bgColor.bgGray = i.bgColor.bgBlackBright, i.color.grey = i.color.blackBright, i.bgColor.bgGrey = i.bgColor.bgBlackBright;
    for (const [a, c] of Object.entries(i)) {
      for (const [l, f] of Object.entries(c))
        i[l] = {
          open: `\x1B[${f[0]}m`,
          close: `\x1B[${f[1]}m`
        }, c[l] = i[l], s.set(f[0], f[1]);
      Object.defineProperty(i, a, {
        value: c,
        enumerable: !1
      });
    }
    return Object.defineProperty(i, "codes", {
      value: s,
      enumerable: !1
    }), i.color.close = "\x1B[39m", i.bgColor.close = "\x1B[49m", i.color.ansi256 = n(), i.color.ansi16m = o(), i.bgColor.ansi256 = n(10), i.bgColor.ansi16m = o(10), Object.defineProperties(i, {
      rgbToAnsi256: {
        value: (a, c, l) => a === c && c === l ? a < 8 ? 16 : a > 248 ? 231 : Math.round((a - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(a / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(l / 255 * 5),
        enumerable: !1
      },
      hexToRgb: {
        value: (a) => {
          const c = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(a.toString(16));
          if (!c)
            return [0, 0, 0];
          let { colorString: l } = c.groups;
          l.length === 3 && (l = l.split("").map((u) => u + u).join(""));
          const f = Number.parseInt(l, 16);
          return [
            f >> 16 & 255,
            f >> 8 & 255,
            f & 255
          ];
        },
        enumerable: !1
      },
      hexToAnsi256: {
        value: (a) => i.rgbToAnsi256(...i.hexToRgb(a)),
        enumerable: !1
      }
    }), i;
  }
  Object.defineProperty(e, "exports", {
    enumerable: !0,
    get: r
  });
})(So);
var Ch = So.exports, tt = {};
Object.defineProperty(tt, "__esModule", {
  value: !0
});
tt.printIteratorEntries = jh;
tt.printIteratorValues = kh;
tt.printListItems = Rh;
tt.printObjectProperties = Fh;
const Nh = (e, t) => {
  const n = Object.keys(e), o = t !== null ? n.sort(t) : n;
  return Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach((r) => {
    Object.getOwnPropertyDescriptor(e, r).enumerable && o.push(r);
  }), o;
};
function jh(e, t, n, o, r, s, i = ": ") {
  let a = "", c = 0, l = e.next();
  if (!l.done) {
    a += t.spacingOuter;
    const f = n + t.indent;
    for (; !l.done; ) {
      if (a += f, c++ === t.maxWidth) {
        a += "…";
        break;
      }
      const u = s(
        l.value[0],
        t,
        f,
        o,
        r
      ), p = s(
        l.value[1],
        t,
        f,
        o,
        r
      );
      a += u + i + p, l = e.next(), l.done ? t.min || (a += ",") : a += `,${t.spacingInner}`;
    }
    a += t.spacingOuter + n;
  }
  return a;
}
function kh(e, t, n, o, r, s) {
  let i = "", a = 0, c = e.next();
  if (!c.done) {
    i += t.spacingOuter;
    const l = n + t.indent;
    for (; !c.done; ) {
      if (i += l, a++ === t.maxWidth) {
        i += "…";
        break;
      }
      i += s(c.value, t, l, o, r), c = e.next(), c.done ? t.min || (i += ",") : i += `,${t.spacingInner}`;
    }
    i += t.spacingOuter + n;
  }
  return i;
}
function Rh(e, t, n, o, r, s) {
  let i = "";
  if (e.length) {
    i += t.spacingOuter;
    const a = n + t.indent;
    for (let c = 0; c < e.length; c++) {
      if (i += a, c === t.maxWidth) {
        i += "…";
        break;
      }
      c in e && (i += s(e[c], t, a, o, r)), c < e.length - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + n;
  }
  return i;
}
function Fh(e, t, n, o, r, s) {
  let i = "";
  const a = Nh(e, t.compareKeys);
  if (a.length) {
    i += t.spacingOuter;
    const c = n + t.indent;
    for (let l = 0; l < a.length; l++) {
      const f = a[l], u = s(f, t, c, o, r), p = s(e[f], t, c, o, r);
      i += `${c + u}: ${p}`, l < a.length - 1 ? i += `,${t.spacingInner}` : t.min || (i += ",");
    }
    i += t.spacingOuter + n;
  }
  return i;
}
var ft = {};
Object.defineProperty(ft, "__esModule", {
  value: !0
});
ft.test = ft.serialize = ft.default = void 0;
var Xs = tt, kr = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
const Dh = typeof kr == "function" && kr.for ? kr.for("jest.asymmetricMatcher") : 1267621, Nn = " ", tc = (e, t, n, o, r, s) => {
  const i = e.toString();
  if (i === "ArrayContaining" || i === "ArrayNotContaining")
    return ++o > t.maxDepth ? `[${i}]` : `${i + Nn}[${(0, Xs.printListItems)(
      e.sample,
      t,
      n,
      o,
      r,
      s
    )}]`;
  if (i === "ObjectContaining" || i === "ObjectNotContaining")
    return ++o > t.maxDepth ? `[${i}]` : `${i + Nn}{${(0, Xs.printObjectProperties)(
      e.sample,
      t,
      n,
      o,
      r,
      s
    )}}`;
  if (i === "StringMatching" || i === "StringNotMatching" || i === "StringContaining" || i === "StringNotContaining")
    return i + Nn + s(e.sample, t, n, o, r);
  if (typeof e.toAsymmetricMatcher != "function")
    throw new Error(
      `Asymmetric matcher ${e.constructor.name} does not implement toAsymmetricMatcher()`
    );
  return e.toAsymmetricMatcher();
};
ft.serialize = tc;
const nc = (e) => e && e.$$typeof === Dh;
ft.test = nc;
const Bh = {
  serialize: tc,
  test: nc
};
var Lh = Bh;
ft.default = Lh;
var pt = {};
Object.defineProperty(pt, "__esModule", {
  value: !0
});
pt.test = pt.serialize = pt.default = void 0;
var Qs = tt;
const qh = " ", rc = ["DOMStringMap", "NamedNodeMap"], zh = /^(HTML\w*Collection|NodeList)$/, Wh = (e) => rc.indexOf(e) !== -1 || zh.test(e), oc = (e) => e && e.constructor && !!e.constructor.name && Wh(e.constructor.name);
pt.test = oc;
const Vh = (e) => e.constructor.name === "NamedNodeMap", sc = (e, t, n, o, r, s) => {
  const i = e.constructor.name;
  return ++o > t.maxDepth ? `[${i}]` : (t.min ? "" : i + qh) + (rc.indexOf(i) !== -1 ? `{${(0, Qs.printObjectProperties)(
    Vh(e) ? Array.from(e).reduce((a, c) => (a[c.name] = c.value, a), {}) : {
      ...e
    },
    t,
    n,
    o,
    r,
    s
  )}}` : `[${(0, Qs.printListItems)(
    Array.from(e),
    t,
    n,
    o,
    r,
    s
  )}]`);
};
pt.serialize = sc;
const Uh = {
  serialize: sc,
  test: oc
};
var Kh = Uh;
pt.default = Kh;
var ht = {}, Re = {}, To = {};
Object.defineProperty(To, "__esModule", {
  value: !0
});
To.default = Gh;
function Gh(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
Object.defineProperty(Re, "__esModule", {
  value: !0
});
Re.printText = Re.printProps = Re.printElementAsLeaf = Re.printElement = Re.printComment = Re.printChildren = void 0;
var ic = Jh(To);
function Jh(e) {
  return e && e.__esModule ? e : { default: e };
}
const Yh = (e, t, n, o, r, s, i) => {
  const a = o + n.indent, c = n.colors;
  return e.map((l) => {
    const f = t[l];
    let u = i(f, n, a, r, s);
    return typeof f != "string" && (u.indexOf(`
`) !== -1 && (u = n.spacingOuter + a + u + n.spacingOuter + o), u = `{${u}}`), `${n.spacingInner + o + c.prop.open + l + c.prop.close}=${c.value.open}${u}${c.value.close}`;
  }).join("");
};
Re.printProps = Yh;
const Hh = (e, t, n, o, r, s) => e.map(
  (i) => t.spacingOuter + n + (typeof i == "string" ? ac(i, t) : s(i, t, n, o, r))
).join("");
Re.printChildren = Hh;
const ac = (e, t) => {
  const n = t.colors.content;
  return n.open + (0, ic.default)(e) + n.close;
};
Re.printText = ac;
const Xh = (e, t) => {
  const n = t.colors.comment;
  return `${n.open}<!--${(0, ic.default)(e)}-->${n.close}`;
};
Re.printComment = Xh;
const Qh = (e, t, n, o, r) => {
  const s = o.colors.tag;
  return `${s.open}<${e}${t && s.close + t + o.spacingOuter + r + s.open}${n ? `>${s.close}${n}${o.spacingOuter}${r}${s.open}</${e}` : `${t && !o.min ? "" : " "}/`}>${s.close}`;
};
Re.printElement = Qh;
const Zh = (e, t) => {
  const n = t.colors.tag;
  return `${n.open}<${e}${n.close} …${n.open} />${n.close}`;
};
Re.printElementAsLeaf = Zh;
Object.defineProperty(ht, "__esModule", {
  value: !0
});
ht.test = ht.serialize = ht.default = void 0;
var kt = Re;
const em = 1, cc = 3, uc = 8, lc = 11, tm = /^((HTML|SVG)\w*)?Element$/, nm = (e) => {
  try {
    return typeof e.hasAttribute == "function" && e.hasAttribute("is");
  } catch {
    return !1;
  }
}, rm = (e) => {
  const t = e.constructor.name, { nodeType: n, tagName: o } = e, r = typeof o == "string" && o.includes("-") || nm(e);
  return n === em && (tm.test(t) || r) || n === cc && t === "Text" || n === uc && t === "Comment" || n === lc && t === "DocumentFragment";
}, fc = (e) => {
  var t;
  return ((t = e == null ? void 0 : e.constructor) == null ? void 0 : t.name) && rm(e);
};
ht.test = fc;
function om(e) {
  return e.nodeType === cc;
}
function sm(e) {
  return e.nodeType === uc;
}
function Rr(e) {
  return e.nodeType === lc;
}
const pc = (e, t, n, o, r, s) => {
  if (om(e))
    return (0, kt.printText)(e.data, t);
  if (sm(e))
    return (0, kt.printComment)(e.data, t);
  const i = Rr(e) ? "DocumentFragment" : e.tagName.toLowerCase();
  return ++o > t.maxDepth ? (0, kt.printElementAsLeaf)(i, t) : (0, kt.printElement)(
    i,
    (0, kt.printProps)(
      Rr(e) ? [] : Array.from(e.attributes, (a) => a.name).sort(),
      Rr(e) ? {} : Array.from(e.attributes).reduce((a, c) => (a[c.name] = c.value, a), {}),
      t,
      n + t.indent,
      o,
      r,
      s
    ),
    (0, kt.printChildren)(
      Array.prototype.slice.call(e.childNodes || e.children),
      t,
      n + t.indent,
      o,
      r,
      s
    ),
    t,
    n
  );
};
ht.serialize = pc;
const im = {
  serialize: pc,
  test: fc
};
var am = im;
ht.default = am;
var mt = {};
Object.defineProperty(mt, "__esModule", {
  value: !0
});
mt.test = mt.serialize = mt.default = void 0;
var wn = tt;
const cm = "@@__IMMUTABLE_ITERABLE__@@", um = "@@__IMMUTABLE_LIST__@@", lm = "@@__IMMUTABLE_KEYED__@@", fm = "@@__IMMUTABLE_MAP__@@", Zs = "@@__IMMUTABLE_ORDERED__@@", pm = "@@__IMMUTABLE_RECORD__@@", hm = "@@__IMMUTABLE_SEQ__@@", mm = "@@__IMMUTABLE_SET__@@", dm = "@@__IMMUTABLE_STACK__@@", Gt = (e) => `Immutable.${e}`, sr = (e) => `[${e}]`, vn = " ", ei = "…", ym = (e, t, n, o, r, s, i) => ++o > t.maxDepth ? sr(Gt(i)) : `${Gt(i) + vn}{${(0, wn.printIteratorEntries)(
  e.entries(),
  t,
  n,
  o,
  r,
  s
)}}`;
function gm(e) {
  let t = 0;
  return {
    next() {
      if (t < e._keys.length) {
        const n = e._keys[t++];
        return {
          done: !1,
          value: [n, e.get(n)]
        };
      }
      return {
        done: !0,
        value: void 0
      };
    }
  };
}
const bm = (e, t, n, o, r, s) => {
  const i = Gt(e._name || "Record");
  return ++o > t.maxDepth ? sr(i) : `${i + vn}{${(0, wn.printIteratorEntries)(
    gm(e),
    t,
    n,
    o,
    r,
    s
  )}}`;
}, wm = (e, t, n, o, r, s) => {
  const i = Gt("Seq");
  return ++o > t.maxDepth ? sr(i) : e[lm] ? `${i + vn}{${// from Immutable collection of entries or from ECMAScript object
  e._iter || e._object ? (0, wn.printIteratorEntries)(
    e.entries(),
    t,
    n,
    o,
    r,
    s
  ) : ei}}` : `${i + vn}[${e._iter || // from Immutable collection of values
  e._array || // from ECMAScript array
  e._collection || // from ECMAScript collection in immutable v4
  e._iterable ? (0, wn.printIteratorValues)(
    e.values(),
    t,
    n,
    o,
    r,
    s
  ) : ei}]`;
}, Fr = (e, t, n, o, r, s, i) => ++o > t.maxDepth ? sr(Gt(i)) : `${Gt(i) + vn}[${(0, wn.printIteratorValues)(
  e.values(),
  t,
  n,
  o,
  r,
  s
)}]`, hc = (e, t, n, o, r, s) => e[fm] ? ym(
  e,
  t,
  n,
  o,
  r,
  s,
  e[Zs] ? "OrderedMap" : "Map"
) : e[um] ? Fr(
  e,
  t,
  n,
  o,
  r,
  s,
  "List"
) : e[mm] ? Fr(
  e,
  t,
  n,
  o,
  r,
  s,
  e[Zs] ? "OrderedSet" : "Set"
) : e[dm] ? Fr(
  e,
  t,
  n,
  o,
  r,
  s,
  "Stack"
) : e[hm] ? wm(e, t, n, o, r, s) : bm(e, t, n, o, r, s);
mt.serialize = hc;
const mc = (e) => e && (e[cm] === !0 || e[pm] === !0);
mt.test = mc;
const vm = {
  serialize: hc,
  test: mc
};
var Em = vm;
mt.default = Em;
var dt = {}, Zr = { exports: {} }, pe = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ti;
function Sm() {
  if (ti)
    return pe;
  ti = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), i = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), b;
  b = Symbol.for("react.module.reference");
  function v(h) {
    if (typeof h == "object" && h !== null) {
      var A = h.$$typeof;
      switch (A) {
        case e:
          switch (h = h.type, h) {
            case n:
            case r:
            case o:
            case l:
            case f:
              return h;
            default:
              switch (h = h && h.$$typeof, h) {
                case a:
                case i:
                case c:
                case p:
                case u:
                case s:
                  return h;
                default:
                  return A;
              }
          }
        case t:
          return A;
      }
    }
  }
  return pe.ContextConsumer = i, pe.ContextProvider = s, pe.Element = e, pe.ForwardRef = c, pe.Fragment = n, pe.Lazy = p, pe.Memo = u, pe.Portal = t, pe.Profiler = r, pe.StrictMode = o, pe.Suspense = l, pe.SuspenseList = f, pe.isAsyncMode = function() {
    return !1;
  }, pe.isConcurrentMode = function() {
    return !1;
  }, pe.isContextConsumer = function(h) {
    return v(h) === i;
  }, pe.isContextProvider = function(h) {
    return v(h) === s;
  }, pe.isElement = function(h) {
    return typeof h == "object" && h !== null && h.$$typeof === e;
  }, pe.isForwardRef = function(h) {
    return v(h) === c;
  }, pe.isFragment = function(h) {
    return v(h) === n;
  }, pe.isLazy = function(h) {
    return v(h) === p;
  }, pe.isMemo = function(h) {
    return v(h) === u;
  }, pe.isPortal = function(h) {
    return v(h) === t;
  }, pe.isProfiler = function(h) {
    return v(h) === r;
  }, pe.isStrictMode = function(h) {
    return v(h) === o;
  }, pe.isSuspense = function(h) {
    return v(h) === l;
  }, pe.isSuspenseList = function(h) {
    return v(h) === f;
  }, pe.isValidElementType = function(h) {
    return typeof h == "string" || typeof h == "function" || h === n || h === r || h === o || h === l || h === f || h === w || typeof h == "object" && h !== null && (h.$$typeof === p || h.$$typeof === u || h.$$typeof === s || h.$$typeof === i || h.$$typeof === c || h.$$typeof === b || h.getModuleId !== void 0);
  }, pe.typeOf = v, pe;
}
var he = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ni;
function Tm() {
  return ni || (ni = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), i = Symbol.for("react.context"), a = Symbol.for("react.server_context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), w = Symbol.for("react.offscreen"), b = !1, v = !1, h = !1, A = !1, M = !1, F;
    F = Symbol.for("react.module.reference");
    function k(O) {
      return !!(typeof O == "string" || typeof O == "function" || O === n || O === r || M || O === o || O === l || O === f || A || O === w || b || v || h || typeof O == "object" && O !== null && (O.$$typeof === p || O.$$typeof === u || O.$$typeof === s || O.$$typeof === i || O.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      O.$$typeof === F || O.getModuleId !== void 0));
    }
    function N(O) {
      if (typeof O == "object" && O !== null) {
        var ce = O.$$typeof;
        switch (ce) {
          case e:
            var oe = O.type;
            switch (oe) {
              case n:
              case r:
              case o:
              case l:
              case f:
                return oe;
              default:
                var ye = oe && oe.$$typeof;
                switch (ye) {
                  case a:
                  case i:
                  case c:
                  case p:
                  case u:
                  case s:
                    return ye;
                  default:
                    return ce;
                }
            }
          case t:
            return ce;
        }
      }
    }
    var U = i, B = s, G = e, ae = c, V = n, Ee = p, be = u, Se = t, Me = r, Fe = o, Pe = l, Ne = f, De = !1, m = !1;
    function T(O) {
      return De || (De = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function x(O) {
      return m || (m = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function P(O) {
      return N(O) === i;
    }
    function j(O) {
      return N(O) === s;
    }
    function D(O) {
      return typeof O == "object" && O !== null && O.$$typeof === e;
    }
    function I(O) {
      return N(O) === c;
    }
    function $(O) {
      return N(O) === n;
    }
    function q(O) {
      return N(O) === p;
    }
    function K(O) {
      return N(O) === u;
    }
    function J(O) {
      return N(O) === t;
    }
    function ne(O) {
      return N(O) === r;
    }
    function Z(O) {
      return N(O) === o;
    }
    function H(O) {
      return N(O) === l;
    }
    function re(O) {
      return N(O) === f;
    }
    he.ContextConsumer = U, he.ContextProvider = B, he.Element = G, he.ForwardRef = ae, he.Fragment = V, he.Lazy = Ee, he.Memo = be, he.Portal = Se, he.Profiler = Me, he.StrictMode = Fe, he.Suspense = Pe, he.SuspenseList = Ne, he.isAsyncMode = T, he.isConcurrentMode = x, he.isContextConsumer = P, he.isContextProvider = j, he.isElement = D, he.isForwardRef = I, he.isFragment = $, he.isLazy = q, he.isMemo = K, he.isPortal = J, he.isProfiler = ne, he.isStrictMode = Z, he.isSuspense = H, he.isSuspenseList = re, he.isValidElementType = k, he.typeOf = N;
  }()), he;
}
process.env.NODE_ENV === "production" ? Zr.exports = Sm() : Zr.exports = Tm();
var xm = Zr.exports;
Object.defineProperty(dt, "__esModule", {
  value: !0
});
dt.test = dt.serialize = dt.default = void 0;
var $t = $m(xm), jn = Re;
function dc(e) {
  if (typeof WeakMap != "function")
    return null;
  var t = /* @__PURE__ */ new WeakMap(), n = /* @__PURE__ */ new WeakMap();
  return (dc = function(o) {
    return o ? n : t;
  })(e);
}
function $m(e, t) {
  if (!t && e && e.__esModule)
    return e;
  if (e === null || typeof e != "object" && typeof e != "function")
    return { default: e };
  var n = dc(t);
  if (n && n.has(e))
    return n.get(e);
  var o = {}, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in e)
    if (s !== "default" && Object.prototype.hasOwnProperty.call(e, s)) {
      var i = r ? Object.getOwnPropertyDescriptor(e, s) : null;
      i && (i.get || i.set) ? Object.defineProperty(o, s, i) : o[s] = e[s];
    }
  return o.default = e, n && n.set(e, o), o;
}
const yc = (e, t = []) => (Array.isArray(e) ? e.forEach((n) => {
  yc(n, t);
}) : e != null && e !== !1 && t.push(e), t), ri = (e) => {
  const t = e.type;
  if (typeof t == "string")
    return t;
  if (typeof t == "function")
    return t.displayName || t.name || "Unknown";
  if ($t.isFragment(e))
    return "React.Fragment";
  if ($t.isSuspense(e))
    return "React.Suspense";
  if (typeof t == "object" && t !== null) {
    if ($t.isContextProvider(e))
      return "Context.Provider";
    if ($t.isContextConsumer(e))
      return "Context.Consumer";
    if ($t.isForwardRef(e)) {
      if (t.displayName)
        return t.displayName;
      const n = t.render.displayName || t.render.name || "";
      return n !== "" ? `ForwardRef(${n})` : "ForwardRef";
    }
    if ($t.isMemo(e)) {
      const n = t.displayName || t.type.displayName || t.type.name || "";
      return n !== "" ? `Memo(${n})` : "Memo";
    }
  }
  return "UNDEFINED";
}, Om = (e) => {
  const { props: t } = e;
  return Object.keys(t).filter((n) => n !== "children" && t[n] !== void 0).sort();
}, gc = (e, t, n, o, r, s) => ++o > t.maxDepth ? (0, jn.printElementAsLeaf)(ri(e), t) : (0, jn.printElement)(
  ri(e),
  (0, jn.printProps)(
    Om(e),
    e.props,
    t,
    n + t.indent,
    o,
    r,
    s
  ),
  (0, jn.printChildren)(
    yc(e.props.children),
    t,
    n + t.indent,
    o,
    r,
    s
  ),
  t,
  n
);
dt.serialize = gc;
const bc = (e) => e != null && $t.isElement(e);
dt.test = bc;
const Am = {
  serialize: gc,
  test: bc
};
var _m = Am;
dt.default = _m;
var yt = {};
Object.defineProperty(yt, "__esModule", {
  value: !0
});
yt.test = yt.serialize = yt.default = void 0;
var kn = Re, Dr = globalThis["jest-symbol-do-not-touch"] || globalThis.Symbol;
const Mm = typeof Dr == "function" && Dr.for ? Dr.for("react.test.json") : 245830487, Pm = (e) => {
  const { props: t } = e;
  return t ? Object.keys(t).filter((n) => t[n] !== void 0).sort() : [];
}, wc = (e, t, n, o, r, s) => ++o > t.maxDepth ? (0, kn.printElementAsLeaf)(e.type, t) : (0, kn.printElement)(
  e.type,
  e.props ? (0, kn.printProps)(
    Pm(e),
    e.props,
    t,
    n + t.indent,
    o,
    r,
    s
  ) : "",
  e.children ? (0, kn.printChildren)(
    e.children,
    t,
    n + t.indent,
    o,
    r,
    s
  ) : "",
  t,
  n
);
yt.serialize = wc;
const vc = (e) => e && e.$$typeof === Mm;
yt.test = vc;
const Im = {
  serialize: wc,
  test: vc
};
var Cm = Im;
yt.default = Cm;
Object.defineProperty(bt, "__esModule", {
  value: !0
});
bt.default = bt.DEFAULT_OPTIONS = void 0;
var Nm = bt.format = Cc, Ec = bt.plugins = void 0, jm = It(Ch), rn = tt, km = It(
  ft
), Rm = It(pt), Fm = It(ht), Dm = It(mt), Bm = It(dt), Lm = It(
  yt
);
function It(e) {
  return e && e.__esModule ? e : { default: e };
}
const Sc = Object.prototype.toString, qm = Date.prototype.toISOString, zm = Error.prototype.toString, oi = RegExp.prototype.toString, Br = (e) => typeof e.constructor == "function" && e.constructor.name || "Object", Wm = (e) => typeof window < "u" && e === window, Vm = /^Symbol\((.*)\)(.*)$/, Um = /\n/gi;
class Tc extends Error {
  constructor(t, n) {
    super(t), this.stack = n, this.name = this.constructor.name;
  }
}
function Km(e) {
  return e === "[object Array]" || e === "[object ArrayBuffer]" || e === "[object DataView]" || e === "[object Float32Array]" || e === "[object Float64Array]" || e === "[object Int8Array]" || e === "[object Int16Array]" || e === "[object Int32Array]" || e === "[object Uint8Array]" || e === "[object Uint8ClampedArray]" || e === "[object Uint16Array]" || e === "[object Uint32Array]";
}
function Gm(e) {
  return Object.is(e, -0) ? "-0" : String(e);
}
function Jm(e) {
  return `${e}n`;
}
function si(e, t) {
  return t ? `[Function ${e.name || "anonymous"}]` : "[Function]";
}
function ii(e) {
  return String(e).replace(Vm, "Symbol($1)");
}
function ai(e) {
  return `[${zm.call(e)}]`;
}
function xc(e, t, n, o) {
  if (e === !0 || e === !1)
    return `${e}`;
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  const r = typeof e;
  if (r === "number")
    return Gm(e);
  if (r === "bigint")
    return Jm(e);
  if (r === "string")
    return o ? `"${e.replace(/"|\\/g, "\\$&")}"` : `"${e}"`;
  if (r === "function")
    return si(e, t);
  if (r === "symbol")
    return ii(e);
  const s = Sc.call(e);
  return s === "[object WeakMap]" ? "WeakMap {}" : s === "[object WeakSet]" ? "WeakSet {}" : s === "[object Function]" || s === "[object GeneratorFunction]" ? si(e, t) : s === "[object Symbol]" ? ii(e) : s === "[object Date]" ? isNaN(+e) ? "Date { NaN }" : qm.call(e) : s === "[object Error]" ? ai(e) : s === "[object RegExp]" ? n ? oi.call(e).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&") : oi.call(e) : e instanceof Error ? ai(e) : null;
}
function $c(e, t, n, o, r, s) {
  if (r.indexOf(e) !== -1)
    return "[Circular]";
  r = r.slice(), r.push(e);
  const i = ++o > t.maxDepth, a = t.min;
  if (t.callToJSON && !i && e.toJSON && typeof e.toJSON == "function" && !s)
    return ot(e.toJSON(), t, n, o, r, !0);
  const c = Sc.call(e);
  return c === "[object Arguments]" ? i ? "[Arguments]" : `${a ? "" : "Arguments "}[${(0, rn.printListItems)(
    e,
    t,
    n,
    o,
    r,
    ot
  )}]` : Km(c) ? i ? `[${e.constructor.name}]` : `${a || !t.printBasicPrototype && e.constructor.name === "Array" ? "" : `${e.constructor.name} `}[${(0, rn.printListItems)(
    e,
    t,
    n,
    o,
    r,
    ot
  )}]` : c === "[object Map]" ? i ? "[Map]" : `Map {${(0, rn.printIteratorEntries)(
    e.entries(),
    t,
    n,
    o,
    r,
    ot,
    " => "
  )}}` : c === "[object Set]" ? i ? "[Set]" : `Set {${(0, rn.printIteratorValues)(
    e.values(),
    t,
    n,
    o,
    r,
    ot
  )}}` : i || Wm(e) ? `[${Br(e)}]` : `${a || !t.printBasicPrototype && Br(e) === "Object" ? "" : `${Br(e)} `}{${(0, rn.printObjectProperties)(
    e,
    t,
    n,
    o,
    r,
    ot
  )}}`;
}
function Ym(e) {
  return e.serialize != null;
}
function Oc(e, t, n, o, r, s) {
  let i;
  try {
    i = Ym(e) ? e.serialize(t, n, o, r, s, ot) : e.print(
      t,
      (a) => ot(a, n, o, r, s),
      (a) => {
        const c = o + n.indent;
        return c + a.replace(Um, `
${c}`);
      },
      {
        edgeSpacing: n.spacingOuter,
        min: n.min,
        spacing: n.spacingInner
      },
      n.colors
    );
  } catch (a) {
    throw new Tc(a.message, a.stack);
  }
  if (typeof i != "string")
    throw new Error(
      `pretty-format: Plugin must return type "string" but instead returned "${typeof i}".`
    );
  return i;
}
function Ac(e, t) {
  for (let n = 0; n < e.length; n++)
    try {
      if (e[n].test(t))
        return e[n];
    } catch (o) {
      throw new Tc(o.message, o.stack);
    }
  return null;
}
function ot(e, t, n, o, r, s) {
  const i = Ac(t.plugins, e);
  if (i !== null)
    return Oc(i, e, t, n, o, r);
  const a = xc(
    e,
    t.printFunctionName,
    t.escapeRegex,
    t.escapeString
  );
  return a !== null ? a : $c(
    e,
    t,
    n,
    o,
    r,
    s
  );
}
const xo = {
  comment: "gray",
  content: "reset",
  prop: "yellow",
  tag: "cyan",
  value: "green"
}, _c = Object.keys(xo), Hm = (e) => e, Ue = Hm({
  callToJSON: !0,
  compareKeys: void 0,
  escapeRegex: !1,
  escapeString: !0,
  highlight: !1,
  indent: 2,
  maxDepth: 1 / 0,
  maxWidth: 1 / 0,
  min: !1,
  plugins: [],
  printBasicPrototype: !0,
  printFunctionName: !0,
  theme: xo
});
bt.DEFAULT_OPTIONS = Ue;
function Xm(e) {
  if (Object.keys(e).forEach((t) => {
    if (!Object.prototype.hasOwnProperty.call(Ue, t))
      throw new Error(`pretty-format: Unknown option "${t}".`);
  }), e.min && e.indent !== void 0 && e.indent !== 0)
    throw new Error(
      'pretty-format: Options "min" and "indent" cannot be used together.'
    );
  if (e.theme !== void 0) {
    if (e.theme === null)
      throw new Error('pretty-format: Option "theme" must not be null.');
    if (typeof e.theme != "object")
      throw new Error(
        `pretty-format: Option "theme" must be of type "object" but instead received "${typeof e.theme}".`
      );
  }
}
const Qm = (e) => _c.reduce((t, n) => {
  const o = e.theme && e.theme[n] !== void 0 ? e.theme[n] : xo[n], r = o && jm.default[o];
  if (r && typeof r.close == "string" && typeof r.open == "string")
    t[n] = r;
  else
    throw new Error(
      `pretty-format: Option "theme" has a key "${n}" whose value "${o}" is undefined in ansi-styles.`
    );
  return t;
}, /* @__PURE__ */ Object.create(null)), Zm = () => _c.reduce((e, t) => (e[t] = {
  close: "",
  open: ""
}, e), /* @__PURE__ */ Object.create(null)), Mc = (e) => (e == null ? void 0 : e.printFunctionName) ?? Ue.printFunctionName, Pc = (e) => (e == null ? void 0 : e.escapeRegex) ?? Ue.escapeRegex, Ic = (e) => (e == null ? void 0 : e.escapeString) ?? Ue.escapeString, ci = (e) => ({
  callToJSON: (e == null ? void 0 : e.callToJSON) ?? Ue.callToJSON,
  colors: e != null && e.highlight ? Qm(e) : Zm(),
  compareKeys: typeof (e == null ? void 0 : e.compareKeys) == "function" || (e == null ? void 0 : e.compareKeys) === null ? e.compareKeys : Ue.compareKeys,
  escapeRegex: Pc(e),
  escapeString: Ic(e),
  indent: e != null && e.min ? "" : ed((e == null ? void 0 : e.indent) ?? Ue.indent),
  maxDepth: (e == null ? void 0 : e.maxDepth) ?? Ue.maxDepth,
  maxWidth: (e == null ? void 0 : e.maxWidth) ?? Ue.maxWidth,
  min: (e == null ? void 0 : e.min) ?? Ue.min,
  plugins: (e == null ? void 0 : e.plugins) ?? Ue.plugins,
  printBasicPrototype: (e == null ? void 0 : e.printBasicPrototype) ?? !0,
  printFunctionName: Mc(e),
  spacingInner: e != null && e.min ? " " : `
`,
  spacingOuter: e != null && e.min ? "" : `
`
});
function ed(e) {
  return new Array(e + 1).join(" ");
}
function Cc(e, t) {
  if (t && (Xm(t), t.plugins)) {
    const o = Ac(t.plugins, e);
    if (o !== null)
      return Oc(o, e, ci(t), "", 0, []);
  }
  const n = xc(
    e,
    Mc(t),
    Pc(t),
    Ic(t)
  );
  return n !== null ? n : $c(e, ci(t), "", 0, []);
}
const td = {
  AsymmetricMatcher: km.default,
  DOMCollection: Rm.default,
  DOMElement: Fm.default,
  Immutable: Dm.default,
  ReactElement: Bm.default,
  ReactTestComponent: Lm.default
};
Ec = bt.plugins = td;
var nd = Cc;
bt.default = nd;
function rd(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Nc = { exports: {} };
/*
 * @version    1.4.0
 * @date       2015-10-26
 * @stability  3 - Stable
 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
 * @license    MIT License
 */
var ui = function(e, t) {
  var n, o, r = 1, s = 0, i = 0, a = String.alphabet;
  function c(l, f, u) {
    if (u) {
      for (n = f; u = c(l, n), u < 76 && u > 65; )
        ++n;
      return +l.slice(f - 1, n);
    }
    return u = a && a.indexOf(l.charAt(f)), u > -1 ? u + 76 : (u = l.charCodeAt(f) || 0, u < 45 || u > 127 ? u : u < 46 ? 65 : u < 48 ? u - 1 : u < 58 ? u + 18 : u < 65 ? u - 11 : u < 91 ? u + 11 : u < 97 ? u - 37 : u < 123 ? u + 5 : u - 63);
  }
  if ((e += "") != (t += "")) {
    for (; r; )
      if (o = c(e, s++), r = c(t, i++), o < 76 && r < 76 && o > 66 && r > 66 && (o = c(e, s, s), r = c(t, i, s = n), i = n), o != r)
        return o < r ? -1 : 1;
  }
  return 0;
};
try {
  Nc.exports = ui;
} catch {
  String.naturalCompare = ui;
}
var od = Nc.exports, sd = /* @__PURE__ */ rd(od);
function jc(e) {
  return e != null;
}
function id(e) {
  return e === null || typeof e != "function" && typeof e != "object";
}
function qn(e) {
  return e != null && typeof e == "object" && !Array.isArray(e);
}
function ad(e) {
  let t = -1, n = null, o = 0, r = 0, s = null;
  for (; t <= e.length; ) {
    s = e[t], t++;
    const i = e[t];
    if ((i === '"' || i === "'" || i === "`") && s !== "\\" && (n === i ? n = null : n || (n = i)), n || (i === "(" && o++, i === ")" && r++), o && r && o === r)
      return t;
  }
  return null;
}
let cd = () => "Promise{…}";
try {
  const { getPromiseDetails: e, kPending: t, kRejected: n } = process.binding("util");
  Array.isArray(e(Promise.resolve())) && (cd = (o, r) => {
    const [s, i] = e(o);
    return s === t ? "Promise{<pending>}" : `Promise${s === n ? "!" : ""}{${r.inspect(i, r)}}`;
  });
} catch {
}
let li = !1;
try {
  const e = require("util");
  li = e.inspect ? e.inspect.custom : !1;
} catch {
  li = !1;
}
const $o = /\r?\n/;
function ud(e, t, n) {
  const o = e.split($o), r = /\r\n/.test(e) ? 2 : 1;
  let s = 0;
  if (t > o.length)
    return e.length;
  for (let i = 0; i < t - 1; i++)
    s += o[i].length + r;
  return s + n;
}
function ld(e, t) {
  if (t > e.length)
    throw new Error(
      `offset is longer than source length! offset ${t} > length ${e.length}`
    );
  const n = e.split($o), o = /\r\n/.test(e) ? 2 : 1;
  let r = 0, s = 0;
  for (; s < n.length; s++) {
    const i = n[s].length + o;
    if (r + i >= t)
      break;
    r += i;
  }
  return s + 1;
}
var kc;
kc = /\r?\n|[\r\u2028\u2029]/y;
RegExp(kc.source);
var Rc = {
  keyword: [
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete"
  ],
  strict: [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield"
  ]
};
new Set(Rc.keyword);
new Set(Rc.strict);
const fd = (e, t, n, o, r, s) => {
  const i = e.getMockName(), a = i === "vi.fn()" ? "" : ` ${i}`;
  let c = "";
  if (e.mock.calls.length !== 0) {
    const l = n + t.indent;
    c = ` {${t.spacingOuter}${l}"calls": ${s(e.mock.calls, t, l, o, r)}${t.min ? ", " : ","}${t.spacingOuter}${l}"results": ${s(e.mock.results, t, l, o, r)}${t.min ? "" : ","}${t.spacingOuter}${n}}`;
  }
  return `[MockFunction${a}]${c}`;
}, pd = (e) => e && !!e._isMockFunction, hd = { serialize: fd, test: pd }, {
  DOMCollection: md,
  DOMElement: dd,
  Immutable: yd,
  ReactElement: gd,
  ReactTestComponent: bd,
  AsymmetricMatcher: wd
} = Ec;
let eo = [
  bd,
  gd,
  dd,
  md,
  yd,
  wd,
  hd
];
function vd(e) {
  eo = [e].concat(eo);
}
function Ed() {
  return eo;
}
function Sd(e, t) {
  return `${e} ${t}`;
}
function Td(e) {
  if (!/ \d+$/.test(e))
    throw new Error("Snapshot keys must end with a number.");
  return e.replace(/ \d+$/, "");
}
function xd(e, t) {
  const n = t.updateSnapshot, o = /* @__PURE__ */ Object.create(null);
  let r = "", s = !1;
  if (e != null)
    try {
      r = e, new Function("exports", r)(o);
    } catch {
    }
  return (n === "all" || n === "new") && r && (s = !0), { data: o, dirty: s };
}
function $d(e) {
  return e.includes(`
`) ? `
${e}
` : e;
}
function fi(e) {
  return e.length > 2 && e.startsWith(`
`) && e.endsWith(`
`) ? e.slice(1, -1) : e;
}
const Od = !0, Ad = !1;
function _d(e, t = 2, n = {}) {
  return Oo(
    Nm(e, {
      escapeRegex: Od,
      indent: t,
      plugins: Ed(),
      printFunctionName: Ad,
      ...n
    })
  );
}
function Md(e) {
  return e.replace(/`|\\|\${/g, "\\$&");
}
function pi(e) {
  return `\`${Md(e)}\``;
}
function Oo(e) {
  return e.replace(/\r\n|\r/g, `
`);
}
async function Pd(e, t, n) {
  const o = Object.keys(t).sort(sd).map(
    (a) => `exports[${pi(a)}] = ${pi(Oo(t[a]))};`
  ), r = `${e.getHeader()}

${o.join(`

`)}
`, s = await e.readSnapshotFile(n);
  s != null && s === r || await e.saveSnapshotFile(
    n,
    r
  );
}
function hi(e) {
  function t() {
    var r, s;
    const i = /^( +)}\s+$/m.exec(e || ""), a = (r = i == null ? void 0 : i[1]) == null ? void 0 : r.length;
    if (a)
      return a;
    const c = /^\n( +)"/.exec(e || "");
    return ((s = c == null ? void 0 : c[1]) == null ? void 0 : s.length) || 0;
  }
  const n = t();
  let o = e == null ? void 0 : e.trim();
  return n && (o = o == null ? void 0 : o.replace(new RegExp(`^${" ".repeat(n)}`, "gm"), "").replace(/ +}$/, "}")), o;
}
function to(e = [], t = []) {
  const n = Array.from(e);
  return t.forEach((o, r) => {
    const s = n[r];
    Array.isArray(e[r]) ? n[r] = to(e[r], o) : qn(s) ? n[r] = Ao(e[r], o) : n[r] = o;
  }), n;
}
function Ao(e, t) {
  if (qn(e) && qn(t)) {
    const n = { ...e };
    return Object.keys(t).forEach((o) => {
      qn(t[o]) && !t[o].$$typeof ? o in e ? n[o] = Ao(e[o], t[o]) : Object.assign(n, { [o]: t[o] }) : Array.isArray(t[o]) ? n[o] = to(e[o], t[o]) : Object.assign(n, { [o]: t[o] });
    }), n;
  } else if (Array.isArray(e) && Array.isArray(t))
    return to(e, t);
  return e;
}
const Id = 44, mi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Cd = new Uint8Array(64), Fc = new Uint8Array(128);
for (let e = 0; e < mi.length; e++) {
  const t = mi.charCodeAt(e);
  Cd[e] = t, Fc[t] = e;
}
function Nd(e) {
  const t = new Int32Array(5), n = [];
  let o = 0;
  do {
    const r = jd(e, o), s = [];
    let i = !0, a = 0;
    t[0] = 0;
    for (let c = o; c < r; c++) {
      let l;
      c = on(e, c, t, 0);
      const f = t[0];
      f < a && (i = !1), a = f, di(e, c, r) ? (c = on(e, c, t, 1), c = on(e, c, t, 2), c = on(e, c, t, 3), di(e, c, r) ? (c = on(e, c, t, 4), l = [f, t[1], t[2], t[3], t[4]]) : l = [f, t[1], t[2], t[3]]) : l = [f], s.push(l);
    }
    i || kd(s), n.push(s), o = r + 1;
  } while (o <= e.length);
  return n;
}
function jd(e, t) {
  const n = e.indexOf(";", t);
  return n === -1 ? e.length : n;
}
function on(e, t, n, o) {
  let r = 0, s = 0, i = 0;
  do {
    const c = e.charCodeAt(t++);
    i = Fc[c], r |= (i & 31) << s, s += 5;
  } while (i & 32);
  const a = r & 1;
  return r >>>= 1, a && (r = -2147483648 | -r), n[o] += r, t;
}
function di(e, t, n) {
  return t >= n ? !1 : e.charCodeAt(t) !== Id;
}
function kd(e) {
  e.sort(Rd);
}
function Rd(e, t) {
  return e[0] - t[0];
}
const Fd = /^[\w+.-]+:\/\//, Dd = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, Bd = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var Oe;
(function(e) {
  e[e.Empty = 1] = "Empty", e[e.Hash = 2] = "Hash", e[e.Query = 3] = "Query", e[e.RelativePath = 4] = "RelativePath", e[e.AbsolutePath = 5] = "AbsolutePath", e[e.SchemeRelative = 6] = "SchemeRelative", e[e.Absolute = 7] = "Absolute";
})(Oe || (Oe = {}));
function Ld(e) {
  return Fd.test(e);
}
function qd(e) {
  return e.startsWith("//");
}
function Dc(e) {
  return e.startsWith("/");
}
function zd(e) {
  return e.startsWith("file:");
}
function yi(e) {
  return /^[.?#]/.test(e);
}
function Rn(e) {
  const t = Dd.exec(e);
  return Bc(t[1], t[2] || "", t[3], t[4] || "", t[5] || "/", t[6] || "", t[7] || "");
}
function Wd(e) {
  const t = Bd.exec(e), n = t[2];
  return Bc("file:", "", t[1] || "", "", Dc(n) ? n : "/" + n, t[3] || "", t[4] || "");
}
function Bc(e, t, n, o, r, s, i) {
  return {
    scheme: e,
    user: t,
    host: n,
    port: o,
    path: r,
    query: s,
    hash: i,
    type: Oe.Absolute
  };
}
function gi(e) {
  if (qd(e)) {
    const n = Rn("http:" + e);
    return n.scheme = "", n.type = Oe.SchemeRelative, n;
  }
  if (Dc(e)) {
    const n = Rn("http://foo.com" + e);
    return n.scheme = "", n.host = "", n.type = Oe.AbsolutePath, n;
  }
  if (zd(e))
    return Wd(e);
  if (Ld(e))
    return Rn(e);
  const t = Rn("http://foo.com/" + e);
  return t.scheme = "", t.host = "", t.type = e ? e.startsWith("?") ? Oe.Query : e.startsWith("#") ? Oe.Hash : Oe.RelativePath : Oe.Empty, t;
}
function Vd(e) {
  if (e.endsWith("/.."))
    return e;
  const t = e.lastIndexOf("/");
  return e.slice(0, t + 1);
}
function Ud(e, t) {
  Lc(t, t.type), e.path === "/" ? e.path = t.path : e.path = Vd(t.path) + e.path;
}
function Lc(e, t) {
  const n = t <= Oe.RelativePath, o = e.path.split("/");
  let r = 1, s = 0, i = !1;
  for (let c = 1; c < o.length; c++) {
    const l = o[c];
    if (!l) {
      i = !0;
      continue;
    }
    if (i = !1, l !== ".") {
      if (l === "..") {
        s ? (i = !0, s--, r--) : n && (o[r++] = l);
        continue;
      }
      o[r++] = l, s++;
    }
  }
  let a = "";
  for (let c = 1; c < r; c++)
    a += "/" + o[c];
  (!a || i && !a.endsWith("/..")) && (a += "/"), e.path = a;
}
function Kd(e, t) {
  if (!e && !t)
    return "";
  const n = gi(e);
  let o = n.type;
  if (t && o !== Oe.Absolute) {
    const s = gi(t), i = s.type;
    switch (o) {
      case Oe.Empty:
        n.hash = s.hash;
      case Oe.Hash:
        n.query = s.query;
      case Oe.Query:
      case Oe.RelativePath:
        Ud(n, s);
      case Oe.AbsolutePath:
        n.user = s.user, n.host = s.host, n.port = s.port;
      case Oe.SchemeRelative:
        n.scheme = s.scheme;
    }
    i > o && (o = i);
  }
  Lc(n, o);
  const r = n.query + n.hash;
  switch (o) {
    case Oe.Hash:
    case Oe.Query:
      return r;
    case Oe.RelativePath: {
      const s = n.path.slice(1);
      return s ? yi(t || e) && !yi(s) ? "./" + s + r : s + r : r || ".";
    }
    case Oe.AbsolutePath:
      return n.path + r;
    default:
      return n.scheme + "//" + n.user + n.host + n.port + n.path + r;
  }
}
function bi(e, t) {
  return t && !t.endsWith("/") && (t += "/"), Kd(e, t);
}
function Gd(e) {
  if (!e)
    return "";
  const t = e.lastIndexOf("/");
  return e.slice(0, t + 1);
}
const wt = 0, Jd = 1, Yd = 2, Hd = 3, Xd = 4;
function Qd(e, t) {
  const n = wi(e, 0);
  if (n === e.length)
    return e;
  t || (e = e.slice());
  for (let o = n; o < e.length; o = wi(e, o + 1))
    e[o] = ey(e[o], t);
  return e;
}
function wi(e, t) {
  for (let n = t; n < e.length; n++)
    if (!Zd(e[n]))
      return n;
  return e.length;
}
function Zd(e) {
  for (let t = 1; t < e.length; t++)
    if (e[t][wt] < e[t - 1][wt])
      return !1;
  return !0;
}
function ey(e, t) {
  return t || (e = e.slice()), e.sort(ty);
}
function ty(e, t) {
  return e[wt] - t[wt];
}
let Jn = !1;
function ny(e, t, n, o) {
  for (; n <= o; ) {
    const r = n + (o - n >> 1), s = e[r][wt] - t;
    if (s === 0)
      return Jn = !0, r;
    s < 0 ? n = r + 1 : o = r - 1;
  }
  return Jn = !1, n - 1;
}
function ry(e, t, n) {
  for (let o = n + 1; o < e.length && e[o][wt] === t; n = o++)
    ;
  return n;
}
function oy(e, t, n) {
  for (let o = n - 1; o >= 0 && e[o][wt] === t; n = o--)
    ;
  return n;
}
function sy() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function iy(e, t, n, o) {
  const { lastKey: r, lastNeedle: s, lastIndex: i } = n;
  let a = 0, c = e.length - 1;
  if (o === r) {
    if (t === s)
      return Jn = i !== -1 && e[i][wt] === t, i;
    t >= s ? a = i === -1 ? 0 : i : c = i;
  }
  return n.lastKey = o, n.lastNeedle = t, n.lastIndex = ny(e, t, a, c);
}
const ay = "`line` must be greater than 0 (lines start at line 1)", cy = "`column` must be greater than or equal to 0 (columns start at column 0)", vi = -1, uy = 1;
let Ei, qc;
class ly {
  constructor(t, n) {
    const o = typeof t == "string";
    if (!o && t._decodedMemo)
      return t;
    const r = o ? JSON.parse(t) : t, { version: s, file: i, names: a, sourceRoot: c, sources: l, sourcesContent: f } = r;
    this.version = s, this.file = i, this.names = a || [], this.sourceRoot = c, this.sources = l, this.sourcesContent = f;
    const u = bi(c || "", Gd(n));
    this.resolvedSources = l.map((w) => bi(w || "", u));
    const { mappings: p } = r;
    typeof p == "string" ? (this._encoded = p, this._decoded = void 0) : (this._encoded = void 0, this._decoded = Qd(p, o)), this._decodedMemo = sy(), this._bySources = void 0, this._bySourceMemos = void 0;
  }
}
Ei = (e) => e._decoded || (e._decoded = Nd(e._encoded)), qc = (e, { line: t, column: n, bias: o }) => {
  if (t--, t < 0)
    throw new Error(ay);
  if (n < 0)
    throw new Error(cy);
  const r = Ei(e);
  if (t >= r.length)
    return Fn(null, null, null, null);
  const s = r[t], i = fy(s, e._decodedMemo, t, n, o || uy);
  if (i === -1)
    return Fn(null, null, null, null);
  const a = s[i];
  if (a.length === 1)
    return Fn(null, null, null, null);
  const { names: c, resolvedSources: l } = e;
  return Fn(l[a[Jd]], a[Yd] + 1, a[Hd], a.length === 5 ? c[a[Xd]] : null);
};
function Fn(e, t, n, o) {
  return { source: e, line: t, column: n, name: o };
}
function fy(e, t, n, o, r) {
  let s = iy(e, o, t, n);
  return Jn ? s = (r === vi ? ry : oy)(e, o, s) : r === vi && s++, s === -1 || s === e.length ? -1 : s;
}
const zc = /^\s*at .*(\S+:\d+|\(native\))/m, py = /^(eval@)?(\[native code])?$/, hy = [
  "node:internal",
  /\/packages\/\w+\/dist\//,
  /\/@vitest\/\w+\/dist\//,
  "/vitest/dist/",
  "/vitest/src/",
  "/vite-node/dist/",
  "/vite-node/src/",
  "/node_modules/chai/",
  "/node_modules/tinypool/",
  "/node_modules/tinyspy/",
  "/deps/chai.js",
  /__vitest_browser__/
];
function Wc(e) {
  if (!e.includes(":"))
    return [e];
  const n = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/^\(|\)$/g, ""));
  if (!n)
    return [e];
  let o = n[1];
  return (o.startsWith("http:") || o.startsWith("https:")) && (o = new URL(o).pathname), o.startsWith("/@fs/") && (o = o.slice(typeof process < "u" && process.platform === "win32" ? 5 : 4)), [o, n[2] || void 0, n[3] || void 0];
}
function my(e) {
  let t = e.trim();
  if (py.test(t) || (t.includes(" > eval") && (t = t.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), !t.includes("@") && !t.includes(":")))
    return null;
  const n = /((.*".+"[^@]*)?[^@]*)(?:@)/, o = t.match(n), r = o && o[1] ? o[1] : void 0, [s, i, a] = Wc(t.replace(n, ""));
  return !s || !i || !a ? null : {
    file: s,
    method: r || "",
    line: Number.parseInt(i),
    column: Number.parseInt(a)
  };
}
function dy(e) {
  let t = e.trim();
  if (!zc.test(t))
    return null;
  t.includes("(eval ") && (t = t.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
  let n = t.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
  const o = n.match(/ (\(.+\)$)/);
  n = o ? n.replace(o[0], "") : n;
  const [r, s, i] = Wc(o ? o[1] : n);
  let a = o && n || "", c = r && ["eval", "<anonymous>"].includes(r) ? void 0 : r;
  return !c || !s || !i ? null : (a.startsWith("async ") && (a = a.slice(6)), c.startsWith("file://") && (c = c.slice(7)), c = Pf(c), a && (a = a.replace(/__vite_ssr_import_\d+__\./g, "")), {
    method: a,
    file: c,
    line: Number.parseInt(s),
    column: Number.parseInt(i)
  });
}
function yy(e, t = {}) {
  const { ignoreStackEntries: n = hy } = t;
  let o = zc.test(e) ? by(e) : gy(e);
  return n.length && (o = o.filter((r) => !n.some((s) => r.file.match(s)))), o.map((r) => {
    var s;
    const i = (s = t.getSourceMap) == null ? void 0 : s.call(t, r.file);
    if (!i || typeof i != "object" || !i.version)
      return r;
    const a = new ly(i), { line: c, column: l } = qc(a, r);
    return c != null && l != null ? { ...r, line: c, column: l } : r;
  });
}
function gy(e) {
  return e.split(`
`).map((t) => my(t)).filter(jc);
}
function by(e) {
  return e.split(`
`).map((t) => dy(t)).filter(jc);
}
function wy(e, t = {}) {
  if (!e || id(e))
    return [];
  if (e.stacks)
    return e.stacks;
  const n = e.stack || e.stackStr || "";
  let o = yy(n, t);
  return t.frameFilter && (o = o.filter((r) => t.frameFilter(e, r) !== !1)), e.stacks = o, o;
}
async function vy(e, t) {
  const n = (await import("../../magic-string.es-irX7syie.js")).default, o = new Set(t.map((r) => r.file));
  await Promise.all(Array.from(o).map(async (r) => {
    const s = t.filter((l) => l.file === r), i = await e.readSnapshotFile(r), a = new n(i);
    for (const l of s) {
      const f = ud(i, l.line, l.column);
      $y(i, a, f, l.snapshot);
    }
    const c = a.toString();
    c !== i && await e.saveSnapshotFile(r, c);
  }));
}
const Ey = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\S\s]*\*\/\s*|\/\/.*\s+)*\s*({)/m;
function Sy(e, t, n, o) {
  let r = e.slice(n);
  const s = Ey.exec(r);
  if (!s)
    return !1;
  r = r.slice(s.index);
  let i = ad(r);
  if (i === null)
    return !1;
  i += n + s.index;
  const a = n + s.index + s[0].length, c = Ty(e, a), l = `, ${Vc(o, e, n)}`;
  return c === i ? t.appendLeft(i, l) : t.overwrite(c, i, l), !0;
}
function Ty(e, t) {
  let n = 1, o = 0;
  for (; n !== o && t < e.length; ) {
    const r = e[t++];
    r === "{" ? n++ : r === "}" && o++;
  }
  return t;
}
function Vc(e, t, n) {
  const o = ld(t, n), s = t.split($o)[o - 1].match(/^\s*/)[0] || "", i = s.includes("	") ? `${s}	` : `${s}  `, a = e.trim().replace(/\\/g, "\\\\").split(/\n/g), c = a.length <= 1, l = "`";
  return c ? `${l}${a.join(`
`).replace(/`/g, "\\`").replace(/\${/g, "\\${")}${l}` : `${l}
${a.map((f) => f ? i + f : "").join(`
`).replace(/`/g, "\\`").replace(/\${/g, "\\${")}
${s}${l}`;
}
const xy = /(?:toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot)\s*\(\s*(?:\/\*[\S\s]*\*\/\s*|\/\/.*\s+)*\s*[\w_$]*(['"`\)])/m;
function $y(e, t, n, o) {
  const r = e.slice(n), s = xy.exec(r), i = /toMatchInlineSnapshot|toThrowErrorMatchingInlineSnapshot/.exec(r);
  if (!s || s.index !== (i == null ? void 0 : i.index))
    return Sy(e, t, n, o);
  const a = s[1], c = n + s.index + s[0].length, l = Vc(o, e, n);
  if (a === ")")
    return t.appendRight(c - 1, l), !0;
  const u = new RegExp(`(?:^|[^\\\\])${a}`).exec(e.slice(c));
  if (!u)
    return !1;
  const p = c + u.index + u[0].length;
  return t.overwrite(c - 1, p, l), !0;
}
const Oy = /^([^\S\n]*)\S/m;
function Si(e) {
  const t = e.match(Oy);
  if (!t || !t[1])
    return e;
  const n = t[1], o = e.split(/\n/g);
  if (o.length <= 2 || o[0].trim() !== "" || o[o.length - 1].trim() !== "")
    return e;
  for (let r = 1; r < o.length - 1; r++)
    if (o[r] !== "") {
      if (o[r].indexOf(n) !== 0)
        return e;
      o[r] = o[r].substring(n.length);
    }
  return o[o.length - 1] = "", e = o.join(`
`), e;
}
async function Ay(e, t) {
  await Promise.all(t.map(async (n) => {
    n.readonly || await e.saveSnapshotFile(n.file, n.snapshot);
  }));
}
class _o {
  constructor(t, n, o, r) {
    se(this, "_counters");
    se(this, "_dirty");
    se(this, "_updateSnapshot");
    se(this, "_snapshotData");
    se(this, "_initialData");
    se(this, "_inlineSnapshots");
    se(this, "_rawSnapshots");
    se(this, "_uncheckedKeys");
    se(this, "_snapshotFormat");
    se(this, "_environment");
    se(this, "_fileExists");
    se(this, "added");
    se(this, "expand");
    se(this, "matched");
    se(this, "unmatched");
    se(this, "updated");
    this.testFilePath = t, this.snapshotPath = n;
    const { data: s, dirty: i } = xd(
      o,
      r
    );
    this._fileExists = o != null, this._initialData = s, this._snapshotData = s, this._dirty = i, this._inlineSnapshots = [], this._rawSnapshots = [], this._uncheckedKeys = new Set(Object.keys(this._snapshotData)), this._counters = /* @__PURE__ */ new Map(), this.expand = r.expand || !1, this.added = 0, this.matched = 0, this.unmatched = 0, this._updateSnapshot = r.updateSnapshot, this.updated = 0, this._snapshotFormat = {
      printBasicPrototype: !1,
      escapeString: !1,
      ...r.snapshotFormat
    }, this._environment = r.snapshotEnvironment;
  }
  static async create(t, n) {
    const o = await n.snapshotEnvironment.resolvePath(t), r = await n.snapshotEnvironment.readSnapshotFile(o);
    return new _o(t, o, r, n);
  }
  get environment() {
    return this._environment;
  }
  markSnapshotsAsCheckedForTest(t) {
    this._uncheckedKeys.forEach((n) => {
      Td(n) === t && this._uncheckedKeys.delete(n);
    });
  }
  _inferInlineSnapshotStack(t) {
    const n = t.findIndex((r) => r.method.match(/__VITEST_(RESOLVES|REJECTS)__/));
    if (n !== -1)
      return t[n + 3];
    const o = t.findIndex((r) => r.method.includes("__INLINE_SNAPSHOT__"));
    return o !== -1 ? t[o + 2] : null;
  }
  _addSnapshot(t, n, o) {
    if (this._dirty = !0, o.isInline) {
      const r = wy(o.error || new Error("snapshot"), { ignoreStackEntries: [] }), s = this._inferInlineSnapshotStack(r);
      if (!s)
        throw new Error(
          `@vitest/snapshot: Couldn't infer stack frame for inline snapshot.
${JSON.stringify(r)}`
        );
      s.column--, this._inlineSnapshots.push({
        snapshot: n,
        ...s
      });
    } else
      o.rawSnapshot ? this._rawSnapshots.push({
        ...o.rawSnapshot,
        snapshot: n
      }) : this._snapshotData[t] = n;
  }
  clear() {
    this._snapshotData = this._initialData, this._counters = /* @__PURE__ */ new Map(), this.added = 0, this.matched = 0, this.unmatched = 0, this.updated = 0, this._dirty = !1;
  }
  async save() {
    const t = Object.keys(this._snapshotData).length, n = this._inlineSnapshots.length, o = this._rawSnapshots.length, r = !t && !n && !o, s = {
      deleted: !1,
      saved: !1
    };
    return (this._dirty || this._uncheckedKeys.size) && !r ? (t && (await Pd(this._environment, this._snapshotData, this.snapshotPath), this._fileExists = !0), n && await vy(this._environment, this._inlineSnapshots), o && await Ay(this._environment, this._rawSnapshots), s.saved = !0) : !t && this._fileExists && (this._updateSnapshot === "all" && (await this._environment.removeSnapshotFile(this.snapshotPath), this._fileExists = !1), s.deleted = !0), s;
  }
  getUncheckedCount() {
    return this._uncheckedKeys.size || 0;
  }
  getUncheckedKeys() {
    return Array.from(this._uncheckedKeys);
  }
  removeUncheckedKeys() {
    this._updateSnapshot === "all" && this._uncheckedKeys.size && (this._dirty = !0, this._uncheckedKeys.forEach((t) => delete this._snapshotData[t]), this._uncheckedKeys.clear());
  }
  match({
    testName: t,
    received: n,
    key: o,
    inlineSnapshot: r,
    isInline: s,
    error: i,
    rawSnapshot: a
  }) {
    this._counters.set(t, (this._counters.get(t) || 0) + 1);
    const c = Number(this._counters.get(t));
    o || (o = Sd(t, c)), s && this._snapshotData[o] !== void 0 || this._uncheckedKeys.delete(o);
    let l = a && typeof n == "string" ? n : _d(n, void 0, this._snapshotFormat);
    a || (l = $d(l)), a && a.content && a.content.match(/\r\n/) && !l.match(/\r\n/) && (a.content = Oo(a.content));
    const f = s ? r : a ? a.content : this._snapshotData[o], u = hi(f), p = u === hi(l), w = f !== void 0, b = s || this._fileExists || a && a.content != null;
    return p && !s && !a && (this._snapshotData[o] = l), w && this._updateSnapshot === "all" || (!w || !b) && (this._updateSnapshot === "new" || this._updateSnapshot === "all") ? (this._updateSnapshot === "all" ? p ? this.matched++ : (w ? this.updated++ : this.added++, this._addSnapshot(o, l, { error: i, isInline: s, rawSnapshot: a })) : (this._addSnapshot(o, l, { error: i, isInline: s, rawSnapshot: a }), this.added++), {
      actual: "",
      count: c,
      expected: "",
      key: o,
      pass: !0
    }) : p ? (this.matched++, {
      actual: "",
      count: c,
      expected: "",
      key: o,
      pass: !0
    }) : (this.unmatched++, {
      actual: fi(l),
      count: c,
      expected: u !== void 0 ? fi(u) : void 0,
      key: o,
      pass: !1
    });
  }
  async pack() {
    const t = {
      filepath: this.testFilePath,
      added: 0,
      fileDeleted: !1,
      matched: 0,
      unchecked: 0,
      uncheckedKeys: [],
      unmatched: 0,
      updated: 0
    }, n = this.getUncheckedCount(), o = this.getUncheckedKeys();
    n && this.removeUncheckedKeys();
    const r = await this.save();
    return t.fileDeleted = r.deleted, t.added = this.added, t.matched = this.matched, t.unmatched = this.unmatched, t.updated = this.updated, t.unchecked = r.deleted ? 0 : n, t.uncheckedKeys = Array.from(o), t;
  }
}
function Ti(e, t, n, o) {
  const r = new Error(e);
  return Object.defineProperty(r, "actual", {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }), Object.defineProperty(r, "expected", {
    value: o,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }), Object.defineProperty(r, "diffOptions", { value: { expand: t } }), r;
}
class _y {
  constructor(t = {}) {
    se(this, "filepath");
    se(this, "name");
    se(this, "snapshotState");
    se(this, "snapshotStateMap", /* @__PURE__ */ new Map());
    this.options = t;
  }
  async startCurrentRun(t, n, o) {
    var r;
    this.filepath = t, this.name = n, ((r = this.snapshotState) == null ? void 0 : r.testFilePath) !== t && (await this.finishCurrentRun(), this.getSnapshotState(t) || this.snapshotStateMap.set(
      t,
      await _o.create(
        t,
        o
      )
    ), this.snapshotState = this.getSnapshotState(t));
  }
  getSnapshotState(t) {
    return this.snapshotStateMap.get(t);
  }
  clearTest() {
    this.filepath = void 0, this.name = void 0;
  }
  skipTestSnapshots(t) {
    var n;
    (n = this.snapshotState) == null || n.markSnapshotsAsCheckedForTest(t);
  }
  assert(t) {
    var n, o, r, s;
    const {
      filepath: i = this.filepath,
      name: a = this.name,
      message: c,
      isInline: l = !1,
      properties: f,
      inlineSnapshot: u,
      error: p,
      errorMessage: w,
      rawSnapshot: b
    } = t;
    let { received: v } = t;
    if (!i)
      throw new Error("Snapshot cannot be used outside of test");
    if (typeof f == "object") {
      if (typeof v != "object" || !v)
        throw new Error("Received value must be an object when the matcher has properties");
      try {
        if (((o = (n = this.options).isEqual) == null ? void 0 : o.call(n, v, f)) ?? !1)
          v = Ao(v, f);
        else
          throw Ti("Snapshot properties mismatched", (r = this.snapshotState) == null ? void 0 : r.expand, v, f);
      } catch (U) {
        throw U.message = w || "Snapshot mismatched", U;
      }
    }
    const h = [
      a,
      ...c ? [c] : []
    ].join(" > "), A = this.getSnapshotState(i), { actual: M, expected: F, key: k, pass: N } = A.match({
      testName: h,
      received: v,
      isInline: l,
      error: p,
      inlineSnapshot: u,
      rawSnapshot: b
    });
    if (!N)
      throw Ti(`Snapshot \`${k || "unknown"}\` mismatched`, (s = this.snapshotState) == null ? void 0 : s.expand, M == null ? void 0 : M.trim(), F == null ? void 0 : F.trim());
  }
  async assertRaw(t) {
    if (!t.rawSnapshot)
      throw new Error("Raw snapshot is required");
    const {
      filepath: n = this.filepath,
      rawSnapshot: o
    } = t;
    if (o.content == null) {
      if (!n)
        throw new Error("Snapshot cannot be used outside of test");
      const r = this.getSnapshotState(n);
      t.filepath || (t.filepath = n), o.file = await r.environment.resolveRawPath(n, o.file), o.content = await r.environment.readSnapshotFile(o.file) || void 0;
    }
    return this.assert(t);
  }
  async finishCurrentRun() {
    if (!this.snapshotState)
      return null;
    const t = await this.snapshotState.pack();
    return this.snapshotState = void 0, t;
  }
  clear() {
    this.snapshotStateMap.clear();
  }
}
function My(e, t = " > ") {
  return xa(e).join(t);
}
function Py(e = "") {
  return !e || !e.includes("\\") ? e : e.replace(/\\/g, "/");
}
const Iy = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
function Cy() {
  return typeof process < "u" ? process.cwd().replace(/\\/g, "/") : "/";
}
const Ny = function(...e) {
  e = e.map((o) => Py(o));
  let t = "", n = !1;
  for (let o = e.length - 1; o >= -1 && !n; o--) {
    const r = o >= 0 ? e[o] : Cy();
    !r || r.length === 0 || (t = `${r}/${t}`, n = xi(r));
  }
  return t = jy(t, !n), n && !xi(t) ? `/${t}` : t.length > 0 ? t : ".";
};
function jy(e, t) {
  let n = "", o = 0, r = -1, s = 0, i = null;
  for (let a = 0; a <= e.length; ++a) {
    if (a < e.length)
      i = e[a];
    else {
      if (i === "/")
        break;
      i = "/";
    }
    if (i === "/") {
      if (!(r === a - 1 || s === 1))
        if (s === 2) {
          if (n.length < 2 || o !== 2 || n[n.length - 1] !== "." || n[n.length - 2] !== ".") {
            if (n.length > 2) {
              const c = n.lastIndexOf("/");
              c === -1 ? (n = "", o = 0) : (n = n.slice(0, c), o = n.length - 1 - n.lastIndexOf("/")), r = a, s = 0;
              continue;
            } else if (n.length > 0) {
              n = "", o = 0, r = a, s = 0;
              continue;
            }
          }
          t && (n += n.length > 0 ? "/.." : "..", o = 2);
        } else
          n.length > 0 ? n += `/${e.slice(r + 1, a)}` : n = e.slice(r + 1, a), o = a - r - 1;
      r = a, s = 0;
    } else
      i === "." && s !== -1 ? ++s : s = -1;
  }
  return n;
}
const xi = function(e) {
  return Iy.test(e);
}, $i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ky = new Uint8Array(64), Ry = new Uint8Array(128);
for (let e = 0; e < $i.length; e++) {
  const t = $i.charCodeAt(e);
  ky[e] = t, Ry[t] = e;
}
var Oi;
(function(e) {
  e[e.Empty = 1] = "Empty", e[e.Hash = 2] = "Hash", e[e.Query = 3] = "Query", e[e.RelativePath = 4] = "RelativePath", e[e.AbsolutePath = 5] = "AbsolutePath", e[e.SchemeRelative = 6] = "SchemeRelative", e[e.Absolute = 7] = "Absolute";
})(Oi || (Oi = {}));
const Uc = /^\s*at .*(\S+:\d+|\(native\))/m, Fy = /^(eval@)?(\[native code])?$/;
function Kc(e) {
  if (!e.includes(":"))
    return [e];
  const n = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(e.replace(/^\(|\)$/g, ""));
  if (!n)
    return [e];
  let o = n[1];
  return (o.startsWith("http:") || o.startsWith("https:")) && (o = new URL(o).pathname), o.startsWith("/@fs/") && (o = o.slice(typeof process < "u" && process.platform === "win32" ? 5 : 4)), [o, n[2] || void 0, n[3] || void 0];
}
function Dy(e) {
  let t = e.trim();
  if (Fy.test(t) || (t.includes(" > eval") && (t = t.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), !t.includes("@") && !t.includes(":")))
    return null;
  const n = /((.*".+"[^@]*)?[^@]*)(?:@)/, o = t.match(n), r = o && o[1] ? o[1] : void 0, [s, i, a] = Kc(t.replace(n, ""));
  return !s || !i || !a ? null : {
    file: s,
    method: r || "",
    line: Number.parseInt(i),
    column: Number.parseInt(a)
  };
}
function By(e) {
  const t = e.trim();
  return Uc.test(t) ? Ly(t) : Dy(t);
}
function Ly(e) {
  let t = e.trim();
  if (!Uc.test(t))
    return null;
  t.includes("(eval ") && (t = t.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));
  let n = t.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
  const o = n.match(/ (\(.+\)$)/);
  n = o ? n.replace(o[0], "") : n;
  const [r, s, i] = Kc(o ? o[1] : n);
  let a = o && n || "", c = r && ["eval", "<anonymous>"].includes(r) ? void 0 : r;
  return !c || !s || !i ? null : (a.startsWith("async ") && (a = a.slice(6)), c.startsWith("file://") && (c = c.slice(7)), c = Ny(c), a && (a = a.replace(/__vite_ssr_import_\d+__\./g, "")), {
    method: a,
    file: c,
    line: Number.parseInt(s),
    column: Number.parseInt(i)
  });
}
function Gc() {
  return typeof process < "u" && !!process.send;
}
const Ke = Date;
let no = null;
class vt extends Ke {
  constructor(t, n, o, r, s, i, a) {
    super();
    let c;
    switch (arguments.length) {
      case 0:
        no !== null ? c = new Ke(no.valueOf()) : c = new Ke();
        break;
      case 1:
        c = new Ke(t);
        break;
      default:
        o = typeof o > "u" ? 1 : o, r = r || 0, s = s || 0, i = i || 0, a = a || 0, c = new Ke(t, n, o, r, s, i, a);
        break;
    }
    return Object.setPrototypeOf(c, vt.prototype), c;
  }
}
vt.UTC = Ke.UTC;
vt.now = function() {
  return new vt().valueOf();
};
vt.parse = function(e) {
  return Ke.parse(e);
};
vt.toString = function() {
  return Ke.toString();
};
function qy(e) {
  const t = new Ke(e.valueOf());
  if (Number.isNaN(t.getTime()))
    throw new TypeError(`mockdate: The time set is an invalid date: ${e}`);
  globalThis.Date = vt, no = t.valueOf();
}
function zy() {
  globalThis.Date = Ke;
}
function Wy(e, t = !1) {
  const n = [
    // Vitest
    /\/vitest\/dist\//,
    /\/vite-node\/dist\//,
    // yarn's .store folder
    /vitest-virtual-\w+\/dist/,
    // cnpm
    /@vitest\/dist/,
    // don't clear mocks
    ...t ? [] : [/^mock:/]
  ];
  e.forEach((o, r) => {
    n.some((s) => s.test(r)) || e.invalidateModule(o);
  });
}
function Vy() {
  const { setTimeout: e } = Qn();
  return new Promise((t) => e(t, 0));
}
async function Jc() {
  await Vy();
  const e = yo(), t = [];
  let n = 0;
  for (const o of e.moduleCache.values())
    o.promise && !o.evaluated && t.push(o.promise), o.resolving && n++;
  !t.length && !n || (await Promise.allSettled(t), await Jc());
}
function Uy(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Yc = { exports: {} };
(function(e, t) {
  (function() {
    (function(n) {
      return typeof Uy == "function" ? e.exports = n : chai.use(n);
    })(function(n, o) {
      var r = n.Assertion, s = r.prototype;
      r.addMethod("containSubset", function(a) {
        var c = o.flag(this, "object"), l = n.config.showDiff;
        s.assert.call(
          this,
          i(a, c),
          "expected #{act} to contain subset #{exp}",
          "expected #{act} to not contain subset #{exp}",
          a,
          c,
          l
        );
      }), n.assert.containSubset = function(a, c, l) {
        new n.Assertion(a, l).to.be.containSubset(c);
      };
      function i(a, c) {
        if (a === c)
          return !0;
        if (typeof c != typeof a)
          return !1;
        if (typeof a != "object" || a === null)
          return a === c;
        if (a && !c)
          return !1;
        if (Array.isArray(a)) {
          if (typeof c.length != "number")
            return !1;
          var l = Array.prototype.slice.call(c);
          return a.every(function(f) {
            return l.some(function(u) {
              return i(f, u);
            });
          });
        }
        return a instanceof Date ? c instanceof Date ? a.getTime() === c.getTime() : !1 : Object.keys(a).every(function(f) {
          var u = a[f], p = c[f];
          return typeof u == "object" && u !== null && p !== null ? i(u, p) : typeof u == "function" ? u(p) : p === u;
        });
      }
    });
  }).call(bn);
})(Yc);
var Ky = Yc.exports, Gy = /* @__PURE__ */ ah(Ky);
const Ai = Symbol.for("matchers-object"), Jy = Symbol.for("$$jest-matchers-object"), Yy = Symbol.for("expect-global"), Hy = Symbol.for("asymmetric-matchers-object");
if (!Object.prototype.hasOwnProperty.call(globalThis, Ai)) {
  const e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ Object.create(null), n = [], o = /* @__PURE__ */ Object.create(null);
  Object.defineProperty(globalThis, Ai, {
    get: () => e
  }), Object.defineProperty(globalThis, Jy, {
    configurable: !0,
    get: () => ({
      state: e.get(globalThis[Yy]),
      matchers: t,
      customEqualityTesters: n
    })
  }), Object.defineProperty(globalThis, Hy, {
    get: () => o
  });
}
function Xy(e, t) {
  return e && t instanceof Promise && (t = t.finally(() => {
    const n = e.promises.indexOf(t);
    n !== -1 && e.promises.splice(n, 1);
  }), e.promises || (e.promises = []), e.promises.push(t)), t;
}
let Lr;
function sn() {
  return Lr || (Lr = new _y({
    isEqual: (e, t) => de(e, t, [Le, $n])
  })), Lr;
}
function _i(e, t) {
  if (typeof e != "function") {
    if (!t)
      throw new Error(`expected must be a function, received ${typeof e}`);
    return e;
  }
  try {
    e();
  } catch (n) {
    return n;
  }
  throw new Error("snapshot function didn't throw");
}
const Qy = (e, t) => {
  const n = (o) => {
    var r;
    return o ? {
      filepath: (r = o.file) == null ? void 0 : r.filepath,
      name: xa(o).slice(1).join(" > ")
    } : {};
  };
  for (const o of ["matchSnapshot", "toMatchSnapshot"])
    t.addMethod(
      e.Assertion.prototype,
      o,
      function(r, s) {
        const i = t.flag(this, "object"), a = t.flag(this, "vitest-test");
        typeof r == "string" && typeof s > "u" && (s = r, r = void 0);
        const c = t.flag(this, "message");
        sn().assert({
          received: i,
          message: s,
          isInline: !1,
          properties: r,
          errorMessage: c,
          ...n(a)
        });
      }
    );
  t.addMethod(
    e.Assertion.prototype,
    "toMatchFileSnapshot",
    function(o, r) {
      const s = t.flag(this, "object"), i = t.flag(this, "vitest-test"), a = t.flag(this, "message"), c = sn().assertRaw({
        received: s,
        message: r,
        isInline: !1,
        rawSnapshot: {
          file: o
        },
        errorMessage: a,
        ...n(i)
      });
      return Xy(i, c);
    }
  ), t.addMethod(
    e.Assertion.prototype,
    "toMatchInlineSnapshot",
    function(r, s, i) {
      var a;
      const c = t.flag(this, "vitest-test");
      if (c && (c.each || ((a = c.suite) == null ? void 0 : a.each)))
        throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
      const f = t.flag(this, "object"), u = t.flag(this, "error");
      typeof r == "string" && (i = s, s = r, r = void 0), s && (s = Si(s));
      const p = t.flag(this, "message");
      sn().assert({
        received: f,
        message: i,
        isInline: !0,
        properties: r,
        inlineSnapshot: s,
        error: u,
        errorMessage: p,
        ...n(c)
      });
    }
  ), t.addMethod(
    e.Assertion.prototype,
    "toThrowErrorMatchingSnapshot",
    function(o) {
      const r = t.flag(this, "object"), s = t.flag(this, "vitest-test"), i = t.flag(this, "promise"), a = t.flag(this, "message");
      sn().assert({
        received: _i(r, i),
        message: o,
        errorMessage: a,
        ...n(s)
      });
    }
  ), t.addMethod(
    e.Assertion.prototype,
    "toThrowErrorMatchingInlineSnapshot",
    function(r, s) {
      var i;
      const a = t.flag(this, "vitest-test");
      if (a && (a.each || ((i = a.suite) == null ? void 0 : i.each)))
        throw new Error("InlineSnapshot cannot be used inside of test.each or describe.each");
      const l = t.flag(this, "object"), f = t.flag(this, "error"), u = t.flag(this, "promise"), p = t.flag(this, "message");
      r && (r = Si(r)), sn().assert({
        received: _i(l, u),
        message: s,
        inlineSnapshot: r,
        isInline: !0,
        error: f,
        errorMessage: p,
        ...n(a)
      });
    }
  ), t.addMethod(
    e.expect,
    "addSnapshotSerializer",
    vd
  );
};
Sn(Ih);
Sn(_h);
Sn(Gy);
Sn(Qy);
Sn(Ah);
function Zy(e) {
  var t;
  const n = (i, a) => {
    const { assertionCalls: c } = qt(n);
    jr({ assertionCalls: c + 1, soft: !1 }, n);
    const l = Nr(i, a), f = e || Kf();
    return f ? l.withTest(f) : l;
  };
  Object.assign(n, Nr), Object.assign(n, globalThis[vo]), n.getState = () => qt(n), n.setState = (i) => jr(i, n);
  const o = qt(globalThis[xn]) || {};
  jr({
    // this should also add "snapshotState" that is added conditionally
    ...o,
    assertionCalls: 0,
    isExpectingAssertions: !1,
    isExpectingAssertionsError: null,
    expectedAssertionsNumber: null,
    expectedAssertionsNumberErrorGen: null,
    environment: tp(),
    testPath: e ? (t = e.suite.file) == null ? void 0 : t.filepath : o.testPath,
    currentTestName: e ? My(e) : o.currentTestName
  }, n), n.extend = (i) => Nr.extend(n, i), n.addEqualityTesters = (i) => yh(i), n.soft = (...i) => {
    const a = n(...i);
    return n.setState({
      soft: !0
    }), a;
  }, n.unreachable = (i) => {
    ih.fail(`expected${i ? ` "${i}" ` : " "}not to be reached`);
  };
  function r(i) {
    const a = () => new Error(`expected number of assertions to be ${i}, but got ${n.getState().assertionCalls}`);
    Error.captureStackTrace && Error.captureStackTrace(a(), r), n.setState({
      expectedAssertionsNumber: i,
      expectedAssertionsNumberErrorGen: a
    });
  }
  function s() {
    const i = new Error("expected any number of assertion, but got none");
    Error.captureStackTrace && Error.captureStackTrace(i, s), n.setState({
      isExpectingAssertions: !0,
      isExpectingAssertionsError: i
    });
  }
  return Kn.addMethod(n, "assertions", r), Kn.addMethod(n, "hasAssertions", s), n;
}
const xe = Zy();
Object.defineProperty(globalThis, xn, {
  value: xe,
  writable: !0,
  configurable: !0
});
var zn;
typeof bn < "u" ? zn = bn : typeof window < "u" ? zn = window : zn = self;
var eg = zn;
let ro;
try {
  ({}).__proto__, ro = !1;
} catch {
  ro = !0;
}
var tg = ro, ng = Function.call, rg = tg, Hc = [
  // ignore size because it throws from Map
  "size",
  "caller",
  "callee",
  "arguments"
];
rg && Hc.push("__proto__");
var Qt = function(t) {
  return Object.getOwnPropertyNames(t).reduce(
    function(n, o) {
      return Hc.includes(o) || typeof t[o] != "function" || (n[o] = ng.bind(t[o])), n;
    },
    /* @__PURE__ */ Object.create(null)
  );
}, og = Qt, ir = og(Array.prototype), sg = ir.every;
function ig(e, t) {
  return e[t.id] === void 0 && (e[t.id] = 0), e[t.id] < t.callCount;
}
function ag(e, t, n, o) {
  var r = !0;
  return n !== o.length - 1 && (r = t.calledBefore(o[n + 1])), ig(e, t) && r ? (e[t.id] += 1, !0) : !1;
}
function cg(e) {
  var t = {}, n = arguments.length > 1 ? arguments : e;
  return sg(n, ag.bind(null, t));
}
var ug = cg, Xc = function(t) {
  if (!t)
    return "";
  try {
    return t.displayName || t.name || // Use function decomposition as a last resort to get function
    // name. Does not rely on function decomposition to work - if it
    // doesn't debugging will be slightly less informative
    // (i.e. toString will say 'spy' rather than 'myFunc').
    (String(t).match(/function ([^\s(]+)/) || [])[1];
  } catch {
    return "";
  }
}, lg = Xc;
function fg(e) {
  return e.constructor && e.constructor.name || // The next branch is for IE11 support only:
  // Because the name property is not set on the prototype
  // of the Function object, we finally try to grab the
  // name from its definition. This will never be reached
  // in node, so we are not able to test this properly.
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
  typeof e.constructor == "function" && /* istanbul ignore next */
  lg(e.constructor) || null;
}
var pg = fg, Qc = {};
(function(e) {
  e.wrap = function(t, n) {
    var o = function() {
      return e.printWarning(n), t.apply(this, arguments);
    };
    return t.prototype && (o.prototype = t.prototype), o;
  }, e.defaultMsg = function(t, n) {
    return `${t}.${n} is deprecated and will be removed from the public API in a future version of ${t}.`;
  }, e.printWarning = function(t) {
    typeof process == "object" && process.emitWarning ? process.emitWarning(t) : console.info ? console.info(t) : console.log(t);
  };
})(Qc);
var hg = function(t, n) {
  var o = !0;
  try {
    t.forEach(function() {
      if (!n.apply(this, arguments))
        throw new Error();
    });
  } catch {
    o = !1;
  }
  return o;
}, mg = ir.sort, dg = ir.slice;
function yg(e, t) {
  var n = e.getCall(0), o = t.getCall(0), r = n && n.callId || -1, s = o && o.callId || -1;
  return r < s ? -1 : 1;
}
function gg(e) {
  return mg(dg(e), yg);
}
var bg = gg, wg = Qt, vg = wg(Function.prototype), Eg = Qt, Sg = Eg(Map.prototype), Tg = Qt, xg = Tg(Object.prototype), $g = Qt, Og = $g(Set.prototype), Ag = Qt, _g = Ag(String.prototype), Mg = {
  array: ir,
  function: vg,
  map: Sg,
  object: xg,
  set: Og,
  string: _g
}, Zc = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(bn, function() {
    var n = typeof Promise == "function", o = typeof self == "object" ? self : bn, r = typeof Symbol < "u", s = typeof Map < "u", i = typeof Set < "u", a = typeof WeakMap < "u", c = typeof WeakSet < "u", l = typeof DataView < "u", f = r && typeof Symbol.iterator < "u", u = r && typeof Symbol.toStringTag < "u", p = i && typeof Set.prototype.entries == "function", w = s && typeof Map.prototype.entries == "function", b = p && Object.getPrototypeOf((/* @__PURE__ */ new Set()).entries()), v = w && Object.getPrototypeOf((/* @__PURE__ */ new Map()).entries()), h = f && typeof Array.prototype[Symbol.iterator] == "function", A = h && Object.getPrototypeOf([][Symbol.iterator]()), M = f && typeof String.prototype[Symbol.iterator] == "function", F = M && Object.getPrototypeOf(""[Symbol.iterator]()), k = 8, N = -1;
    function U(B) {
      var G = typeof B;
      if (G !== "object")
        return G;
      if (B === null)
        return "null";
      if (B === o)
        return "global";
      if (Array.isArray(B) && (u === !1 || !(Symbol.toStringTag in B)))
        return "Array";
      if (typeof window == "object" && window !== null) {
        if (typeof window.location == "object" && B === window.location)
          return "Location";
        if (typeof window.document == "object" && B === window.document)
          return "Document";
        if (typeof window.navigator == "object") {
          if (typeof window.navigator.mimeTypes == "object" && B === window.navigator.mimeTypes)
            return "MimeTypeArray";
          if (typeof window.navigator.plugins == "object" && B === window.navigator.plugins)
            return "PluginArray";
        }
        if ((typeof window.HTMLElement == "function" || typeof window.HTMLElement == "object") && B instanceof window.HTMLElement) {
          if (B.tagName === "BLOCKQUOTE")
            return "HTMLQuoteElement";
          if (B.tagName === "TD")
            return "HTMLTableDataCellElement";
          if (B.tagName === "TH")
            return "HTMLTableHeaderCellElement";
        }
      }
      var ae = u && B[Symbol.toStringTag];
      if (typeof ae == "string")
        return ae;
      var V = Object.getPrototypeOf(B);
      return V === RegExp.prototype ? "RegExp" : V === Date.prototype ? "Date" : n && V === Promise.prototype ? "Promise" : i && V === Set.prototype ? "Set" : s && V === Map.prototype ? "Map" : c && V === WeakSet.prototype ? "WeakSet" : a && V === WeakMap.prototype ? "WeakMap" : l && V === DataView.prototype ? "DataView" : s && V === v ? "Map Iterator" : i && V === b ? "Set Iterator" : h && V === A ? "Array Iterator" : M && V === F ? "String Iterator" : V === null ? "Object" : Object.prototype.toString.call(B).slice(k, N);
    }
    return U;
  });
})(Zc);
var Pg = Zc.exports, Ig = Pg, Cg = function(t) {
  return Ig(t).toLowerCase();
};
function Ng(e) {
  return e && e.toString ? e.toString() : String(e);
}
var jg = Ng, kg = {
  global: eg,
  calledInOrder: ug,
  className: pg,
  deprecated: Qc,
  every: hg,
  functionName: Xc,
  orderByFirstCall: bg,
  prototypes: Mg,
  typeOf: Cg,
  valueToString: jg
};
const eu = kg.global;
let Ft;
if (typeof __vitest_required__ < "u")
  try {
    Ft = __vitest_required__.timers;
  } catch {
  }
function Mo(e) {
  const t = Math.pow(2, 31) - 1, n = 1e12, o = function() {
  }, r = function() {
    return [];
  }, s = e.setTimeout(o, 0), i = typeof s == "object", a = e.process && typeof e.process.hrtime == "function", c = a && typeof e.process.hrtime.bigint == "function", l = e.process && typeof e.process.nextTick == "function", f = e.process && e.__vitest_required__ && e.__vitest_required__.util.promisify, u = e.performance && typeof e.performance.now == "function", p = e.Performance && (typeof e.Performance).match(/^(function|object)$/), w = e.performance && e.performance.constructor && e.performance.constructor.prototype, b = e.hasOwnProperty("queueMicrotask"), v = e.requestAnimationFrame && typeof e.requestAnimationFrame == "function", h = e.cancelAnimationFrame && typeof e.cancelAnimationFrame == "function", A = e.requestIdleCallback && typeof e.requestIdleCallback == "function", M = e.cancelIdleCallback && typeof e.cancelIdleCallback == "function", F = e.setImmediate && typeof e.setImmediate == "function", k = e.Intl && typeof e.Intl == "object";
  e.clearTimeout(s);
  const N = e.Date, U = e.Intl;
  let B = n;
  function G(E) {
    return Number.isFinite ? Number.isFinite(E) : isFinite(E);
  }
  let ae = !1;
  function V(E, S) {
    E.loopLimit && S === E.loopLimit - 1 && (ae = !0);
  }
  function Ee() {
    ae = !1;
  }
  function be(E) {
    if (!E)
      return 0;
    const S = E.split(":"), C = S.length;
    let R = C, y = 0, X;
    if (C > 3 || !/^(\d\d:){0,2}\d\d?$/.test(E))
      throw new Error(
        "tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits"
      );
    for (; R--; ) {
      if (X = parseInt(S[R], 10), X >= 60)
        throw new Error(`Invalid time ${E}`);
      y += X * Math.pow(60, C - R - 1);
    }
    return y * 1e3;
  }
  function Se(E) {
    const C = E * 1e6 % 1e6, R = C < 0 ? C + 1e6 : C;
    return Math.floor(R);
  }
  function Me(E) {
    if (!E)
      return 0;
    if (typeof E.getTime == "function")
      return E.getTime();
    if (typeof E == "number")
      return E;
    throw new TypeError("now should be milliseconds since UNIX epoch");
  }
  function Fe(E, S, C) {
    return C && C.callAt >= E && C.callAt <= S;
  }
  function Pe(E, S) {
    const C = new Error(
      `Aborting after running ${E.loopLimit} timers, assuming an infinite loop!`
    );
    if (!S.error)
      return C;
    const R = /target\.*[<|(|[].*?[>|\]|)]\s*/;
    let y = new RegExp(
      String(Object.keys(E).join("|"))
    );
    i && (y = new RegExp(
      `\\s+at (Object\\.)?(?:${Object.keys(E).join("|")})\\s+`
    ));
    let X = -1;
    S.error.stack.split(`
`).some(function(ve, Be) {
      return ve.match(R) ? (X = Be, !0) : ve.match(y) ? (X = Be, !1) : X >= 0;
    });
    const we = `${C}
${S.type || "Microtask"} - ${S.func.name || "anonymous"}
${S.error.stack.split(`
`).slice(X + 1).join(`
`)}`;
    try {
      Object.defineProperty(C, "stack", {
        value: we
      });
    } catch {
    }
    return C;
  }
  function Ne(E, S) {
    let C;
    for (C in S)
      S.hasOwnProperty(C) && (E[C] = S[C]);
    return S.now ? E.now = function() {
      return E.clock.now;
    } : delete E.now, S.toSource ? E.toSource = function() {
      return S.toSource();
    } : delete E.toSource, E.toString = function() {
      return S.toString();
    }, E.prototype = S.prototype, E.parse = S.parse, E.UTC = S.UTC, E.prototype.toUTCString = S.prototype.toUTCString, E.isFake = !0, E;
  }
  function De() {
    function E(S, C, R, y, X, we, ve) {
      if (!(this instanceof E))
        return new N(E.clock.now).toString();
      switch (arguments.length) {
        case 0:
          return new N(E.clock.now);
        case 1:
          return new N(S);
        case 2:
          return new N(S, C);
        case 3:
          return new N(S, C, R);
        case 4:
          return new N(S, C, R, y);
        case 5:
          return new N(S, C, R, y, X);
        case 6:
          return new N(
            S,
            C,
            R,
            y,
            X,
            we
          );
        default:
          return new N(
            S,
            C,
            R,
            y,
            X,
            we,
            ve
          );
      }
    }
    return Ne(E, N);
  }
  function m() {
    const E = { ...U };
    return E.DateTimeFormat = function(...S) {
      const C = new U.DateTimeFormat(...S), R = {};
      return ["formatRange", "formatRangeToParts", "resolvedOptions"].forEach(
        (y) => {
          R[y] = C[y].bind(C);
        }
      ), ["format", "formatToParts"].forEach((y) => {
        R[y] = function(X) {
          return C[y](X || E.clock.now);
        };
      }), R;
    }, E.DateTimeFormat.prototype = Object.create(
      U.DateTimeFormat.prototype
    ), E.DateTimeFormat.supportedLocalesOf = U.DateTimeFormat.supportedLocalesOf, E;
  }
  function T(E, S) {
    E.jobs || (E.jobs = []), E.jobs.push(S);
  }
  function x(E) {
    if (E.jobs) {
      for (let S = 0; S < E.jobs.length; S++) {
        const C = E.jobs[S];
        if (C.func.apply(null, C.args), V(E, S), E.loopLimit && S > E.loopLimit)
          throw Pe(E, C);
      }
      Ee(), E.jobs = [];
    }
  }
  function P(E, S) {
    if (S.func === void 0)
      throw new Error("Callback must be provided to timer calls");
    if (i && typeof S.func != "function")
      throw new TypeError(
        `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${S.func} of type ${typeof S.func}`
      );
    if (ae && (S.error = new Error()), S.type = S.immediate ? "Immediate" : "Timeout", S.hasOwnProperty("delay") && (typeof S.delay != "number" && (S.delay = parseInt(S.delay, 10)), G(S.delay) || (S.delay = 0), S.delay = S.delay > t ? 1 : S.delay, S.delay = Math.max(0, S.delay)), S.hasOwnProperty("interval") && (S.type = "Interval", S.interval = S.interval > t ? 1 : S.interval), S.hasOwnProperty("animation") && (S.type = "AnimationFrame", S.animation = !0), S.hasOwnProperty("idleCallback") && (S.type = "IdleCallback", S.idleCallback = !0), E.timers || (E.timers = {}), S.id = B++, S.createdAt = E.now, S.callAt = E.now + (parseInt(S.delay) || (E.duringTick ? 1 : 0)), E.timers[S.id] = S, i) {
      const C = {
        refed: !0,
        ref: function() {
          return this.refed = !0, C;
        },
        unref: function() {
          return this.refed = !1, C;
        },
        hasRef: function() {
          return this.refed;
        },
        refresh: function() {
          return S.callAt = E.now + (parseInt(S.delay) || (E.duringTick ? 1 : 0)), E.timers[S.id] = S, C;
        },
        [Symbol.toPrimitive]: function() {
          return S.id;
        }
      };
      return C;
    }
    return S.id;
  }
  function j(E, S) {
    if (E.callAt < S.callAt)
      return -1;
    if (E.callAt > S.callAt)
      return 1;
    if (E.immediate && !S.immediate)
      return -1;
    if (!E.immediate && S.immediate)
      return 1;
    if (E.createdAt < S.createdAt)
      return -1;
    if (E.createdAt > S.createdAt)
      return 1;
    if (E.id < S.id)
      return -1;
    if (E.id > S.id)
      return 1;
  }
  function D(E, S, C) {
    const R = E.timers;
    let y = null, X, we;
    for (X in R)
      R.hasOwnProperty(X) && (we = Fe(S, C, R[X]), we && (!y || j(y, R[X]) === 1) && (y = R[X]));
    return y;
  }
  function I(E) {
    const S = E.timers;
    let C = null, R;
    for (R in S)
      S.hasOwnProperty(R) && (!C || j(C, S[R]) === 1) && (C = S[R]);
    return C;
  }
  function $(E) {
    const S = E.timers;
    let C = null, R;
    for (R in S)
      S.hasOwnProperty(R) && (!C || j(C, S[R]) === -1) && (C = S[R]);
    return C;
  }
  function q(E, S) {
    if (typeof S.interval == "number" ? E.timers[S.id].callAt += S.interval : delete E.timers[S.id], typeof S.func == "function")
      S.func.apply(null, S.args);
    else {
      const C = eval;
      (function() {
        C(S.func);
      })();
    }
  }
  function K(E) {
    return E === "IdleCallback" || E === "AnimationFrame" ? `cancel${E}` : `clear${E}`;
  }
  function J(E) {
    return E === "IdleCallback" || E === "AnimationFrame" ? `request${E}` : `set${E}`;
  }
  function ne() {
    let E = 0;
    return function(S) {
      !E++ && console.warn(S);
    };
  }
  const Z = ne();
  function H(E, S, C) {
    if (!S)
      return;
    E.timers || (E.timers = {});
    const R = Number(S);
    if (Number.isNaN(R) || R < n) {
      const y = K(C);
      if (E.shouldClearNativeTimers === !0) {
        const X = E[`_${y}`];
        return typeof X == "function" ? X(S) : void 0;
      }
      Z(
        `FakeTimers: ${y} was invoked to clear a native timer instead of one created by this library.
To automatically clean-up native timers, use \`shouldClearNativeTimers\`.`
      );
    }
    if (E.timers.hasOwnProperty(R)) {
      const y = E.timers[R];
      if (y.type === C || y.type === "Timeout" && C === "Interval" || y.type === "Interval" && C === "Timeout")
        delete E.timers[R];
      else {
        const X = K(C), we = J(y.type);
        throw new Error(
          `Cannot clear timer: timer created with ${we}() but cleared with ${X}()`
        );
      }
    }
  }
  function re(E, S) {
    let C, R, y;
    const X = "_hrtime", we = "_nextTick";
    for (R = 0, y = E.methods.length; R < y; R++) {
      if (C = E.methods[R], C === "hrtime" && e.process)
        e.process.hrtime = E[X];
      else if (C === "nextTick" && e.process)
        e.process.nextTick = E[we];
      else if (C === "performance") {
        const ve = Object.getOwnPropertyDescriptor(
          E,
          `_${C}`
        );
        ve && ve.get && !ve.set ? Object.defineProperty(
          e,
          C,
          ve
        ) : ve.configurable && (e[C] = E[`_${C}`]);
      } else if (e[C] && e[C].hadOwnProperty)
        e[C] = E[`_${C}`];
      else
        try {
          delete e[C];
        } catch {
        }
      if (E.timersModuleMethods !== void 0)
        for (let ve = 0; ve < E.timersModuleMethods.length; ve++) {
          const Be = E.timersModuleMethods[ve];
          Ft[Be.methodName] = Be.original;
        }
    }
    return S.shouldAdvanceTime === !0 && e.clearInterval(E.attachedInterval), E.methods = [], E.timers ? Object.keys(E.timers).map(function(Be) {
      return E.timers[Be];
    }) : [];
  }
  function O(E, S, C) {
    if (C[S].hadOwnProperty = Object.prototype.hasOwnProperty.call(
      E,
      S
    ), C[`_${S}`] = E[S], S === "Date") {
      const R = Ne(C[S], E[S]);
      E[S] = R;
    } else if (S === "Intl")
      E[S] = C[S];
    else if (S === "performance") {
      const R = Object.getOwnPropertyDescriptor(
        E,
        S
      );
      if (R && R.get && !R.set) {
        Object.defineProperty(
          C,
          `_${S}`,
          R
        );
        const y = Object.getOwnPropertyDescriptor(
          C,
          S
        );
        Object.defineProperty(E, S, y);
      } else
        E[S] = C[S];
    } else
      E[S] = function() {
        return C[S].apply(C, arguments);
      }, Object.defineProperties(
        E[S],
        Object.getOwnPropertyDescriptors(C[S])
      );
    E[S].clock = C;
  }
  function ce(E, S) {
    E.tick(S);
  }
  const oe = {
    setTimeout: e.setTimeout,
    clearTimeout: e.clearTimeout,
    setInterval: e.setInterval,
    clearInterval: e.clearInterval,
    Date: e.Date
  };
  F && (oe.setImmediate = e.setImmediate, oe.clearImmediate = e.clearImmediate), a && (oe.hrtime = e.process.hrtime), l && (oe.nextTick = e.process.nextTick), u && (oe.performance = e.performance), v && (oe.requestAnimationFrame = e.requestAnimationFrame), b && (oe.queueMicrotask = !0), h && (oe.cancelAnimationFrame = e.cancelAnimationFrame), A && (oe.requestIdleCallback = e.requestIdleCallback), M && (oe.cancelIdleCallback = e.cancelIdleCallback), k && (oe.Intl = e.Intl);
  const ye = e.setImmediate || e.setTimeout;
  function qe(E, S) {
    E = Math.floor(Me(E)), S = S || 1e3;
    let C = 0;
    const R = [0, 0];
    if (N === void 0)
      throw new Error(
        "The global scope doesn't have a `Date` object (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)"
      );
    const y = {
      now: E,
      Date: De(),
      loopLimit: S
    };
    y.Date.clock = y;
    function X() {
      return 16 - (y.now - E) % 16;
    }
    function we(Y) {
      const W = y.now - R[0] - E, Q = Math.floor(W / 1e3), te = (W - Q * 1e3) * 1e6 + C - R[1];
      if (Array.isArray(Y)) {
        if (Y[1] > 1e9)
          throw new TypeError(
            "Number of nanoseconds can't exceed a billion"
          );
        const ge = Y[0];
        let $e = te - Y[1], nt = Q - ge;
        return $e < 0 && ($e += 1e9, nt -= 1), [nt, $e];
      }
      return [Q, te];
    }
    function ve() {
      const Y = we();
      return Y[0] * 1e3 + Y[1] / 1e6;
    }
    c && (we.bigint = function() {
      const Y = we();
      return BigInt(Y[0]) * BigInt(1e9) + BigInt(Y[1]);
    }), k && (y.Intl = m(), y.Intl.clock = y), y.requestIdleCallback = function(W, Q) {
      let te = 0;
      y.countTimers() > 0 && (te = 50);
      const ge = P(y, {
        func: W,
        args: Array.prototype.slice.call(arguments, 2),
        delay: typeof Q > "u" ? te : Math.min(Q, te),
        idleCallback: !0
      });
      return Number(ge);
    }, y.cancelIdleCallback = function(W) {
      return H(y, W, "IdleCallback");
    }, y.setTimeout = function(W, Q) {
      return P(y, {
        func: W,
        args: Array.prototype.slice.call(arguments, 2),
        delay: Q
      });
    }, typeof e.Promise < "u" && f && (y.setTimeout[f.custom] = function(W, Q) {
      return new e.Promise(function(ge) {
        P(y, {
          func: ge,
          args: [Q],
          delay: W
        });
      });
    }), y.clearTimeout = function(W) {
      return H(y, W, "Timeout");
    }, y.nextTick = function(W) {
      return T(y, {
        func: W,
        args: Array.prototype.slice.call(arguments, 1),
        error: ae ? new Error() : null
      });
    }, y.queueMicrotask = function(W) {
      return y.nextTick(W);
    }, y.setInterval = function(W, Q) {
      return Q = parseInt(Q, 10), P(y, {
        func: W,
        args: Array.prototype.slice.call(arguments, 2),
        delay: Q,
        interval: Q
      });
    }, y.clearInterval = function(W) {
      return H(y, W, "Interval");
    }, F && (y.setImmediate = function(W) {
      return P(y, {
        func: W,
        args: Array.prototype.slice.call(arguments, 1),
        immediate: !0
      });
    }, typeof e.Promise < "u" && f && (y.setImmediate[f.custom] = function(W) {
      return new e.Promise(
        function(te) {
          P(y, {
            func: te,
            args: [W],
            immediate: !0
          });
        }
      );
    }), y.clearImmediate = function(W) {
      return H(y, W, "Immediate");
    }), y.countTimers = function() {
      return Object.keys(y.timers || {}).length + (y.jobs || []).length;
    }, y.requestAnimationFrame = function(W) {
      const Q = P(y, {
        func: W,
        delay: X(),
        get args() {
          return [ve()];
        },
        animation: !0
      });
      return Number(Q);
    }, y.cancelAnimationFrame = function(W) {
      return H(y, W, "AnimationFrame");
    }, y.runMicrotasks = function() {
      x(y);
    };
    function Be(Y, W, Q, te) {
      const ge = typeof Y == "number" ? Y : be(Y), $e = Math.floor(ge), nt = Se(ge);
      let Ct = C + nt, ze = y.now + $e;
      if (ge < 0)
        throw new TypeError("Negative ticks are not supported");
      Ct >= 1e6 && (ze += 1, Ct -= 1e6), C = Ct;
      let d = y.now, g = y.now, _, L, z, ee, ie, me;
      y.duringTick = !0, z = y.now, x(y), z !== y.now && (d += y.now - z, ze += y.now - z);
      function Ie() {
        for (_ = D(y, d, ze); _ && d <= ze; ) {
          if (y.timers[_.id]) {
            d = _.callAt, y.now = _.callAt, z = y.now;
            try {
              x(y), q(y, _);
            } catch (Te) {
              L = L || Te;
            }
            if (W) {
              ye(ee);
              return;
            }
            ie();
          }
          me();
        }
        if (z = y.now, x(y), z !== y.now && (d += y.now - z, ze += y.now - z), y.duringTick = !1, _ = D(y, d, ze), _)
          try {
            y.tick(ze - y.now);
          } catch (Te) {
            L = L || Te;
          }
        else
          y.now = ze, C = Ct;
        if (L)
          throw L;
        if (W)
          Q(y.now);
        else
          return y.now;
      }
      return ee = W && function() {
        try {
          ie(), me(), Ie();
        } catch (Te) {
          te(Te);
        }
      }, ie = function() {
        z !== y.now && (d += y.now - z, ze += y.now - z, g += y.now - z);
      }, me = function() {
        _ = D(y, g, ze), g = d;
      }, Ie();
    }
    return y.tick = function(W) {
      return Be(W, !1);
    }, typeof e.Promise < "u" && (y.tickAsync = function(W) {
      return new e.Promise(function(Q, te) {
        ye(function() {
          try {
            Be(W, !0, Q, te);
          } catch (ge) {
            te(ge);
          }
        });
      });
    }), y.next = function() {
      x(y);
      const W = I(y);
      if (!W)
        return y.now;
      y.duringTick = !0;
      try {
        return y.now = W.callAt, q(y, W), x(y), y.now;
      } finally {
        y.duringTick = !1;
      }
    }, typeof e.Promise < "u" && (y.nextAsync = function() {
      return new e.Promise(function(W, Q) {
        ye(function() {
          try {
            const te = I(y);
            if (!te) {
              W(y.now);
              return;
            }
            let ge;
            y.duringTick = !0, y.now = te.callAt;
            try {
              q(y, te);
            } catch ($e) {
              ge = $e;
            }
            y.duringTick = !1, ye(function() {
              ge ? Q(ge) : W(y.now);
            });
          } catch (te) {
            Q(te);
          }
        });
      });
    }), y.runAll = function() {
      let W, Q;
      for (x(y), Q = 0; Q < y.loopLimit; Q++) {
        if (!y.timers || (W = Object.keys(y.timers).length, W === 0))
          return Ee(), y.now;
        y.next(), V(y, Q);
      }
      const te = I(y);
      throw Pe(y, te);
    }, y.runToFrame = function() {
      return y.tick(X());
    }, typeof e.Promise < "u" && (y.runAllAsync = function() {
      return new e.Promise(function(W, Q) {
        let te = 0;
        function ge() {
          ye(function() {
            try {
              let $e;
              if (te < y.loopLimit) {
                if (!y.timers) {
                  Ee(), W(y.now);
                  return;
                }
                if ($e = Object.keys(
                  y.timers
                ).length, $e === 0) {
                  Ee(), W(y.now);
                  return;
                }
                y.next(), te++, ge(), V(y, te);
                return;
              }
              const nt = I(y);
              Q(Pe(y, nt));
            } catch ($e) {
              Q($e);
            }
          });
        }
        ge();
      });
    }), y.runToLast = function() {
      const W = $(y);
      return W ? y.tick(W.callAt - y.now) : (x(y), y.now);
    }, typeof e.Promise < "u" && (y.runToLastAsync = function() {
      return new e.Promise(function(W, Q) {
        ye(function() {
          try {
            const te = $(y);
            te || W(y.now), W(y.tickAsync(te.callAt - y.now));
          } catch (te) {
            Q(te);
          }
        });
      });
    }), y.reset = function() {
      C = 0, y.timers = {}, y.jobs = [], y.now = E;
    }, y.setSystemTime = function(W) {
      const Q = Me(W), te = Q - y.now;
      let ge, $e;
      R[0] = R[0] + te, R[1] = R[1] + C, y.now = Q, C = 0;
      for (ge in y.timers)
        y.timers.hasOwnProperty(ge) && ($e = y.timers[ge], $e.createdAt += te, $e.callAt += te);
    }, y.jump = function(W) {
      const Q = typeof W == "number" ? W : be(W), te = Math.floor(Q);
      for (const ge of Object.values(y.timers))
        y.now + te > ge.callAt && (ge.callAt = y.now + te);
      y.tick(te);
    }, u && (y.performance = /* @__PURE__ */ Object.create(null), y.performance.now = ve), a && (y.hrtime = we), y;
  }
  function ar(E) {
    if (arguments.length > 1 || E instanceof Date || Array.isArray(E) || typeof E == "number")
      throw new TypeError(
        `FakeTimers.install called with ${String(
          E
        )} install requires an object parameter`
      );
    if (e.Date.isFake === !0)
      throw new TypeError(
        "Can't install fake timers twice on the same global object."
      );
    if (E = typeof E < "u" ? E : {}, E.shouldAdvanceTime = E.shouldAdvanceTime || !1, E.advanceTimeDelta = E.advanceTimeDelta || 20, E.shouldClearNativeTimers = E.shouldClearNativeTimers || !1, E.target)
      throw new TypeError(
        "config.target is no longer supported. Use `withGlobal(target)` instead."
      );
    let S, C;
    const R = qe(E.now, E.loopLimit);
    if (R.shouldClearNativeTimers = E.shouldClearNativeTimers, R.uninstall = function() {
      return re(R, E);
    }, R.methods = E.toFake || [], R.methods.length === 0 && (R.methods = Object.keys(oe).filter(function(y) {
      return y !== "nextTick" && y !== "queueMicrotask";
    })), E.shouldAdvanceTime === !0) {
      const y = ce.bind(
        null,
        R,
        E.advanceTimeDelta
      ), X = e.setInterval(
        y,
        E.advanceTimeDelta
      );
      R.attachedInterval = X;
    }
    if (R.methods.includes("performance")) {
      const y = (() => {
        if (w)
          return e.performance.constructor.prototype;
        if (p)
          return e.Performance.prototype;
      })();
      if (y)
        Object.getOwnPropertyNames(y).forEach(function(X) {
          X !== "now" && (R.performance[X] = X.indexOf("getEntries") === 0 ? r : o);
        });
      else if ((E.toFake || []).includes("performance"))
        throw new ReferenceError(
          "non-existent performance object cannot be faked"
        );
    }
    for (e === eu && Ft && (R.timersModuleMethods = []), S = 0, C = R.methods.length; S < C; S++) {
      const y = R.methods[S];
      if (y === "hrtime" ? e.process && typeof e.process.hrtime == "function" && O(e.process, y, R) : y === "nextTick" ? e.process && typeof e.process.nextTick == "function" && O(e.process, y, R) : O(e, y, R), R.timersModuleMethods !== void 0 && Ft[y]) {
        const X = Ft[y];
        R.timersModuleMethods.push({
          methodName: y,
          original: X
        }), Ft[y] = e[y];
      }
    }
    return R;
  }
  return {
    timers: oe,
    createClock: qe,
    install: ar,
    withGlobal: Mo
  };
}
const Po = Mo(eu);
Po.timers;
Po.createClock;
Po.install;
var Rg = Mo;
class Fg {
  constructor({
    global: t,
    config: n
  }) {
    se(this, "_global");
    se(this, "_clock");
    se(this, "_fakingTime");
    se(this, "_fakingDate");
    se(this, "_fakeTimers");
    se(this, "_userConfig");
    se(this, "_now", Ke.now);
    this._userConfig = n, this._fakingDate = !1, this._fakingTime = !1, this._fakeTimers = Rg(t), this._global = t;
  }
  clearAllTimers() {
    this._fakingTime && this._clock.reset();
  }
  dispose() {
    this.useRealTimers();
  }
  runAllTimers() {
    this._checkFakeTimers() && this._clock.runAll();
  }
  async runAllTimersAsync() {
    this._checkFakeTimers() && await this._clock.runAllAsync();
  }
  runOnlyPendingTimers() {
    this._checkFakeTimers() && this._clock.runToLast();
  }
  async runOnlyPendingTimersAsync() {
    this._checkFakeTimers() && await this._clock.runToLastAsync();
  }
  advanceTimersToNextTimer(t = 1) {
    if (this._checkFakeTimers())
      for (let n = t; n > 0 && (this._clock.next(), this._clock.tick(0), this._clock.countTimers() !== 0); n--)
        ;
  }
  async advanceTimersToNextTimerAsync(t = 1) {
    if (this._checkFakeTimers())
      for (let n = t; n > 0 && (await this._clock.nextAsync(), this._clock.tick(0), this._clock.countTimers() !== 0); n--)
        ;
  }
  advanceTimersByTime(t) {
    this._checkFakeTimers() && this._clock.tick(t);
  }
  async advanceTimersByTimeAsync(t) {
    this._checkFakeTimers() && await this._clock.tickAsync(t);
  }
  runAllTicks() {
    this._checkFakeTimers() && this._clock.runMicrotasks();
  }
  useRealTimers() {
    this._fakingDate && (zy(), this._fakingDate = !1), this._fakingTime && (this._clock.uninstall(), this._fakingTime = !1);
  }
  useFakeTimers() {
    var t, n, o;
    if (this._fakingDate)
      throw new Error(
        '"setSystemTime" was called already and date was mocked. Reset timers using `vi.useRealTimers()` if you want to use fake timers again.'
      );
    if (!this._fakingTime) {
      const r = Object.keys(this._fakeTimers.timers).filter((i) => i !== "nextTick");
      if ((n = (t = this._userConfig) == null ? void 0 : t.toFake) != null && n.includes("nextTick") && Gc())
        throw new Error("process.nextTick cannot be mocked inside child_process");
      const s = (((o = this._userConfig) == null ? void 0 : o.toFake) || r).filter((i) => {
        switch (i) {
          case "setImmediate":
          case "clearImmediate":
            return i in this._global && this._global[i];
          default:
            return !0;
        }
      });
      this._clock = this._fakeTimers.install({
        now: Date.now(),
        ...this._userConfig,
        toFake: s
      }), this._fakingTime = !0;
    }
  }
  reset() {
    if (this._checkFakeTimers()) {
      const { now: t } = this._clock;
      this._clock.reset(), this._clock.setSystemTime(t);
    }
  }
  setSystemTime(t) {
    this._fakingTime ? this._clock.setSystemTime(t) : (qy(t ?? this.getRealSystemTime()), this._fakingDate = !0);
  }
  getRealSystemTime() {
    return this._now();
  }
  getTimerCount() {
    return this._checkFakeTimers() ? this._clock.countTimers() : 0;
  }
  configure(t) {
    this._userConfig = t;
  }
  isFakeTimers() {
    return this._fakingTime;
  }
  _checkFakeTimers() {
    if (!this._fakingTime)
      throw new Error(
        'Timers are not mocked. Try calling "vi.useFakeTimers()" first.'
      );
    return this._fakingTime;
  }
}
function tu(e, t) {
  return t.stack !== void 0 && (e.stack = t.stack.replace(t.message, e.message)), e;
}
function Dg(e, t = {}) {
  const { setTimeout: n, setInterval: o, clearTimeout: r, clearInterval: s } = Qn(), { interval: i = 50, timeout: a = 1e3 } = typeof t == "number" ? { timeout: t } : t, c = new Error("STACK_TRACE_ERROR");
  return new Promise((l, f) => {
    let u, p = "idle", w, b;
    const v = (M) => {
      w && r(w), b && s(b), l(M);
    }, h = () => {
      let M = u;
      M || (M = tu(new Error("Timed out in waitFor!"), c)), f(M);
    }, A = () => {
      if (Yn.isFakeTimers() && Yn.advanceTimersByTime(i), p !== "pending")
        try {
          const M = e();
          if (M !== null && typeof M == "object" && typeof M.then == "function") {
            const F = M;
            p = "pending", F.then(
              (k) => {
                p = "resolved", v(k);
              },
              (k) => {
                p = "rejected", u = k;
              }
            );
          } else
            return v(M), !0;
        } catch (M) {
          u = M;
        }
    };
    A() !== !0 && (w = n(h, a), b = o(A, i));
  });
}
function Bg(e, t = {}) {
  const { setTimeout: n, setInterval: o, clearTimeout: r, clearInterval: s } = Qn(), { interval: i = 50, timeout: a = 1e3 } = typeof t == "number" ? { timeout: t } : t, c = new Error("STACK_TRACE_ERROR");
  return new Promise((l, f) => {
    let u = "idle", p, w;
    const b = (A) => {
      A || (A = tu(new Error("Timed out in waitUntil!"), c)), f(A);
    }, v = (A) => {
      if (A)
        return p && r(p), w && s(w), l(A), !0;
    }, h = () => {
      if (Yn.isFakeTimers() && Yn.advanceTimersByTime(i), u !== "pending")
        try {
          const A = e();
          if (A !== null && typeof A == "object" && typeof A.then == "function") {
            const M = A;
            u = "pending", M.then(
              (F) => {
                u = "resolved", v(F);
              },
              (F) => {
                u = "rejected", b(F);
              }
            );
          } else
            return v(A);
        } catch (A) {
          b(A);
        }
    };
    h() !== !0 && (p = n(b, a), w = o(h, i));
  });
}
function Lg() {
  const e = typeof __vitest_mocker__ < "u" ? __vitest_mocker__ : new Proxy({}, {
    get(l, f) {
      throw new Error(
        `Vitest mocker was not initialized in this environment. vi.${String(f)}() is forbidden.`
      );
    }
  });
  let t = null, n = null;
  const o = yo(), r = new Fg({
    global: globalThis,
    config: o.config.fakeTimers
  }), s = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = () => {
    const f = Ql({ stackTraceLimit: 4 }).split(`
`)[4], u = By(f);
    return (u == null ? void 0 : u.file) || "";
  }, c = {
    useFakeTimers(l) {
      var f, u, p, w;
      if (Gc() && ((f = l == null ? void 0 : l.toFake) != null && f.includes("nextTick") || (w = (p = (u = o.config) == null ? void 0 : u.fakeTimers) == null ? void 0 : p.toFake) != null && w.includes("nextTick")))
        throw new Error(
          'vi.useFakeTimers({ toFake: ["nextTick"] }) is not supported in node:child_process. Use --pool=threads if mocking nextTick is required.'
        );
      return l ? r.configure({ ...o.config.fakeTimers, ...l }) : r.configure(o.config.fakeTimers), r.useFakeTimers(), c;
    },
    isFakeTimers() {
      return r.isFakeTimers();
    },
    useRealTimers() {
      return r.useRealTimers(), t = null, c;
    },
    runOnlyPendingTimers() {
      return r.runOnlyPendingTimers(), c;
    },
    async runOnlyPendingTimersAsync() {
      return await r.runOnlyPendingTimersAsync(), c;
    },
    runAllTimers() {
      return r.runAllTimers(), c;
    },
    async runAllTimersAsync() {
      return await r.runAllTimersAsync(), c;
    },
    runAllTicks() {
      return r.runAllTicks(), c;
    },
    advanceTimersByTime(l) {
      return r.advanceTimersByTime(l), c;
    },
    async advanceTimersByTimeAsync(l) {
      return await r.advanceTimersByTimeAsync(l), c;
    },
    advanceTimersToNextTimer() {
      return r.advanceTimersToNextTimer(), c;
    },
    async advanceTimersToNextTimerAsync() {
      return await r.advanceTimersToNextTimerAsync(), c;
    },
    getTimerCount() {
      return r.getTimerCount();
    },
    setSystemTime(l) {
      const f = l instanceof Date ? l : new Date(l);
      return t = f, r.setSystemTime(f), c;
    },
    getMockedSystemTime() {
      return t;
    },
    getRealSystemTime() {
      return r.getRealSystemTime();
    },
    clearAllTimers() {
      return r.clearAllTimers(), c;
    },
    // mocks
    spyOn: hh,
    fn: dh,
    waitFor: Dg,
    waitUntil: Bg,
    hoisted(l) {
      return He(l, '"vi.hoisted" factory', ["function"]), l();
    },
    mock(l, f) {
      const u = a();
      e.queueMock(
        l,
        u,
        f ? () => f(() => e.importActual(l, u, e.getMockContext().callstack)) : void 0,
        !0
      );
    },
    unmock(l) {
      e.queueUnmock(l, a());
    },
    doMock(l, f) {
      const u = a();
      e.queueMock(
        l,
        u,
        f ? () => f(() => e.importActual(l, u, e.getMockContext().callstack)) : void 0,
        !1
      );
    },
    doUnmock(l) {
      e.queueUnmock(l, a());
    },
    async importActual(l) {
      return e.importActual(
        l,
        a(),
        e.getMockContext().callstack
      );
    },
    async importMock(l) {
      return e.importMock(l, a());
    },
    // this is typed in the interface so it's not necessary to type it here
    mocked(l, f = {}) {
      return l;
    },
    isMockFunction(l) {
      return Ka(l);
    },
    clearAllMocks() {
      return Ln.forEach((l) => l.mockClear()), c;
    },
    resetAllMocks() {
      return Ln.forEach((l) => l.mockReset()), c;
    },
    restoreAllMocks() {
      return Ln.forEach((l) => l.mockRestore()), c;
    },
    stubGlobal(l, f) {
      return s.has(l) || s.set(l, Object.getOwnPropertyDescriptor(globalThis, l)), Object.defineProperty(globalThis, l, {
        value: f,
        writable: !0,
        configurable: !0,
        enumerable: !0
      }), c;
    },
    stubEnv(l, f) {
      return i.has(l) || i.set(l, process.env[l]), process.env[l] = f, c;
    },
    unstubAllGlobals() {
      return s.forEach((l, f) => {
        l ? Object.defineProperty(globalThis, f, l) : Reflect.deleteProperty(globalThis, f);
      }), s.clear(), c;
    },
    unstubAllEnvs() {
      return i.forEach((l, f) => {
        l === void 0 ? delete process.env[f] : process.env[f] = l;
      }), i.clear(), c;
    },
    resetModules() {
      return Wy(o.moduleCache), c;
    },
    async dynamicImportSettled() {
      return Jc();
    },
    setConfig(l) {
      n || (n = { ...o.config }), Object.assign(o.config, l);
    },
    resetConfig() {
      n && Object.assign(o.config, n);
    }
  };
  return c;
}
const qg = Lg(), Yn = qg, Jt = {
  "@context": "http://www.w3.org/ns/anno.jsonld",
  type: "Annotation",
  body: [{ type: "TextualBody", value: "first", purpose: "commenting" }],
  target: {
    source: "http://example.com/1",
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=pixel:10,20,30,40"
    }
  },
  id: "123abc"
}, Ae = (e, t) => ({
  type: "Annotation",
  body: { type: "TextualBody", value: "first", format: "text/plain" },
  motivation: "commenting",
  target: {
    type: "SpecificResource",
    source: {
      id: t,
      type: "Canvas",
      partOf: [
        {
          id: e,
          type: "Manifest"
        }
      ]
    },
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=10,20,30,40"
    }
  },
  id: "123abc"
}), Hn = {
  "@context": "http://www.w3.org/ns/anno.jsonld",
  type: "Annotation",
  body: [{ type: "TextualBody", value: "second", purpose: "commenting" }],
  target: {
    source: "http://example.com/2",
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=pixel:15,25,35,45"
    }
  },
  id: "456def"
}, Ge = (e, t) => ({
  type: "Annotation",
  body: { type: "TextualBody", value: "second", format: "text/plain" },
  motivation: "commenting",
  target: {
    type: "SpecificResource",
    source: {
      id: t,
      type: "Canvas",
      partOf: [
        {
          id: e,
          type: "Manifest"
        }
      ]
    },
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=15,25,35,45"
    }
  },
  id: "456def"
}), Io = {
  "@context": "http://www.w3.org/ns/anno.jsonld",
  type: "Annotation",
  body: [
    { type: "TextualBody", value: "second b", purpose: "commenting" },
    { type: "TextualBody", value: "second c", purpose: "commenting" }
  ],
  target: {
    source: "http://example.com/1",
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=pixel:10,20,30,40"
    }
  },
  id: "123abc"
}, Yt = (e, t) => ({
  type: "Annotation",
  body: [
    { type: "TextualBody", value: "second b", format: "text/plain" },
    { type: "TextualBody", value: "second c", format: "text/plain" }
  ],
  motivation: "commenting",
  target: {
    type: "SpecificResource",
    source: {
      id: t,
      type: "Canvas",
      partOf: [
        {
          id: e,
          type: "Manifest"
        }
      ]
    },
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=10,20,30,40"
    }
  },
  id: "123abc"
}), zg = {
  "@context": "http://www.w3.org/ns/anno.jsonld",
  type: "Annotation",
  body: [],
  target: {
    source: "http://example.com/canvas/1",
    selector: {
      type: "FragmentSelector",
      conformsTo: "http://www.w3.org/TR/media-frags/",
      value: "xywh=pixel:10,20,30,40"
    }
  },
  id: "123abc"
}, nu = (e, t) => ({
  type: "Annotation",
  motivation: "commenting",
  target: {
    selector: {
      conformsTo: "http://www.w3.org/TR/media-frags/",
      type: "FragmentSelector",
      value: "xywh=10,20,30,40"
    },
    source: {
      id: t,
      partOf: [
        {
          id: e,
          type: "Manifest"
        }
      ],
      type: "Canvas"
    },
    type: "SpecificResource"
  },
  id: "123abc"
}), Ce = "pixel";
Ht("saveAnnotation with guest user", () => {
  mo(() => {
    localStorage.clear();
  }), _e("saves annotation when there are no saved annotation", () => {
    const e = "canvas1", t = "manifest";
    On(Jt, t, e, Ce);
    const n = localStorage.getItem("annotations"), o = JSON.stringify({
      [e]: {
        "@context": "http://iiif.io/api/presentation/3/context.json",
        id: e,
        items: [Ae(t, e)],
        type: "AnnotationPage"
      }
    });
    xe(n).toStrictEqual(o);
  }), _e("saves annotation when there are saved annotation", () => {
    const e = "canvas1", t = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          "@context": "http://iiif.io/api/presentation/3/context.json",
          id: e,
          items: [Ae(t, e)],
          type: "AnnotationPage"
        }
      })
    ), On(Hn, t, e, Ce);
    const n = localStorage.getItem("annotations"), o = JSON.stringify({
      [e]: {
        "@context": "http://iiif.io/api/presentation/3/context.json",
        id: e,
        items: [Ae(t, e), Ge(t, e)],
        type: "AnnotationPage"
      }
    });
    xe(n).toStrictEqual(o);
  }), _e("saves annotation when there are saved annotation with multiple canvas", () => {
    const e = "canvas1", t = "canvas2", n = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          "@context": "http://iiif.io/api/presentation/3/context.json",
          id: e,
          items: [Ae(n, e)],
          type: "AnnotationPage"
        }
      })
    ), On(Hn, n, t, Ce);
    const o = localStorage.getItem("annotations"), r = JSON.stringify({
      [e]: {
        "@context": "http://iiif.io/api/presentation/3/context.json",
        id: e,
        items: [Ae(n, e)],
        type: "AnnotationPage"
      },
      [t]: {
        "@context": "http://iiif.io/api/presentation/3/context.json",
        id: t,
        items: [Ge(n, t)],
        type: "AnnotationPage"
      }
    });
    xe(o).toStrictEqual(r);
  }), _e("saves annotation with multiple bodies", () => {
    const e = "canvas1", t = "manifest";
    On(Io, t, e, Ce);
    const n = localStorage.getItem("annotations"), o = JSON.stringify({
      [e]: {
        "@context": "http://iiif.io/api/presentation/3/context.json",
        id: e,
        items: [Yt(t, e)],
        type: "AnnotationPage"
      }
    });
    xe(n).toStrictEqual(o);
  });
});
Ht("deleteAnnotation with guest user", () => {
  mo(() => {
    localStorage.clear();
  }), _e("deletes annotation when there is one annotation", () => {
    const e = "canvas1", t = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(t, e)],
          type: "AnnotationPage"
        }
      })
    ), An(Jt, t, e, Ce);
    const n = localStorage.getItem("annotations"), o = JSON.stringify({
      [e]: { id: e, items: [], type: "AnnotationPage" }
    });
    xe(n).toStrictEqual(o);
  }), _e("deletes annotation when there are multiple annotations", () => {
    const e = "canvas1", t = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(t, e), Ge(t, e)],
          type: "AnnotationPage"
        }
      })
    ), An(Jt, t, e, Ce);
    const n = localStorage.getItem("annotations"), o = JSON.stringify({
      [e]: {
        id: e,
        items: [Ge(t, e)],
        type: "AnnotationPage"
      }
    });
    xe(n).toStrictEqual(o);
  }), _e("deletes annotation when multiple canvases", () => {
    const e = "canvas1", t = "canvas2", n = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(n, e)],
          type: "AnnotationPage"
        },
        [t]: {
          id: t,
          items: [Ge(n, t)],
          type: "AnnotationPage"
        }
      })
    ), An(Hn, n, t, Ce);
    const o = localStorage.getItem("annotations"), r = JSON.stringify({
      [e]: {
        id: e,
        items: [Ae(n, e)],
        type: "AnnotationPage"
      },
      [t]: {
        id: t,
        items: [],
        type: "AnnotationPage"
      }
    });
    xe(o).toStrictEqual(r);
  }), _e("does nothing if canvas for annotation does not match saved annotations", () => {
    const e = "canvas1", t = "canvas2", n = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(n, e)],
          type: "AnnotationPage"
        },
        [t]: {
          id: t,
          items: [Ge(n, t)],
          type: "AnnotationPage"
        }
      })
    ), An(Hn, n, e, Ce);
    const o = localStorage.getItem("annotations"), r = JSON.stringify({
      [e]: {
        id: e,
        items: [Ae(n, e)],
        type: "AnnotationPage"
      },
      [t]: {
        id: t,
        items: [Ge(n, t)],
        type: "AnnotationPage"
      }
    });
    xe(o).toStrictEqual(r);
  });
});
Ht("updateAnnotation with guest user", () => {
  mo(() => {
    localStorage.clear();
  }), _e("updates annotation when there is one annotation", () => {
    const e = "canvas1", t = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(t, e)],
          type: "AnnotationPage"
        }
      })
    ), _n({
      "@context": "http://www.w3.org/ns/anno.jsonld",
      type: "Annotation",
      body: [{ type: "TextualBody", value: "updated", purpose: "commenting" }],
      target: {
        source: "http://example.com/1",
        selector: {
          type: "FragmentSelector",
          conformsTo: "http://www.w3.org/TR/media-frags/",
          value: "xywh=100,200,300,400"
        }
      },
      id: "123abc"
    }, t, e, Ce);
    const o = localStorage.getItem("annotations"), r = JSON.stringify({
      [e]: {
        id: e,
        items: [
          {
            type: "Annotation",
            body: {
              type: "TextualBody",
              value: "updated",
              format: "text/plain"
            },
            motivation: "commenting",
            target: {
              type: "SpecificResource",
              source: {
                id: e,
                type: "Canvas",
                partOf: [
                  {
                    id: t,
                    type: "Manifest"
                  }
                ]
              },
              selector: {
                type: "FragmentSelector",
                conformsTo: "http://www.w3.org/TR/media-frags/",
                value: "xywh=100,200,300,400"
              }
            },
            id: "123abc"
          }
        ],
        type: "AnnotationPage"
      }
    });
    xe(o).toStrictEqual(r);
  }), _e("updates annotation when there are multiple annotations", () => {
    const e = "canvas1", t = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(t, e), Ge(t, e)],
          type: "AnnotationPage"
        }
      })
    );
    const n = {
      ...Jt,
      body: [{ type: "TextualBody", value: "updated", purpose: "commenting" }]
    };
    _n(n, t, e, Ce);
    const o = localStorage.getItem("annotations"), r = JSON.stringify({
      [e]: {
        id: e,
        items: [
          {
            ...Ae(t, e),
            body: {
              type: "TextualBody",
              value: "updated",
              format: "text/plain"
            }
          },
          Ge(t, e)
        ],
        type: "AnnotationPage"
      }
    });
    xe(o).toStrictEqual(r);
  }), _e("does nothing if canvas for annotation does not match saved annotations", () => {
    const e = "canvas1", t = "canvas2", n = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(n, e)],
          type: "AnnotationPage"
        },
        [t]: {
          id: t,
          items: [Ge(n, t)],
          type: "AnnotationPage"
        }
      })
    );
    const o = {
      ...Jt,
      body: [{ type: "TextualBody", value: "updated", purpose: "commenting" }]
    };
    _n(o, n, t, Ce);
    const r = localStorage.getItem("annotations"), s = JSON.stringify({
      [e]: {
        id: e,
        items: [Ae(n, e)],
        type: "AnnotationPage"
      },
      [t]: {
        id: t,
        items: [Ge(n, t)],
        type: "AnnotationPage"
      }
    });
    xe(r).toStrictEqual(s);
  }), _e("update annotation when there are multiple bodies", () => {
    const e = "canvas1", t = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [e]: {
          id: e,
          items: [Ae(t, e)],
          type: "AnnotationPage"
        }
      })
    ), _n(Io, t, e, Ce);
    const n = localStorage.getItem("annotations"), o = JSON.stringify({
      [e]: {
        id: e,
        items: [Yt(t, e)],
        type: "AnnotationPage"
      }
    });
    xe(n).toStrictEqual(o);
  });
});
Ht("fetchAnnotations with guest user", () => {
  const e = "http://example.com";
  _e("returns empty array if no saved annotations", async () => {
    const n = await lr(void 0, e), o = [];
    xe(n).toStrictEqual(o);
  }), _e("returns all annotations", async () => {
    const n = "canvas1", o = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [n]: {
          id: n,
          items: [Ae(o, n)],
          type: "AnnotationPage"
        }
      })
    );
    const r = await lr(void 0, e), s = [Ae(o, n)];
    xe(r).toStrictEqual(s);
  }), _e("returns annotations with multiple bodies", async () => {
    const n = "canvas1", o = "manifest";
    localStorage.setItem(
      "annotations",
      JSON.stringify({
        [n]: {
          id: n,
          items: [Yt(o, n)],
          type: "AnnotationPage"
        }
      })
    );
    const r = await lr(void 0, e), s = [Yt(o, n)];
    xe(r).toStrictEqual(s);
  });
});
Ht("convertWebAnnotationToIIIFAnnotation", () => {
  _e("converts web annoatation to IIIF annotation", () => {
    const e = "canvas1", t = "manifest", n = fr(
      Jt,
      t,
      e,
      Ce
    );
    xe(n).toStrictEqual(Ae(t, e));
  }), _e("handles web annotation with multiple bodies", () => {
    const e = Io, t = "canvas1", n = "manifest", o = fr(
      e,
      n,
      t,
      Ce
    );
    xe(o).toStrictEqual(Yt(n, t));
  }), _e("handles web annotation with empty body", () => {
    const e = zg, t = "canvas1", n = "manifest", o = fr(
      e,
      n,
      t,
      Ce
    );
    xe(o).toStrictEqual(nu(n, t));
  });
});
Ht("convertIIIFAnnotationToWebAnnotation", () => {
  _e("converts annotation to format compatible with Annotorious", () => {
    const e = "canvas1", t = "manifest", n = Ae(t, e), o = pr(n, Ce), r = {
      "@context": "http://www.w3.org/ns/anno.jsonld",
      type: "Annotation",
      body: [{ type: "TextualBody", value: "first", purpose: "commenting" }],
      target: {
        source: {
          id: e,
          type: "Canvas",
          partOf: [
            {
              id: t,
              type: "Manifest"
            }
          ]
        },
        selector: {
          type: "FragmentSelector",
          conformsTo: "http://www.w3.org/TR/media-frags/",
          value: "xywh=pixel:10,20,30,40"
        }
      },
      id: "123abc"
    };
    xe(o).toStrictEqual(r);
  }), _e("handles annotation with multiple bodies", () => {
    const e = "canvas1", t = "manifest", n = Yt(t, e), o = pr(n, Ce), r = {
      "@context": "http://www.w3.org/ns/anno.jsonld",
      type: "Annotation",
      body: [
        { type: "TextualBody", value: "second b", purpose: "commenting" },
        { type: "TextualBody", value: "second c", purpose: "commenting" }
      ],
      target: {
        source: {
          id: e,
          type: "Canvas",
          partOf: [
            {
              id: t,
              type: "Manifest"
            }
          ]
        },
        selector: {
          type: "FragmentSelector",
          conformsTo: "http://www.w3.org/TR/media-frags/",
          value: "xywh=pixel:10,20,30,40"
        }
      },
      id: "123abc"
    };
    xe(o).toStrictEqual(r);
  }), _e("handles annotation with no body", () => {
    const e = "canvas1", t = "manifest", n = nu(t, e), o = pr(n, Ce), r = {
      "@context": "http://www.w3.org/ns/anno.jsonld",
      type: "Annotation",
      body: [],
      target: {
        source: {
          id: e,
          type: "Canvas",
          partOf: [
            {
              id: t,
              type: "Manifest"
            }
          ]
        },
        selector: {
          type: "FragmentSelector",
          conformsTo: "http://www.w3.org/TR/media-frags/",
          value: "xywh=pixel:10,20,30,40"
        }
      },
      id: "123abc"
    };
    xe(o).toStrictEqual(r);
  });
});
