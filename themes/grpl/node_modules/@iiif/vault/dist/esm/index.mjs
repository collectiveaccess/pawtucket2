import { normalize, serialize, serializeConfigPresentation2, serializeConfigPresentation3 } from '@iiif/parser';
import { createAction } from 'typesafe-actions';
import { combineReducers, createStore as createStore$1, applyMiddleware, compose } from 'redux';

const IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
const MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
const REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
const ADD_REFERENCE = "@iiif/ADD_REFERENCE";
const REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
const importEntities = createAction(IMPORT_ENTITIES)();
const modifyEntityField = createAction(MODIFY_ENTITY_FIELD)();
const reorderEntityField = createAction(REORDER_ENTITY_FIELD)();
const addReference = createAction(ADD_REFERENCE)();
const removeReference = createAction(REMOVE_REFERENCE)();
const entityActions = { importEntities, modifyEntityField, reorderEntityField, addReference, removeReference };

const ADD_MAPPING = "@iiif/ADD_MAPPING";
const ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
const addMapping = createAction(ADD_MAPPING)();
const addMappings = createAction(ADD_MAPPINGS)();

const SET_META_VALUE = "@iiif/SET_META_VALUE";
const SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
const UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
const setMetaValue = createAction(SET_META_VALUE)();
const setMetaValueDynamic = createAction(SET_META_VALUE_DYNAMIC)();
const unsetMetaValue = createAction(UNSET_META_VALUE)();
const metaActions = {
  setMetaValue,
  setMetaValueDynamic,
  unsetMetaValue
};

const RESOURCE_ERROR = "RESOURCE_ERROR";
const RESOURCE_LOADING = "RESOURCE_LOADING";
const RESOURCE_READY = "RESOURCE_READY";
const REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
const REQUEST_ERROR = "@iiif/REQUEST_ERROR";
const REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
const REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
const REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
const requestResource = createAction(REQUEST_RESOURCE)();
const requestError = createAction(REQUEST_ERROR)();
const requestMismatch = createAction(REQUEST_MISMATCH)();
const requestComplete = createAction(REQUEST_COMPLETE)();
createAction(REQUEST_OFFLINE_RESOURCE)();

const BATCH_ACTIONS = "@iiif/BATCH";
const BATCH_IMPORT = "@iiif/BATCH_IMPORT";
const batchActions = createAction(BATCH_ACTIONS)();
createAction(BATCH_IMPORT)();

const actionListFromResource = (id, response) => {
  const { entities, resource, mapping } = normalize(response);
  if (resource.id === void 0) {
    return [requestError({ id, message: "ID is not defined in resource." })];
  }
  const actions = [importEntities({ entities }), addMappings({ mapping })];
  if (resource.id !== id) {
    actions.push(addMapping({ id, type: resource.type }));
    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
  }
  actions.push(requestComplete({ id }));
  return actions;
};

const safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
    return newInputs === lastInputs;
  }
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}

function resolveIfExists(state, url) {
  const request = state.iiif.requests[url];
  const resourceType = state.iiif.mapping[url];
  if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
    return void 0;
  }
  return state.iiif.entities[resourceType][request.resourceUri];
}

function createFetchHelper(store, fetcher, { waitTimeout = 30 } = {}) {
  return async (url, options) => {
    const state = store.getState();
    const request = state.iiif.requests[url];
    if (request) {
      switch (request.loadingState) {
        case RESOURCE_ERROR:
          break;
        case RESOURCE_LOADING: {
          let cleanupSubscription;
          let didContinue = false;
          try {
            const resolvedEntity = await Promise.race([
              new Promise((resolve, reject) => {
                if (didContinue) {
                  return;
                }
                cleanupSubscription = store.subscribe(() => {
                  const latestState = store.getState();
                  if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                    reject();
                    return;
                  }
                  if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                    const maybeResolvedEntity = resolveIfExists(latestState, url);
                    if (maybeResolvedEntity) {
                      resolve(maybeResolvedEntity);
                    } else {
                      reject();
                    }
                  }
                });
              }),
              new Promise((resolve, reject) => setTimeout(() => {
                didContinue = true;
                reject();
              }, waitTimeout * 60))
            ]);
            if (cleanupSubscription) {
              cleanupSubscription();
            }
            if (resolvedEntity) {
              return resolvedEntity;
            }
          } catch (e) {
            if (cleanupSubscription) {
              cleanupSubscription();
            }
            break;
          }
          break;
        }
        case RESOURCE_READY: {
          const resolvedEntity = resolveIfExists(state, url);
          if (resolvedEntity) {
            return resolvedEntity;
          }
          break;
        }
      }
    }
    store.dispatch(requestResource({ id: url }));
    try {
      const resource = await fetcher(url, options);
      if (!resource.id && !resource["@id"]) {
        if (resource["@type"]) {
          resource["@id"] = url;
          resource.id = url;
        } else {
          resource.id = url;
        }
      }
      const toDispatch = actionListFromResource(url, resource);
      store.dispatch(batchActions({ actions: toDispatch }));
      return resolveIfExists(store.getState(), url);
    } catch (err) {
      store.dispatch(requestError({ id: url, message: err.toString() }));
      throw err;
    }
  };
}

function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

const mappingReducer = (state = {}, action) => {
  switch (action.type) {
    case ADD_MAPPING:
      return {
        ...state,
        [action.payload.id]: action.payload.type
      };
    case ADD_MAPPINGS:
      return {
        ...state,
        ...action.payload.mapping
      };
    default:
      return state;
  }
};

function isReferenceList(state, id, type, key) {
  return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
}

function quickMerge(a, b) {
  const newResource = {};
  const added = [];
  for (const [key, value] of Object.entries(a || {})) {
    added.push(key);
    const bValue = (b || {})[key];
    if (!bValue || bValue.length === 0) {
      newResource[key] = value;
      continue;
    }
    newResource[key] = bValue;
  }
  for (const [key, value] of Object.entries(b || {})) {
    if (added.indexOf(key) !== -1) {
      continue;
    }
    newResource[key] = value;
  }
  return newResource;
}

const entitiesReducer = (state = getDefaultEntities(), action) => {
  switch (action.type) {
    case MODIFY_ENTITY_FIELD: {
      if (!state[action.payload.type] || !state[action.payload.type][action.payload.id]) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      if (typeof entity === "string") {
        return state;
      }
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: action.payload.value
          }
        }
      };
    }
    case REORDER_ENTITY_FIELD: {
      if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      if (typeof entity === "string") {
        return state;
      }
      const result = Array.from(entity[action.payload.key]);
      const [removed] = result.splice(action.payload.startIndex, 1);
      result.splice(action.payload.endIndex, 0, removed);
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: result
          }
        }
      };
    }
    case IMPORT_ENTITIES: {
      const keys = Object.keys(action.payload.entities);
      const toReturn = { ...state };
      for (const key of keys) {
        const entities = action.payload.entities[key];
        const newEntities = { ...state[key] || {} };
        let changed = false;
        const ids = Object.keys(entities || {}) || [];
        if (entities && ids) {
          for (const id of ids) {
            changed = true;
            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
          }
          if (changed) {
            toReturn[key] = newEntities;
          }
        }
      }
      return toReturn;
    }
    case ADD_REFERENCE: {
      if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      const result = Array.from(entity[action.payload.key]);
      result.splice(action.payload.index || result.length + 1, 0, action.payload.reference);
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: result
          }
        }
      };
    }
    case REMOVE_REFERENCE: {
      if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      const result = Array.from(entity[action.payload.key]);
      const indexToRemove = action.payload.index || result.findIndex((e) => e && e.id === action.payload.reference.id);
      if (indexToRemove === -1) {
        return state;
      }
      if (result[indexToRemove]?.id !== action.payload.reference.id) {
        return state;
      }
      result.splice(indexToRemove, 1);
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: result
          }
        }
      };
    }
    default:
      return state;
  }
};

const requestReducer = (state = {}, action) => {
  switch (action.type) {
    case REQUEST_RESOURCE:
    case REQUEST_OFFLINE_RESOURCE:
      return {
        ...state,
        [action.payload.id]: {
          requestUri: action.payload.id,
          loadingState: RESOURCE_LOADING,
          uriMismatch: false,
          resourceUri: action.payload.id
        }
      };
    case REQUEST_MISMATCH:
      return {
        ...state,
        [action.payload.requestId]: {
          ...state[action.payload.requestId] || {},
          uriMismatch: true,
          resourceUri: action.payload.actualId
        },
        [action.payload.actualId]: {
          requestUri: action.payload.requestId,
          loadingState: state[action.payload.requestId].loadingState,
          uriMismatch: true,
          resourceUri: action.payload.actualId
        }
      };
    case REQUEST_ERROR:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_ERROR,
          error: action.payload.message
        }
      };
    case REQUEST_COMPLETE:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_READY,
          error: void 0
        }
      };
  }
  return state;
};

const metaReducer = (state = {}, action) => {
  const { id, updateValue, value, meta, key } = action && action.payload || {};
  switch (action.type) {
    case SET_META_VALUE: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: value
          }
        }
      };
    }
    case SET_META_VALUE_DYNAMIC: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
          }
        }
      };
    }
    case UNSET_META_VALUE: {
      if (state[id] && state[id][meta] && state[id][meta][key]) {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: void 0
            }
          }
        };
      }
      return state;
    }
    default:
      return state;
  }
};

function createBatchReducer(rootReducer) {
  return (state, action) => {
    if (action && action.type === BATCH_ACTIONS) {
      return action.payload.actions.reduce(rootReducer, state);
    }
    if (action && action.type === BATCH_IMPORT) {
      return action.payload.state;
    }
    return rootReducer(state, action);
  };
}

const reducers = combineReducers({
  mapping: mappingReducer,
  entities: entitiesReducer,
  requests: requestReducer,
  meta: metaReducer
});
const composeEnhancers = typeof window !== "undefined" ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose : compose;
function createStore(options = {}) {
  const {
    enableDevtools = true,
    iiifStoreName = "iiif",
    defaultState = {},
    extraMiddleware = [],
    customReducers = {}
  } = options;
  const rootReducer = combineReducers({ [iiifStoreName]: reducers, ...customReducers });
  const store = createStore$1(createBatchReducer(rootReducer), defaultState, enableDevtools ? composeEnhancers(applyMiddleware(...extraMiddleware)) : compose(applyMiddleware(...extraMiddleware)));
  return store;
}

function mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]));},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e);}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e);});}}}

class Vault {
  options;
  store;
  emitter;
  isBatching = false;
  batchQueue = [];
  remoteFetcher;
  staticFetcher;
  constructor(options, store) {
    this.options = Object.assign({
      reducers: {},
      middleware: [],
      defaultState: {},
      customFetcher: this.defaultFetcher,
      enableDevtools: true
    }, options || {});
    this.store = store || createStore({
      customReducers: this.options.reducers,
      extraMiddleware: [...this.options.middleware, this.middleware],
      defaultState: this.options.defaultState,
      enableDevtools: this.options.enableDevtools
    });
    this.emitter = mitt();
    this.remoteFetcher = createFetchHelper(this.store, this.options.customFetcher);
    this.staticFetcher = createFetchHelper(this.store, (id, json) => json);
  }
  defaultFetcher = (url) => {
    return fetch(url).then((r) => r.json());
  };
  batch(cb) {
    this.isBatching = true;
    try {
      cb(this);
      this.store.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
    this.isBatching = false;
  }
  async asyncBatch(cb) {
    this.isBatching = true;
    try {
      await cb(this);
      this.store.dispatch(batchActions({ actions: this.batchQueue }));
    } catch (e) {
      this.batchQueue = [];
      this.isBatching = false;
      throw e;
    }
    this.batchQueue = [];
    this.isBatching = false;
  }
  modifyEntityField(entity, key, value) {
    this.dispatch(entityActions.modifyEntityField({
      id: entity.id,
      type: entity.type,
      key,
      value
    }));
  }
  dispatch(action) {
    if (!this.isBatching) {
      this.store.dispatch(action);
    } else {
      this.batchQueue.push(action);
    }
  }
  middleware = (store) => (next) => (action) => {
    if (action.type === BATCH_ACTIONS) {
      for (const realAction of action.payload.actions) {
        this.emitter.emit(realAction.type, { realAction, state: store.getState() });
      }
      const state2 = next(action);
      for (const realAction of action.payload.actions) {
        this.emitter.emit(`after:${action.type}`, { action, state: state2 });
      }
      return state2;
    }
    this.emitter.emit(action.type, { action, state: store.getState() });
    const state = next(action);
    this.emitter.emit(`after:${action.type}`, { action, state });
    return state;
  };
  serialize(entity, config) {
    return serialize(this.getState().iiif, entity, config);
  }
  toPresentation2(entity) {
    return this.serialize(entity, serializeConfigPresentation2);
  }
  toPresentation3(entity) {
    return this.serialize(entity, serializeConfigPresentation3);
  }
  hydrate(reference, type) {
    return this.get(reference, type, { skipSelfReturn: false });
  }
  get(reference, type, options = {}) {
    if (typeof type !== "string") {
      options = type || {};
      type = void 0;
    }
    const { skipSelfReturn = true } = options || {};
    if (Array.isArray(reference)) {
      return reference.map((i) => this.get(i, options));
    }
    const state = this.getState();
    if (typeof reference === "string") {
      const _type2 = type ? type : state.iiif.mapping[reference];
      if (!_type2) {
        if (skipSelfReturn) {
          return null;
        }
        return { id: reference, type: "unknown" };
      }
      reference = { id: reference, type: _type2 };
    }
    const _type = type ? type : reference.type;
    const _id = reference.id;
    const entities = state.iiif.entities[_type];
    if (!entities) {
      const request = state.iiif.requests[_id];
      if (request && request.resourceUri !== _id) {
        return this.get(request.resourceUri, options);
      }
      if (skipSelfReturn) {
        return null;
      }
      return reference;
    }
    return entities[reference.id] || (skipSelfReturn ? null : reference);
  }
  select(selector) {
    return selector(this.getState());
  }
  getStore() {
    return this.store;
  }
  getState() {
    return this.store.getState();
  }
  loadManifest(id, json) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json);
  }
  loadCollection(id, json) {
    const _id = typeof id === "string" ? id : id.id;
    return this.load(_id, json);
  }
  load(id, json) {
    const _id = typeof id === "string" ? id : id.id;
    if (json) {
      return this.staticFetcher(_id, json);
    }
    return this.remoteFetcher(_id);
  }
  areInputsEqual(newInputs, lastInputs) {
    return areInputsEqual(newInputs, lastInputs);
  }
  subscribe(selector, subscription, skipInitial) {
    if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
      skipInitial = subscription;
      subscription = selector;
      selector = (a) => a;
    }
    let lastState = skipInitial ? null : selector(this.store.getState());
    if (!skipInitial) {
      subscription(lastState, this);
    }
    return this.store.subscribe(() => {
      const state = this.store.getState();
      const selectedState = selector(state);
      if (lastState !== selectedState && !areInputsEqual(lastState, selectedState)) {
        subscription(selectedState, this);
      }
      lastState = selectedState;
    });
  }
  async ensureLoaded(_id) {
    const id = typeof _id === "string" ? _id : _id.id;
    if (!this.requestStatus(id)) {
      await this.load(id);
    }
  }
  requestStatus(id) {
    return this.select((state) => {
      return state.iiif.requests[id];
    });
  }
  getResourceMeta(resource, metaKey) {
    const resourceMeta = this.getState().iiif.meta[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
  setMetaValue([id, meta, key], newValueOrUpdate) {
    this.dispatch(typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
      id,
      meta,
      key,
      updateValue: newValueOrUpdate
    }) : metaActions.setMetaValue({
      id,
      meta,
      key,
      value: newValueOrUpdate
    }));
  }
}

function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  return {};
}

function globalVault(options) {
  const g = getGlobal();
  try {
    const gv = g["IIIF_VAULT"];
    if (gv) {
      return gv;
    }
  } catch (e) {
  }
  const newVault = new Vault(options);
  try {
    g["IIIF_VAULT"] = newVault;
  } catch (e) {
  }
  return newVault;
}

export { Vault, globalVault };
