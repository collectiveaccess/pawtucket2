'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var redux = require('redux');
var typesafeActions = require('typesafe-actions');
require('@iiif/parser');

const IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
const MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
const REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
const ADD_REFERENCE = "@iiif/ADD_REFERENCE";
const REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
typesafeActions.createAction(IMPORT_ENTITIES)();
typesafeActions.createAction(MODIFY_ENTITY_FIELD)();
typesafeActions.createAction(REORDER_ENTITY_FIELD)();
typesafeActions.createAction(ADD_REFERENCE)();
typesafeActions.createAction(REMOVE_REFERENCE)();

const ADD_MAPPING = "@iiif/ADD_MAPPING";
const ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
typesafeActions.createAction(ADD_MAPPING)();
typesafeActions.createAction(ADD_MAPPINGS)();

const SET_META_VALUE = "@iiif/SET_META_VALUE";
const SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
const UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
typesafeActions.createAction(SET_META_VALUE)();
typesafeActions.createAction(SET_META_VALUE_DYNAMIC)();
typesafeActions.createAction(UNSET_META_VALUE)();

const RESOURCE_ERROR = "RESOURCE_ERROR";
const RESOURCE_LOADING = "RESOURCE_LOADING";
const RESOURCE_READY = "RESOURCE_READY";
const REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
const REQUEST_ERROR = "@iiif/REQUEST_ERROR";
const REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
const REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
const REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
typesafeActions.createAction(REQUEST_RESOURCE)();
typesafeActions.createAction(REQUEST_ERROR)();
typesafeActions.createAction(REQUEST_MISMATCH)();
typesafeActions.createAction(REQUEST_COMPLETE)();
typesafeActions.createAction(REQUEST_OFFLINE_RESOURCE)();

const BATCH_ACTIONS = "@iiif/BATCH";
const BATCH_IMPORT = "@iiif/BATCH_IMPORT";
typesafeActions.createAction(BATCH_ACTIONS)();
typesafeActions.createAction(BATCH_IMPORT)();

const mappingReducer = (state = {}, action) => {
  switch (action.type) {
    case ADD_MAPPING:
      return {
        ...state,
        [action.payload.id]: action.payload.type
      };
    case ADD_MAPPINGS:
      return {
        ...state,
        ...action.payload.mapping
      };
    default:
      return state;
  }
};

function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

function isReferenceList(state, id, type, key) {
  return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
}

function quickMerge(a, b) {
  const newResource = {};
  const added = [];
  for (const [key, value] of Object.entries(a || {})) {
    added.push(key);
    const bValue = (b || {})[key];
    if (!bValue || bValue.length === 0) {
      newResource[key] = value;
      continue;
    }
    newResource[key] = bValue;
  }
  for (const [key, value] of Object.entries(b || {})) {
    if (added.indexOf(key) !== -1) {
      continue;
    }
    newResource[key] = value;
  }
  return newResource;
}

const entitiesReducer = (state = getDefaultEntities(), action) => {
  switch (action.type) {
    case MODIFY_ENTITY_FIELD: {
      if (!state[action.payload.type] || !state[action.payload.type][action.payload.id]) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      if (typeof entity === "string") {
        return state;
      }
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: action.payload.value
          }
        }
      };
    }
    case REORDER_ENTITY_FIELD: {
      if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      if (typeof entity === "string") {
        return state;
      }
      const result = Array.from(entity[action.payload.key]);
      const [removed] = result.splice(action.payload.startIndex, 1);
      result.splice(action.payload.endIndex, 0, removed);
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: result
          }
        }
      };
    }
    case IMPORT_ENTITIES: {
      const keys = Object.keys(action.payload.entities);
      const toReturn = { ...state };
      for (const key of keys) {
        const entities = action.payload.entities[key];
        const newEntities = { ...state[key] || {} };
        let changed = false;
        const ids = Object.keys(entities || {}) || [];
        if (entities && ids) {
          for (const id of ids) {
            changed = true;
            newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
          }
          if (changed) {
            toReturn[key] = newEntities;
          }
        }
      }
      return toReturn;
    }
    case ADD_REFERENCE: {
      if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      const result = Array.from(entity[action.payload.key]);
      result.splice(action.payload.index || result.length + 1, 0, action.payload.reference);
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: result
          }
        }
      };
    }
    case REMOVE_REFERENCE: {
      if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
        return state;
      }
      const entity = state[action.payload.type][action.payload.id];
      const result = Array.from(entity[action.payload.key]);
      const indexToRemove = action.payload.index || result.findIndex((e) => e && e.id === action.payload.reference.id);
      if (indexToRemove === -1) {
        return state;
      }
      if (result[indexToRemove]?.id !== action.payload.reference.id) {
        return state;
      }
      result.splice(indexToRemove, 1);
      return {
        ...state,
        [action.payload.type]: {
          ...state[action.payload.type],
          [action.payload.id]: {
            ...entity,
            [action.payload.key]: result
          }
        }
      };
    }
    default:
      return state;
  }
};

const requestReducer = (state = {}, action) => {
  switch (action.type) {
    case REQUEST_RESOURCE:
    case REQUEST_OFFLINE_RESOURCE:
      return {
        ...state,
        [action.payload.id]: {
          requestUri: action.payload.id,
          loadingState: RESOURCE_LOADING,
          uriMismatch: false,
          resourceUri: action.payload.id
        }
      };
    case REQUEST_MISMATCH:
      return {
        ...state,
        [action.payload.requestId]: {
          ...state[action.payload.requestId] || {},
          uriMismatch: true,
          resourceUri: action.payload.actualId
        },
        [action.payload.actualId]: {
          requestUri: action.payload.requestId,
          loadingState: state[action.payload.requestId].loadingState,
          uriMismatch: true,
          resourceUri: action.payload.actualId
        }
      };
    case REQUEST_ERROR:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_ERROR,
          error: action.payload.message
        }
      };
    case REQUEST_COMPLETE:
      return {
        ...state,
        [action.payload.id]: {
          ...state[action.payload.id] || {},
          loadingState: RESOURCE_READY,
          error: void 0
        }
      };
  }
  return state;
};

const metaReducer = (state = {}, action) => {
  const { id, updateValue, value, meta, key } = action && action.payload || {};
  switch (action.type) {
    case SET_META_VALUE: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: value
          }
        }
      };
    }
    case SET_META_VALUE_DYNAMIC: {
      return {
        ...state,
        [id]: {
          ...state[id] || {},
          [meta]: {
            ...state[id] ? state[id][meta] || {} : {},
            [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
          }
        }
      };
    }
    case UNSET_META_VALUE: {
      if (state[id] && state[id][meta] && state[id][meta][key]) {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: void 0
            }
          }
        };
      }
      return state;
    }
    default:
      return state;
  }
};

function createBatchReducer(rootReducer) {
  return (state, action) => {
    if (action && action.type === BATCH_ACTIONS) {
      return action.payload.actions.reduce(rootReducer, state);
    }
    if (action && action.type === BATCH_IMPORT) {
      return action.payload.state;
    }
    return rootReducer(state, action);
  };
}

const reducers = redux.combineReducers({
  mapping: mappingReducer,
  entities: entitiesReducer,
  requests: requestReducer,
  meta: metaReducer
});
const composeEnhancers = typeof window !== "undefined" ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || redux.compose : redux.compose;
function createStore(options = {}) {
  const {
    enableDevtools = true,
    iiifStoreName = "iiif",
    defaultState = {},
    extraMiddleware = [],
    customReducers = {}
  } = options;
  const rootReducer = redux.combineReducers({ [iiifStoreName]: reducers, ...customReducers });
  const store = redux.createStore(createBatchReducer(rootReducer), defaultState, enableDevtools ? composeEnhancers(redux.applyMiddleware(...extraMiddleware)) : redux.compose(redux.applyMiddleware(...extraMiddleware)));
  return store;
}

exports.createStore = createStore;
exports.reducers = reducers;
