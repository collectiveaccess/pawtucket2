'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parser = require('@iiif/parser');
var typesafeActions = require('typesafe-actions');

const IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
const MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
const REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
const ADD_REFERENCE = "@iiif/ADD_REFERENCE";
const REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
const importEntities = typesafeActions.createAction(IMPORT_ENTITIES)();
typesafeActions.createAction(MODIFY_ENTITY_FIELD)();
typesafeActions.createAction(REORDER_ENTITY_FIELD)();
typesafeActions.createAction(ADD_REFERENCE)();
typesafeActions.createAction(REMOVE_REFERENCE)();

const ADD_MAPPING = "@iiif/ADD_MAPPING";
const ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
const addMapping = typesafeActions.createAction(ADD_MAPPING)();
const addMappings = typesafeActions.createAction(ADD_MAPPINGS)();

const SET_META_VALUE = "@iiif/SET_META_VALUE";
const SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
const UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
typesafeActions.createAction(SET_META_VALUE)();
typesafeActions.createAction(SET_META_VALUE_DYNAMIC)();
typesafeActions.createAction(UNSET_META_VALUE)();

const RESOURCE_ERROR = "RESOURCE_ERROR";
const RESOURCE_LOADING = "RESOURCE_LOADING";
const RESOURCE_READY = "RESOURCE_READY";
const REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
const REQUEST_ERROR = "@iiif/REQUEST_ERROR";
const REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
const REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
const REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
const requestResource = typesafeActions.createAction(REQUEST_RESOURCE)();
const requestError = typesafeActions.createAction(REQUEST_ERROR)();
const requestMismatch = typesafeActions.createAction(REQUEST_MISMATCH)();
const requestComplete = typesafeActions.createAction(REQUEST_COMPLETE)();
typesafeActions.createAction(REQUEST_OFFLINE_RESOURCE)();

const BATCH_ACTIONS = "@iiif/BATCH";
const BATCH_IMPORT = "@iiif/BATCH_IMPORT";
const batchActions = typesafeActions.createAction(BATCH_ACTIONS)();
typesafeActions.createAction(BATCH_IMPORT)();

const actionListFromResource = (id, response) => {
  const { entities, resource, mapping } = parser.normalize(response);
  if (resource.id === void 0) {
    return [requestError({ id, message: "ID is not defined in resource." })];
  }
  const actions = [importEntities({ entities }), addMappings({ mapping })];
  if (resource.id !== id) {
    actions.push(addMapping({ id, type: resource.type }));
    actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
  }
  actions.push(requestComplete({ id }));
  return actions;
};

const safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
    return newInputs === lastInputs;
  }
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (let i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}

function resolveIfExists(state, url) {
  const request = state.iiif.requests[url];
  const resourceType = state.iiif.mapping[url];
  if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
    return void 0;
  }
  return state.iiif.entities[resourceType][request.resourceUri];
}

function createFetchHelper(store, fetcher, { waitTimeout = 30 } = {}) {
  return async (url, options) => {
    const state = store.getState();
    const request = state.iiif.requests[url];
    if (request) {
      switch (request.loadingState) {
        case RESOURCE_ERROR:
          break;
        case RESOURCE_LOADING: {
          let cleanupSubscription;
          let didContinue = false;
          try {
            const resolvedEntity = await Promise.race([
              new Promise((resolve, reject) => {
                if (didContinue) {
                  return;
                }
                cleanupSubscription = store.subscribe(() => {
                  const latestState = store.getState();
                  if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                    reject();
                    return;
                  }
                  if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                    const maybeResolvedEntity = resolveIfExists(latestState, url);
                    if (maybeResolvedEntity) {
                      resolve(maybeResolvedEntity);
                    } else {
                      reject();
                    }
                  }
                });
              }),
              new Promise((resolve, reject) => setTimeout(() => {
                didContinue = true;
                reject();
              }, waitTimeout * 60))
            ]);
            if (cleanupSubscription) {
              cleanupSubscription();
            }
            if (resolvedEntity) {
              return resolvedEntity;
            }
          } catch (e) {
            if (cleanupSubscription) {
              cleanupSubscription();
            }
            break;
          }
          break;
        }
        case RESOURCE_READY: {
          const resolvedEntity = resolveIfExists(state, url);
          if (resolvedEntity) {
            return resolvedEntity;
          }
          break;
        }
      }
    }
    store.dispatch(requestResource({ id: url }));
    try {
      const resource = await fetcher(url, options);
      if (!resource.id && !resource["@id"]) {
        if (resource["@type"]) {
          resource["@id"] = url;
          resource.id = url;
        } else {
          resource.id = url;
        }
      }
      const toDispatch = actionListFromResource(url, resource);
      store.dispatch(batchActions({ actions: toDispatch }));
      return resolveIfExists(store.getState(), url);
    } catch (err) {
      store.dispatch(requestError({ id: url, message: err.toString() }));
      throw err;
    }
  };
}

function getDefaultEntities() {
  return {
    Collection: {},
    Manifest: {},
    Canvas: {},
    AnnotationPage: {},
    AnnotationCollection: {},
    Annotation: {},
    ContentResource: {},
    Range: {},
    Service: {},
    Selector: {},
    Agent: {}
  };
}

function resolveList(state, items) {
  const returnItems = [];
  for (const ref of items) {
    if (state.iiif.entities[ref.type] && state.iiif.entities[ref.type][ref.id]) {
      returnItems.push(state.iiif.entities[ref.type][ref.id]);
    }
  }
  return returnItems;
}

exports.actionListFromResource = actionListFromResource;
exports.areInputsEqual = areInputsEqual;
exports.createFetchHelper = createFetchHelper;
exports.getDefaultEntities = getDefaultEntities;
exports.resolveIfExists = resolveIfExists;
exports.resolveList = resolveList;
