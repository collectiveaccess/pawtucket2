const metaState = {};
const compatVault = {
  get(nonRef) {
    return nonRef;
  },
  setMetaValue([id, meta, key], value) {
    const oldValue = compatVault.getResourceMeta(id, meta);
    const oldValueItem = oldValue ? oldValue[key] : void 0;
    const newValue = typeof value === "function" ? value(oldValueItem) : value;
    metaState[id] = {
      ...metaState[id] || {},
      [meta]: {
        ...(metaState[id] || {})[meta] || {},
        [key]: newValue
      }
    };
  },
  getResourceMeta: (resource, metaKey) => {
    const resourceMeta = metaState[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
};
function createEventsHelper(vault = compatVault) {
  return {
    addEventListener(resource, event, listener, scope) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          const callbacks = registeredCallbacks || [];
          for (const registered of callbacks) {
            if (registered.callback === listener) {
              return callbacks;
            }
          }
          return [...callbacks, { callback: listener, scope }];
        }
      );
      return listener;
    },
    removeEventListener(resource, event, listener) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);
        }
      );
    },
    getListenersAsProps(resourceOrId, scope) {
      const resource = typeof resourceOrId === "string" ? { id: resourceOrId } : resourceOrId;
      if (!resource || !resource.id) {
        return {};
      }
      const hooks = vault.getResourceMeta(resource.id, "eventManager");
      const props = {};
      if (hooks && resource) {
        for (const hook of Object.keys(hooks)) {
          props[hook] = (e) => {
            const fullResource = vault.get(resource);
            for (const { callback, scope: _scope } of hooks[hook] || []) {
              if (!_scope || scope && _scope.indexOf(scope) !== -1) {
                callback(e, fullResource);
              }
            }
          };
        }
      }
      return props;
    }
  };
}
function createStylesHelper(vault = compatVault) {
  return {
    applyStyles(resource, scope, styles) {
      const id = typeof resource === "string" ? resource : resource.id;
      return vault.setMetaValue([id, "styles", scope], styles);
    },
    getAppliedStyles(resource) {
      const id = typeof resource === "string" ? resource : resource.id;
      return vault.getResourceMeta(id, "styles");
    }
  };
}
function p(i) {
  return i.endsWith("info.json") ? i : i.endsWith("/") ? `${i}info.json` : `${i}/info.json`;
}
const te = "http://library.stanford.edu/iiif/image-api/compliance.html#level0", z = "http://library.stanford.edu/iiif/image-api/compliance.html#level1", A = "http://library.stanford.edu/iiif/image-api/compliance.html#level2", ne = "http://library.stanford.edu/iiif/image-api/conformance.html#level0", E = "http://library.stanford.edu/iiif/image-api/conformance.html#level1", b = "http://library.stanford.edu/iiif/image-api/conformance.html#level2", re = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0", L = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1", M = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2", se = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0", W = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1", j = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2", ae = "http://iiif.io/api/image/1/level0.json", oe = "http://iiif.io/api/image/1/profiles/level0.json", $ = "http://iiif.io/api/image/1/level1.json", C = "http://iiif.io/api/image/1/profiles/level1.json", P = "http://iiif.io/api/image/1/level2.json", B = "http://iiif.io/api/image/1/profiles/level2.json", fe = "http://iiif.io/api/image/2/level0.json", le = "http://iiif.io/api/image/2/profiles/level0.json", N = "http://iiif.io/api/image/2/level1.json", R = "http://iiif.io/api/image/2/profiles/level1.json", H = "http://iiif.io/api/image/2/level2.json", T = "http://iiif.io/api/image/2/profiles/level2.json", he = "level0", G = "level1", k = "level2", ue = "http://iiif.io/api/image/2/level0", Q = "http://iiif.io/api/image/2/level1", V = "http://iiif.io/api/image/2/level2", D = [V, A, b, M, j, P, B, H, T, k], U = [...D, Q, z, E, L, W, $, C, N, R, G], J = [ue, Q, V, te, z, A, ne, E, b, re, L, M, se, W, j, ae, oe, $, C, P, B, fe, le, N, R, H, T, he, G, k], ce = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["sizeByWhListed"] }, de = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPx", "regionSquare", "sizeByWhListed", "sizeByH", "sizeByW", "sizeByWh"] }, ge = { extraFormats: ["jpg", "png"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPct", "regionByPx", "regionSquare", "rotationBy90s", "sizeByWhListed", "sizeByConfinedWh", "sizeByH", "sizeByPct", "sizeByW", "sizeByWh"] };
function pe(i) {
  return D.indexOf(i) !== -1 ? ge : U.indexOf(i) !== -1 ? de : ce;
}
function K(i) {
  const e = i ? Array.isArray(i.profile) ? i.profile : [i.profile] : [], t = { extraQualities: [], extraFormats: [], extraFeatures: [] };
  for (let n of e)
    if (typeof n == "string" && (n = pe(n)), !!n) {
      if (n.formats)
        for (const r of n.formats)
          t.extraFormats.indexOf(r) === -1 && t.extraFormats.push(r);
      if (n.qualities)
        for (const r of n.qualities)
          t.extraQualities.indexOf(r) === -1 && t.extraQualities.push(r);
      if (n.supports)
        for (const r of n.supports)
          t.extraFeatures.indexOf(r) === -1 && t.extraFeatures.push(r);
      if (n.maxHeight && (t.maxHeight = n.maxHeight), n.maxWidth && (t.maxWidth = n.maxWidth), n.maxArea && (t.maxArea = n.maxArea), n.extraFormats)
        for (const r of n.extraFormats)
          t.extraFormats.indexOf(r) === -1 && t.extraFormats.push(r);
      if (n.extraQualities)
        for (const r of n.extraQualities)
          t.extraQualities.indexOf(r) === -1 && t.extraQualities.push(r);
      if (n.extraFeatures)
        for (const r of n.extraFeatures)
          t.extraFeatures.indexOf(r) === -1 && t.extraFeatures.push(r);
      n.maxHeight && (t.maxHeight = n.maxHeight), n.maxWidth && (t.maxWidth = n.maxWidth), n.maxArea && (t.maxArea = n.maxArea);
    }
  if (i.extraFormats)
    for (const n of i.extraFormats)
      t.extraFormats.indexOf(n) === -1 && t.extraFormats.push(n);
  if (i.extraFeatures)
    for (const n of i.extraFeatures)
      t.extraFeatures.indexOf(n) === -1 && t.extraFeatures.push(n);
  if (i.extraQualities)
    for (const n of i.extraQualities)
      t.extraQualities.indexOf(n) === -1 && t.extraQualities.push(n);
  return t;
}
function me(i) {
  try {
    if (i === "full")
      return { full: true };
    if (i === "square")
      return { square: true };
    const e = i.startsWith("pct:"), n = i.substr(e ? 4 : 0).split(",").map((r) => parseFloat(r));
    return { x: n[0], y: n[1], w: n[2], h: n[3], percent: e };
  } catch {
    throw new Error("Expected 'full', 'square' or 'x,y,w,h'. Found " + i);
  }
}
function xe(i) {
  const e = { upscaled: false, max: false, confined: false };
  if (i[0] === "^" && (e.upscaled = true, i = i.slice(1)), i === "max" || i === "full")
    return e.max = true, e.serialiseAsFull = i === "full", e;
  if (i[0] === "!" && (e.confined = true, i = i.slice(1)), i[0] === "p")
    return e.percentScale = parseFloat(i.slice(4)), e;
  const t = i.split(",").map((n) => n.trim());
  return t.length && (t[0] !== "" && (e.width = parseInt(t[0], 10)), t[1] !== "" ? (e.height = parseInt(t[1], 10), e.version = 2) : e.version = 3), e;
}
function Ie(i) {
  const e = { angle: 0 };
  if (i[0] === "!" && (e.mirror = true, i = i.substr(1)), e.angle = parseFloat(i) % 360, Number.isNaN(e.angle))
    throw new Error(`Invalid rotation ${i}`);
  return e;
}
function ye(i, e = "") {
  const t = i.match(/^(([a-zA-Z]+):\/\/([^/]+))?((.*)+)/);
  if (!t)
    throw new Error(`Invalid or unknown input ${i}`);
  const n = t[2], r = t[3];
  let s = t[4];
  if (s[0] === "/" && (s = s.substr(1)), e.length > 0) {
    if (e[0] === "/" && (e = e.substr(1)), e !== s.substr(0, e.length))
      throw new Error(`Path does not start with prefix (path: ${s}, prefix: ${e})`);
    s = s.substr(e.length);
  }
  return { scheme: n, server: r, path: s, prefix: e };
}
function _e(i, e = "") {
  const { path: t, scheme: n, server: r, prefix: s } = ye(i, e), a = t.split("/").reverse(), [o, f, u, l, ...d] = a, g = d.reverse().filter(Boolean).join("/");
  if (a.length === 1 || o === "")
    return { type: "base", scheme: n, server: r, prefix: s, identifier: g };
  if (o === "info.json") {
    const [, ...c] = a;
    return { type: "info", scheme: n, server: r, prefix: s, identifier: c.reverse().filter(Boolean).join("/") };
  }
  const m = o.split(".");
  return { type: "image", scheme: n, server: r, prefix: s, identifier: g, originalPath: t, region: me(l), size: xe(u), rotation: Ie(f), quality: m[0], format: m[1] };
}
function we(i) {
  const e = _e(p(i.id));
  if (e.type !== "info")
    throw new Error("Invalid service URL");
  const t = K(i);
  return { identifier: e.identifier, originalPath: "", server: e.server, prefix: e.prefix, scheme: e.scheme, type: "image", quality: t.extraQualities.indexOf("default") === -1 ? t.extraQualities[0] : "default", region: { full: true }, size: { max: true, upscaled: false, confined: false }, format: "jpg", rotation: { angle: 0 } };
}
function Se(i, e, t) {
  const n = t.length, r = [];
  for (let s = 0; s < n; s++) {
    const o = t[s].width;
    r.push(i / o);
  }
  return r;
}
function ve(i, e, t) {
  const n = t.length, r = [];
  for (let s = 0; s < n; s++) {
    const a = t[s];
    r.push({ width: Math.floor(i / a), height: Math.floor(e / a) });
  }
  return r;
}
function h(i) {
  if (i["@id"])
    return i["@id"];
  if (i.id)
    return i.id;
}
function w(i) {
  if (!i || !i.profile || !h(i))
    return false;
  const e = Array.isArray(i.profile) ? i.profile : [i.profile];
  for (const t of e)
    if (typeof t == "string" && J.indexOf(t) !== -1)
      return true;
  return false;
}
function Fe(i) {
  if (!w(i))
    return false;
  const e = Array.isArray(i.profile) ? i.profile : [i.profile];
  for (const t of e)
    if (typeof t == "string") {
      if (U.indexOf(t) !== -1)
        return true;
    } else {
      const n = [...t.supports || [], ...t.extraFeatures || []];
      if (n.indexOf("regionByPx") !== -1 && (n.indexOf("sizeByW") !== -1 || n.indexOf("sizeByWh") !== -1))
        return true;
    }
  return false;
}
function v(i, e) {
  if (e && e.profile) {
    const t = e.profile;
    if (t) {
      const n = Array.isArray(t) ? t : [t];
      return n.includes(`level${i}`) || n.includes(`http://iiif.io/api/image/2/level${i}.json`) || n.includes(`http://iiif.io/api/image/1/level${i}.json`) || n.includes(`http://iiif.io/api/image/1/profiles/level${i}.json`);
    }
  }
  return false;
}
function F(i) {
  return w(i) ? v(0, i) ? 0 : v(1, i) ? 1 : v(2, i) ? 2 : null : null;
}
function X(i) {
  return (i["@context"] ? Array.isArray(i["@context"]) ? i["@context"] : [i["@context"]] : []).indexOf("http://iiif.io/api/image/3/context.json") !== -1;
}
function Oe(i) {
  if (!Fe(i))
    return [];
  const e = [], t = Array.isArray(i.profile) ? i.profile : [i.profile], n = t.length;
  for (let r = 0; r < n; r++) {
    const s = t[r];
    if (typeof s != "string" && (s.maxHeight || s.maxWidth))
      return [{ id: h(i), type: "variable", minWidth: 0, minHeight: 0, maxHeight: s.maxHeight || s.maxWidth, maxWidth: s.maxWidth || s.maxHeight, level: F(i), version: i["@context"] === "http://iiif.io/api/image/3/context.json" ? 3 : 2 }];
  }
  if (i.tiles) {
    const r = i.tiles.length;
    for (let s = 0; s < r; s++) {
      const a = i.tiles[s];
      (a.height || a.width) && e.push({ id: h(i), type: "variable", minHeight: 0, minWidth: 0, maxHeight: a.height || a.width, maxWidth: a.width, level: F(i), version: X(i) ? 3 : 2 });
    }
  }
  return e;
}
function Y(i) {
  const e = /^.*\/(full)\/(((\d+),(\d+)?)|max)\/(\d+)\/default\.(jpg|png|jpeg)$/, t = i.match(e);
  if (t) {
    const n = t[1], r = parseInt(t[4], 10), s = parseInt(t[5], 10), a = t[7];
    if ((n === "max" || n === "full") && r && s && a)
      return { type: "fixed", id: i, height: s, width: r };
  }
  return { type: "unknown", id: i };
}
function ze(i) {
  if (i["@type"])
    return i["@type"];
  if (i.type)
    return i.type;
}
function Ae(i) {
  if (typeof i == "string")
    return Y(i);
  const e = ze(i);
  if (e !== "Image" && e !== "sc:Image")
    return null;
  const t = i, n = h(t);
  return n ? n && t.width && t.height ? { id: n, type: "fixed", width: t.width, height: t.height, unsafe: true } : Y(n) : null;
}
function Ee(i) {
  return w(i) ? (i && i.sizes ? i.sizes : []).map((e) => ({ id: h(i), type: "fixed-service", height: e.height, width: e.width, level: F(i), version: X(i) ? 3 : 2 })) : [];
}
function q(i) {
  const e = [], t = i.length;
  for (let n = 0; n < t; n++) {
    const r = Ee(i[n]);
    r.length && e.push(...r);
    const s = Oe(i[n]);
    s.length && e.push(...s);
  }
  return e;
}
function ee(i) {
  const e = i.service ? Array.isArray(i.service) ? i.service : [i.service] : [], t = e.length, n = [];
  for (let r = 0; r < t; r++)
    w(e[r]) && n.push(e[r]);
  return n;
}
function be(i, e = true, t) {
  const n = [], r = Ae(i);
  if (r === null)
    return n;
  const s = i;
  if (n.push(r), e && s.width && s.height) {
    const a = [], o = ee(s);
    for (const f of o) {
      const u = { id: h(f), width: s.width, height: s.height };
      if (t.canLoadSync(u)) {
        const l = t.loadServiceSync(u);
        l && (l.height || (l.height = s.height), l.width || (l.width = s.width), a.push(...q([l])));
      }
    }
    if (a.length)
      return n.push(...a), n;
  }
  return s.service && n.push(...q(s.service)), n;
}
function Le({ x: i = 0, y: e = 0, w: t, h: n, full: r, square: s, percent: a }) {
  if (r)
    return "full";
  if (s)
    return "square";
  if (typeof t > "u" || typeof n > "u")
    throw new Error("RegionParameter: invalid region");
  const o = `${i},${e},${t},${n}`;
  return a ? `pct:${o}` : o;
}
function Me({ max: i, percentScale: e, upscaled: t, confined: n, width: r, height: s, serialiseAsFull: a, version: o }) {
  const f = [];
  return t && f.push("^"), i ? (f.push(a ? "full" : "max"), f.join("")) : (n && f.push("!"), e && f.push(`pct:${e}`), r && f.push(`${r}`), f.push(","), s && o === 3 && f.push(`${s}`), f.join(""));
}
function We(i) {
  return `${i.mirror ? "!" : ""}${(i.angle || 0) % 360}`;
}
var Ve = Object.defineProperty, De = Object.defineProperties, Ue = Object.getOwnPropertyDescriptors, je = Object.getOwnPropertySymbols, Je = Object.prototype.hasOwnProperty, Ze = Object.prototype.propertyIsEnumerable, $e = (i, e, t) => e in i ? Ve(i, e, { enumerable: true, configurable: true, writable: true, value: t }) : i[e] = t, x = (i, e) => {
  for (var t in e || (e = {}))
    Je.call(e, t) && $e(i, t, e[t]);
  if (je)
    for (var t of je(e))
      Ze.call(e, t) && $e(i, t, e[t]);
  return i;
}, I = (i, e) => De(i, Ue(e));
function Ce(i, e) {
  const t = i.prefix.startsWith("/") ? i.prefix.substr(1) : i.prefix, n = `${i.scheme}://${i.server}/${t ? `${t}/` : ""}${i.identifier}`;
  if (i.type === "base")
    return n;
  if (i.type === "info")
    return `${n}/info.json`;
  let { size: r } = i;
  const { region: s, rotation: a, format: o, quality: f } = i;
  if (e) {
    const u = e["@context"] ? Array.isArray(e["@context"]) ? e["@context"] : [e["@context"]] : [], l = u.indexOf("http://iiif.io/api/image/2/context.json") !== -1, d = u.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
    if ((r.width === e.width && !r.height || r.height === e.height && !r.width || r.width === e.width && r.height === e.height) && (r = I(x({}, r), { max: true })), l && (r.max && !r.serialiseAsFull && (r = I(x({}, r), { serialiseAsFull: true })), !r.max && r.width && r.height && (r = I(x({}, r), { height: void 0 })), r = I(x({}, r), { version: 2 })), d) {
      if (r.max && r.serialiseAsFull && (r = I(x({}, r), { serialiseAsFull: false })), r.width && !r.height && e.width && e.height) {
        const g = e.height / e.width;
        r = I(x({}, r), { height: Math.ceil(r.width * g) });
      }
      r = I(x({}, r), { version: 3 });
    }
  }
  return [n, Le(s), Me(r), We(a), `${f}.${o}`].filter(Boolean).join("/");
}
function O(i, e, t) {
  const n = we({ "@context": i.version === 3 ? "http://iiif.io/api/image/3/context.json" : "http://iiif.io/api/image/2/context.json", id: p(h(i)), profile: i.level === null || typeof i.level > "u" ? "level0" : `level${i.level}}`, type: i.version === 3 ? "ImageService3" : "ImageService2" });
  if (n.type !== "image")
    throw new Error("Invalid service");
  return n.size.max = false, n.size.width = e, n.size.height = t, { id: Ce(n), type: "fixed", width: e, height: t || i.height / (i.width || 1) * e, unsafe: i.width > e };
}
function y(i) {
  const e = i.replace(/(https?:\/\/)?(www.)?/i, "");
  return e.indexOf("/") !== -1 ? e.split("/")[0] : e;
}
function Pe(i, e, t) {
  const n = i.width ? i.width : i.maxWidth;
  return t.height <= i.maxHeight && t.width <= i.maxWidth && t.height >= i.minHeight && t.width >= i.minWidth && (!e || Math.abs(t.width - n) < Math.abs(e.width - n));
}
function Be(i, e) {
  const t = [], n = Object.assign({ unsafeImageService: false, atAnyCost: true, fallback: true, minHeight: 64, minWidth: 64, maxHeight: 1 / 0, maxWidth: 1 / 0, returnAllOptions: false, preferFixedSize: false, allowUnsafe: false, explain: false, height: 0, width: 0 }, i), r = (l, d = 0) => n.explain ? t.push(new Array(d).fill(0).map((g) => "    ").join("") + l().trim()) : void 0, s = [], a = [];
  let o = null;
  r(() => `Using configuration: ${JSON.stringify(n, null, 2)}`);
  const f = (l, d) => {
    if (r(() => "Swapping choice", 3), Pe(n, d, l)) {
      if (n.preferFixedSize && l.unsafe) {
        r(() => `We found an image that was marked as unsafe, but it was the best size. (${l.id})`, 4), a.push(l);
        return;
      }
      n.returnAllOptions && d && a.push(d), r(() => `We found a new image that was the best size. (${l.id})`, 4), o = l;
    } else
      n.returnAllOptions && a.push(l);
  };
  r(() => `The input shows we have ${e.length} list(s) of candidates to choose from.`);
  const u = e.length;
  for (let l = 0; l < u; l++) {
    const d = e[l]();
    r(() => `Candidate group ${l}: ${JSON.stringify(d, null, 2)}`, 1);
    const g = d.length;
    r(() => `Checking candidate list number ${l} and found ${g} potential ways of creating image(s)`, 1);
    for (let m = 0; m < g; m++) {
      const c = d[m];
      if (r(() => `-> Checking candidate ${m}`, 1), c.type === "unknown" && n.atAnyCost && (r(() => `We've found an unknown image type, adding this to the "last resort" list`, 2), s.push(c)), c.type === "fixed" && (c.unsafe ? (r(() => `We've found an unsafe fixed image type, adding this to the "last resort" list`, 2), s.push(c)) : (r(() => "We've found a fixed size image, checking if it matches the request", 2), f(c, o))), c.type === "fixed-service")
        if (n.unsafeImageService) {
          r(() => "Checking for an image from the tile source, without calculating the right height and width (unsafeImageService)", 2);
          const S = O(c, n.width, n.height);
          f(S, o);
        } else {
          r(() => "Checking for an image from the tile source 3", 2);
          const S = O(c, c.width, c.height);
          f(S, o);
        }
      if (c.type === "variable" && c.maxWidth) {
        const S = O({ id: c.id, type: "fixed-service", width: c.maxWidth, height: c.maxWidth, level: c.level, version: c.version }, c.maxWidth);
        f(S, o);
      }
    }
    if (o && !n.returnAllOptions) {
      if (o.unsafe || n.allowUnsafe)
        continue;
      r(() => `We found a match in choice list number ${l}, no searching any more`);
      break;
    }
  }
  return n.atAnyCost && a.length === 0 ? (r(() => o ? `We found an image! ${o.id} of type ${o.type}` : 'We found no images, but "atAnyCost" is set, so returning that'), { best: o || s[0], fallback: s.slice(1), log: t }) : n.returnAllOptions ? (r(() => "Returning all options that we have found"), { best: n.atAnyCost ? o || a[0] || s[0] : o || a[0], fallback: [...a, ...s], log: t }) : (r(() => "Returning the best image that we found, and a fallback"), { best: o || a[0] || null, fallback: o ? a : a.slice(1), log: t });
}
var qe = Object.defineProperty, ei = Object.defineProperties, ii = Object.getOwnPropertyDescriptors, Ne = Object.getOwnPropertySymbols, ti = Object.prototype.hasOwnProperty, ni = Object.prototype.propertyIsEnumerable, Re = (i, e, t) => e in i ? qe(i, e, { enumerable: true, configurable: true, writable: true, value: t }) : i[e] = t, ri = (i, e) => {
  for (var t in e || (e = {}))
    ti.call(e, t) && Re(i, t, e[t]);
  if (Ne)
    for (var t of Ne(e))
      ni.call(e, t) && Re(i, t, e[t]);
  return i;
}, si = (i, e) => ei(i, ii(e));
function He(i, e, t) {
  const n = i > e ? i : e, r = t.length, s = [];
  for (let a = 0; a < r; a++) {
    const o = t[a];
    let f = o.scaleFactors[0], u = n / f;
    const l = [f];
    for (; u >= o.width; )
      f = f * 2, l.push(f), u = u / 2;
    s.push(si(ri({}, o), { scaleFactors: l }));
  }
  return s;
}
function Te(i, e) {
  if (i.length !== e.length)
    return false;
  if (i.length === 0 && e.length === 0)
    return true;
  const t = i.length;
  let n = true;
  for (let s = 0; s < t; s++) {
    const a = i[s], o = e[s];
    if (a.width !== o.width || a.height !== o.height) {
      n = false;
      break;
    }
  }
  if (n)
    return true;
  let r = 0;
  for (let s = 0; s < t; s++)
    for (let a = 0; a < t; a++)
      if (i[s].width === e[a].width && i[s].height === e[a].height) {
        r++;
        break;
      }
  return r === t;
}
function Ge(i) {
  return v(0, i);
}
var _ = (i, e, t) => new Promise((n, r) => {
  var s = (f) => {
    try {
      o(t.next(f));
    } catch (u) {
      r(u);
    }
  }, a = (f) => {
    try {
      o(t.throw(f));
    } catch (u) {
      r(u);
    }
  }, o = (f) => f.done ? n(f.value) : Promise.resolve(f.value).then(s, a);
  o((t = t.apply(i, e)).next());
});
class ke {
  constructor() {
    this.config = { verificationsRequired: 1, approximateServices: true, enableFetching: true, disableThrottling: false }, this.fetchingCount = 0, this.imageServices = {}, this.knownImageServers = {};
  }
  setConfig(e) {
    Object.assign(this.config, e);
  }
  sample(e, t, n = true) {
    const r = y(h(e)), s = p(h(e)), a = this.knownImageServers[r];
    return this.imageServices[s] = Object.assign(e, { real: true }), !a && e.tiles && !Ge(e) ? (this.knownImageServers[r] = { verifications: 0, malformed: false, root: r, preLoaded: n, sampledId: h(e), verified: false, server: null, result: { context: e["@context"] || [], sampledProfile: e.profile, resourceServiceRatio: t && e.height ? t.height / e.height : 1, sampledSizes: e.sizes || [], sizeRatios: Se(e.width, e.height, e.sizes || []), sampledTiles: e.tiles || [] } }, true) : this.verify(e);
  }
  preLoad(e, t = true) {
    this.knownImageServers[e.root] = e, t && (this.knownImageServers[e.root].malformed = false, this.knownImageServers[e.root].verifications = this.config.verificationsRequired);
  }
  predict(e, t = false, n = false) {
    const r = e == null ? void 0 : e.source, s = y(h(e)), a = this.knownImageServers[s];
    if (!a || !a.result || !((r == null ? void 0 : r.height) || e.height) || !((r == null ? void 0 : r.width) || e.width) || !n && (a.malformed || a.verifications < this.config.verificationsRequired) || Ge(e.source))
      return null;
    const o = p(h(e));
    return this.imageServices[o] || (this.imageServices[o] = { "@context": a.result.context, "@id": h(e), id: h(e), protocol: "http://iiif.io/api/image", tiles: (r == null ? void 0 : r.tiles) || He(e.width, e.height, a.result.sampledTiles), sizes: (r == null ? void 0 : r.sizes) || ve(Math.round(e.width / a.result.resourceServiceRatio), Math.round(e.height / a.result.resourceServiceRatio), a.result.sizeRatios), profile: (r == null ? void 0 : r.profile) || a.result.sampledProfile, height: (r == null ? void 0 : r.height) || e.height, width: (r == null ? void 0 : r.width) || e.width, real: false }), this.imageServices[o];
  }
  getThumbnailFromResource(e, t) {
    return _(this, arguments, function* (n, r, s = true, a = []) {
      const o = n ? yield this.getImageCandidates(n, s) : [];
      return Be(r, [() => a, () => o]);
    });
  }
  getImageCandidates(e, t = true) {
    return _(this, null, function* () {
      const n = e;
      if (t && n.height && n.width) {
        const r = ee(n);
        for (const s of r) {
          const a = { id: h(s), width: s.width ? s.width : n.width, height: s.height ? s.height : n.height, source: s };
          yield this.loadService(a);
        }
      }
      return be(e, t, this);
    });
  }
  verify(e) {
    return _(this, null, function* () {
      const t = this.predict(e, false, true), n = yield this.fetchService(h(e));
      if (!t)
        return false;
      const r = t.height === n.height && t.width === n.width && t["@context"] === n["@context"] && Te(t.sizes || [], n.sizes || []);
      if (r) {
        const s = y(h(e));
        this.knownImageServers[s].verifications += 1, this.knownImageServers[s].verifications >= this.config.verificationsRequired && (this.knownImageServers[s].verified = true);
      }
      return r;
    });
  }
  canLoadSync(e) {
    const t = typeof e == "string" ? e : h(e), n = p(t);
    if (this.imageServices[n])
      return true;
    const r = this.knownImageServers[y(t)];
    return r && !r.malformed && r.verifications >= this.config.verificationsRequired;
  }
  markAsMalformed(e) {
    return _(this, null, function* () {
      return this.knownImageServers[y(h(e))].malformed = true, this.loadService(e, true);
    });
  }
  fetchService(e, t = false) {
    return _(this, null, function* () {
      const n = p(e);
      if (this.imageServices[n] && (!t || this.imageServices[n].real))
        return this.imageServices[n];
      if (!this.config.enableFetching)
        throw new Error("Fetching is not enabled");
      const r = yield this.fetch(n).then((s) => s.json());
      return !r.id && r["@id"] && (r.id = r["@id"]), r.id !== e && (r.id = e, r["@id"] && (r["@id"] = e)), this.imageServices[n] = Object.assign(r, { real: true }), this.imageServices[n];
    });
  }
  fetch(e, t) {
    return _(this, null, function* () {
      return fetch(e, t);
    });
  }
  loadService(e, t = false) {
    return _(this, null, function* () {
      if (!this.config.disableThrottling) {
        let s = true;
        for (; s; )
          if (this.fetchingCount >= this.config.verificationsRequired)
            yield new Promise((a) => setTimeout(a, 500));
          else {
            s = false;
            break;
          }
      }
      const n = this.knownImageServers[y(h(e))];
      if (n && !n.malformed && !t) {
        yield n.result;
        const s = this.loadServiceSync(e);
        if (s)
          return s;
      }
      this.fetchingCount++;
      const r = yield this.fetchService(h(e), t);
      return this.fetchingCount--, r.real && this.sample(r, e), r;
    });
  }
  loadServiceSync(e) {
    const t = p(h(e));
    return this.imageServices[t] ? this.imageServices[t] : this.predict(e);
  }
}
new ke();
function createThumbnailHelper(vault = compatVault, dependencies = {}) {
  const imageServiceLoader = dependencies.imageServiceLoader || new ke();
  async function getBestThumbnailAtSize(input, request, dereference, candidates = [], dimensions) {
    const thumbnailNotFound = () => imageServiceLoader.getThumbnailFromResource(void 0, request, dereference, candidates);
    if (!input) {
      return await imageServiceLoader.getThumbnailFromResource(void 0, request, dereference, candidates);
    }
    if (typeof input === "string") {
      const fixed = Ae(input);
      if (fixed) {
        candidates.push(fixed);
      }
      return await imageServiceLoader.getThumbnailFromResource(void 0, request, dereference, candidates);
    }
    const fullInput = vault.get(input, { skipSelfReturn: false });
    if (typeof fullInput === "string") {
      return { best: Ae(fullInput), fallback: [], log: [] };
    }
    if (!fullInput) {
      return await thumbnailNotFound();
    }
    const parseThumbnail = async (resource) => {
      if (resource && resource.thumbnail && resource.thumbnail.length) {
        const thumbnail = vault.get(resource.thumbnail[0]);
        const potentialThumbnails = await imageServiceLoader.getImageCandidates(thumbnail, dereference);
        if (potentialThumbnails && potentialThumbnails.length) {
          candidates.push(...potentialThumbnails);
        }
      }
    };
    await parseThumbnail(fullInput);
    switch (fullInput.type) {
      case "Annotation": {
        const contentResources = Array.isArray(fullInput.body) ? fullInput.body : [fullInput.body];
        const firstContentResources = vault.get(contentResources[0]);
        if (dimensions && !firstContentResources.width) {
          firstContentResources.width = dimensions.width;
          firstContentResources.height = dimensions.height;
        }
        return await imageServiceLoader.getThumbnailFromResource(
          firstContentResources,
          request,
          dereference,
          candidates
        );
      }
      case "Canvas": {
        const canvas = fullInput;
        return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {
          width: canvas.width,
          height: canvas.height
        });
      }
      case "AnnotationPage": {
        const annotationPage = fullInput;
        return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);
      }
      case "Choice": {
        const choice = fullInput;
        if (!choice.items || choice.items[0]) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(choice.items[0], request, dereference, candidates, dimensions);
      }
      case "Collection": {
        const collection = fullInput;
        const firstManifest = collection.items[0];
        if (!firstManifest) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);
      }
      case "Manifest": {
        const manifest = fullInput;
        const firstCanvas = manifest.items[0];
        if (!firstCanvas) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);
      }
      case "SpecificResource":
      case "Image":
      case "Dataset":
      case "Sound":
      case "Text":
      case "TextualBody":
      case "Video":
        if (dimensions && !fullInput.width) {
          fullInput.width = dimensions.width;
          fullInput.height = dimensions.height;
        }
        return imageServiceLoader.getThumbnailFromResource(fullInput, request, dereference, candidates);
      case "Service":
      case "Range":
      case "AnnotationCollection":
      case "CanvasReference":
      case "ContentResource":
        return await thumbnailNotFound();
    }
    return await thumbnailNotFound();
  }
  return {
    getBestThumbnailAtSize
  };
}
function getClosestLanguage(i18nLanguage, languages, i18nLanguages = [], strictFallback = false) {
  if (!i18nLanguage || !languages || languages.length === 0) {
    return void 0;
  }
  if (languages.length === 1) {
    return languages[0];
  }
  if (languages.indexOf(i18nLanguage) !== -1) {
    return i18nLanguage;
  }
  const root = i18nLanguage.indexOf("-") !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf("-")) : null;
  if (root && languages.indexOf(root) !== -1) {
    return root;
  }
  for (const lang of i18nLanguages) {
    if (languages.indexOf(lang) !== -1) {
      return lang;
    }
  }
  if (!strictFallback) {
    const inverseRoot = languages.map((l) => l.indexOf("-") !== -1 ? l.slice(0, l.indexOf("-")) : null);
    const inverseIdx = inverseRoot.indexOf(i18nLanguage);
    if (inverseIdx !== -1) {
      return languages[inverseIdx];
    }
    for (const lang of i18nLanguages) {
      const root2 = lang.indexOf("-") !== -1 ? lang.slice(0, lang.indexOf("-")) : null;
      const inverseIdx2 = root2 ? languages.indexOf(root2) : -1;
      if (inverseIdx2 !== -1) {
        return languages[inverseIdx2];
      }
    }
  }
  if (languages.indexOf("none") !== -1) {
    return "none";
  }
  if (languages.indexOf("@none") !== -1) {
    return "@none";
  }
  return languages[0];
}
function buildLocaleString(inputText, i18nLanguage, options = {}) {
  const { strictFallback = false, defaultText = "", separator = "\n", fallbackLanguages = [], closest } = options;
  const languages = Object.keys(inputText || {});
  const language = closest ? i18nLanguage : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback);
  if (!inputText) {
    return defaultText;
  }
  if (typeof inputText === "string") {
    return inputText;
  }
  const candidateText = language ? inputText[language] : void 0;
  if (candidateText) {
    if (typeof candidateText === "string") {
      return candidateText;
    }
    return candidateText.join(separator);
  }
  return "";
}
function getValue(inputText, options = {}) {
  return buildLocaleString(inputText, typeof navigator !== "undefined" ? navigator.language : void 0, options);
}
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e2 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e2 = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e2;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x2 = _ref.x, y2 = _ref.y;
  x2 *= rx;
  y2 *= ry;
  var xp = cosphi * x2 - sinphi * y2;
  var yp = sinphi * x2 + cosphi * y2;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x3 = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x: x3, y: y3 };
  });
};
var parseSvgPath = parse;
var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function parse(path) {
  var data = [];
  path.replace(segment, function(_2, command, args) {
    var type = command.toLowerCase();
    args = parseValues(args);
    if (type == "m" && args.length > 2) {
      data.push([command].concat(args.splice(0, 2)));
      type = "l";
      command = command == "m" ? "l" : "L";
    }
    while (true) {
      if (args.length == length[type]) {
        args.unshift(command);
        return data.push(args);
      }
      if (args.length < length[type])
        throw new Error("malformed path data");
      data.push([command].concat(args.splice(0, length[type])));
    }
  });
  return data;
}
var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function parseValues(args) {
  var numbers = args.match(number);
  return numbers ? numbers.map(Number) : [];
}
var absSvgPath = absolutize;
function absolutize(path) {
  var startX = 0;
  var startY = 0;
  var x2 = 0;
  var y2 = 0;
  return path.map(function(seg) {
    seg = seg.slice();
    var type = seg[0];
    var command = type.toUpperCase();
    if (type != command) {
      seg[0] = command;
      switch (type) {
        case "a":
          seg[6] += x2;
          seg[7] += y2;
          break;
        case "v":
          seg[1] += y2;
          break;
        case "h":
          seg[1] += x2;
          break;
        default:
          for (var i = 1; i < seg.length; ) {
            seg[i++] += x2;
            seg[i++] += y2;
          }
      }
    }
    switch (command) {
      case "Z":
        x2 = startX;
        y2 = startY;
        break;
      case "H":
        x2 = seg[1];
        break;
      case "V":
        y2 = seg[1];
        break;
      case "M":
        x2 = startX = seg[1];
        y2 = startY = seg[2];
        break;
      default:
        x2 = seg[seg.length - 2];
        y2 = seg[seg.length - 1];
    }
    return seg;
  });
}
function parseAndNormalizeSvgPath(path) {
  const parsed = parseSvgPath(path);
  const absolute = absSvgPath(parsed);
  let prevCmd;
  let startX = 0;
  let startY = 0;
  let bezierX = 0;
  let bezierY = 0;
  let quadX;
  let quadY;
  let x2 = 0;
  let y2 = 0;
  const out = [];
  for (let i = 0; i < absolute.length; i++) {
    let seg = absolute[i];
    const cmd = seg[0];
    switch (cmd) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "H":
        seg = ["L", seg[1], startY];
        break;
      case "V":
        seg = ["L", startX, seg[1]];
        break;
      case "S":
        {
          let cx = x2;
          let cy = y2;
          if (prevCmd === "C" || prevCmd == "S") {
            cx += cx - bezierX;
            cy += cy - bezierY;
          }
          seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
        }
        break;
      case "T":
        if (prevCmd === "Q" || prevCmd == "T") {
          quadX = x2 * 2 - quadX;
          quadY = y2 * 2 - quadY;
        } else {
          quadX = x2;
          quadY = y2;
        }
        seg = ["Q", quadX, quadY, seg[1], seg[2]];
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        break;
      case "A":
        {
          const curves = arcToBezier({
            px: x2,
            py: y2,
            cx: seg[6],
            cy: seg[7],
            rx: seg[1],
            ry: seg[2],
            xAxisRotation: seg[3],
            largeArcFlag: seg[4],
            sweepFlag: seg[5]
          });
          if (!curves.length) {
            continue;
          }
          for (const [j2, curve] of curves.entries()) {
            seg = ["C", curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];
            if (j2 < curves.length - 1) {
              out.push(seg);
            }
          }
          seg = seg;
        }
        break;
      case "Z":
        seg = ["L", startX, startY];
        break;
    }
    prevCmd = cmd;
    x2 = seg[seg.length - 2];
    y2 = seg[seg.length - 1];
    if (["C", "Q", "A"].indexOf(cmd) > -1) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x2;
      bezierY = y2;
    }
    out.push(seg);
  }
  return out;
}
/** Code to "flatten" quadratic and cubic Bézier curves to polylines.
 *
 * All code in this module is based on JavaScript code by Raph Levien, published on his blog at
 * https://raphlinus.github.io/.
 * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.
 *
 * Flattening of quadratic Bézier curves:
 * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html
 * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212
 *
 * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html
 *
 * Note that the code in this module has a different license than the rest of the package,
 * due to the inclusion of Apache-licensed third party code.
 *
 * @license
 * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>
 * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function flattenQuadraticBezier(start, control, end, tolerance = 1) {
  return new QuadraticBezier(start, control, end).subdivide(tolerance);
}
function flattenCubicBezier(start, startControl, end, endControl, tolerance = 1) {
  return new CubicBezier(
    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])
  ).subdivide(tolerance);
}
function hypot2(p2) {
  return p2.x * p2.x + p2.y * p2.y;
}
function approx_myint(x2) {
  const d = 0.67;
  return x2 / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x2 * x2, 0.25));
}
function approx_inv_myint(x2) {
  const b2 = 0.39;
  return x2 * (1 - b2 + Math.sqrt(b2 * b2 + 0.25 * x2 * x2));
}
class QuadraticBezier {
  constructor(start, control, end) {
    this.start = start;
    this.control = control;
    this.end = end;
  }
  eval(t) {
    const mt = 1 - t;
    return {
      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,
      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t
    };
  }
  mapToBasic() {
    const { x: x0, y: y0 } = this.start;
    const { x: x1, y: y1 } = this.control;
    const { x: x2, y: y2 } = this.end;
    const ddx = 2 * x1 - x0 - x2;
    const ddy = 2 * y1 - y0 - y2;
    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;
    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;
    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;
    const paramX0 = u0 / cross;
    const paramX2 = u2 / cross;
    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));
    return { x0, x2, scale, cross };
  }
  subdivide(tolerance) {
    const params = this.mapToBasic();
    const a0 = approx_myint(params.x0);
    const a2 = approx_myint(params.x2);
    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);
    const n = Math.ceil(count);
    const u0 = approx_inv_myint(a0);
    const u2 = approx_inv_myint(a2);
    const tValues = [0];
    for (let i = 1; i < n; i++) {
      const u = approx_inv_myint(a0 + (a2 - a0) * i / n);
      const t = (u - u0) / (u2 - u0);
      tValues.push(t);
    }
    tValues.push(1);
    return tValues.map((t) => this.eval(t));
  }
}
class CubicBezier {
  constructor(coords) {
    this.c = coords;
  }
  weightsum(c0, c1, c2, c3) {
    const x2 = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];
    const y2 = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];
    return { x: x2, y: y2 };
  }
  eval(t) {
    const mt = 1 - t;
    const c0 = mt * mt * mt;
    const c1 = 3 * mt * mt * t;
    const c2 = 3 * mt * t * t;
    const c3 = t * t * t;
    return this.weightsum(c0, c1, c2, c3);
  }
  deriv(t) {
    const mt = 1 - t;
    const c0 = -3 * mt * mt;
    const c3 = 3 * t * t;
    const c1 = -6 * t * mt - c0;
    const c2 = 6 * t * mt - c3;
    return this.weightsum(c0, c1, c2, c3);
  }
  midpoint_quadbez() {
    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);
    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });
  }
  subsegment(t0, t1) {
    const c = new Float64Array(8);
    const p0 = this.eval(t0);
    const p3 = this.eval(t1);
    c[0] = p0.x;
    c[1] = p0.y;
    const scale = (t1 - t0) / 3;
    const d1 = this.deriv(t0);
    c[2] = p0.x + scale * d1.x;
    c[3] = p0.y + scale * d1.y;
    const d2 = this.deriv(t1);
    c[4] = p3.x - scale * d2.x;
    c[5] = p3.y - scale * d2.y;
    c[6] = p3.x;
    c[7] = p3.y;
    return new CubicBezier(c);
  }
  subdivide(tol) {
    const tol1 = 0.1 * tol;
    const tol2 = tol - tol1;
    const sqrt_tol2 = Math.sqrt(tol2);
    const err2 = hypot2(this.weightsum(1, -3, 3, -1));
    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));
    const quads = [];
    let sum = 0;
    for (let i2 = 0; i2 < n_quads; i2++) {
      const t0 = i2 / n_quads;
      const t1 = (i2 + 1) / n_quads;
      const quad = this.subsegment(t0, t1).midpoint_quadbez();
      const params = quad.mapToBasic();
      const a0 = approx_myint(params.x0);
      const a2 = approx_myint(params.x2);
      const scale = Math.sqrt(params.scale);
      let val2 = Math.abs(a2 - a0) * scale;
      if (Math.sign(params.x0) != Math.sign(params.x2)) {
        const xmin = sqrt_tol2 / scale;
        const cusp_val = sqrt_tol2 * Math.abs(a2 - a0) / approx_myint(xmin);
        val2 = Math.max(val2, cusp_val);
      }
      quads.push({
        quad,
        a0,
        a2,
        val: val2
      });
      sum += val2;
    }
    const count = 0.5 * sum / sqrt_tol2;
    const n = Math.ceil(count);
    const result = [{ x: this.c[0], y: this.c[1] }];
    let val = 0;
    let i = 0;
    for (let j2 = 1; j2 < n; j2++) {
      const target = sum * j2 / n;
      while (val + quads[i].val < target) {
        val += quads[i].val;
        i++;
      }
      const a0 = quads[i].a0;
      const a2 = quads[i].a2;
      const u0 = approx_inv_myint(a0);
      const u2 = approx_inv_myint(a2);
      const a = a0 + (a2 - a0) * (target - val) / quads[i].val;
      const u = approx_inv_myint(a);
      const t = (u - u0) / (u2 - u0);
      result.push(quads[i].quad.eval(t));
    }
    result.push({ x: this.c[6], y: this.c[7] });
    return result;
  }
}
const BOX_SELECTOR = /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?)/;
const TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(.[0-9]+)?)?(,([0-9]+(.[0-9]+)?))?/;
const RGBA_COLOR = /^rgba\((\d+),(\d+),(\d+),([0-9.]+)\)$/;
function parseSelector(source, {
  domParser,
  svgPreprocessor,
  iiifRenderingHints
} = {}) {
  var _a, _b;
  if (Array.isArray(source)) {
    return resolveHints(
      source.reduce(
        (data, nextSource) => {
          const {
            selector,
            selectors,
            iiifRenderingHints: newIiifRenderingHints
          } = parseSelector(nextSource, { domParser, svgPreprocessor, iiifRenderingHints });
          if (selector) {
            if (!data.selector) {
              data.selector = selector;
            }
            data.selectors.push(...selectors);
          }
          if (newIiifRenderingHints) {
            data.iiifRenderingHints = data.iiifRenderingHints || { type: "ImageApiSelector" };
            Object.assign(data.iiifRenderingHints, newIiifRenderingHints);
          }
          return data;
        },
        {
          selector: null,
          selectors: [],
          iiifRenderingHints
        }
      )
    );
  }
  if (!source) {
    return resolveHints({
      selector: null,
      selectors: [],
      iiifRenderingHints
    });
  }
  if (typeof source === "string") {
    const [id, fragment] = source.split("#");
    if (!fragment) {
      return resolveHints({
        selector: null,
        selectors: [],
        iiifRenderingHints
      });
    }
    return parseSelector(
      { type: "FragmentSelector", value: fragment },
      { svgPreprocessor, iiifRenderingHints, domParser }
    );
  }
  if (source.type) {
    if (source.type === "PointSelector" && (source.t || source.t === 0)) {
      const selector = {
        type: "TemporalSelector",
        temporal: {
          startTime: source.t
        }
      };
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
  }
  if (isImageApiSelector(source)) {
    const selectors = [];
    if (source.region) {
      const parsedRegion = parseSelector(
        { type: "FragmentSelector", value: "xywh=" + source.region },
        { domParser, svgPreprocessor, iiifRenderingHints }
      );
      selectors.push(...parsedRegion.selectors);
    }
    return resolveHints({
      selector: selectors[0],
      selectors,
      iiifRenderingHints: iiifRenderingHints ? { ...iiifRenderingHints, ...source } : source
    });
  }
  if (source.type === "FragmentSelector") {
    const matchBoxSelector = BOX_SELECTOR.exec(source.value);
    if (matchBoxSelector) {
      const selector = {
        type: "BoxSelector",
        spatial: {
          unit: matchBoxSelector[2] === "percent:" || matchBoxSelector[2] === "pct:" ? "percent" : "pixel",
          x: parseFloat(matchBoxSelector[3]),
          y: parseFloat(matchBoxSelector[4]),
          width: parseFloat(matchBoxSelector[5]),
          height: parseFloat(matchBoxSelector[6])
        }
      };
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);
    if (matchTimeSelector) {
      const selector = {
        type: "TemporalSelector",
        temporal: {
          startTime: matchTimeSelector[4] ? parseFloat(matchTimeSelector[4]) : 0,
          endTime: matchTimeSelector[7] ? parseFloat(matchTimeSelector[7]) : void 0
        }
      };
      return resolveHints({
        selector,
        selectors: [selector],
        iiifRenderingHints
      });
    }
    return resolveHints({
      selector: null,
      selectors: [],
      iiifRenderingHints
    });
  }
  if (source.type === "SvgSelector" && "value" in source) {
    if (!domParser) {
      if (typeof window !== "undefined") {
        domParser = new window.DOMParser();
      } else {
        console.warn(
          "No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized."
        );
      }
    }
    let points = [];
    let rect;
    let style;
    let svg = (_a = svgPreprocessor == null ? void 0 : svgPreprocessor(source.value)) != null ? _a : source.value;
    let svgShape;
    if (domParser) {
      const svgElement = domParser.parseFromString(source.value, "image/svg+xml").querySelector("svg");
      if (!svgElement) {
        console.warn(`Illegal SVG selector: ${source.value}`);
        return resolveHints({
          selector: null,
          selectors: [],
          iiifRenderingHints
        });
      }
      const selectorElem = getSelectorElement(svgElement);
      if (selectorElem) {
        points = selectorElem.points;
        svgShape = selectorElem.shapeType;
        rect = [
          Math.min(...points.map((p2) => p2[0])),
          Math.min(...points.map((p2) => p2[1])),
          Math.max(...points.map((p2) => p2[0])),
          Math.max(...points.map((p2) => p2[1]))
        ];
        ({ style, svg } = (_b = extractStyles(selectorElem.element)) != null ? _b : { svg });
      }
    }
    const sel = {
      type: "SvgSelector",
      svg,
      svgShape,
      style,
      points: points.length ? points : void 0,
      spatial: rect ? { unit: "pixel", x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] } : void 0
    };
    return resolveHints({
      selector: sel,
      selectors: [sel],
      iiifRenderingHints
    });
  }
  return resolveHints({
    selector: null,
    selectors: [],
    iiifRenderingHints
  });
}
function getShapeTypeFromPath(svgPath) {
  const cmdFrequencies = svgPath.map((seg) => seg[0]).reduce(
    (acc, cmd) => {
      acc[cmd] += 1;
      return acc;
    },
    { C: 0, Q: 0, L: 0, M: 0 }
  );
  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));
  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {
    return "path";
  }
  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || cmdTypes.size === 2 && cmdTypes.has("M"))) {
    if (cmdFrequencies.L === 4) {
      return "rect";
    }
    const lastSeg = svgPath.slice(-1)[0];
    if (svgPath[0][0] === "M" && lastSeg[0] === "L" && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2] || lastSeg[1] === 0 && lastSeg[2] === 0) {
      return "polygon";
    } else {
      return "polyline";
    }
  }
  return "path";
}
function getSelectorElement(svgElem) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  for (const element of Array.from(svgElem.children)) {
    switch (element == null ? void 0 : element.tagName.toLowerCase()) {
      case "g":
        {
          const res = getSelectorElement(element);
          if (res) {
            return res;
          }
        }
        continue;
      case "path": {
        const p2 = element.getAttribute("d");
        if (!p2) {
          continue;
        }
        const normalized = parseAndNormalizeSvgPath(p2);
        return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };
      }
      case "circle": {
        const cx = parseFloat((_a = element.getAttribute("cx")) != null ? _a : "0");
        const cy = parseFloat((_b = element.getAttribute("cy")) != null ? _b : "0");
        const r = parseFloat((_c = element.getAttribute("r")) != null ? _c : "0");
        if (!r) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const rad = angle * Math.PI / 180;
          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);
        }
        return { element, points, shapeType: "circle" };
      }
      case "ellipse": {
        const cx = parseFloat((_d = element.getAttribute("cx")) != null ? _d : "0");
        const cy = parseFloat((_e2 = element.getAttribute("cy")) != null ? _e2 : "0");
        const rx = parseFloat((_f = element.getAttribute("rx")) != null ? _f : "0");
        const ry = parseFloat((_g = element.getAttribute("ry")) != null ? _g : "0");
        if (!rx && !ry) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const t = Math.tan(angle / 360 * Math.PI);
          const px = rx * (1 - t ** 2) / (1 + t ** 2);
          const py = ry * 2 * t / (1 + t ** 2);
          points.push([cx + px, cy + py]);
        }
        return { element, points, shapeType: "ellipse" };
      }
      case "line": {
        const x0 = parseFloat((_h = element.getAttribute("x0")) != null ? _h : "0");
        const y0 = parseFloat((_i = element.getAttribute("y0")) != null ? _i : "0");
        const x1 = parseFloat((_j = element.getAttribute("x1")) != null ? _j : "0");
        const y1 = parseFloat((_k = element.getAttribute("y1")) != null ? _k : "0");
        if (x0 === x1 && y0 === y1) {
          continue;
        }
        return {
          element,
          points: [
            [x0, y0],
            [x1, y1]
          ],
          shapeType: "polyline"
        };
      }
      case "polygon":
      case "polyline": {
        const points = (_m = (_l = element.getAttribute("points")) == null ? void 0 : _l.split(" ").map((ps) => ps.split(",").map(parseFloat))) != null ? _m : [];
        if (!points.length) {
          continue;
        }
        let shapeType = "polyline";
        if (element.tagName.toLowerCase() === "polygon") {
          points.push(points[0]);
          shapeType = "polygon";
        }
        return { element, points, shapeType };
      }
      case "rect": {
        const x2 = parseFloat((_n = element.getAttribute("x")) != null ? _n : "0");
        const y2 = parseFloat((_o = element.getAttribute("y")) != null ? _o : "0");
        const width = parseFloat((_p = element.getAttribute("width")) != null ? _p : "0");
        const height = parseFloat((_q = element.getAttribute("height")) != null ? _q : "0");
        if (!width || !height) {
          continue;
        }
        return {
          element,
          points: [
            [x2, y2],
            [x2 + width, y2],
            [x2 + width, y2 + height],
            [x2, y2 + height],
            [x2, y2]
          ],
          shapeType: "rect"
        };
      }
      default:
        continue;
    }
  }
  return null;
}
function pathToPoints(normalizedPath) {
  var _a;
  const out = [];
  for (let i = 0; i < normalizedPath.length; i++) {
    const startPoint = (_a = out[out.length - 1]) != null ? _a : [0, 0];
    const seg = normalizedPath[i];
    switch (seg[0]) {
      case "M":
      case "L":
        out.push([seg[1], seg[2]]);
        continue;
      case "C":
        out.push(
          ...flattenCubicBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] },
            { x: seg[5], y: seg[6] }
          ).map((p2) => [p2.x, p2.y]).slice(1)
        );
        continue;
      case "Q":
        out.push(
          ...flattenQuadraticBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] }
          ).map((p2) => [p2.x, p2.y]).slice(1)
        );
        continue;
    }
  }
  return out;
}
function extractStyles(selectorElement) {
  const style = {};
  if (selectorElement.hasAttribute("fill")) {
    style.fill = selectorElement.getAttribute("fill");
    selectorElement.removeAttribute("fill");
  } else if (selectorElement.style.fill) {
    style.fill = selectorElement.style.fill;
  }
  if (style.fill) {
    const rgbaMatch = RGBA_COLOR.exec(style.fill);
    if (rgbaMatch) {
      style.fillOpacity = parseFloat(rgbaMatch[4]);
      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("fill-opacity")) {
    style.fillOpacity = parseFloat(selectorElement.getAttribute("fill-opacity"));
    selectorElement.removeAttribute("fill-opacity");
  } else if (selectorElement.style.fillOpacity) {
    style.fillOpacity = parseFloat(selectorElement.style.fillOpacity);
  }
  if (selectorElement.hasAttribute("stroke")) {
    style.stroke = selectorElement.getAttribute("stroke");
    selectorElement.removeAttribute("stroke");
  } else if (selectorElement.style.stroke) {
    style.stroke = selectorElement.style.stroke;
  }
  if (style.stroke) {
    const rgbaMatch = RGBA_COLOR.exec(style.stroke);
    if (rgbaMatch) {
      style.strokeOpacity = parseFloat(rgbaMatch[4]);
      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("stroke-opacity")) {
    style.strokeOpacity = parseFloat(selectorElement.getAttribute("stroke-opacity"));
    selectorElement.removeAttribute("stroke-opacity");
  } else if (selectorElement.style.strokeOpacity) {
    style.strokeOpacity = parseFloat(selectorElement.style.strokeOpacity);
  }
  if (selectorElement.hasAttribute("stroke-width")) {
    style.strokeWidth = selectorElement.getAttribute("stroke-width");
    selectorElement.removeAttribute("stroke-width");
  } else if (selectorElement.style.strokeWidth) {
    style.strokeWidth = selectorElement.style.strokeWidth;
  }
  if (selectorElement.hasAttribute("stroke-dasharray")) {
    style.strokeDasharray = selectorElement.getAttribute("stroke-dasharray");
    selectorElement.removeAttribute("stroke-dasharray");
  } else if (selectorElement.style.strokeDasharray) {
    style.strokeDasharray = selectorElement.style.strokeDasharray;
  }
  let rootElem = selectorElement;
  while (rootElem.tagName.toLowerCase() !== "svg") {
    rootElem = rootElem.parentElement;
    if (rootElem === null) {
      throw new Error("Could not find root SVG element");
    }
  }
  return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : void 0 };
}
function isImageApiSelector(t) {
  return !!t && t.type === "iiif:ImageApiSelector" && t.type === "iiif:ImageApiSelector";
}
function resolveHints(supported) {
  if (supported.iiifRenderingHints) {
    const source = supported.iiifRenderingHints;
    if (source.rotation) {
      const parsedRotation = parseRotation(source.rotation);
      if (parsedRotation) {
        if (supported.selectors.length) {
          for (const selector of supported.selectors) {
            selector.rotation = parsedRotation;
          }
        } else {
          supported.selectors.push({
            type: "RotationSelector",
            rotation: parsedRotation
          });
        }
      }
    }
  } else {
    delete supported.iiifRenderingHints;
  }
  return supported;
}
function parseRotation(input) {
  let num = parseFloat(input);
  if (num && input.startsWith("!")) {
    num = 360 - num;
  }
  if (num) {
    num = num % 360;
  }
  if (num !== num) {
    return 0;
  }
  return num || 0;
}
function expandTarget(target, options = {}) {
  if (Array.isArray(target)) {
    return expandTarget(target[0]);
  }
  if (typeof target === "string") {
    const [id, fragment] = target.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: { id, type: options.typeMap && options.typeMap[id] || "Unknown" },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: { id, type: "Unknown" },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  if (target.type === "Choice" || target.type === "List" || target.type === "Composite" || target.type === "Independents") {
    return expandTarget(target.items[0]);
  }
  if (target.type === "SpecificResource") {
    if (target.source.type === "Canvas" && target.source.partOf && typeof target.source.partOf === "string") {
      target.source.partOf = [
        {
          id: target.source.partOf,
          type: "Manifest"
        }
      ];
    }
    const { selector, selectors } = target.selector ? parseSelector(target.selector, options) : { selector: null, selectors: [] };
    return {
      type: "SpecificResource",
      source: target.source,
      selector,
      selectors
    };
  }
  if (target.id) {
    if (target.type === "Canvas" && target.partOf && typeof target.partOf === "string") {
      target.partOf = [
        {
          id: target.partOf,
          type: "Manifest"
        }
      ];
    }
    const [id, fragment] = target.id.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: {
          ...target,
          id
        },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: {
        ...target,
        id
      },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  return {
    type: "SpecificResource",
    source: target,
    selector: null,
    selectors: []
  };
}
function validateContentState(annotation, strict = false) {
  if (typeof annotation === "string") {
    if (annotation.startsWith("{")) {
      try {
        const parsed = JSON.parse(annotation);
        return validateContentState(parsed);
      } catch (err) {
        return [false, { reason: "Invalid JSON" }];
      }
    }
    return [true];
  }
  if (Array.isArray(annotation)) {
    for (const anno of annotation) {
      const [valid, reason] = validateContentState(anno);
      if (!valid && reason) {
        return [valid, reason];
      }
    }
    return [true];
  }
  if (annotation.type === "Annotation") {
    return [true];
  }
  if (strict && annotation.type === "Canvas" && !annotation.partOf) {
    return [false, { reason: "Canvas without partOf cannot be loaded" }];
  }
  return [true];
}
function serialiseContentState(annotation) {
  return encodeContentState(typeof annotation === "string" ? annotation : JSON.stringify(annotation));
}
function parseContentState(state, asyncOrFetcher) {
  state = state.trim();
  if (state[0] === "{") {
    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);
  }
  if (state.startsWith("http")) {
    if (!asyncOrFetcher) {
      throw new Error("Cannot fetch remote fetch with async=false in parseContentState");
    }
    return fetch(state).then((r) => r.json());
  }
  return parseContentState(decodeContentState(state), asyncOrFetcher);
}
function encodeContentState(state) {
  const uriEncoded = encodeURIComponent(state);
  const base64 = typeof btoa === "undefined" ? Buffer.from(uriEncoded, "utf-8").toString("base64") : btoa(uriEncoded);
  const base64url = base64.replace(/\+/g, "-").replace(/\//g, "_");
  return base64url.replace(/=/g, "");
}
function decodeContentState(encodedContentState) {
  const base64url = restorePadding(encodedContentState);
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const base64Decoded = typeof atob === "undefined" ? Buffer.from(base64, "base64").toString("utf-8") : atob(base64);
  return decodeURIComponent(base64Decoded).trim();
}
function restorePadding(s) {
  const pad = s.length % 4;
  if (pad === 1) {
    throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");
  }
  return s + (pad ? "====".slice(0, 4 - pad) : "");
}
function normaliseContentState(state) {
  if (!state) {
    throw new Error("Content state is empty");
  }
  if (!Array.isArray(state)) {
    state = [state];
  }
  let annoId = "vault://virtual-annotation/" + new Date().getTime();
  const targets = [];
  for (const source of state) {
    if (typeof source === "string") {
      throw new Error("Content state is a [String] type and cannot be inferred");
    }
    if (source.type === "Annotation") {
      annoId = source.id;
      if (Array.isArray(source.motivation)) {
        for (const singleMotivation of source.motivation) {
        }
      }
      if (Array.isArray(source.target)) {
        for (const target2 of source.target) {
          const expanded = expandTarget(target2);
          targets.push(expanded);
        }
      } else {
        const expanded = expandTarget(source.target);
        targets.push(expanded);
      }
      continue;
    }
    const target = expandTarget(source);
    targets.push(target);
  }
  return {
    id: annoId,
    type: "Annotation",
    motivation: ["contentState", ...state.motivation || []],
    target: targets,
    extensions: {}
  };
}
function parseSpecificResource(resource) {
  if (resource.type === "SpecificResource") {
    return [resource.source, { selector: resource.selector }];
  }
  return [resource, { selector: null }];
}
function createPaintingAnnotationsHelper(vault = compatVault) {
  function getAllPaintingAnnotations(canvasOrId) {
    const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
    if (!canvas) {
      return [];
    }
    const annotationPages = vault.get(canvas.items);
    const flatAnnotations = [];
    for (const page of annotationPages) {
      flatAnnotations.push(...vault.get(page.items));
    }
    return flatAnnotations;
  }
  function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
    const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
    const types = [];
    let choice = null;
    const items = [];
    for (const annotation of paintingAnnotations) {
      if (annotation.type !== "Annotation") {
        throw new Error(`getPaintables() accept either a canvas or list of annotations`);
      }
      const unknownBodies = vault.get(annotation.body);
      const bodies = Array.isArray(unknownBodies) ? unknownBodies : [unknownBodies];
      for (const unknownBody of bodies) {
        const [body, { selector }] = parseSpecificResource(unknownBody);
        const type = (body.type || "unknown").toLowerCase();
        if (type === "choice") {
          const nestedBodies = vault.get(body.items);
          const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b2) => b2.id === cid)).filter(Boolean) : [nestedBodies[0]];
          if (selected.length === 0) {
            selected.push(nestedBodies[0]);
          }
          choice = {
            type: "single-choice",
            items: nestedBodies.map((b2) => ({
              id: b2.id,
              label: b2.label,
              selected: selected.indexOf(b2) !== -1
            })),
            label: unknownBody.label
          };
          bodies.push(...selected);
          continue;
        }
        if (types.indexOf(type) === -1) {
          types.push(type);
        }
        items.push({
          type,
          resource: body,
          target: annotation.target,
          selector
        });
      }
    }
    return {
      types,
      items,
      choice
    };
  }
  function extractChoices(paintingAnnotationsOrCanvas) {
    const { choice } = getPaintables(paintingAnnotationsOrCanvas);
    return choice;
  }
  return {
    getAllPaintingAnnotations,
    getPaintables,
    extractChoices
  };
}
function defineProperty(name, prototype, vault) {
  prototype[DEFINED] = prototype[DEFINED] || [];
  prototype[DEFINED].push(name);
  Object.defineProperty(prototype, name, {
    get() {
      if (typeof prototype[REFS][name] === "undefined") {
        return void 0;
      }
      const ref = prototype[REFS][name];
      if (!ref) {
        return ref;
      }
      return wrapObject(vault.get(prototype[REFS][name]), vault);
    },
    set(items) {
      const existing = prototype[REFS][name];
      if (existing !== items) {
        this[REFS][name] = items;
      }
    }
  });
}
const REFS = Symbol.for("_refs_");
const REACTIVE = Symbol.for("_reactive_");
const DEFINED = Symbol.for("_defined_");
function createPrototype(vault, reactive = false) {
  const prototype = {
    id: null,
    [DEFINED]: [],
    [REFS]: {},
    [REACTIVE]: null,
    is(refOrObject) {
      if (typeof refOrObject === "string") {
        return this.id === refOrObject;
      }
      if (refOrObject.id) {
        return refOrObject.id === this.id;
      }
      return false;
    },
    reactive() {
      if (this[REACTIVE]) {
        return;
      }
      this[REACTIVE] = this.subscribe(() => this.refresh(), true);
      return () => {
        this.unreactive();
      };
    },
    refresh() {
      if (this.id) {
        const fresh = this.unwrap();
        for (const key of Object.keys(fresh || {})) {
          if (this[DEFINED].includes(key)) {
            this[REFS][key] = fresh[key];
          } else {
            this[key] = fresh[key];
          }
        }
      }
    },
    unreactive() {
      if (this[REACTIVE]) {
        this[REACTIVE]();
        this[REACTIVE] = null;
      }
    },
    unwrap() {
      if (!this.id) {
        throw new Error("Invalid object");
      }
      return vault.get(this.id);
    },
    toPresentation3() {
      return vault.toPresentation3(this.unwrap());
    },
    toPresentation2() {
      return vault.toPresentation2(this.unwrap());
    },
    toJSON() {
      const that = this;
      return {
        ...that,
        items: that.items,
        annotations: that.annotations,
        structures: that.structures,
        seeAlso: that.seeAlso,
        service: that.service,
        services: that.services,
        rendering: that.rendering,
        partOf: that.partOf,
        start: that.start,
        supplementary: that.supplementary,
        homepage: that.homepage,
        thumbnail: that.thumbnail,
        placeholderCanvas: that.placeholderCanvas,
        accompanyingCanvas: that.accompanyingCanvas,
        provider: that.provider
      };
    },
    subscribe(subscription, skipInitial = true) {
      return vault.subscribe(
        () => {
          return this.id ? vault.get(this.id) : null;
        },
        subscription,
        skipInitial
      );
    }
  };
  defineProperty("items", prototype, vault);
  defineProperty("annotations", prototype, vault);
  defineProperty("structures", prototype, vault);
  defineProperty("seeAlso", prototype, vault);
  defineProperty("service", prototype, vault);
  defineProperty("services", prototype, vault);
  defineProperty("rendering", prototype, vault);
  defineProperty("partOf", prototype, vault);
  defineProperty("start", prototype, vault);
  defineProperty("supplementary", prototype, vault);
  defineProperty("homepage", prototype, vault);
  defineProperty("thumbnail", prototype, vault);
  defineProperty("placeholderCanvas", prototype, vault);
  defineProperty("accompanyingCanvas", prototype, vault);
  defineProperty("provider", prototype, vault);
  defineProperty("body", prototype, vault);
  defineProperty("logo", prototype, vault);
  return prototype;
}
function unwrapObject(object) {
  if (Array.isArray(object)) {
    return object.map((o) => unwrapObject(o));
  }
  if (!object || !object.type) {
    return object;
  }
  return { id: object.id, type: object.type };
}
function wrapObject(object, vault, reactive = false) {
  if (Array.isArray(object)) {
    return object.map((o) => wrapObject(o, vault, reactive));
  }
  if (!object || !object.type || !object.id) {
    return object;
  }
  const prototype = createPrototype(vault, reactive);
  const newObject = Object.create(prototype);
  const wrapped = Object.assign(newObject, object);
  if (reactive) {
    wrapped.reactive();
  }
  return wrapped;
}
function createObjectsHelper(vault) {
  return {
    get(id, reactive = false) {
      return wrapObject(vault.get(id), vault, reactive);
    },
    async load(id, json) {
      return wrapObject(await vault.load(id, json), vault);
    },
    async loadManifest(id, json) {
      return wrapObject(await vault.loadManifest(id, json), vault);
    },
    async loadCollection(id, json) {
      return wrapObject(await vault.loadCollection(id, json), vault);
    },
    wrapObject(objectType) {
      return wrapObject(vault.get(objectType, { skipSelfReturn: false }), vault);
    },
    isWrapped(object) {
      return !!object[DEFINED];
    }
  };
}
function createRangeHelper(vault = compatVault) {
  return {
    findFirstCanvasFromRange: (range) => findFirstCanvasFromRange(vault, range),
    findAllCanvasesInRange: (range) => findAllCanvasesInRange(vault, range),
    findManifestSelectedRange: (manifest, canvasId) => findManifestSelectedRange(vault, manifest, canvasId),
    findSelectedRange: (range, canvasId) => findSelectedRange(vault, range, canvasId)
  };
}
function findFirstCanvasFromRange(vault, range) {
  for (const inner of range.items) {
    if (inner.type === "Canvas") {
      return inner;
    }
    if (inner.type === "Range") {
      const found = findFirstCanvasFromRange(vault, vault.get(inner));
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findAllCanvasesInRange(vault, range) {
  const found = [];
  for (const inner of range.items) {
    if (inner.type === "Canvas") {
      if (inner.id.indexOf("#") !== -1) {
        found.push({ id: inner.id.split("#")[0], type: "Canvas" });
      } else {
        found.push(inner);
      }
    }
    if (inner.type === "Range") {
      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));
    }
    if (inner.type === "SpecificResource") {
      const sourceId = typeof inner.source === "string" ? inner.source : inner.source.id;
      found.push({ id: sourceId, type: "Canvas" });
    }
  }
  return found;
}
function findManifestSelectedRange(vault, manifest, canvasId) {
  for (const range of manifest.structures) {
    const found = findSelectedRange(vault, vault.get(range), canvasId);
    if (found) {
      return found;
    }
  }
  return null;
}
function findSelectedRange(vault, range, canvasId) {
  var _a;
  for (const inner of range.items) {
    const parsedId = (_a = inner.id) == null ? void 0 : _a.split("#")[0];
    if (inner.type === "SpecificResource" && inner.source === canvasId) {
      return range;
    }
    if (inner.type === "Canvas" && canvasId === parsedId) {
      return range;
    }
    if (inner.type === "Range") {
      const found = findSelectedRange(vault, vault.get(inner), canvasId);
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function createSequenceHelper(vault = compatVault) {
  return {
    getVisibleCanvasesFromCanvasId: (manifestOrRange, canvasId, preventPaged = false) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),
    getManifestSequence: (manifestOrRange, options = {}) => getManifestSequence(vault, manifestOrRange, options)
  };
}
function getVisibleCanvasesFromCanvasId(vault = compatVault, manifestOrRange, canvasId, preventPaged = false) {
  const behavior = manifestOrRange.behavior || [];
  const fullCanvas = canvasId ? vault.get(canvasId) : null;
  if (!fullCanvas) {
    return [];
  }
  const canvasBehavior = fullCanvas.behavior || [];
  const isPaged = preventPaged ? false : behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const isCanvasFacingPages = canvasBehavior.includes("facing-pages");
  const isCanvasNonPaged = canvasBehavior.includes("non-paged");
  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {
    return [{ id: fullCanvas.id, type: "Canvas" }];
  }
  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);
  if (isContinuous) {
    return manifestItems;
  }
  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);
  if (canvasIndex === -1) {
    return [];
  }
  for (const indexes of ordering) {
    if (indexes.includes(canvasIndex)) {
      return indexes.map((index) => manifestItems[index]);
    }
  }
  return [{ id: fullCanvas.id, type: "Canvas" }];
}
function getManifestSequence(vault = compatVault, manifestOrRange, { disablePaging, skipNonPaged } = {}) {
  const behavior = manifestOrRange.behavior || [];
  const isPaged = behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const manifestItems = manifestOrRange.type === "Manifest" ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);
  if (isContinuous) {
    return [manifestItems, [manifestItems.map((_2, index) => index)]];
  }
  if (isIndividuals || !isPaged || disablePaging) {
    return [manifestItems, manifestItems.map((_2, index) => [index])];
  }
  const ordering = [];
  let currentOrdering = [];
  const flush = () => {
    if (currentOrdering.length) {
      ordering.push([...currentOrdering]);
      currentOrdering = [];
    }
  };
  let offset = 0;
  let flushNextPaged = false;
  for (let i = 0; i < manifestItems.length; i++) {
    const canvas = vault.get(manifestItems[i]);
    const canvasBehavior = canvas.behavior || [];
    if (canvasBehavior.includes("non-paged")) {
      if (i === offset) {
        offset++;
      }
      if (!skipNonPaged) {
        flush();
        ordering.push([i]);
        flush();
      }
      continue;
    }
    if (i === offset || canvasBehavior.includes("facing-pages")) {
      if (currentOrdering.length) {
        flushNextPaged = true;
      }
      flush();
      ordering.push([i]);
      flush();
      continue;
    }
    currentOrdering.push(i);
    if (flushNextPaged) {
      flush();
      flushNextPaged = false;
      continue;
    }
    if (currentOrdering.length > 1) {
      flush();
    }
  }
  if (currentOrdering.length) {
    flush();
  }
  return [manifestItems, ordering];
}
export { buildLocaleString, createEventsHelper, createObjectsHelper, createPaintingAnnotationsHelper, createRangeHelper, createSequenceHelper, createStylesHelper, createThumbnailHelper, decodeContentState, encodeContentState, expandTarget, findAllCanvasesInRange, findFirstCanvasFromRange, findManifestSelectedRange, findSelectedRange, getClosestLanguage, getManifestSequence, getValue, getVisibleCanvasesFromCanvasId, isImageApiSelector, normaliseContentState, parseContentState, parseRotation, parseSelector, parseSpecificResource, serialiseContentState, unwrapObject, validateContentState, wrapObject };
//# sourceMappingURL=index.mjs.map
