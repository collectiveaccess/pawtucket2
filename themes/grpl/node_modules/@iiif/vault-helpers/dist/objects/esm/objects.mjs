function defineProperty(name, prototype, vault) {
  prototype[DEFINED] = prototype[DEFINED] || [];
  prototype[DEFINED].push(name);
  Object.defineProperty(prototype, name, {
    get() {
      if (typeof prototype[REFS][name] === "undefined") {
        return void 0;
      }
      const ref = prototype[REFS][name];
      if (!ref) {
        return ref;
      }
      return wrapObject(vault.get(prototype[REFS][name]), vault);
    },
    set(items) {
      const existing = prototype[REFS][name];
      if (existing !== items) {
        this[REFS][name] = items;
      }
    }
  });
}
const REFS = Symbol.for("_refs_");
const REACTIVE = Symbol.for("_reactive_");
const DEFINED = Symbol.for("_defined_");
function createPrototype(vault, reactive = false) {
  const prototype = {
    id: null,
    [DEFINED]: [],
    [REFS]: {},
    [REACTIVE]: null,
    is(refOrObject) {
      if (typeof refOrObject === "string") {
        return this.id === refOrObject;
      }
      if (refOrObject.id) {
        return refOrObject.id === this.id;
      }
      return false;
    },
    reactive() {
      if (this[REACTIVE]) {
        return;
      }
      this[REACTIVE] = this.subscribe(() => this.refresh(), true);
      return () => {
        this.unreactive();
      };
    },
    refresh() {
      if (this.id) {
        const fresh = this.unwrap();
        for (const key of Object.keys(fresh || {})) {
          if (this[DEFINED].includes(key)) {
            this[REFS][key] = fresh[key];
          } else {
            this[key] = fresh[key];
          }
        }
      }
    },
    unreactive() {
      if (this[REACTIVE]) {
        this[REACTIVE]();
        this[REACTIVE] = null;
      }
    },
    unwrap() {
      if (!this.id) {
        throw new Error("Invalid object");
      }
      return vault.get(this.id);
    },
    toPresentation3() {
      return vault.toPresentation3(this.unwrap());
    },
    toPresentation2() {
      return vault.toPresentation2(this.unwrap());
    },
    toJSON() {
      const that = this;
      return {
        ...that,
        items: that.items,
        annotations: that.annotations,
        structures: that.structures,
        seeAlso: that.seeAlso,
        service: that.service,
        services: that.services,
        rendering: that.rendering,
        partOf: that.partOf,
        start: that.start,
        supplementary: that.supplementary,
        homepage: that.homepage,
        thumbnail: that.thumbnail,
        placeholderCanvas: that.placeholderCanvas,
        accompanyingCanvas: that.accompanyingCanvas,
        provider: that.provider
      };
    },
    subscribe(subscription, skipInitial = true) {
      return vault.subscribe(
        () => {
          return this.id ? vault.get(this.id) : null;
        },
        subscription,
        skipInitial
      );
    }
  };
  defineProperty("items", prototype, vault);
  defineProperty("annotations", prototype, vault);
  defineProperty("structures", prototype, vault);
  defineProperty("seeAlso", prototype, vault);
  defineProperty("service", prototype, vault);
  defineProperty("services", prototype, vault);
  defineProperty("rendering", prototype, vault);
  defineProperty("partOf", prototype, vault);
  defineProperty("start", prototype, vault);
  defineProperty("supplementary", prototype, vault);
  defineProperty("homepage", prototype, vault);
  defineProperty("thumbnail", prototype, vault);
  defineProperty("placeholderCanvas", prototype, vault);
  defineProperty("accompanyingCanvas", prototype, vault);
  defineProperty("provider", prototype, vault);
  defineProperty("body", prototype, vault);
  defineProperty("logo", prototype, vault);
  return prototype;
}
function unwrapObject(object) {
  if (Array.isArray(object)) {
    return object.map((o) => unwrapObject(o));
  }
  if (!object || !object.type) {
    return object;
  }
  return { id: object.id, type: object.type };
}
function wrapObject(object, vault, reactive = false) {
  if (Array.isArray(object)) {
    return object.map((o) => wrapObject(o, vault, reactive));
  }
  if (!object || !object.type || !object.id) {
    return object;
  }
  const prototype = createPrototype(vault, reactive);
  const newObject = Object.create(prototype);
  const wrapped = Object.assign(newObject, object);
  if (reactive) {
    wrapped.reactive();
  }
  return wrapped;
}
function createObjectsHelper(vault) {
  return {
    get(id, reactive = false) {
      return wrapObject(vault.get(id), vault, reactive);
    },
    async load(id, json) {
      return wrapObject(await vault.load(id, json), vault);
    },
    async loadManifest(id, json) {
      return wrapObject(await vault.loadManifest(id, json), vault);
    },
    async loadCollection(id, json) {
      return wrapObject(await vault.loadCollection(id, json), vault);
    },
    wrapObject(objectType) {
      return wrapObject(vault.get(objectType, { skipSelfReturn: false }), vault);
    },
    isWrapped(object) {
      return !!object[DEFINED];
    }
  };
}
export { createObjectsHelper, unwrapObject, wrapObject };
//# sourceMappingURL=objects.mjs.map
