import { ImageServiceLoader, getFixedSizeFromImage } from "@atlas-viewer/iiif-image-api";
const metaState = {};
const compatVault = {
  get(nonRef) {
    return nonRef;
  },
  setMetaValue([id, meta, key], value) {
    const oldValue = compatVault.getResourceMeta(id, meta);
    const oldValueItem = oldValue ? oldValue[key] : void 0;
    const newValue = typeof value === "function" ? value(oldValueItem) : value;
    metaState[id] = {
      ...metaState[id] || {},
      [meta]: {
        ...(metaState[id] || {})[meta] || {},
        [key]: newValue
      }
    };
  },
  getResourceMeta: (resource, metaKey) => {
    const resourceMeta = metaState[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
};
function createThumbnailHelper(vault = compatVault, dependencies = {}) {
  const imageServiceLoader = dependencies.imageServiceLoader || new ImageServiceLoader();
  async function getBestThumbnailAtSize(input, request, dereference, candidates = [], dimensions) {
    const thumbnailNotFound = () => imageServiceLoader.getThumbnailFromResource(void 0, request, dereference, candidates);
    if (!input) {
      return await imageServiceLoader.getThumbnailFromResource(void 0, request, dereference, candidates);
    }
    if (typeof input === "string") {
      const fixed = getFixedSizeFromImage(input);
      if (fixed) {
        candidates.push(fixed);
      }
      return await imageServiceLoader.getThumbnailFromResource(void 0, request, dereference, candidates);
    }
    const fullInput = vault.get(input, { skipSelfReturn: false });
    if (typeof fullInput === "string") {
      return { best: getFixedSizeFromImage(fullInput), fallback: [], log: [] };
    }
    if (!fullInput) {
      return await thumbnailNotFound();
    }
    const parseThumbnail = async (resource) => {
      if (resource && resource.thumbnail && resource.thumbnail.length) {
        const thumbnail = vault.get(resource.thumbnail[0]);
        const potentialThumbnails = await imageServiceLoader.getImageCandidates(thumbnail, dereference);
        if (potentialThumbnails && potentialThumbnails.length) {
          candidates.push(...potentialThumbnails);
        }
      }
    };
    await parseThumbnail(fullInput);
    switch (fullInput.type) {
      case "Annotation": {
        const contentResources = Array.isArray(fullInput.body) ? fullInput.body : [fullInput.body];
        const firstContentResources = vault.get(contentResources[0]);
        if (dimensions && !firstContentResources.width) {
          firstContentResources.width = dimensions.width;
          firstContentResources.height = dimensions.height;
        }
        return await imageServiceLoader.getThumbnailFromResource(
          firstContentResources,
          request,
          dereference,
          candidates
        );
      }
      case "Canvas": {
        const canvas = fullInput;
        return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {
          width: canvas.width,
          height: canvas.height
        });
      }
      case "AnnotationPage": {
        const annotationPage = fullInput;
        return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);
      }
      case "Choice": {
        const choice = fullInput;
        if (!choice.items || choice.items[0]) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(choice.items[0], request, dereference, candidates, dimensions);
      }
      case "Collection": {
        const collection = fullInput;
        const firstManifest = collection.items[0];
        if (!firstManifest) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);
      }
      case "Manifest": {
        const manifest = fullInput;
        const firstCanvas = manifest.items[0];
        if (!firstCanvas) {
          return await thumbnailNotFound();
        }
        return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);
      }
      case "SpecificResource":
      case "Image":
      case "Dataset":
      case "Sound":
      case "Text":
      case "TextualBody":
      case "Video":
        if (dimensions && !fullInput.width) {
          fullInput.width = dimensions.width;
          fullInput.height = dimensions.height;
        }
        return imageServiceLoader.getThumbnailFromResource(fullInput, request, dereference, candidates);
      case "Service":
      case "Range":
      case "AnnotationCollection":
      case "CanvasReference":
      case "ContentResource":
        return await thumbnailNotFound();
    }
    return await thumbnailNotFound();
  }
  return {
    getBestThumbnailAtSize
  };
}
export { createThumbnailHelper };
//# sourceMappingURL=thumbnail.mjs.map
