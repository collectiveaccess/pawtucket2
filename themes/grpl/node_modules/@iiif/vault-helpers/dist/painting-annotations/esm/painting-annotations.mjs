function parseSpecificResource(resource) {
  if (resource.type === "SpecificResource") {
    return [resource.source, { selector: resource.selector }];
  }
  return [resource, { selector: null }];
}
const metaState = {};
const compatVault = {
  get(nonRef) {
    return nonRef;
  },
  setMetaValue([id, meta, key], value) {
    const oldValue = compatVault.getResourceMeta(id, meta);
    const oldValueItem = oldValue ? oldValue[key] : void 0;
    const newValue = typeof value === "function" ? value(oldValueItem) : value;
    metaState[id] = {
      ...metaState[id] || {},
      [meta]: {
        ...(metaState[id] || {})[meta] || {},
        [key]: newValue
      }
    };
  },
  getResourceMeta: (resource, metaKey) => {
    const resourceMeta = metaState[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
};
function createPaintingAnnotationsHelper(vault = compatVault) {
  function getAllPaintingAnnotations(canvasOrId) {
    const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
    if (!canvas) {
      return [];
    }
    const annotationPages = vault.get(canvas.items);
    const flatAnnotations = [];
    for (const page of annotationPages) {
      flatAnnotations.push(...vault.get(page.items));
    }
    return flatAnnotations;
  }
  function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
    const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
    const types = [];
    let choice = null;
    const items = [];
    for (const annotation of paintingAnnotations) {
      if (annotation.type !== "Annotation") {
        throw new Error(`getPaintables() accept either a canvas or list of annotations`);
      }
      const unknownBodies = vault.get(annotation.body);
      const bodies = Array.isArray(unknownBodies) ? unknownBodies : [unknownBodies];
      for (const unknownBody of bodies) {
        const [body, { selector }] = parseSpecificResource(unknownBody);
        const type = (body.type || "unknown").toLowerCase();
        if (type === "choice") {
          const nestedBodies = vault.get(body.items);
          const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b) => b.id === cid)).filter(Boolean) : [nestedBodies[0]];
          if (selected.length === 0) {
            selected.push(nestedBodies[0]);
          }
          choice = {
            type: "single-choice",
            items: nestedBodies.map((b) => ({
              id: b.id,
              label: b.label,
              selected: selected.indexOf(b) !== -1
            })),
            label: unknownBody.label
          };
          bodies.push(...selected);
          continue;
        }
        if (types.indexOf(type) === -1) {
          types.push(type);
        }
        items.push({
          type,
          resource: body,
          target: annotation.target,
          selector
        });
      }
    }
    return {
      types,
      items,
      choice
    };
  }
  function extractChoices(paintingAnnotationsOrCanvas) {
    const { choice } = getPaintables(paintingAnnotationsOrCanvas);
    return choice;
  }
  return {
    getAllPaintingAnnotations,
    getPaintables,
    extractChoices
  };
}
export { createPaintingAnnotationsHelper, parseSpecificResource };
//# sourceMappingURL=painting-annotations.mjs.map
