const metaState = {};
const compatVault = {
  get(nonRef) {
    return nonRef;
  },
  setMetaValue([id, meta, key], value) {
    const oldValue = compatVault.getResourceMeta(id, meta);
    const oldValueItem = oldValue ? oldValue[key] : void 0;
    const newValue = typeof value === "function" ? value(oldValueItem) : value;
    metaState[id] = {
      ...metaState[id] || {},
      [meta]: {
        ...(metaState[id] || {})[meta] || {},
        [key]: newValue
      }
    };
  },
  getResourceMeta: (resource, metaKey) => {
    const resourceMeta = metaState[resource];
    if (!resourceMeta) {
      return void 0;
    }
    if (!metaKey) {
      return resourceMeta;
    }
    return resourceMeta[metaKey];
  }
};
function createEventsHelper(vault = compatVault) {
  return {
    addEventListener(resource, event, listener, scope) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          const callbacks = registeredCallbacks || [];
          for (const registered of callbacks) {
            if (registered.callback === listener) {
              return callbacks;
            }
          }
          return [...callbacks, { callback: listener, scope }];
        }
      );
      return listener;
    },
    removeEventListener(resource, event, listener) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);
        }
      );
    },
    getListenersAsProps(resourceOrId, scope) {
      const resource = typeof resourceOrId === "string" ? { id: resourceOrId } : resourceOrId;
      if (!resource || !resource.id) {
        return {};
      }
      const hooks = vault.getResourceMeta(resource.id, "eventManager");
      const props = {};
      if (hooks && resource) {
        for (const hook of Object.keys(hooks)) {
          props[hook] = (e) => {
            const fullResource = vault.get(resource);
            for (const { callback, scope: _scope } of hooks[hook] || []) {
              if (!_scope || scope && _scope.indexOf(scope) !== -1) {
                callback(e, fullResource);
              }
            }
          };
        }
      }
      return props;
    }
  };
}
export { createEventsHelper };
//# sourceMappingURL=events.mjs.map
