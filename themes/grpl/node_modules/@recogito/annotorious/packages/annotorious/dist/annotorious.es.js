function N() {
}
function Wt(e, t) {
  for (const n in t)
    e[n] = t[n];
  return e;
}
function Rt(e) {
  return e();
}
function lt() {
  return /* @__PURE__ */ Object.create(null);
}
function ie(e) {
  e.forEach(Rt);
}
function z(e) {
  return typeof e == "function";
}
function q(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function Jt(e) {
  return Object.keys(e).length === 0;
}
function Xt(e, ...t) {
  if (e == null)
    return N;
  const n = e.subscribe(...t);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function at(e, t, n) {
  e.$$.on_destroy.push(Xt(t, n));
}
function Qt(e, t, n, o) {
  if (e) {
    const i = Dt(e, t, n, o);
    return e[0](i);
  }
}
function Dt(e, t, n, o) {
  return e[1] && o ? Wt(n.ctx.slice(), e[1](o(t))) : n.ctx;
}
function Zt(e, t, n, o) {
  if (e[2] && o) {
    const i = e[2](o(n));
    if (t.dirty === void 0)
      return i;
    if (typeof i == "object") {
      const s = [], r = Math.max(t.dirty.length, i.length);
      for (let a = 0; a < r; a += 1)
        s[a] = t.dirty[a] | i[a];
      return s;
    }
    return t.dirty | i;
  }
  return t.dirty;
}
function Kt(e, t, n, o, i, s) {
  if (i) {
    const r = Dt(t, n, o, s);
    e.p(r, i);
  }
}
function xt(e) {
  if (e.ctx.length > 32) {
    const t = [], n = e.ctx.length / 32;
    for (let o = 0; o < n; o++)
      t[o] = -1;
    return t;
  }
  return -1;
}
function re(e, t) {
  e.appendChild(t);
}
function B(e, t, n) {
  e.insertBefore(t, n || null);
}
function L(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function tt(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function P(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function Gt(e) {
  return document.createTextNode(e);
}
function x() {
  return Gt(" ");
}
function se() {
  return Gt("");
}
function V(e, t, n, o) {
  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);
}
function f(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
function $t(e) {
  return Array.from(e.childNodes);
}
function ct(e, t, n) {
  e.classList[n ? "add" : "remove"](t);
}
function en(e, t, { bubbles: n = !1, cancelable: o = !1 } = {}) {
  const i = document.createEvent("CustomEvent");
  return i.initCustomEvent(e, n, o, t), i;
}
let ve;
function Se(e) {
  ve = e;
}
function Nt() {
  if (!ve)
    throw new Error("Function called outside component initialization");
  return ve;
}
function Me(e) {
  Nt().$$.on_mount.push(e);
}
function be() {
  const e = Nt();
  return (t, n, { cancelable: o = !1 } = {}) => {
    const i = e.$$.callbacks[t];
    if (i) {
      const s = en(t, n, { cancelable: o });
      return i.slice().forEach((r) => {
        r.call(e, s);
      }), !s.defaultPrevented;
    }
    return !0;
  };
}
function _e(e, t) {
  const n = e.$$.callbacks[t.type];
  n && n.slice().forEach((o) => o.call(this, t));
}
const ge = [], we = [];
let ye = [];
const ft = [], tn = /* @__PURE__ */ Promise.resolve();
let $e = !1;
function nn() {
  $e || ($e = !0, tn.then(Ut));
}
function et(e) {
  ye.push(e);
}
const We = /* @__PURE__ */ new Set();
let de = 0;
function Ut() {
  if (de !== 0)
    return;
  const e = ve;
  do {
    try {
      for (; de < ge.length; ) {
        const t = ge[de];
        de++, Se(t), on(t.$$);
      }
    } catch (t) {
      throw ge.length = 0, de = 0, t;
    }
    for (Se(null), ge.length = 0, de = 0; we.length; )
      we.pop()();
    for (let t = 0; t < ye.length; t += 1) {
      const n = ye[t];
      We.has(n) || (We.add(n), n());
    }
    ye.length = 0;
  } while (ge.length);
  for (; ft.length; )
    ft.pop()();
  $e = !1, We.clear(), Se(e);
}
function on(e) {
  if (e.fragment !== null) {
    e.update(), ie(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(et);
  }
}
function sn(e) {
  const t = [], n = [];
  ye.forEach((o) => e.indexOf(o) === -1 ? t.push(o) : n.push(o)), n.forEach((o) => o()), ye = t;
}
const Ge = /* @__PURE__ */ new Set();
let ce;
function ne() {
  ce = {
    r: 0,
    c: [],
    p: ce
    // parent group
  };
}
function oe() {
  ce.r || ie(ce.c), ce = ce.p;
}
function Y(e, t) {
  e && e.i && (Ge.delete(e), e.i(t));
}
function D(e, t, n, o) {
  if (e && e.o) {
    if (Ge.has(e))
      return;
    Ge.add(e), ce.c.push(() => {
      Ge.delete(e), o && (n && e.d(1), o());
    }), e.o(t);
  } else
    o && o();
}
function ue(e) {
  e && e.c();
}
function le(e, t, n, o) {
  const { fragment: i, after_update: s } = e.$$;
  i && i.m(t, n), o || et(() => {
    const r = e.$$.on_mount.map(Rt).filter(z);
    e.$$.on_destroy ? e.$$.on_destroy.push(...r) : ie(r), e.$$.on_mount = [];
  }), s.forEach(et);
}
function ae(e, t) {
  const n = e.$$;
  n.fragment !== null && (sn(n.after_update), ie(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function rn(e, t) {
  e.$$.dirty[0] === -1 && (ge.push(e), nn(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function $(e, t, n, o, i, s, r, a = [-1]) {
  const l = ve;
  Se(e);
  const u = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: N,
    not_equal: i,
    bound: lt(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (l ? l.$$.context : [])),
    // everything else
    callbacks: lt(),
    dirty: a,
    skip_bound: !1,
    root: t.target || l.$$.root
  };
  r && r(u.root);
  let h = !1;
  if (u.ctx = n ? n(e, t.props || {}, (c, d, ...m) => {
    const g = m.length ? m[0] : d;
    return u.ctx && i(u.ctx[c], u.ctx[c] = g) && (!u.skip_bound && u.bound[c] && u.bound[c](g), h && rn(e, c)), d;
  }) : [], u.update(), h = !0, ie(u.before_update), u.fragment = o ? o(u.ctx) : !1, t.target) {
    if (t.hydrate) {
      const c = $t(t.target);
      u.fragment && u.fragment.l(c), c.forEach(L);
    } else
      u.fragment && u.fragment.c();
    t.intro && Y(e.$$.fragment), le(e, t.target, t.anchor, t.customElement), Ut();
  }
  Se(l);
}
class ee {
  $destroy() {
    ae(this, 1), this.$destroy = N;
  }
  $on(t, n) {
    if (!z(n))
      return N;
    const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return o.push(n), () => {
      const i = o.indexOf(n);
      i !== -1 && o.splice(i, 1);
    };
  }
  $set(t) {
    this.$$set && !Jt(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);
  }
}
var H = /* @__PURE__ */ ((e) => (e.ELLIPSE = "ELLIPSE", e.POLYGON = "POLYGON", e.RECTANGLE = "RECTANGLE", e))(H || {});
const nt = {}, ot = (e, t) => nt[e] = t, ut = (e) => nt[e.type].area(e), ln = (e, t, n) => nt[e.type].intersects(e, t, n), Ne = (e) => {
  let t = 1 / 0, n = 1 / 0, o = -1 / 0, i = -1 / 0;
  return e.forEach(([s, r]) => {
    t = Math.min(t, s), n = Math.min(n, r), o = Math.max(o, s), i = Math.max(i, r);
  }), { minX: t, minY: n, maxX: o, maxY: i };
}, an = {
  area: (e) => Math.PI * e.geometry.rx * e.geometry.ry,
  intersects: (e, t, n) => {
    const { cx: o, cy: i, rx: s, ry: r } = e.geometry, a = 0, l = Math.cos(a), u = Math.sin(a), h = t - o, c = n - i, d = l * h + u * c, m = u * h - l * c;
    return d * d / (s * s) + m * m / (r * r) <= 1;
  }
};
ot(H.ELLIPSE, an);
const cn = {
  area: (e) => {
    const { points: t } = e.geometry;
    let n = 0, o = t.length - 1;
    for (let i = 0; i < t.length; i++)
      n += (t[o][0] + t[i][0]) * (t[o][1] - t[i][1]), o = i;
    return Math.abs(0.5 * n);
  },
  intersects: (e, t, n) => {
    const { points: o } = e.geometry;
    let i = !1;
    for (let s = 0, r = o.length - 1; s < o.length; r = s++) {
      const a = o[s][0], l = o[s][1], u = o[r][0], h = o[r][1];
      l > n != h > n && t < (u - a) * (n - l) / (h - l) + a && (i = !i);
    }
    return i;
  }
};
ot(H.POLYGON, cn);
const fn = {
  area: (e) => e.geometry.w * e.geometry.h,
  intersects: (e, t, n) => t >= e.geometry.x && t <= e.geometry.x + e.geometry.w && n >= e.geometry.y && n <= e.geometry.y + e.geometry.h
};
ot(H.RECTANGLE, fn);
const un = (e, t = !1) => {
  const n = typeof e == "string" ? e : e.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, i = [...n.matchAll(o)][0], [s, r, a, l, u, h, c] = i;
  if (r !== "xywh")
    throw new Error("Unsupported MediaFragment: " + n);
  if (a && a !== "pixel")
    throw new Error(`Unsupported MediaFragment unit: ${a}`);
  const [d, m, g, _] = [l, u, h, c].map(parseFloat);
  return {
    type: H.RECTANGLE,
    geometry: {
      x: d,
      y: m,
      w: g,
      h: _,
      bounds: {
        minX: d,
        minY: t ? m - _ : m,
        maxX: d + g,
        maxY: t ? m : m + _
      }
    }
  };
}, dn = (e) => {
  const { x: t, y: n, w: o, h: i } = e;
  return {
    type: "FragmentSelector",
    conformsTo: "http://www.w3.org/TR/media-frags/",
    value: `xywh=pixel:${t},${n},${o},${i}`
  };
}, Ht = "http://www.w3.org/2000/svg", dt = (e) => {
  const t = (o) => {
    Array.from(o.attributes).forEach((i) => {
      i.name.startsWith("on") && o.removeAttribute(i.name);
    });
  }, n = e.getElementsByTagName("script");
  return Array.from(n).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(e.querySelectorAll("*")).forEach(t), e;
}, hn = (e) => {
  const o = new XMLSerializer().serializeToString(e.documentElement).replace("<svg>", `<svg xmlns="${Ht}">`);
  return new DOMParser().parseFromString(o, "image/svg+xml").documentElement;
}, mn = (e) => {
  const n = new DOMParser().parseFromString(e, "image/svg+xml"), o = n.lookupPrefix(Ht), i = n.lookupNamespaceURI(null);
  return o || i ? dt(n).firstChild : dt(hn(n)).firstChild;
}, gn = (e) => {
  const [t, n, o] = e.match(/(<polygon points=["|'])([^("|')]*)/) || [];
  if (!o)
    return;
  const i = o.split(" ").map((s) => s.split(",").map(parseFloat));
  return {
    type: H.POLYGON,
    geometry: {
      points: i,
      bounds: Ne(i)
    }
  };
}, pn = (e) => {
  const t = mn(e), n = parseFloat(t.getAttribute("cx")), o = parseFloat(t.getAttribute("cy")), i = parseFloat(t.getAttribute("rx")), s = parseFloat(t.getAttribute("ry")), r = {
    minX: n - i,
    minY: o - s,
    maxX: n + i,
    maxY: o + s
  };
  return {
    type: H.ELLIPSE,
    geometry: {
      cx: n,
      cy: o,
      rx: i,
      ry: s,
      bounds: r
    }
  };
}, _n = (e) => {
  const t = typeof e == "string" ? e : e.value;
  if (t.includes("<polygon points="))
    return gn(t);
  if (t.includes("<ellipse "))
    return pn(t);
}, yn = (e) => {
  let t;
  if (e.type === H.POLYGON) {
    const n = e.geometry, { points: o } = n;
    t = `<svg><polygon points="${o.map((i) => i.join(",")).join(" ")}" /></svg>`;
  } else if (e.type === H.ELLIPSE) {
    const n = e.geometry;
    t = `<svg><ellipse cx="${n.cx}" cy="${n.cy}" rx="${n.rx}" ry="${n.ry}" /></svg>`;
  }
  if (t)
    return { type: "SvgSelector", value: t };
  throw `Unsupported shape type: ${e.type}`;
};
let Re;
const wn = new Uint8Array(16);
function bn() {
  if (!Re && (Re = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Re))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Re(wn);
}
const j = [];
for (let e = 0; e < 256; ++e)
  j.push((e + 256).toString(16).slice(1));
function En(e, t = 0) {
  return j[e[t + 0]] + j[e[t + 1]] + j[e[t + 2]] + j[e[t + 3]] + "-" + j[e[t + 4]] + j[e[t + 5]] + "-" + j[e[t + 6]] + j[e[t + 7]] + "-" + j[e[t + 8]] + j[e[t + 9]] + "-" + j[e[t + 10]] + j[e[t + 11]] + j[e[t + 12]] + j[e[t + 13]] + j[e[t + 14]] + j[e[t + 15]];
}
const An = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), ht = {
  randomUUID: An
};
function it(e, t, n) {
  if (ht.randomUUID && !t && !e)
    return ht.randomUUID();
  e = e || {};
  const o = e.random || (e.rng || bn)();
  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, t) {
    n = n || 0;
    for (let i = 0; i < 16; ++i)
      t[n + i] = o[i];
    return t;
  }
  return En(o);
}
var mt = Object.prototype.hasOwnProperty;
function fe(e, t) {
  var n, o;
  if (e === t)
    return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date)
      return e.getTime() === t.getTime();
    if (n === RegExp)
      return e.toString() === t.toString();
    if (n === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && fe(e[o], t[o]); )
          ;
      return o === -1;
    }
    if (!n || typeof e == "object") {
      o = 0;
      for (n in e)
        if (mt.call(e, n) && ++o && !mt.call(t, n) || !(n in t) || !fe(e[n], t[n]))
          return !1;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
const he = [];
function Ue(e, t = N) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function i(a) {
    if (q(e, a) && (e = a, n)) {
      const l = !he.length;
      for (const u of o)
        u[1](), he.push(u, e);
      if (l) {
        for (let u = 0; u < he.length; u += 2)
          he[u][0](he[u + 1]);
        he.length = 0;
      }
    }
  }
  function s(a) {
    i(a(e));
  }
  function r(a, l = N) {
    const u = [a, l];
    return o.add(u), o.size === 1 && (n = t(i) || N), a(e), () => {
      o.delete(u), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: r };
}
const Tn = (e) => {
  const { subscribe: t, set: n } = Ue(null);
  let o = null;
  return t((i) => o = i), e.observe(({ changes: i }) => {
    if (o) {
      i.deleted.some((a) => a.id === o) && n(null);
      const r = i.updated.find(({ oldValue: a }) => a.id === o);
      r && n(r.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: t,
    set: n
  };
};
var Ft = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.HIGHLIGHT = "HIGHLIGHT", e.NONE = "NONE", e))(Ft || {});
const Je = { selected: [] }, Sn = (e, t = "EDIT") => {
  const { subscribe: n, set: o } = Ue(Je);
  let i = Je;
  n((c) => i = c);
  const s = () => o(Je), r = () => {
    var c;
    return ((c = i.selected) == null ? void 0 : c.length) === 0;
  }, a = (c) => {
    if (i.selected.length === 0)
      return !1;
    const d = typeof c == "string" ? c : c.id;
    return i.selected.some((m) => m.id === d);
  }, l = (c, d) => {
    const m = e.getAnnotation(c);
    if (m) {
      const g = vn(m, t);
      o(g === "EDIT" ? { selected: [{ id: c, editable: !0 }], pointerEvent: d } : g === "HIGHLIGHT" ? { selected: [{ id: c }], pointerEvent: d } : { selected: [], pointerEvent: d });
    } else
      console.warn("Invalid selection: " + c);
  }, u = (c, d = !0) => {
    const m = Array.isArray(c) ? c : [c], g = m.map((_) => e.getAnnotation(_)).filter((_) => _);
    o({ selected: g.map(({ id: _ }) => ({ id: _, editable: d })) }), g.length !== m.length && console.warn("Invalid selection", c);
  }, h = (c) => {
    if (i.selected.length === 0)
      return !1;
    const { selected: d } = i;
    d.filter(({ id: g }) => c.includes(g)).length > 0 && o({ selected: d.filter(({ id: g }) => !c.includes(g)) });
  };
  return e.observe(({ changes: c }) => h(c.deleted.map((d) => d.id))), {
    clear: s,
    clickSelect: l,
    get selected() {
      return i ? [...i.selected] : null;
    },
    get pointerEvent() {
      return i ? i.pointerEvent : null;
    },
    isEmpty: r,
    isSelected: a,
    setSelected: u,
    subscribe: n
  };
}, vn = (e, t) => typeof t == "function" ? t(e) || "EDIT" : t || "EDIT", ui = (e) => {
  const { creator: t, updatedBy: n } = e.target, o = e.bodies.reduce((i, s) => [...i, s.creator, s.updatedBy], []);
  return [
    t,
    n,
    ...o
  ].filter((i) => i);
}, di = (e, t, n, o) => ({
  id: it(),
  annotation: e.id,
  created: n || /* @__PURE__ */ new Date(),
  creator: o,
  ...t
}), Mn = (e, t) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
}, Ln = (e, t) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
}, On = (e, t) => t.bodies.map((n) => {
  const o = e.bodies.find((i) => i.id === n.id);
  return { newBody: n, oldBody: o && !fe(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n), Bn = (e, t) => !fe(e.target, t.target), In = (e, t) => ({
  oldValue: e,
  newValue: t,
  bodiesCreated: Mn(e, t),
  bodiesDeleted: Ln(e, t),
  bodiesUpdated: On(e, t),
  targetUpdated: Bn(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0
});
var U = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e))(U || {});
const kn = (e, t) => {
  var s, r;
  const { changes: n, origin: o } = t;
  if (!(!e.options.origin || e.options.origin === o))
    return !1;
  if (e.options.ignore) {
    const { ignore: a } = e.options, l = (h) => (h == null ? void 0 : h.length) > 0;
    if (!(l(n.created) || l(n.deleted))) {
      const h = (s = n.updated) == null ? void 0 : s.some((d) => l(d.bodiesCreated) || l(d.bodiesDeleted) || l(d.bodiesUpdated)), c = (r = n.updated) == null ? void 0 : r.some((d) => d.targetUpdated);
      if (a === "BODY_ONLY" && h && !c || a === "TARGET_ONLY" && c && !h)
        return !1;
    }
  }
  if (e.options.annotations) {
    const a = /* @__PURE__ */ new Set([
      ...n.created.map((u) => u.id),
      ...n.deleted.map((u) => u.id),
      ...n.updated.map(({ oldValue: u }) => u.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((u) => a.has(u));
  } else
    return !0;
}, Cn = (e) => e.id !== void 0, Pn = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (y, b = {}) => n.push({ onChange: y, options: b }), i = (y) => {
    const b = n.findIndex((A) => A.onChange == y);
    b > -1 && n.splice(b, 1);
  }, s = (y, b) => {
    const A = {
      origin: y,
      changes: {
        created: b.created || [],
        updated: b.updated || [],
        deleted: b.deleted || []
      },
      state: [...e.values()]
    };
    n.forEach((M) => {
      kn(M, A) && M.onChange(A);
    });
  }, r = (y, b = U.LOCAL) => {
    if (e.get(y.id))
      throw Error(`Cannot add annotation ${y.id} - exists already`);
    e.set(y.id, y), y.bodies.forEach((M) => t.set(M.id, y.id)), s(b, { created: [y] });
  }, a = (y, b = U.LOCAL, A = U.LOCAL) => {
    const M = Cn(b) ? A : b, w = typeof y == "string" ? b : y, O = typeof y == "string" ? y : y.id, R = e.get(O);
    if (R) {
      const te = In(R, w);
      O === w.id ? e.set(O, w) : (e.delete(O), e.set(w.id, w)), R.bodies.forEach((W) => t.delete(W.id)), w.bodies.forEach((W) => t.set(W.id, w.id)), s(M, { updated: [te] });
    } else
      throw Error(`Cannot update annotation ${O} - does not exist`);
  }, l = (y, b = U.LOCAL) => {
    const A = e.get(y.annotation);
    if (A) {
      const M = {
        ...A,
        bodies: [...A.bodies, y]
      };
      e.set(A.id, M), t.set(y.id, M.id), s(b, { updated: [{
        oldValue: A,
        newValue: M,
        bodiesCreated: [y]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${y.annotation}`);
  }, u = () => [...e.values()], h = (y = U.LOCAL) => {
    const b = [...e.values()];
    e.clear(), t.clear(), s(y, { deleted: b });
  }, c = (y, b = !0, A = U.LOCAL) => {
    if (b) {
      const M = [...e.values()];
      e.clear(), t.clear(), y.forEach((w) => {
        e.set(w.id, w), w.bodies.forEach((O) => t.set(O.id, w.id));
      }), s(A, { created: y, deleted: M });
    } else {
      const M = y.reduce((w, O) => {
        const R = e.get(O.id);
        return R ? [...w, R] : w;
      }, []);
      if (M.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${M.map((w) => w.id).join(", ")}`);
      y.forEach((w) => {
        e.set(w.id, w), w.bodies.forEach((O) => t.set(O.id, w.id));
      }), s(A, { created: y });
    }
  }, d = (y) => {
    const b = typeof y == "string" ? y : y.id, A = e.get(b);
    if (A)
      return e.delete(b), A.bodies.forEach((M) => t.delete(M.id)), A;
    console.warn(`Attempt to delete missing annotation: ${b}`);
  }, m = (y, b = U.LOCAL) => {
    const A = d(y);
    A && s(b, { deleted: [A] });
  }, g = (y, b = U.LOCAL) => {
    const A = y.reduce((M, w) => {
      const O = d(w);
      return O ? [...M, O] : M;
    }, []);
    A.length > 0 && s(b, { deleted: A });
  }, _ = (y, b = U.LOCAL) => {
    const A = e.get(y.annotation);
    if (A) {
      const M = A.bodies.find((w) => w.id === y.id);
      if (M) {
        t.delete(M.id);
        const w = {
          ...A,
          bodies: A.bodies.filter((R) => R.id !== y.id)
        };
        e.set(A.id, w), s(b, { updated: [{
          oldValue: A,
          newValue: w,
          bodiesDeleted: [M]
        }] });
      } else
        console.warn(`Attempt to delete missing body ${y.id} from annotation ${y.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${y.annotation}`);
  }, p = (y) => {
    const b = e.get(y);
    return b ? { ...b } : void 0;
  }, T = (y) => {
    const b = t.get(y);
    if (b) {
      const M = p(b).bodies.find((w) => w.id === y);
      if (M)
        return M;
      console.error(`Store integrity error: body ${y} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${y}`);
  }, E = (y, b) => {
    if (y.annotation !== b.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const A = e.get(y.annotation);
    if (A) {
      const M = A.bodies.find((O) => O.id === y.id), w = {
        ...A,
        bodies: A.bodies.map((O) => O.id === M.id ? b : O)
      };
      return e.set(A.id, w), M.id !== b.id && (t.delete(M.id), t.set(b.id, w.id)), {
        oldValue: A,
        newValue: w,
        bodiesUpdated: [{ oldBody: M, newBody: b }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${y.annotation}`);
  }, I = (y, b, A = U.LOCAL) => {
    const M = E(y, b);
    s(A, { updated: [M] });
  }, X = (y, b = U.LOCAL) => {
    const A = y.map((M) => E({ id: M.id, annotation: M.annotation }, M));
    s(b, { updated: A });
  }, G = (y) => {
    const b = e.get(y.annotation);
    if (b) {
      const A = {
        ...b,
        target: {
          ...b.target,
          ...y
        }
      };
      return e.set(b.id, A), {
        oldValue: b,
        newValue: A,
        targetUpdated: {
          oldTarget: b.target,
          newTarget: y
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${y.annotation}`);
  };
  return {
    addAnnotation: r,
    addBody: l,
    all: u,
    bulkAddAnnotation: c,
    bulkDeleteAnnotation: g,
    bulkUpdateBodies: X,
    bulkUpdateTargets: (y, b = U.LOCAL) => {
      const A = y.map(G).filter((M) => M);
      A.length > 0 && s(b, { updated: A });
    },
    clear: h,
    deleteAnnotation: m,
    deleteBody: _,
    getAnnotation: p,
    getBody: T,
    observe: o,
    unobserve: i,
    updateAnnotation: a,
    updateBody: I,
    updateTarget: (y, b = U.LOCAL) => {
      const A = G(y);
      A && s(b, { updated: [A] });
    }
  };
}, Yn = (e) => ({
  ...e,
  subscribe: (n) => {
    const o = (i) => n(i.state);
    return e.observe(o), n(e.all()), () => e.unobserve(o);
  }
}), Rn = () => {
  const { subscribe: e, set: t } = Ue([]);
  return {
    subscribe: e,
    set: t
  };
}, Xn = (e, t, n, o, i, s) => {
  const r = /* @__PURE__ */ new Map();
  let a = [], l, u;
  const h = (g, _) => {
    r.has(g) ? r.get(g).push(_) : r.set(g, [_]);
  }, c = (g, _) => {
    const p = r.get(g);
    p && p.indexOf(_) > 0 && p.splice(p.indexOf(_), 1);
  }, d = (g, _, p) => {
    r.has(g) && setTimeout(() => {
      r.get(g).forEach((T) => {
        if (i) {
          const E = Array.isArray(_) ? _.map((X) => i.serialize(X)) : i.serialize(_), I = p ? p instanceof PointerEvent ? p : i.serialize(p) : void 0;
          T(E, I);
        } else
          T(_, p);
      });
    }, 1);
  }, m = () => {
    const { selected: g } = t, _ = g.map(({ id: p }) => e.getAnnotation(p));
    _.forEach((p) => {
      const T = a.find((E) => E.id === p.id);
      (!T || !fe(T, p)) && d("updateAnnotation", p, T);
    }), a = a.map((p) => {
      const T = _.find(({ id: E }) => E === p.id);
      return T || p;
    });
  };
  return t.subscribe(({ selected: g }) => {
    if (!(a.length === 0 && g.length === 0)) {
      if (a.length === 0 && g.length > 0)
        a = g.map(({ id: _ }) => e.getAnnotation(_));
      else if (a.length > 0 && g.length === 0)
        a.forEach((_) => {
          const p = e.getAnnotation(_.id);
          p && !fe(p, _) && d("updateAnnotation", p, _);
        }), a = [];
      else {
        const _ = new Set(a.map((E) => E.id)), p = new Set(g.map(({ id: E }) => E));
        a.filter((E) => !p.has(E.id)).forEach((E) => {
          const I = e.getAnnotation(E.id);
          I && !fe(I, E) && d("updateAnnotation", I, E);
        }), a = [
          // Remove annotations that were deselected
          ...a.filter((E) => p.has(E.id)),
          // Add editable annotations that were selected
          ...g.filter(({ id: E }) => !_.has(E)).map(({ id: E }) => e.getAnnotation(E))
        ];
      }
      d("selectionChanged", a);
    }
  }), n.subscribe((g) => {
    !l && g ? d("mouseEnterAnnotation", e.getAnnotation(g)) : l && !g ? d("mouseLeaveAnnotation", e.getAnnotation(l)) : l && g && (d("mouseLeaveAnnotation", e.getAnnotation(l)), d("mouseEnterAnnotation", e.getAnnotation(g))), l = g;
  }), o == null || o.subscribe((g) => d("viewportIntersect", g.map(e.getAnnotation))), e.observe((g) => {
    s && (u && clearTimeout(u), u = setTimeout(m, 1e3));
    const { created: _, deleted: p } = g.changes;
    _.forEach((E) => d("createAnnotation", E)), p.forEach((E) => d("deleteAnnotation", E)), g.changes.updated.filter((E) => [
      ...E.bodiesCreated || [],
      ...E.bodiesDeleted || [],
      ...E.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: E, newValue: I }) => {
      const X = a.find((G) => G.id === E.id) || E;
      a = a.map((G) => G.id === E.id ? I : G), d("updateAnnotation", I, X);
    });
  }, { origin: U.LOCAL }), e.observe((g) => {
    if (a) {
      const _ = new Set(a.map((T) => T.id)), p = g.changes.updated.filter(({ newValue: T }) => _.has(T.id)).map(({ newValue: T }) => T);
      p.length > 0 && (a = a.map((T) => {
        const E = p.find((I) => I.id === T.id);
        return E || T;
      }));
    }
  }, { origin: U.REMOTE }), { on: h, off: c, emit: d };
}, hi = (e) => (t) => t.map((n) => e.serialize(n)), Dn = (e) => (t) => t.reduce((n, o) => {
  const { parsed: i, error: s } = e.parse(o);
  return s ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : {
    parsed: [...n.parsed, i],
    failed: n.failed
  };
}, { parsed: [], failed: [] }), Gn = (e, t) => {
  const n = (h) => {
    if (t) {
      const { parsed: c, error: d } = t.parse(h);
      c ? e.addAnnotation(c, U.REMOTE) : console.error(d);
    } else
      e.addAnnotation(h, U.REMOTE);
  }, o = () => e.clear(), i = (h) => {
    const c = e.getAnnotation(h);
    return t && c ? t.serialize(c) : c;
  }, s = () => t ? e.all().map(t.serialize) : e.all(), r = (h) => fetch(h).then((c) => c.json()).then((c) => (l(c), c)), a = (h) => {
    if (typeof h == "string") {
      const c = e.getAnnotation(h);
      return e.deleteAnnotation(h), t ? t.serialize(c) : c;
    } else {
      const c = t ? t.parse(h).parsed : h;
      return e.deleteAnnotation(c), h;
    }
  }, l = (h) => {
    if (t) {
      const { parsed: c, failed: d } = Dn(t)(h);
      d.length > 0 && console.warn(`Discarded ${d.length} invalid annotations`, d), e.bulkAddAnnotation(c, !0, U.REMOTE);
    } else
      e.bulkAddAnnotation(h, !0, U.REMOTE);
  };
  return {
    addAnnotation: n,
    clearAnnotations: o,
    getAnnotationById: i,
    getAnnotations: s,
    loadAnnotations: r,
    removeAnnotation: a,
    setAnnotations: l,
    updateAnnotation: (h) => {
      if (t) {
        const c = t.parse(h).parsed, d = t.serialize(e.getAnnotation(c.id));
        return e.updateAnnotation(c), d;
      } else {
        const c = e.getAnnotation(h.id);
        return e.updateAnnotation(h), c;
      }
    }
  };
};
let Nn = (e) => crypto.getRandomValues(new Uint8Array(e)), Un = (e, t, n) => {
  let o = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * o * t / e.length);
  return (s = t) => {
    let r = "";
    for (; ; ) {
      let a = n(i), l = i;
      for (; l--; )
        if (r += e[a[l] & o] || "", r.length === s)
          return r;
    }
  };
}, Hn = (e, t = 21) => Un(e, t, Nn), Fn = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const zn = () => ({ isGuest: !0, id: Hn("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), jn = (e) => {
  const t = JSON.stringify(e);
  let n = 0;
  for (let o = 0, i = t.length; o < i; o++) {
    let s = t.charCodeAt(o);
    n = (n << 5) - n + s, n |= 0;
  }
  return `${n}`;
}, Vn = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {
  const { id: o, type: i, purpose: s, value: r, created: a, creator: l, ...u } = n;
  return {
    id: o || jn(n),
    annotation: t,
    type: i,
    purpose: s,
    value: r,
    created: a,
    creator: l ? typeof l == "object" ? { ...l } : l : void 0,
    ...u
  };
}), qn = (e) => e.map((t) => {
  const n = { ...t };
  return delete n.annotation, delete n.id, n;
}), Wn = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], Jn = () => {
  const e = [...Wn];
  return { assignRandomColor: () => {
    const o = Math.floor(Math.random() * e.length), i = e[o];
    return e.splice(o, 1), i;
  }, releaseColor: (o) => e.push(o) };
}, Qn = () => {
  const e = Jn();
  return { addUser: (o, i) => {
    const s = e.assignRandomColor();
    return {
      label: i.name || i.id,
      avatar: i.avatar,
      color: s
    };
  }, removeUser: (o) => e.releaseColor(o.appearance.color) };
};
let Zn = () => ({
  emit(e, ...t) {
    let n = this.events[e] || [];
    for (let o = 0, i = n.length; o < i; o++)
      n[o](...t);
  },
  events: {},
  on(e, t) {
    var n;
    return (n = this.events[e]) != null && n.push(t) || (this.events[e] = [t]), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => t !== i);
    };
  }
});
const Kn = (e, t) => e.every((n) => e.includes(n)) && t.every((n) => e.includes(n)), mi = Fn(), gi = (e = Qn()) => {
  const t = Zn(), n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = (c, d) => {
    if (n.has(c)) {
      console.warn("Attempt to add user that is already present", c, d);
      return;
    }
    const m = e.addUser(c, d);
    n.set(c, {
      ...d,
      presenceKey: c,
      appearance: m
    });
  }, s = (c) => {
    const d = n.get(c);
    if (!d) {
      console.warn("Attempt to remove user that is not present", c);
      return;
    }
    e.removeUser(d), n.delete(c);
  }, r = (c) => {
    const d = new Set(c.map((_) => _.presenceKey)), m = c.filter(({ presenceKey: _ }) => !n.has(_)), g = Array.from(n.values()).filter((_) => !d.has(_.presenceKey));
    m.forEach(({ presenceKey: _, user: p }) => i(_, p)), g.forEach((_) => {
      const { presenceKey: p } = _;
      o.has(p) && t.emit("selectionChange", _, null), s(p);
    }), (m.length > 0 || g.length > 0) && t.emit("presence", u());
  }, a = (c, d) => {
    const m = n.get(c);
    if (!m) {
      console.warn("Activity notification from user that is not present");
      return;
    }
    const g = o.get(c);
    (!g || !Kn(g, d)) && (o.set(c, d), t.emit("selectionChange", m, d));
  }, l = (c, d) => {
    const m = n.get(c);
    if (!m) {
      console.warn("Selection change for user that is not present", c);
      return;
    }
    d ? o.set(c, d) : o.delete(c), t.emit("selectionChange", m, d);
  }, u = () => [...Array.from(n.values())];
  return {
    getPresentUsers: u,
    notifyActivity: a,
    on: (c, d) => t.on(c, d),
    syncUsers: r,
    updateSelection: l
  };
}, pi = (e, t = !1) => ({ parse: (i) => xn(i, t), serialize: (i) => $n(i, e) }), xn = (e, t = !1) => {
  const n = e.id || it(), o = Vn(e.body, n), i = Array.isArray(e.target) ? e.target[0] : e.target, s = Array.isArray(i.selector) ? i.selector[0] : i.selector, r = s.type === "FragmentSelector" ? un(s, t) : s.type === "SvgSelector" ? _n(s) : void 0;
  return r ? {
    parsed: {
      id: n,
      bodies: o,
      target: {
        annotation: n,
        selector: r
      }
    }
  } : {
    error: Error(`Unknown selector type: ${r.type}`)
  };
}, $n = (e, t) => {
  const n = e.target.selector, o = n.type == H.RECTANGLE ? dn(n.geometry) : yn(n);
  return {
    "@context": "http://www.w3.org/ns/anno.jsonld",
    id: e.id,
    type: "Annotation",
    body: qn(e.bodies),
    target: {
      source: t,
      selector: o
    }
  };
};
function gt(e, t, n) {
  const o = e.slice();
  return o[11] = t[n], o[13] = n, o;
}
function pt(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("rect"), f(t, "class", "a9s-corner-handle"), f(t, "x", n = /*point*/
      e[11][0] - /*handleSize*/
      e[3] / 2), f(t, "y", o = /*point*/
      e[11][1] - /*handleSize*/
      e[3] / 2), f(
        t,
        "height",
        /*handleSize*/
        e[3]
      ), f(
        t,
        "width",
        /*handleSize*/
        e[3]
      );
    },
    m(r, a) {
      B(r, t, a), i || (s = V(t, "pointerdown", function() {
        z(
          /*grab*/
          e[10](v(
            /*idx*/
            e[13]
          ))
        ) && e[10](v(
          /*idx*/
          e[13]
        )).apply(this, arguments);
      }), i = !0);
    },
    p(r, a) {
      e = r, a & /*geom, handleSize*/
      24 && n !== (n = /*point*/
      e[11][0] - /*handleSize*/
      e[3] / 2) && f(t, "x", n), a & /*geom, handleSize*/
      24 && o !== (o = /*point*/
      e[11][1] - /*handleSize*/
      e[3] / 2) && f(t, "y", o), a & /*handleSize*/
      8 && f(
        t,
        "height",
        /*handleSize*/
        e[3]
      ), a & /*handleSize*/
      8 && f(
        t,
        "width",
        /*handleSize*/
        e[3]
      );
    },
    d(r) {
      r && L(t), i = !1, s();
    }
  };
}
function eo(e) {
  let t, n, o, i, s, r, a, l, u, h, c = (
    /*geom*/
    e[4].points
  ), d = [];
  for (let m = 0; m < c.length; m += 1)
    d[m] = pt(gt(e, c, m));
  return {
    c() {
      t = P("polygon"), i = x(), s = P("polygon"), a = x();
      for (let m = 0; m < d.length; m += 1)
        d[m].c();
      l = se(), f(t, "class", "a9s-outer"), f(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), f(t, "points", o = /*geom*/
      e[4].points.map(_t).join(" ")), f(s, "class", "a9s-inner a9s-shape-handle"), f(
        s,
        "style",
        /*computedStyle*/
        e[1]
      ), f(s, "points", r = /*geom*/
      e[4].points.map(yt).join(" "));
    },
    m(m, g) {
      B(m, t, g), B(m, i, g), B(m, s, g), B(m, a, g);
      for (let _ = 0; _ < d.length; _ += 1)
        d[_] && d[_].m(m, g);
      B(m, l, g), u || (h = [
        V(t, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.SHAPE)
          ) && e[10](v.SHAPE).apply(this, arguments);
        }),
        V(s, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.SHAPE)
          ) && e[10](v.SHAPE).apply(this, arguments);
        })
      ], u = !0);
    },
    p(m, g) {
      if (e = m, g & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      e[1] ? "display:none;" : void 0) && f(t, "style", n), g & /*geom*/
      16 && o !== (o = /*geom*/
      e[4].points.map(_t).join(" ")) && f(t, "points", o), g & /*computedStyle*/
      2 && f(
        s,
        "style",
        /*computedStyle*/
        e[1]
      ), g & /*geom*/
      16 && r !== (r = /*geom*/
      e[4].points.map(yt).join(" ")) && f(s, "points", r), g & /*geom, handleSize, grab, Handle*/
      1048) {
        c = /*geom*/
        e[4].points;
        let _;
        for (_ = 0; _ < c.length; _ += 1) {
          const p = gt(e, c, _);
          d[_] ? d[_].p(p, g) : (d[_] = pt(p), d[_].c(), d[_].m(l.parentNode, l));
        }
        for (; _ < d.length; _ += 1)
          d[_].d(1);
        d.length = c.length;
      }
    },
    d(m) {
      m && L(t), m && L(i), m && L(s), m && L(a), tt(d, m), m && L(l), u = !1, ie(h);
    }
  };
}
function to(e) {
  let t, n;
  return t = new jt({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[5]
      ),
      $$slots: {
        default: [
          eo,
          ({ grab: o }) => ({ 10: o }),
          ({ grab: o }) => o ? 1024 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "change",
    /*change_handler*/
    e[7]
  ), t.$on(
    "grab",
    /*grab_handler*/
    e[8]
  ), t.$on(
    "release",
    /*release_handler*/
    e[9]
  ), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, [i]) {
      const s = {};
      i & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i & /*$$scope, geom, handleSize, grab, computedStyle*/
      17434 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
const _t = (e) => e.join(","), yt = (e) => e.join(",");
function no(e, t, n) {
  let o, i, { shape: s } = t, { computedStyle: r = void 0 } = t, { transform: a } = t, { viewportScale: l = 1 } = t;
  const u = (m, g, _) => {
    let p;
    g === v.SHAPE ? p = m.geometry.points.map(([E, I]) => [E + _[0], I + _[1]]) : p = m.geometry.points.map(([E, I], X) => g === v(X) ? [E + _[0], I + _[1]] : [E, I]);
    const T = Ne(p);
    return { ...m, geometry: { points: p, bounds: T } };
  };
  function h(m) {
    _e.call(this, e, m);
  }
  function c(m) {
    _e.call(this, e, m);
  }
  function d(m) {
    _e.call(this, e, m);
  }
  return e.$$set = (m) => {
    "shape" in m && n(0, s = m.shape), "computedStyle" in m && n(1, r = m.computedStyle), "transform" in m && n(2, a = m.transform), "viewportScale" in m && n(6, l = m.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(4, o = s.geometry), e.$$.dirty & /*viewportScale*/
    64 && n(3, i = 10 / l);
  }, [
    s,
    r,
    a,
    i,
    o,
    u,
    l,
    h,
    c,
    d
  ];
}
class oo extends ee {
  constructor(t) {
    super(), $(this, t, no, to, q, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 6
    });
  }
}
function io(e) {
  let t, n, o, i, s, r, a, l, u, h, c, d, m, g, _, p, T, E, I, X, G, C, F, y, b, A, M, w, O, R, te, W, Fe, J, Le, Oe, ze, Q, Be, Ie, je, Z, ke, Ce, Ve, K, Pe, Ye, qe, rt;
  return {
    c() {
      t = P("rect"), a = x(), l = P("rect"), m = x(), g = P("rect"), E = x(), I = P("rect"), F = x(), y = P("rect"), w = x(), O = P("rect"), Fe = x(), J = P("rect"), ze = x(), Q = P("rect"), je = x(), Z = P("rect"), Ve = x(), K = P("rect"), f(t, "class", "a9s-outer"), f(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), f(t, "x", o = /*geom*/
      e[4].x), f(t, "y", i = /*geom*/
      e[4].y), f(t, "width", s = /*geom*/
      e[4].w), f(t, "height", r = /*geom*/
      e[4].h), f(l, "class", "a9s-inner a9s-shape-handle"), f(
        l,
        "style",
        /*computedStyle*/
        e[1]
      ), f(l, "x", u = /*geom*/
      e[4].x), f(l, "y", h = /*geom*/
      e[4].y), f(l, "width", c = /*geom*/
      e[4].w), f(l, "height", d = /*geom*/
      e[4].h), f(g, "class", "a9s-edge-handle a9s-edge-handle-top"), f(g, "x", _ = /*geom*/
      e[4].x), f(g, "y", p = /*geom*/
      e[4].y), f(g, "height", 1), f(g, "width", T = /*geom*/
      e[4].w), f(I, "class", "a9s-edge-handle a9s-edge-handle-right"), f(I, "x", X = /*geom*/
      e[4].x + /*geom*/
      e[4].w), f(I, "y", G = /*geom*/
      e[4].y), f(I, "height", C = /*geom*/
      e[4].h), f(I, "width", 1), f(y, "class", "a9s-edge-handle a9s-edge-handle-bottom"), f(y, "x", b = /*geom*/
      e[4].x), f(y, "y", A = /*geom*/
      e[4].y + /*geom*/
      e[4].h), f(y, "height", 1), f(y, "width", M = /*geom*/
      e[4].w), f(O, "class", "a9s-edge-handle a9s-edge-handle-left"), f(O, "x", R = /*geom*/
      e[4].x), f(O, "y", te = /*geom*/
      e[4].y), f(O, "height", W = /*geom*/
      e[4].h), f(O, "width", 1), f(J, "class", "a9s-corner-handle a9s-corner-handle-topleft"), f(J, "x", Le = /*geom*/
      e[4].x - /*handleSize*/
      e[3] / 2), f(J, "y", Oe = /*geom*/
      e[4].y - /*handleSize*/
      e[3] / 2), f(
        J,
        "height",
        /*handleSize*/
        e[3]
      ), f(
        J,
        "width",
        /*handleSize*/
        e[3]
      ), f(Q, "class", "a9s-corner-handle a9s-corner-handle-topright"), f(Q, "x", Be = /*geom*/
      e[4].x + /*geom*/
      e[4].w - /*handleSize*/
      e[3] / 2), f(Q, "y", Ie = /*geom*/
      e[4].y - /*handleSize*/
      e[3] / 2), f(
        Q,
        "height",
        /*handleSize*/
        e[3]
      ), f(
        Q,
        "width",
        /*handleSize*/
        e[3]
      ), f(Z, "class", "a9s-corner-handle a9s-corner-handle-bottomright"), f(Z, "x", ke = /*geom*/
      e[4].x + /*geom*/
      e[4].w - /*handleSize*/
      e[3] / 2), f(Z, "y", Ce = /*geom*/
      e[4].y + /*geom*/
      e[4].h - /*handleSize*/
      e[3] / 2), f(
        Z,
        "height",
        /*handleSize*/
        e[3]
      ), f(
        Z,
        "width",
        /*handleSize*/
        e[3]
      ), f(K, "class", "a9s-corner-handle a9s-corner-handle-bottomleft"), f(K, "x", Pe = /*geom*/
      e[4].x - /*handleSize*/
      e[3] / 2), f(K, "y", Ye = /*geom*/
      e[4].y + /*geom*/
      e[4].h - /*handleSize*/
      e[3] / 2), f(
        K,
        "height",
        /*handleSize*/
        e[3]
      ), f(
        K,
        "width",
        /*handleSize*/
        e[3]
      );
    },
    m(k, S) {
      B(k, t, S), B(k, a, S), B(k, l, S), B(k, m, S), B(k, g, S), B(k, E, S), B(k, I, S), B(k, F, S), B(k, y, S), B(k, w, S), B(k, O, S), B(k, Fe, S), B(k, J, S), B(k, ze, S), B(k, Q, S), B(k, je, S), B(k, Z, S), B(k, Ve, S), B(k, K, S), qe || (rt = [
        V(t, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.SHAPE)
          ) && e[10](v.SHAPE).apply(this, arguments);
        }),
        V(l, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.SHAPE)
          ) && e[10](v.SHAPE).apply(this, arguments);
        }),
        V(g, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.TOP)
          ) && e[10](v.TOP).apply(this, arguments);
        }),
        V(I, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.RIGHT)
          ) && e[10](v.RIGHT).apply(this, arguments);
        }),
        V(y, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.BOTTOM)
          ) && e[10](v.BOTTOM).apply(this, arguments);
        }),
        V(O, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.LEFT)
          ) && e[10](v.LEFT).apply(this, arguments);
        }),
        V(J, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.TOP_LEFT)
          ) && e[10](v.TOP_LEFT).apply(this, arguments);
        }),
        V(Q, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.TOP_RIGHT)
          ) && e[10](v.TOP_RIGHT).apply(this, arguments);
        }),
        V(Z, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.BOTTOM_RIGHT)
          ) && e[10](v.BOTTOM_RIGHT).apply(this, arguments);
        }),
        V(K, "pointerdown", function() {
          z(
            /*grab*/
            e[10](v.BOTTOM_LEFT)
          ) && e[10](v.BOTTOM_LEFT).apply(this, arguments);
        })
      ], qe = !0);
    },
    p(k, S) {
      e = k, S & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      e[1] ? "display:none;" : void 0) && f(t, "style", n), S & /*geom*/
      16 && o !== (o = /*geom*/
      e[4].x) && f(t, "x", o), S & /*geom*/
      16 && i !== (i = /*geom*/
      e[4].y) && f(t, "y", i), S & /*geom*/
      16 && s !== (s = /*geom*/
      e[4].w) && f(t, "width", s), S & /*geom*/
      16 && r !== (r = /*geom*/
      e[4].h) && f(t, "height", r), S & /*computedStyle*/
      2 && f(
        l,
        "style",
        /*computedStyle*/
        e[1]
      ), S & /*geom*/
      16 && u !== (u = /*geom*/
      e[4].x) && f(l, "x", u), S & /*geom*/
      16 && h !== (h = /*geom*/
      e[4].y) && f(l, "y", h), S & /*geom*/
      16 && c !== (c = /*geom*/
      e[4].w) && f(l, "width", c), S & /*geom*/
      16 && d !== (d = /*geom*/
      e[4].h) && f(l, "height", d), S & /*geom*/
      16 && _ !== (_ = /*geom*/
      e[4].x) && f(g, "x", _), S & /*geom*/
      16 && p !== (p = /*geom*/
      e[4].y) && f(g, "y", p), S & /*geom*/
      16 && T !== (T = /*geom*/
      e[4].w) && f(g, "width", T), S & /*geom*/
      16 && X !== (X = /*geom*/
      e[4].x + /*geom*/
      e[4].w) && f(I, "x", X), S & /*geom*/
      16 && G !== (G = /*geom*/
      e[4].y) && f(I, "y", G), S & /*geom*/
      16 && C !== (C = /*geom*/
      e[4].h) && f(I, "height", C), S & /*geom*/
      16 && b !== (b = /*geom*/
      e[4].x) && f(y, "x", b), S & /*geom*/
      16 && A !== (A = /*geom*/
      e[4].y + /*geom*/
      e[4].h) && f(y, "y", A), S & /*geom*/
      16 && M !== (M = /*geom*/
      e[4].w) && f(y, "width", M), S & /*geom*/
      16 && R !== (R = /*geom*/
      e[4].x) && f(O, "x", R), S & /*geom*/
      16 && te !== (te = /*geom*/
      e[4].y) && f(O, "y", te), S & /*geom*/
      16 && W !== (W = /*geom*/
      e[4].h) && f(O, "height", W), S & /*geom, handleSize*/
      24 && Le !== (Le = /*geom*/
      e[4].x - /*handleSize*/
      e[3] / 2) && f(J, "x", Le), S & /*geom, handleSize*/
      24 && Oe !== (Oe = /*geom*/
      e[4].y - /*handleSize*/
      e[3] / 2) && f(J, "y", Oe), S & /*handleSize*/
      8 && f(
        J,
        "height",
        /*handleSize*/
        e[3]
      ), S & /*handleSize*/
      8 && f(
        J,
        "width",
        /*handleSize*/
        e[3]
      ), S & /*geom, handleSize*/
      24 && Be !== (Be = /*geom*/
      e[4].x + /*geom*/
      e[4].w - /*handleSize*/
      e[3] / 2) && f(Q, "x", Be), S & /*geom, handleSize*/
      24 && Ie !== (Ie = /*geom*/
      e[4].y - /*handleSize*/
      e[3] / 2) && f(Q, "y", Ie), S & /*handleSize*/
      8 && f(
        Q,
        "height",
        /*handleSize*/
        e[3]
      ), S & /*handleSize*/
      8 && f(
        Q,
        "width",
        /*handleSize*/
        e[3]
      ), S & /*geom, handleSize*/
      24 && ke !== (ke = /*geom*/
      e[4].x + /*geom*/
      e[4].w - /*handleSize*/
      e[3] / 2) && f(Z, "x", ke), S & /*geom, handleSize*/
      24 && Ce !== (Ce = /*geom*/
      e[4].y + /*geom*/
      e[4].h - /*handleSize*/
      e[3] / 2) && f(Z, "y", Ce), S & /*handleSize*/
      8 && f(
        Z,
        "height",
        /*handleSize*/
        e[3]
      ), S & /*handleSize*/
      8 && f(
        Z,
        "width",
        /*handleSize*/
        e[3]
      ), S & /*geom, handleSize*/
      24 && Pe !== (Pe = /*geom*/
      e[4].x - /*handleSize*/
      e[3] / 2) && f(K, "x", Pe), S & /*geom, handleSize*/
      24 && Ye !== (Ye = /*geom*/
      e[4].y + /*geom*/
      e[4].h - /*handleSize*/
      e[3] / 2) && f(K, "y", Ye), S & /*handleSize*/
      8 && f(
        K,
        "height",
        /*handleSize*/
        e[3]
      ), S & /*handleSize*/
      8 && f(
        K,
        "width",
        /*handleSize*/
        e[3]
      );
    },
    d(k) {
      k && L(t), k && L(a), k && L(l), k && L(m), k && L(g), k && L(E), k && L(I), k && L(F), k && L(y), k && L(w), k && L(O), k && L(Fe), k && L(J), k && L(ze), k && L(Q), k && L(je), k && L(Z), k && L(Ve), k && L(K), qe = !1, ie(rt);
    }
  };
}
function so(e) {
  let t, n;
  return t = new jt({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[5]
      ),
      $$slots: {
        default: [
          io,
          ({ grab: o }) => ({ 10: o }),
          ({ grab: o }) => o ? 1024 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "grab",
    /*grab_handler*/
    e[7]
  ), t.$on(
    "change",
    /*change_handler*/
    e[8]
  ), t.$on(
    "release",
    /*release_handler*/
    e[9]
  ), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, [i]) {
      const s = {};
      i & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i & /*$$scope, geom, handleSize, grab, computedStyle*/
      3098 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
function ro(e, t, n) {
  let o, i, { shape: s } = t, { computedStyle: r = void 0 } = t, { transform: a } = t, { viewportScale: l = 1 } = t;
  const u = (m, g, _) => {
    const p = m.geometry.bounds;
    let [T, E] = [p.minX, p.minY], [I, X] = [p.maxX, p.maxY];
    const [G, C] = _;
    if (g === v.SHAPE)
      T += G, I += G, E += C, X += C;
    else {
      switch (g) {
        case v.TOP:
        case v.TOP_LEFT:
        case v.TOP_RIGHT: {
          E += C;
          break;
        }
        case v.BOTTOM:
        case v.BOTTOM_LEFT:
        case v.BOTTOM_RIGHT: {
          X += C;
          break;
        }
      }
      switch (g) {
        case v.LEFT:
        case v.TOP_LEFT:
        case v.BOTTOM_LEFT: {
          T += G;
          break;
        }
        case v.RIGHT:
        case v.TOP_RIGHT:
        case v.BOTTOM_RIGHT: {
          I += G;
          break;
        }
      }
    }
    const F = Math.min(T, I), y = Math.min(E, X), b = Math.abs(I - T), A = Math.abs(X - E);
    return {
      ...m,
      geometry: {
        x: F,
        y,
        w: b,
        h: A,
        bounds: {
          minX: F,
          minY: y,
          maxX: F + b,
          maxY: y + A
        }
      }
    };
  };
  function h(m) {
    _e.call(this, e, m);
  }
  function c(m) {
    _e.call(this, e, m);
  }
  function d(m) {
    _e.call(this, e, m);
  }
  return e.$$set = (m) => {
    "shape" in m && n(0, s = m.shape), "computedStyle" in m && n(1, r = m.computedStyle), "transform" in m && n(2, a = m.transform), "viewportScale" in m && n(6, l = m.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(4, o = s.geometry), e.$$.dirty & /*viewportScale*/
    64 && n(3, i = 10 / l);
  }, [
    s,
    r,
    a,
    i,
    o,
    u,
    l,
    h,
    c,
    d
  ];
}
class lo extends ee {
  constructor(t) {
    super(), $(this, t, ro, so, q, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 6
    });
  }
}
const zt = /* @__PURE__ */ new Map([
  [H.RECTANGLE, lo],
  [H.POLYGON, oo]
]), wt = (e) => zt.get(e.type), ao = (e, t) => zt.set(e, t), v = (e) => `HANDLE-${e}`;
v.SHAPE = "SHAPE";
v.TOP = "TOP";
v.RIGHT = "RIGHT";
v.BOTTOM = "BOTTOM";
v.LEFT = "LEFT";
v.TOP_LEFT = "TOP_LEFT";
v.TOP_RIGHT = "TOP_RIGHT";
v.BOTTOM_RIGHT = "BOTTOM_RIGHT";
v.BOTTOM_LEFT = "BOTTOM_LEFT";
const co = (e) => ({}), bt = (e) => ({ grab: (
  /*onGrab*/
  e[0]
) });
function fo(e) {
  let t, n, o, i;
  const s = (
    /*#slots*/
    e[7].default
  ), r = Qt(
    s,
    e,
    /*$$scope*/
    e[6],
    bt
  );
  return {
    c() {
      t = P("g"), r && r.c(), f(t, "class", "a9s-annotation selected");
    },
    m(a, l) {
      B(a, t, l), r && r.m(t, null), n = !0, o || (i = [
        V(
          t,
          "pointerup",
          /*onRelease*/
          e[2]
        ),
        V(
          t,
          "pointermove",
          /*onPointerMove*/
          e[1]
        )
      ], o = !0);
    },
    p(a, [l]) {
      r && r.p && (!n || l & /*$$scope*/
      64) && Kt(
        r,
        s,
        a,
        /*$$scope*/
        a[6],
        n ? Zt(
          s,
          /*$$scope*/
          a[6],
          l,
          co
        ) : xt(
          /*$$scope*/
          a[6]
        ),
        bt
      );
    },
    i(a) {
      n || (Y(r, a), n = !0);
    },
    o(a) {
      D(r, a), n = !1;
    },
    d(a) {
      a && L(t), r && r.d(a), o = !1, ie(i);
    }
  };
}
function uo(e, t, n) {
  let { $$slots: o = {}, $$scope: i } = t;
  const s = be();
  let { shape: r } = t, { editor: a } = t, { transform: l } = t, u = null, h, c = null;
  const d = (_) => (p) => {
    u = _, h = l.elementToImage(p.offsetX, p.offsetY), c = r, p.target.setPointerCapture(p.pointerId), s("grab");
  }, m = (_) => {
    if (u) {
      const [p, T] = l.elementToImage(_.offsetX, _.offsetY), E = [p - h[0], T - h[1]];
      n(3, r = a(c, u, E)), s("change", r);
    }
  }, g = (_) => {
    _.target.releasePointerCapture(_.pointerId), u = null, c = r, s("release");
  };
  return e.$$set = (_) => {
    "shape" in _ && n(3, r = _.shape), "editor" in _ && n(4, a = _.editor), "transform" in _ && n(5, l = _.transform), "$$scope" in _ && n(6, i = _.$$scope);
  }, [d, m, g, r, a, l, i, o];
}
class jt extends ee {
  constructor(t) {
    super(), $(this, t, uo, fo, q, { shape: 3, editor: 4, transform: 5 });
  }
}
const He = (e, t) => {
  const n = typeof t == "function" ? t(e) : t;
  if (n) {
    const { fill: o, fillOpacity: i } = n;
    let s = "";
    return o && (s += `fill:${o};stroke:${o};`), s += `fill-opacity:${i || "0.25"};`, s;
  }
};
function ho(e, t, n) {
  let o;
  const i = be();
  let { annotation: s } = t, { editor: r } = t, { style: a = void 0 } = t, { target: l } = t, { transform: u } = t, { viewportScale: h } = t, c;
  return Me(() => (n(6, c = new r({
    target: l,
    props: {
      shape: s.target.selector,
      computedStyle: o,
      transform: u,
      viewportScale: h
    }
  })), c.$on("change", (d) => {
    c.$$set({ shape: d.detail }), i("change", d.detail);
  }), () => {
    c.$destroy();
  })), e.$$set = (d) => {
    "annotation" in d && n(0, s = d.annotation), "editor" in d && n(1, r = d.editor), "style" in d && n(2, a = d.style), "target" in d && n(3, l = d.target), "transform" in d && n(4, u = d.transform), "viewportScale" in d && n(5, h = d.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    5 && (o = He(s, a)), e.$$.dirty & /*editorComponent, transform*/
    80 && c && c.$set({ transform: u }), e.$$.dirty & /*editorComponent, viewportScale*/
    96 && c && c.$set({ viewportScale: h });
  }, [s, r, a, l, u, h, c];
}
class mo extends ee {
  constructor(t) {
    super(), $(this, t, ho, null, q, {
      annotation: 0,
      editor: 1,
      style: 2,
      target: 3,
      transform: 4,
      viewportScale: 5
    });
  }
}
function go(e, t, n) {
  const o = be();
  let { target: i } = t, { tool: s } = t, { transform: r } = t, { viewportScale: a } = t, l;
  return Me(() => (n(4, l = new s({
    target: i,
    props: { transform: r, viewportScale: a }
  })), l.$on("create", (u) => o("create", u.detail)), () => {
    l.$destroy();
  })), e.$$set = (u) => {
    "target" in u && n(0, i = u.target), "tool" in u && n(1, s = u.tool), "transform" in u && n(2, r = u.transform), "viewportScale" in u && n(3, a = u.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*toolComponent, transform*/
    20 && l && l.$set({ transform: r }), e.$$.dirty & /*toolComponent, viewportScale*/
    24 && l && l.$set({ viewportScale: a });
  }, [i, s, r, a, l];
}
class po extends ee {
  constructor(t) {
    super(), $(this, t, go, null, q, {
      target: 0,
      tool: 1,
      transform: 2,
      viewportScale: 3
    });
  }
}
function Et(e) {
  let t, n;
  return {
    c() {
      t = P("rect"), n = P("rect"), f(t, "class", "a9s-outer"), f(
        t,
        "x",
        /*x*/
        e[2]
      ), f(
        t,
        "y",
        /*y*/
        e[3]
      ), f(
        t,
        "width",
        /*w*/
        e[4]
      ), f(
        t,
        "height",
        /*h*/
        e[5]
      ), f(n, "class", "a9s-inner"), f(
        n,
        "x",
        /*x*/
        e[2]
      ), f(
        n,
        "y",
        /*y*/
        e[3]
      ), f(
        n,
        "width",
        /*w*/
        e[4]
      ), f(
        n,
        "height",
        /*h*/
        e[5]
      );
    },
    m(o, i) {
      B(o, t, i), B(o, n, i);
    },
    p(o, i) {
      i & /*x*/
      4 && f(
        t,
        "x",
        /*x*/
        o[2]
      ), i & /*y*/
      8 && f(
        t,
        "y",
        /*y*/
        o[3]
      ), i & /*w*/
      16 && f(
        t,
        "width",
        /*w*/
        o[4]
      ), i & /*h*/
      32 && f(
        t,
        "height",
        /*h*/
        o[5]
      ), i & /*x*/
      4 && f(
        n,
        "x",
        /*x*/
        o[2]
      ), i & /*y*/
      8 && f(
        n,
        "y",
        /*y*/
        o[3]
      ), i & /*w*/
      16 && f(
        n,
        "width",
        /*w*/
        o[4]
      ), i & /*h*/
      32 && f(
        n,
        "height",
        /*h*/
        o[5]
      );
    },
    d(o) {
      o && L(t), o && L(n);
    }
  };
}
function _o(e) {
  let t, n = (
    /*origin*/
    e[1] && Et(e)
  );
  return {
    c() {
      t = P("g"), n && n.c(), f(t, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, i) {
      B(o, t, i), n && n.m(t, null), e[7](t);
    },
    p(o, [i]) {
      /*origin*/
      o[1] ? n ? n.p(o, i) : (n = Et(o), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    i: N,
    o: N,
    d(o) {
      o && L(t), n && n.d(), e[7](null);
    }
  };
}
function yo(e, t, n) {
  const o = be();
  let { transform: i } = t, s, r, a, l, u, h, c;
  const d = (p) => {
    n(1, r = i.elementToImage(p.offsetX, p.offsetY)), a = r, n(2, l = r[0]), n(3, u = r[1]), n(4, h = 1), n(5, c = 1);
  }, m = (p) => {
    r && (a = i.elementToImage(p.offsetX, p.offsetY), n(2, l = Math.min(a[0], r[0])), n(3, u = Math.min(a[1], r[1])), n(4, h = Math.abs(a[0] - r[0])), n(5, c = Math.abs(a[1] - r[1])));
  }, g = () => {
    if (h * c > 15) {
      const p = {
        type: H.RECTANGLE,
        geometry: {
          bounds: {
            minX: l,
            minY: u,
            maxX: l + h,
            maxY: u + c
          },
          x: l,
          y: u,
          w: h,
          h: c
        }
      };
      o("create", p);
    }
    n(1, r = null), a = null;
  };
  Me(() => {
    const p = s.closest("svg");
    return p.addEventListener("pointerdown", d), p.addEventListener("pointermove", m), p.addEventListener("pointerup", g), () => {
      p.removeEventListener("pointerdown", d), p.removeEventListener("pointermove", m), p.removeEventListener("pointerup", g);
    };
  });
  function _(p) {
    we[p ? "unshift" : "push"](() => {
      s = p, n(0, s);
    });
  }
  return e.$$set = (p) => {
    "transform" in p && n(6, i = p.transform);
  }, [s, r, l, u, h, c, i, _];
}
class wo extends ee {
  constructor(t) {
    super(), $(this, t, yo, _o, q, { transform: 6 });
  }
}
const At = (e, t) => {
  const n = Math.abs(t[0] - e[0]), o = Math.abs(t[1] - e[1]);
  return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));
}, bo = (e, t) => {
  const { naturalWidth: n, naturalHeight: o } = e;
  if (!n && !o) {
    const { width: i, height: s } = e;
    t.setAttribute("viewBox", `0 0 ${i} ${s}`), e.addEventListener("load", (r) => {
      const a = r.target;
      t.setAttribute("viewBox", `0 0 ${a.naturalWidth} ${a.naturalHeight}`);
    });
  } else
    t.setAttribute("viewBox", `0 0 ${n} ${o}`);
}, Eo = (e, t) => {
  bo(e, t);
  const { subscribe: n, set: o } = Ue(1);
  let i;
  return window.ResizeObserver && (i = new ResizeObserver(() => {
    const r = t.getBoundingClientRect(), { width: a, height: l } = t.viewBox.baseVal, u = Math.max(
      r.width / a,
      r.height / l
    );
    o(u);
  }), i.observe(t.parentElement)), { destroy: () => {
    i && i.disconnect();
  }, subscribe: n };
}, Ao = "ontouchstart" in window || navigator.maxTouchPoints > 0;
function Qe(e) {
  const t = e.slice(), n = (
    /*isClosable*/
    (t[3] ? (
      /*points*/
      t[1]
    ) : [
      .../*points*/
      t[1],
      /*cursor*/
      t[2]
    ]).map((o) => o.join(",")).join(" ")
  );
  return t[13] = n, t;
}
function Tt(e) {
  let t, n, o, i, s, r = (
    /*isClosable*/
    e[3] && St(e)
  );
  return {
    c() {
      t = P("polygon"), o = P("polygon"), r && r.c(), s = se(), f(t, "class", "a9s-outer"), f(t, "points", n = /*coords*/
      e[13]), f(o, "class", "a9s-inner"), f(o, "points", i = /*coords*/
      e[13]);
    },
    m(a, l) {
      B(a, t, l), B(a, o, l), r && r.m(a, l), B(a, s, l);
    },
    p(a, l) {
      l & /*isClosable, points, cursor*/
      14 && n !== (n = /*coords*/
      a[13]) && f(t, "points", n), l & /*isClosable, points, cursor*/
      14 && i !== (i = /*coords*/
      a[13]) && f(o, "points", i), /*isClosable*/
      a[3] ? r ? r.p(a, l) : (r = St(a), r.c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null);
    },
    d(a) {
      a && L(t), a && L(o), r && r.d(a), a && L(s);
    }
  };
}
function St(e) {
  let t, n, o;
  return {
    c() {
      t = P("rect"), f(t, "class", "a9s-corner-handle"), f(t, "x", n = /*points*/
      e[1][0][0] - /*handleSize*/
      e[4] / 2), f(t, "y", o = /*points*/
      e[1][0][1] - /*handleSize*/
      e[4] / 2), f(
        t,
        "height",
        /*handleSize*/
        e[4]
      ), f(
        t,
        "width",
        /*handleSize*/
        e[4]
      );
    },
    m(i, s) {
      B(i, t, s);
    },
    p(i, s) {
      s & /*points, handleSize*/
      18 && n !== (n = /*points*/
      i[1][0][0] - /*handleSize*/
      i[4] / 2) && f(t, "x", n), s & /*points, handleSize*/
      18 && o !== (o = /*points*/
      i[1][0][1] - /*handleSize*/
      i[4] / 2) && f(t, "y", o), s & /*handleSize*/
      16 && f(
        t,
        "height",
        /*handleSize*/
        i[4]
      ), s & /*handleSize*/
      16 && f(
        t,
        "width",
        /*handleSize*/
        i[4]
      );
    },
    d(i) {
      i && L(t);
    }
  };
}
function To(e) {
  let t, n = (
    /*cursor*/
    e[2] && Tt(Qe(e))
  );
  return {
    c() {
      t = P("g"), n && n.c(), f(t, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, i) {
      B(o, t, i), n && n.m(t, null), e[7](t);
    },
    p(o, [i]) {
      /*cursor*/
      o[2] ? n ? n.p(Qe(o), i) : (n = Tt(Qe(o)), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    i: N,
    o: N,
    d(o) {
      o && L(t), n && n.d(), e[7](null);
    }
  };
}
const So = 20;
function vo(e, t, n) {
  let o;
  const i = be();
  let { transform: s } = t, { viewportScale: r = 1 } = t, a, l = [], u = null, h = !1;
  const c = (p) => {
    const T = s.elementToImage(p.offsetX, p.offsetY);
    l.length === 0 && l.push(T), n(2, u = T);
  }, d = (p) => {
    if (l.length > 0 && (n(2, u = s.elementToImage(p.offsetX, p.offsetY)), l.length > 2)) {
      const T = At(u, l[0]) * r;
      n(3, h = T < So);
    }
  }, m = (p) => {
    if (l.length === 1 && At(l[0], u) <= 4) {
      n(1, l = []), n(2, u = null);
      return;
    }
    if (p.stopImmediatePropagation(), h) {
      const T = {
        type: H.POLYGON,
        geometry: {
          bounds: Ne(l),
          points: [...l]
        }
      };
      n(1, l = []), n(2, u = null), i("create", T);
    } else
      l.push(u);
  }, g = () => {
    const p = [...l, u], T = {
      type: H.POLYGON,
      geometry: { bounds: Ne(p), points: p }
    };
    n(1, l = []), n(2, u = null), i("create", T);
  };
  Me(() => {
    const p = a.closest("svg");
    return p.addEventListener("pointerdown", c, !0), p.addEventListener("pointermove", d), p.addEventListener("pointerup", m, !0), p.addEventListener("dblclick", g, !0), () => {
      p.removeEventListener("pointerdown", c, !0), p.removeEventListener("pointermove", d, !0), p.removeEventListener("pointerup", m, !0), p.removeEventListener("dblclick", g, !0);
    };
  });
  function _(p) {
    we[p ? "unshift" : "push"](() => {
      a = p, n(0, a);
    });
  }
  return e.$$set = (p) => {
    "transform" in p && n(5, s = p.transform), "viewportScale" in p && n(6, r = p.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*viewportScale*/
    64 && n(4, o = 10 / r);
  }, [
    a,
    l,
    u,
    h,
    o,
    s,
    r,
    _
  ];
}
class Mo extends ee {
  constructor(t) {
    super(), $(this, t, vo, To, q, { transform: 5, viewportScale: 6 });
  }
}
const st = /* @__PURE__ */ new Map([
  ["rectangle", wo],
  ["polygon", Mo]
]), _i = () => [...st.keys()], Vt = (e) => st.get(e), Lo = (e, t) => st.set(e, t);
function Oo(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("ellipse"), i = P("ellipse"), f(n, "class", "a9s-outer"), f(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), f(
        n,
        "cx",
        /*cx*/
        e[2]
      ), f(
        n,
        "cy",
        /*cy*/
        e[3]
      ), f(
        n,
        "rx",
        /*rx*/
        e[4]
      ), f(
        n,
        "ry",
        /*ry*/
        e[5]
      ), f(i, "class", "a9s-inner"), f(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), f(
        i,
        "cx",
        /*cx*/
        e[2]
      ), f(
        i,
        "cy",
        /*cy*/
        e[3]
      ), f(
        i,
        "rx",
        /*rx*/
        e[4]
      ), f(
        i,
        "ry",
        /*ry*/
        e[5]
      ), f(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, a) {
      B(r, t, a), re(t, n), re(t, i);
    },
    p(r, [a]) {
      a & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && f(n, "style", o), a & /*computedStyle*/
      2 && f(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), a & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && f(t, "data-id", s);
    },
    i: N,
    o: N,
    d(r) {
      r && L(t);
    }
  };
}
function Bo(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r = void 0 } = t;
  const { cx: a, cy: l, rx: u, ry: h } = s;
  return e.$$set = (c) => {
    "annotation" in c && n(0, i = c.annotation), "geom" in c && n(6, s = c.geom), "style" in c && n(7, r = c.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(1, o = He(i, r));
  }, [i, o, a, l, u, h, s, r];
}
class Io extends ee {
  constructor(t) {
    super(), $(this, t, Bo, Oo, q, { annotation: 0, geom: 6, style: 7 });
  }
}
function ko(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("polygon"), i = P("polygon"), f(n, "class", "a9s-outer"), f(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), f(
        n,
        "points",
        /*points*/
        e[2].map(Co).join(" ")
      ), f(i, "class", "a9s-inner"), f(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), f(
        i,
        "points",
        /*points*/
        e[2].map(Po).join(" ")
      ), f(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, a) {
      B(r, t, a), re(t, n), re(t, i);
    },
    p(r, [a]) {
      a & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && f(n, "style", o), a & /*computedStyle*/
      2 && f(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), a & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && f(t, "data-id", s);
    },
    i: N,
    o: N,
    d(r) {
      r && L(t);
    }
  };
}
const Co = (e) => e.join(","), Po = (e) => e.join(",");
function Yo(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r = void 0 } = t;
  const { points: a } = s;
  return e.$$set = (l) => {
    "annotation" in l && n(0, i = l.annotation), "geom" in l && n(3, s = l.geom), "style" in l && n(4, r = l.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    17 && n(1, o = He(i, r));
  }, [i, o, a, s, r];
}
class Ro extends ee {
  constructor(t) {
    super(), $(this, t, Yo, ko, q, { annotation: 0, geom: 3, style: 4 });
  }
}
function Xo(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("rect"), i = P("rect"), f(n, "class", "a9s-outer"), f(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), f(
        n,
        "x",
        /*x*/
        e[2]
      ), f(
        n,
        "y",
        /*y*/
        e[3]
      ), f(
        n,
        "width",
        /*w*/
        e[4]
      ), f(
        n,
        "height",
        /*h*/
        e[5]
      ), f(i, "class", "a9s-inner"), f(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), f(
        i,
        "x",
        /*x*/
        e[2]
      ), f(
        i,
        "y",
        /*y*/
        e[3]
      ), f(
        i,
        "width",
        /*w*/
        e[4]
      ), f(
        i,
        "height",
        /*h*/
        e[5]
      ), f(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, a) {
      B(r, t, a), re(t, n), re(t, i);
    },
    p(r, [a]) {
      a & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && f(n, "style", o), a & /*computedStyle*/
      2 && f(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), a & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && f(t, "data-id", s);
    },
    i: N,
    o: N,
    d(r) {
      r && L(t);
    }
  };
}
function Do(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r = void 0 } = t;
  const { x: a, y: l, w: u, h } = s;
  return e.$$set = (c) => {
    "annotation" in c && n(0, i = c.annotation), "geom" in c && n(6, s = c.geom), "style" in c && n(7, r = c.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(1, o = He(i, r));
  }, [i, o, a, l, u, h, s, r];
}
class Go extends ee {
  constructor(t) {
    super(), $(this, t, Do, Xo, q, { annotation: 0, geom: 6, style: 7 });
  }
}
const yi = {
  elementToImage: (e, t) => [e, t]
}, No = (e) => ({
  elementToImage: (t, n) => {
    const o = e.createSVGPoint();
    o.x = t, o.y = n;
    const { x: i, y: s } = o.matrixTransform(e.getCTM().inverse());
    return [i, s];
  }
}), Uo = 200, Ho = (e, t) => {
  const n = be();
  let o;
  return { onPointerDown: () => o = (/* @__PURE__ */ new Date()).getTime(), onPointerUp: (r) => {
    if ((/* @__PURE__ */ new Date()).getTime() - o < Uo) {
      const { x: l, y: u } = Fo(r, e), h = t.getAt(l, u);
      h ? n("click", { originalEvent: r, annotation: h }) : n("click", { originalEvent: r });
    }
  } };
}, Fo = (e, t) => {
  const n = t.createSVGPoint();
  if (Ao) {
    const o = t.getBoundingClientRect(), i = e.clientX - o.x, s = e.clientY - o.y, { left: r, top: a } = t.getBoundingClientRect();
    return n.x = i + r, n.y = s + a, n.matrixTransform(t.getScreenCTM().inverse());
  } else
    return n.x = e.offsetX, n.y = e.offsetY, n.matrixTransform(t.getCTM().inverse());
};
function vt(e, t, n) {
  const o = e.slice();
  return o[23] = t[n], o;
}
function Mt(e, t, n) {
  const o = e.slice();
  return o[26] = t[n], o;
}
function Ze(e) {
  const t = e.slice(), n = (
    /*annotation*/
    t[26].target.selector
  );
  return t[29] = n, t;
}
function Lt(e) {
  let t = (
    /*annotation*/
    e[26].id
  ), n, o, i = Ot(e);
  return {
    c() {
      i.c(), n = se();
    },
    m(s, r) {
      i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r & /*$store*/
      1024 && q(t, t = /*annotation*/
      s[26].id) ? (ne(), D(i, 1, 1, N), oe(), i = Ot(s), i.c(), Y(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (Y(i), o = !0);
    },
    o(s) {
      D(i), o = !1;
    },
    d(s) {
      s && L(n), i.d(s);
    }
  };
}
function zo(e) {
  let t, n;
  return t = new Ro({
    props: {
      annotation: (
        /*annotation*/
        e[26]
      ),
      geom: (
        /*selector*/
        e[29].geometry
      ),
      style: (
        /*style*/
        e[0]
      )
    }
  }), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i & /*$store*/
      1024 && (s.annotation = /*annotation*/
      o[26]), i & /*$store*/
      1024 && (s.geom = /*selector*/
      o[29].geometry), i & /*style*/
      1 && (s.style = /*style*/
      o[0]), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
function jo(e) {
  let t, n;
  return t = new Go({
    props: {
      annotation: (
        /*annotation*/
        e[26]
      ),
      geom: (
        /*selector*/
        e[29].geometry
      ),
      style: (
        /*style*/
        e[0]
      )
    }
  }), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i & /*$store*/
      1024 && (s.annotation = /*annotation*/
      o[26]), i & /*$store*/
      1024 && (s.geom = /*selector*/
      o[29].geometry), i & /*style*/
      1 && (s.style = /*style*/
      o[0]), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
function Vo(e) {
  let t, n;
  return t = new Io({
    props: {
      annotation: (
        /*annotation*/
        e[26]
      ),
      geom: (
        /*selector*/
        e[29].geometry
      ),
      style: (
        /*style*/
        e[0]
      )
    }
  }), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i & /*$store*/
      1024 && (s.annotation = /*annotation*/
      o[26]), i & /*$store*/
      1024 && (s.geom = /*selector*/
      o[29].geometry), i & /*style*/
      1 && (s.style = /*style*/
      o[0]), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
function Ot(e) {
  let t, n, o, i;
  const s = [Vo, jo, zo], r = [];
  function a(l, u) {
    return (
      /*selector*/
      l[29].type === H.ELLIPSE ? 0 : (
        /*selector*/
        l[29].type === H.RECTANGLE ? 1 : (
          /*selector*/
          l[29].type === H.POLYGON ? 2 : -1
        )
      )
    );
  }
  return ~(t = a(e)) && (n = r[t] = s[t](e)), {
    c() {
      n && n.c(), o = se();
    },
    m(l, u) {
      ~t && r[t].m(l, u), B(l, o, u), i = !0;
    },
    p(l, u) {
      let h = t;
      t = a(l), t === h ? ~t && r[t].p(l, u) : (n && (ne(), D(r[h], 1, 1, () => {
        r[h] = null;
      }), oe()), ~t ? (n = r[t], n ? n.p(l, u) : (n = r[t] = s[t](l), n.c()), Y(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(l) {
      i || (Y(n), i = !0);
    },
    o(l) {
      D(n), i = !1;
    },
    d(l) {
      ~t && r[t].d(l), l && L(o);
    }
  };
}
function Bt(e) {
  let t = !/*isEditable*/
  e[6](
    /*annotation*/
    e[26]
  ), n, o, i = t && Lt(Ze(e));
  return {
    c() {
      i && i.c(), n = se();
    },
    m(s, r) {
      i && i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r & /*isEditable, $store*/
      1088 && (t = !/*isEditable*/
      s[6](
        /*annotation*/
        s[26]
      )), t ? i ? (i.p(Ze(s), r), r & /*isEditable, $store*/
      1088 && Y(i, 1)) : (i = Lt(Ze(s)), i.c(), Y(i, 1), i.m(n.parentNode, n)) : i && (ne(), D(i, 1, 1, () => {
        i = null;
      }), oe());
    },
    i(s) {
      o || (Y(i), o = !0);
    },
    o(s) {
      D(i), o = !1;
    },
    d(s) {
      i && i.d(s), s && L(n);
    }
  };
}
function It(e) {
  let t, n, o, i;
  const s = [Wo, qo], r = [];
  function a(l, u) {
    return (
      /*editableAnnotations*/
      l[5] ? 0 : (
        /*tool*/
        l[1] ? 1 : -1
      )
    );
  }
  return ~(t = a(e)) && (n = r[t] = s[t](e)), {
    c() {
      n && n.c(), o = se();
    },
    m(l, u) {
      ~t && r[t].m(l, u), B(l, o, u), i = !0;
    },
    p(l, u) {
      let h = t;
      t = a(l), t === h ? ~t && r[t].p(l, u) : (n && (ne(), D(r[h], 1, 1, () => {
        r[h] = null;
      }), oe()), ~t ? (n = r[t], n ? n.p(l, u) : (n = r[t] = s[t](l), n.c()), Y(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(l) {
      i || (Y(n), i = !0);
    },
    o(l) {
      D(n), i = !1;
    },
    d(l) {
      ~t && r[t].d(l), l && L(o);
    }
  };
}
function qo(e) {
  let t = (
    /*tool*/
    e[1]
  ), n, o, i = kt(e);
  return {
    c() {
      i.c(), n = se();
    },
    m(s, r) {
      i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r & /*tool*/
      2 && q(t, t = /*tool*/
      s[1]) ? (ne(), D(i, 1, 1, N), oe(), i = kt(s), i.c(), Y(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (Y(i), o = !0);
    },
    o(s) {
      D(i), o = !1;
    },
    d(s) {
      s && L(n), i.d(s);
    }
  };
}
function Wo(e) {
  let t, n, o = (
    /*editableAnnotations*/
    e[5]
  ), i = [];
  for (let r = 0; r < o.length; r += 1)
    i[r] = Pt(vt(e, o, r));
  const s = (r) => D(i[r], 1, 1, () => {
    i[r] = null;
  });
  return {
    c() {
      for (let r = 0; r < i.length; r += 1)
        i[r].c();
      t = se();
    },
    m(r, a) {
      for (let l = 0; l < i.length; l += 1)
        i[l] && i[l].m(r, a);
      B(r, t, a), n = !0;
    },
    p(r, a) {
      if (a & /*editableAnnotations, drawingEl, getEditor, style, transform, $scale, onChangeSelected*/
      35369) {
        o = /*editableAnnotations*/
        r[5];
        let l;
        for (l = 0; l < o.length; l += 1) {
          const u = vt(r, o, l);
          i[l] ? (i[l].p(u, a), Y(i[l], 1)) : (i[l] = Pt(u), i[l].c(), Y(i[l], 1), i[l].m(t.parentNode, t));
        }
        for (ne(), l = o.length; l < i.length; l += 1)
          s(l);
        oe();
      }
    },
    i(r) {
      if (!n) {
        for (let a = 0; a < o.length; a += 1)
          Y(i[a]);
        n = !0;
      }
    },
    o(r) {
      i = i.filter(Boolean);
      for (let a = 0; a < i.length; a += 1)
        D(i[a]);
      n = !1;
    },
    d(r) {
      tt(i, r), r && L(t);
    }
  };
}
function kt(e) {
  let t, n;
  return t = new po({
    props: {
      target: (
        /*drawingEl*/
        e[3]
      ),
      tool: (
        /*tool*/
        e[1]
      ),
      transform: (
        /*transform*/
        e[9]
      ),
      viewportScale: (
        /*$scale*/
        e[11]
      )
    }
  }), t.$on(
    "create",
    /*onSelectionCreated*/
    e[14]
  ), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, i) {
      const s = {};
      i & /*drawingEl*/
      8 && (s.target = /*drawingEl*/
      o[3]), i & /*tool*/
      2 && (s.tool = /*tool*/
      o[1]), i & /*transform*/
      512 && (s.transform = /*transform*/
      o[9]), i & /*$scale*/
      2048 && (s.viewportScale = /*$scale*/
      o[11]), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
function Ct(e) {
  let t, n;
  return t = new mo({
    props: {
      target: (
        /*drawingEl*/
        e[3]
      ),
      editor: wt(
        /*editable*/
        e[23].target.selector
      ),
      annotation: (
        /*editable*/
        e[23]
      ),
      style: (
        /*style*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[9]
      ),
      viewportScale: (
        /*$scale*/
        e[11]
      )
    }
  }), t.$on("change", function() {
    z(
      /*onChangeSelected*/
      e[15](
        /*editable*/
        e[23]
      )
    ) && e[15](
      /*editable*/
      e[23]
    ).apply(this, arguments);
  }), {
    c() {
      ue(t.$$.fragment);
    },
    m(o, i) {
      le(t, o, i), n = !0;
    },
    p(o, i) {
      e = o;
      const s = {};
      i & /*drawingEl*/
      8 && (s.target = /*drawingEl*/
      e[3]), i & /*editableAnnotations*/
      32 && (s.editor = wt(
        /*editable*/
        e[23].target.selector
      )), i & /*editableAnnotations*/
      32 && (s.annotation = /*editable*/
      e[23]), i & /*style*/
      1 && (s.style = /*style*/
      e[0]), i & /*transform*/
      512 && (s.transform = /*transform*/
      e[9]), i & /*$scale*/
      2048 && (s.viewportScale = /*$scale*/
      e[11]), t.$set(s);
    },
    i(o) {
      n || (Y(t.$$.fragment, o), n = !0);
    },
    o(o) {
      D(t.$$.fragment, o), n = !1;
    },
    d(o) {
      ae(t, o);
    }
  };
}
function Pt(e) {
  let t = (
    /*editable*/
    e[23].id
  ), n, o, i = Ct(e);
  return {
    c() {
      i.c(), n = se();
    },
    m(s, r) {
      i.m(s, r), B(s, n, r), o = !0;
    },
    p(s, r) {
      r & /*editableAnnotations*/
      32 && q(t, t = /*editable*/
      s[23].id) ? (ne(), D(i, 1, 1, N), oe(), i = Ct(s), i.c(), Y(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (Y(i), o = !0);
    },
    o(s) {
      D(i), o = !1;
    },
    d(s) {
      s && L(n), i.d(s);
    }
  };
}
function Jo(e) {
  let t, n, o, i, s, r, a = (
    /*$store*/
    e[10]
  ), l = [];
  for (let c = 0; c < a.length; c += 1)
    l[c] = Bt(Mt(e, a, c));
  const u = (c) => D(l[c], 1, 1, () => {
    l[c] = null;
  });
  let h = (
    /*drawingEl*/
    e[3] && It(e)
  );
  return {
    c() {
      t = P("svg"), n = P("g");
      for (let c = 0; c < l.length; c += 1)
        l[c].c();
      o = P("g"), h && h.c(), f(o, "class", "drawing"), f(t, "class", "a9s-annotationlayer"), ct(
        t,
        "drawing",
        /*tool*/
        e[1]
      );
    },
    m(c, d) {
      B(c, t, d), re(t, n);
      for (let m = 0; m < l.length; m += 1)
        l[m] && l[m].m(n, null);
      re(t, o), h && h.m(o, null), e[19](o), e[20](t), i = !0, s || (r = [
        V(t, "pointerup", function() {
          z(
            /*onPointerUp*/
            e[7]
          ) && e[7].apply(this, arguments);
        }),
        V(t, "pointerdown", function() {
          z(
            /*onPointerDown*/
            e[8]
          ) && e[8].apply(this, arguments);
        })
      ], s = !0);
    },
    p(c, [d]) {
      if (e = c, d & /*$store, style, ShapeType, isEditable*/
      1089) {
        a = /*$store*/
        e[10];
        let m;
        for (m = 0; m < a.length; m += 1) {
          const g = Mt(e, a, m);
          l[m] ? (l[m].p(g, d), Y(l[m], 1)) : (l[m] = Bt(g), l[m].c(), Y(l[m], 1), l[m].m(n, null));
        }
        for (ne(), m = a.length; m < l.length; m += 1)
          u(m);
        oe();
      }
      /*drawingEl*/
      e[3] ? h ? (h.p(e, d), d & /*drawingEl*/
      8 && Y(h, 1)) : (h = It(e), h.c(), Y(h, 1), h.m(o, null)) : h && (ne(), D(h, 1, 1, () => {
        h = null;
      }), oe()), (!i || d & /*tool*/
      2) && ct(
        t,
        "drawing",
        /*tool*/
        e[1]
      );
    },
    i(c) {
      if (!i) {
        for (let d = 0; d < a.length; d += 1)
          Y(l[d]);
        Y(h), i = !0;
      }
    },
    o(c) {
      l = l.filter(Boolean);
      for (let d = 0; d < l.length; d += 1)
        D(l[d]);
      D(h), i = !1;
    },
    d(c) {
      c && L(t), tt(l, c), h && h.d(), e[19](null), e[20](null), s = !1, ie(r);
    }
  };
}
function Qo(e, t, n) {
  let o, i, s, r, a, l, u, h = N, c = () => (h(), h = Xt(E, (w) => n(11, u = w)), E);
  e.$$.on_destroy.push(() => h());
  let { image: d } = t, { state: m } = t, { style: g = void 0 } = t, { tool: _ = Vt("rectangle") } = t, p, T, E;
  Me(() => c(n(4, E = Eo(d, T))));
  const { selection: I, store: X } = m;
  at(e, I, (w) => n(18, a = w)), at(e, X, (w) => n(10, l = w));
  let G = null, C = null;
  const F = (w) => {
    X.unobserve(G);
    const O = w.filter(({ editable: R }) => R).map(({ id: R }) => R);
    O.length > 0 ? (n(5, C = O.map((R) => X.getAnnotation(R))), G = (R) => {
      const { updated: te } = R.changes;
      n(5, C = te.map((W) => W.newValue));
    }, X.observe(G, { annotations: O })) : n(5, C = null);
  }, y = (w) => {
    const O = it(), R = {
      id: O,
      bodies: [],
      target: {
        annotation: O,
        selector: w.detail,
        creator: null,
        created: /* @__PURE__ */ new Date()
      }
    };
    X.addAnnotation(R), I.setSelected(R.id);
  }, b = (w) => (O) => {
    const { target: R } = w, te = 10 * 60 * 1e3, W = (
      // target.creator?.id !== user.id ||
      !R.created || (/* @__PURE__ */ new Date()).getTime() - R.created.getTime() > te
    );
    X.updateTarget({
      ...R,
      selector: O.detail,
      created: W ? R.created : /* @__PURE__ */ new Date(),
      updated: W ? /* @__PURE__ */ new Date() : null
    });
  };
  function A(w) {
    we[w ? "unshift" : "push"](() => {
      p = w, n(3, p);
    });
  }
  function M(w) {
    we[w ? "unshift" : "push"](() => {
      T = w, n(2, T);
    });
  }
  return e.$$set = (w) => {
    "image" in w && n(16, d = w.image), "state" in w && n(17, m = w.state), "style" in w && n(0, g = w.style), "tool" in w && n(1, _ = w.tool);
  }, e.$$.update = () => {
    e.$$.dirty & /*svgEl*/
    4 && n(9, o = No(T)), e.$$.dirty & /*svgEl*/
    4 && n(8, { onPointerDown: i, onPointerUp: s } = Ho(T, X), i, (n(7, s), n(2, T))), e.$$.dirty & /*$selection*/
    262144 && n(6, r = (w) => a.selected.find((O) => O.id === w.id && O.editable)), e.$$.dirty & /*$selection*/
    262144 && F(a.selected);
  }, [
    g,
    _,
    T,
    p,
    E,
    C,
    r,
    s,
    i,
    o,
    l,
    u,
    I,
    X,
    y,
    b,
    d,
    m,
    a,
    A,
    M
  ];
}
class Zo extends ee {
  constructor(t) {
    super(), $(this, t, Qo, Jo, q, { image: 16, state: 17, style: 0, tool: 1 });
  }
}
function Ko(e, t, n, o, i) {
  qt(e, t, n || 0, o || e.length - 1, i || xo);
}
function qt(e, t, n, o, i) {
  for (; o > n; ) {
    if (o - n > 600) {
      var s = o - n + 1, r = t - n + 1, a = Math.log(s), l = 0.5 * Math.exp(2 * a / 3), u = 0.5 * Math.sqrt(a * l * (s - l) / s) * (r - s / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - r * l / s + u)), c = Math.min(o, Math.floor(t + (s - r) * l / s + u));
      qt(e, t, h, c, i);
    }
    var d = e[t], m = n, g = o;
    for (Ee(e, n, t), i(e[o], d) > 0 && Ee(e, n, o); m < g; ) {
      for (Ee(e, m, g), m++, g--; i(e[m], d) < 0; )
        m++;
      for (; i(e[g], d) > 0; )
        g--;
    }
    i(e[n], d) === 0 ? Ee(e, n, g) : (g++, Ee(e, g, o)), g <= t && (n = g + 1), t <= g && (o = g - 1);
  }
}
function Ee(e, t, n) {
  var o = e[t];
  e[t] = e[n], e[n] = o;
}
function xo(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
class $o {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const o = [];
    if (!De(t, n))
      return o;
    const i = this.toBBox, s = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const a = n.children[r], l = n.leaf ? i(a) : a;
        De(t, l) && (n.leaf ? o.push(a) : xe(t, l) ? this._all(a, o) : s.push(a));
      }
      n = s.pop();
    }
    return o;
  }
  collides(t) {
    let n = this.data;
    if (!De(t, n))
      return !1;
    const o = [];
    for (; n; ) {
      for (let i = 0; i < n.children.length; i++) {
        const s = n.children[i], r = n.leaf ? this.toBBox(s) : s;
        if (De(t, r)) {
          if (n.leaf || xe(t, r))
            return !0;
          o.push(s);
        }
      }
      n = o.pop();
    }
    return !1;
  }
  load(t) {
    if (!(t && t.length))
      return this;
    if (t.length < this._minEntries) {
      for (let o = 0; o < t.length; o++)
        this.insert(t[o]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const o = this.data;
        this.data = n, n = o;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = pe([]), this;
  }
  remove(t, n) {
    if (!t)
      return this;
    let o = this.data;
    const i = this.toBBox(t), s = [], r = [];
    let a, l, u;
    for (; o || s.length; ) {
      if (o || (o = s.pop(), l = s[s.length - 1], a = r.pop(), u = !0), o.leaf) {
        const h = ei(t, o.children, n);
        if (h !== -1)
          return o.children.splice(h, 1), s.push(o), this._condense(s), this;
      }
      !u && !o.leaf && xe(o, i) ? (s.push(o), r.push(a), a = 0, l = o, o = o.children[0]) : l ? (a++, o = l.children[a], u = !1) : o = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const o = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : o.push(...t.children), t = o.pop();
    return n;
  }
  _build(t, n, o, i) {
    const s = o - n + 1;
    let r = this._maxEntries, a;
    if (s <= r)
      return a = pe(t.slice(n, o + 1)), me(a, this.toBBox), a;
    i || (i = Math.ceil(Math.log(s) / Math.log(r)), r = Math.ceil(s / Math.pow(r, i - 1))), a = pe([]), a.leaf = !1, a.height = i;
    const l = Math.ceil(s / r), u = l * Math.ceil(Math.sqrt(r));
    Yt(t, n, o, u, this.compareMinX);
    for (let h = n; h <= o; h += u) {
      const c = Math.min(h + u - 1, o);
      Yt(t, h, c, l, this.compareMinY);
      for (let d = h; d <= c; d += l) {
        const m = Math.min(d + l - 1, c);
        a.children.push(this._build(t, d, m, i - 1));
      }
    }
    return me(a, this.toBBox), a;
  }
  _chooseSubtree(t, n, o, i) {
    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {
      let s = 1 / 0, r = 1 / 0, a;
      for (let l = 0; l < n.children.length; l++) {
        const u = n.children[l], h = Ke(u), c = oi(t, u) - h;
        c < r ? (r = c, s = h < s ? h : s, a = u) : c === r && h < s && (s = h, a = u);
      }
      n = a || n.children[0];
    }
    return n;
  }
  _insert(t, n, o) {
    const i = o ? t : this.toBBox(t), s = [], r = this._chooseSubtree(i, this.data, n, s);
    for (r.children.push(t), Te(r, i); n >= 0 && s[n].children.length > this._maxEntries; )
      this._split(s, n), n--;
    this._adjustParentBBoxes(i, s, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const o = t[n], i = o.children.length, s = this._minEntries;
    this._chooseSplitAxis(o, s, i);
    const r = this._chooseSplitIndex(o, s, i), a = pe(o.children.splice(r, o.children.length - r));
    a.height = o.height, a.leaf = o.leaf, me(o, this.toBBox), me(a, this.toBBox), n ? t[n - 1].children.push(a) : this._splitRoot(o, a);
  }
  _splitRoot(t, n) {
    this.data = pe([t, n]), this.data.height = t.height + 1, this.data.leaf = !1, me(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, o) {
    let i, s = 1 / 0, r = 1 / 0;
    for (let a = n; a <= o - n; a++) {
      const l = Ae(t, 0, a, this.toBBox), u = Ae(t, a, o, this.toBBox), h = ii(l, u), c = Ke(l) + Ke(u);
      h < s ? (s = h, i = a, r = c < r ? c : r) : h === s && c < r && (r = c, i = a);
    }
    return i || o - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, o) {
    const i = t.leaf ? this.compareMinX : ti, s = t.leaf ? this.compareMinY : ni, r = this._allDistMargin(t, n, o, i), a = this._allDistMargin(t, n, o, s);
    r < a && t.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, o, i) {
    t.children.sort(i);
    const s = this.toBBox, r = Ae(t, 0, n, s), a = Ae(t, o - n, o, s);
    let l = Xe(r) + Xe(a);
    for (let u = n; u < o - n; u++) {
      const h = t.children[u];
      Te(r, t.leaf ? s(h) : h), l += Xe(r);
    }
    for (let u = o - n - 1; u >= n; u--) {
      const h = t.children[u];
      Te(a, t.leaf ? s(h) : h), l += Xe(a);
    }
    return l;
  }
  _adjustParentBBoxes(t, n, o) {
    for (let i = o; i >= 0; i--)
      Te(n[i], t);
  }
  _condense(t) {
    for (let n = t.length - 1, o; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (o = t[n - 1].children, o.splice(o.indexOf(t[n]), 1)) : this.clear() : me(t[n], this.toBBox);
  }
}
function ei(e, t, n) {
  if (!n)
    return t.indexOf(e);
  for (let o = 0; o < t.length; o++)
    if (n(e, t[o]))
      return o;
  return -1;
}
function me(e, t) {
  Ae(e, 0, e.children.length, t, e);
}
function Ae(e, t, n, o, i) {
  i || (i = pe(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let s = t; s < n; s++) {
    const r = e.children[s];
    Te(i, e.leaf ? o(r) : r);
  }
  return i;
}
function Te(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function ti(e, t) {
  return e.minX - t.minX;
}
function ni(e, t) {
  return e.minY - t.minY;
}
function Ke(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function Xe(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function oi(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function ii(e, t) {
  const n = Math.max(e.minX, t.minX), o = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);
  return Math.max(0, i - n) * Math.max(0, s - o);
}
function xe(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function De(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function pe(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Yt(e, t, n, o, i) {
  const s = [t, n];
  for (; s.length; ) {
    if (n = s.pop(), t = s.pop(), n - t <= o)
      continue;
    const r = t + Math.ceil((n - t) / o / 2) * o;
    Ko(e, r, t, n, i), s.push(t, r, r, n);
  }
}
const si = () => {
  const e = new $o(), t = /* @__PURE__ */ new Map(), n = () => [...t.values()], o = () => {
    e.clear(), t.clear();
  }, i = (c) => {
    const { minX: d, minY: m, maxX: g, maxY: _ } = c.selector.geometry.bounds, p = { minX: d, minY: m, maxX: g, maxY: _, target: c };
    e.insert(p), t.set(c.annotation, p);
  }, s = (c) => {
    const d = t.get(c.annotation);
    e.remove(d), t.delete(c.annotation);
  };
  return {
    all: n,
    clear: o,
    getAt: (c, d) => {
      const g = e.search({
        minX: c,
        minY: d,
        maxX: c,
        maxY: d
      }).map((_) => _.target).filter((_) => _.selector.type === H.RECTANGLE || ln(_.selector, c, d));
      if (g.length > 0)
        return g.sort((_, p) => ut(_.selector) - ut(p.selector)), g[0];
    },
    getIntersecting: (c, d, m, g) => e.search({
      minX: c,
      minY: d,
      maxX: c + m,
      maxY: d + g
    }).map((_) => _.target),
    insert: i,
    remove: s,
    set: (c, d = !0) => {
      d && o();
      const m = c.map((g) => {
        const { minX: _, minY: p, maxX: T, maxY: E } = g.selector.geometry.bounds;
        return { minX: _, minY: p, maxX: T, maxY: E, target: g };
      });
      m.forEach((g) => t.set(g.target.annotation, g)), e.load(m);
    },
    size: () => e.all().length,
    update: (c, d) => {
      s(c), i(d);
    }
  };
}, ri = (e) => {
  const t = Pn(), n = si(), o = Sn(t, e.pointerSelectAction), i = Tn(t), s = Rn();
  return t.observe(({ changes: l }) => {
    n.set(l.created.map((u) => u.target), !1), l.deleted.forEach((u) => n.remove(u.target)), l.updated.forEach(({ oldValue: u, newValue: h }) => n.update(u.target, h.target));
  }), {
    store: {
      ...t,
      getAt: (l, u) => {
        const h = n.getAt(l, u);
        return h ? t.getAnnotation(h.annotation) : void 0;
      },
      getIntersecting: (l, u, h, c) => n.getIntersecting(l, u, h, c).map((d) => t.getAnnotation(d.annotation))
    },
    selection: o,
    hover: i,
    viewport: s
  };
}, li = (e) => {
  const t = ri(e);
  return {
    ...t,
    store: Yn(t.store)
  };
}, ai = (e) => {
  let t, n;
  if (e.nodeName === "CANVAS")
    t = e, n = t.getContext("2d", { willReadFrequently: !0 });
  else {
    const i = e;
    t = document.createElement("canvas"), t.width = i.width, t.height = i.height, n = t.getContext("2d", { willReadFrequently: !0 }), n.drawImage(i, 0, 0, i.width, i.height);
  }
  let o = 0;
  for (let i = 1; i < 10; i++)
    for (let s = 1; s < 10; s++) {
      const r = Math.round(s * t.width / 10), a = Math.round(i * t.height / 10), l = n.getImageData(r, a, 1, 1).data, u = (0.299 * l[0] + 0.587 * l[1] + 0.114 * l[2]) / 255;
      o += u;
    }
  return o / 81;
}, ci = (e, t) => {
  const n = ai(e), o = n > 0.6 ? "dark" : "light";
  console.log(`[Annotorious] Image brightness: ${n.toFixed(1)}. Setting ${o} theme.`), t.setAttribute("data-theme", o);
}, fi = (e) => ({
  ...e,
  pointerSelectAction: e.pointerSelectAction || Ft.EDIT
});
const wi = (e, t = {}) => {
  if (!e)
    throw "Missing argument: image";
  const n = typeof e == "string" ? document.getElementById(e) : e, o = fi(t), i = li(o), { hover: s, selection: r, store: a } = i, l = Xn(
    a,
    r,
    s,
    void 0,
    o.adapter,
    o.autoSave
  );
  let u = o.style, h = o.readOnly ? null : zn();
  const c = document.createElement("DIV");
  c.style.position = "relative", c.style.display = "inline-block", n.style.display = "block", n.parentNode.insertBefore(c, n), c.appendChild(n), ci(n, c);
  const d = new Zo({
    target: c,
    props: { image: n, state: i, style: u }
  });
  d.$on("click", (C) => {
    const { originalEvent: F, annotation: y } = C.detail;
    y ? r.clickSelect(y.id, F) : r.isEmpty() || r.clear();
  });
  const m = Gn(a, o.adapter), g = (C) => {
    u = C, d.$set({ style: C });
  }, _ = () => {
    d.$destroy(), c.parentNode.insertBefore(n, c), c.parentNode.removeChild(c);
  }, p = (C, F) => Lo(C, F), T = (C, F) => ao(C, F), E = () => h, I = (C) => {
    const F = Vt(C);
    d.$set({ tool: F });
  }, X = (C) => {
    C ? r.setSelected(C) : r.clear();
  }, G = (C) => {
    h = C;
  };
  return {
    ...m,
    get style() {
      return u;
    },
    set style(C) {
      g(C);
    },
    destroy: _,
    getUser: E,
    on: l.on,
    off: l.off,
    registerDrawingTool: p,
    registerShapeEditor: T,
    setDrawingTool: I,
    setSelected: X,
    setUser: G,
    state: i
  };
};
export {
  jt as Editor,
  mo as EditorMount,
  v as Handle,
  yi as IdentityTransform,
  mi as PRESENCE_KEY,
  oo as PolygonEditor,
  lo as RectangleEditor,
  fn as RectangleUtil,
  wo as RubberbandRectangle,
  Zo as SVGAnnotationLayer,
  H as ShapeType,
  po as ToolMount,
  pi as W3CImageFormat,
  Ho as addEventListeners,
  Ne as boundsFromPoints,
  ut as computeArea,
  zn as createAnonymousGuest,
  Gn as createBaseAnnotator,
  di as createBody,
  Qn as createDefaultAppearenceProvider,
  wi as createImageAnnotator,
  ri as createImageAnnotatorState,
  gi as createPresenceState,
  No as createSVGTransform,
  li as createSvelteImageAnnotatorState,
  Jn as defaultColorProvider,
  In as diffAnnotations,
  At as distance,
  Eo as enableResponsive,
  fi as fillDefaults,
  ui as getContributors,
  wt as getEditor,
  Vt as getTool,
  ln as intersects,
  Ao as isTouch,
  _i as listTools,
  Dn as parseAll,
  un as parseFragmentSelector,
  _n as parseSVGSelector,
  Vn as parseW3CBodies,
  xn as parseW3CImageAnnotation,
  ao as registerEditor,
  ot as registerShapeUtil,
  Lo as registerTool,
  ai as sampleBrightness,
  hi as serializeAll,
  dn as serializeFragmentSelector,
  yn as serializeSVGSelector,
  qn as serializeW3CBodies,
  $n as serializeW3CImageAnnotation,
  ci as setTheme
};
//# sourceMappingURL=annotorious.es.js.map
