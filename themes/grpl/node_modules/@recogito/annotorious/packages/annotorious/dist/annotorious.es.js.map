{"version":3,"file":"annotorious.es.js","sources":["../../../node_modules/svelte/internal/index.mjs","../src/model/core/Shape.ts","../src/model/core/shapeUtils.ts","../src/model/core/ellipse/ellipseUtils.ts","../src/model/core/polygon/polygonUtils.ts","../src/model/core/rectangle/rectangleUtils.ts","../src/model/w3c/fragment/FragmentSelector.ts","../src/model/w3c/svg/SVG.ts","../src/model/w3c/svg/SVGSelector.ts","../../../node_modules/uuid/dist/esm-browser/rng.js","../../../node_modules/uuid/dist/esm-browser/stringify.js","../../../node_modules/uuid/dist/esm-browser/native.js","../../../node_modules/uuid/dist/esm-browser/v4.js","../../../node_modules/dequal/lite/index.mjs","../../../node_modules/svelte/store/index.mjs","../../annotorious-core/src/state/Hover.ts","../../annotorious-core/src/state/Selection.ts","../../annotorious-core/src/utils/annotationUtils.ts","../../annotorious-core/src/utils/diffAnnotations.ts","../../annotorious-core/src/state/StoreObserver.ts","../../annotorious-core/src/state/Store.ts","../../annotorious-core/src/state/SvelteStore.ts","../../annotorious-core/src/state/Viewport.ts","../../annotorious-core/src/lifecycle/Lifecycle.ts","../../annotorious-core/src/model/FormatAdapter.ts","../../annotorious-core/src/model/Annotator.ts","../../../node_modules/nanoid/index.browser.js","../../annotorious-core/src/model/User.ts","../../annotorious-core/src/model/W3CAnnotation.ts","../../annotorious-core/src/presence/ColorPalette.ts","../../annotorious-core/src/presence/AppearanceProvider.ts","../../../node_modules/nanoevents/index.js","../../annotorious-core/src/presence/PresenceState.ts","../src/model/w3c/W3CImageFormatAdapter.ts","../src/annotation/editors/polygon/PolygonEditor.svelte","../src/annotation/editors/rectangle/RectangleEditor.svelte","../src/annotation/editors/editorsRegistry.ts","../src/annotation/editors/Handle.ts","../src/annotation/editors/Editor.svelte","../src/annotation/utils/styling.ts","../src/annotation/editors/EditorMount.svelte","../src/annotation/tools/ToolMount.svelte","../src/annotation/tools/rectangle/RubberbandRectangle.svelte","../src/annotation/utils/math.ts","../src/annotation/utils/responsive.ts","../src/annotation/utils/touch.ts","../src/annotation/tools/polygon/RubberbandPolygon.svelte","../src/annotation/tools/drawingToolsRegistry.ts","../src/annotation/shapes/Ellipse.svelte","../src/annotation/shapes/Polygon.svelte","../src/annotation/shapes/Rectangle.svelte","../src/annotation/Transform.ts","../src/annotation/SVGAnnotationLayerPointerEvent.ts","../src/annotation/SVGAnnotationLayer.svelte","../../../node_modules/quickselect/index.js","../../../node_modules/rbush/index.js","../src/state/spatialTree.ts","../src/state/ImageAnnotatorState.ts","../src/themes/smart/setTheme.ts","../src/AnnotoriousOpts.ts","../src/Annotorious.ts"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n    constructor(options) {\n        this.options = options;\n        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\n    }\n    observe(element, listener) {\n        this._listeners.set(element, listener);\n        this._getObserver().observe(element, this.options);\n        return () => {\n            this._listeners.delete(element);\n            this._observer.unobserve(element); // this line can probably be removed\n        };\n    }\n    _getObserver() {\n        var _a;\n        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {\n            var _a;\n            for (const entry of entries) {\n                ResizeObserverSingleton.entries.set(entry.target, entry);\n                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n            }\n        }));\n    }\n}\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value == null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_iframe_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro  we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro  needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_iframe_resize_listener, add_location, add_render_callback, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n","import type { AbstractSelector } from '@annotorious/core';\n\nexport interface Shape extends AbstractSelector {\n\n  type: ShapeType;\n\n  geometry: Geometry;\n\n}\n\nexport enum ShapeType {\n\n  ELLIPSE = 'ELLIPSE',\n\n  POLYGON = 'POLYGON',\n\n  RECTANGLE = 'RECTANGLE'\n\n}\n\nexport interface Geometry {\n\n  bounds: Bounds;\n\n}\n\nexport interface Bounds {\n\n  minX: number;\n\n  minY: number;\n\n  maxX: number;\n\n  maxY: number;\n\n}","import type { Bounds, Shape, ShapeType } from './Shape';\n\nexport interface ShapeUtil<T extends Shape> {\n\n  area: (shape: T) => number;\n\n  intersects: (shape: T, x: number, y: number) => boolean;\n\n}\n\nconst Utils: { [key: string]: ShapeUtil<any> } = {};\n\n/**\n * Registers a new ShapeUtil for a given shape type.\n * @param type the shape type\n * @param util the ShapeUtil implementation for this shape type\n */\nexport const registerShapeUtil = (type: ShapeType | string, util: ShapeUtil<any>) =>\n  (Utils[type] = util);\n\n/**\n * Computes the area of the given shape. Delegates to the corresponding ShapeUtil.\n * @param shape the shape\n */\nexport const computeArea = (shape: Shape) => Utils[shape.type].area(shape);\n\n/**\n * Tests if the given shape intersects the given point. Delegates to\n * the corresponding ShapeUtil.\n * @param shape the shape\n * @param x point x coord\n * @param y point y coord\n * @returns true if shape and point intersect\n */\nexport const intersects = (shape: Shape, x: number, y: number): boolean =>\n  Utils[shape.type].intersects(shape, x, y);\n\n/**\n * Computes Bounds from a given list of points.\n * @param points the points\n * @returns the Bounds\n */\nexport const boundsFromPoints = (points: Array<[number, number]>): Bounds => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  points.forEach(([x, y]) => {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  });\n\n  return { minX, minY, maxX, maxY };\n};","import { ShapeType } from '../Shape';\nimport { registerShapeUtil, type ShapeUtil } from '../shapeUtils';\nimport type { Ellipse } from './Ellipse';\n\nconst EllipseUtil: ShapeUtil<Ellipse> = {\n\n  area: (e: Ellipse): number => Math.PI * e.geometry.rx * e.geometry.ry,\n\n  intersects: (e: Ellipse, x: number, y: number): boolean => {\n    const { cx, cy, rx, ry } = e.geometry;\n\n    // For future use\n    const rot = 0;\n\n    const cos = Math.cos(rot);\n    const sin = Math.sin(rot);\n  \n    const dx  = x - cx;\n    const dy  = y - cy;\n  \n    const tdx = cos * dx + sin * dy;\n    const tdy = sin * dx - cos * dy;\n  \n    return (tdx * tdx) / (rx * rx) + (tdy * tdy) / (ry * ry) <= 1;\n  }\n};\n\nregisterShapeUtil(ShapeType.ELLIPSE, EllipseUtil);","import { ShapeType } from '../Shape';\nimport { registerShapeUtil, type ShapeUtil } from '../shapeUtils';\nimport type { Polygon } from './Polygon';\n\nconst PolygonUtil: ShapeUtil<Polygon> = {\n\n  area: (polygon: Polygon): number => {\n    const { points } = polygon.geometry;\n\n    let area = 0;\n    let j = points.length - 1;\n\n    for (let i = 0; i < points.length; i++) {\n      area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n      j = i;\n    }\n\n    return Math.abs(0.5 * area);\n  },\n\n  intersects: (polygon: Polygon, x: number, y: number): boolean => {\n    // Based on https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n    const { points } = polygon.geometry;\n\n    let inside = false;\n\n    for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n      const xi = points[i][0],\n        yi = points[i][1];\n      const xj = points[j][0],\n        yj = points[j][1];\n\n      const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n\n      if (intersect) inside = !inside;\n    }\n\n    return inside;\n  }\n  \n};\n\nregisterShapeUtil(ShapeType.POLYGON, PolygonUtil);","import { ShapeType } from '../Shape';\nimport type { Rectangle } from './Rectangle';\nimport { registerShapeUtil, type ShapeUtil } from '../shapeUtils';\n\nexport const RectangleUtil: ShapeUtil<Rectangle> = {\n\n  area: (rect: Rectangle): number => rect.geometry.w * rect.geometry.h,\n\n  intersects: (rect: Rectangle, x: number, y: number): boolean =>\n    x >= rect.geometry.x &&\n    x <= rect.geometry.x + rect.geometry.w &&\n    y >= rect.geometry.y &&\n    y <= rect.geometry.y + rect.geometry.h\n    \n};\n\nregisterShapeUtil(ShapeType.RECTANGLE, RectangleUtil);","import type { W3CSelector } from '@annotorious/core';\nimport { ShapeType } from '../../core';\nimport type { Rectangle, RectangleGeometry } from '../../core';\n\nexport interface FragmentSelector extends W3CSelector {\n\n  type: 'FragmentSelector';\n\n  conformsTo: 'http://www.w3.org/TR/media-frags/',\n\n  value: string;\n  \n}\n\nexport const parseFragmentSelector = (\n  fragmentOrSelector: FragmentSelector | string,\n  invertY = false\n): Rectangle => {\n\n  const fragment =\n    typeof fragmentOrSelector === 'string' ? fragmentOrSelector : fragmentOrSelector.value;\n\n  const regex = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g;\n\n  const matches = [...fragment.matchAll(regex)][0];\n  const [_, prefix, unit, a, b, c, d] = matches;\n\n  if (prefix !== 'xywh') throw new Error('Unsupported MediaFragment: ' + fragment);\n\n  if (unit && unit !== 'pixel') throw new Error(`Unsupported MediaFragment unit: ${unit}`);\n\n  const [x, y, w, h] = [a, b, c, d].map(parseFloat);\n\n  return {\n    type: ShapeType.RECTANGLE,\n    geometry: {\n      x,\n      y,\n      w,\n      h,\n      bounds: {\n        minX: x,\n        minY: invertY ? y - h : y,\n        maxX: x + w,\n        maxY: invertY ? y : y + h\n      }\n    }\n  }\n};\n\nexport const serializeFragmentSelector = (geometry: RectangleGeometry): FragmentSelector => {\n  const { x, y, w, h } = geometry;\n  \n  return {\n    type: 'FragmentSelector',\n    conformsTo: 'http://www.w3.org/TR/media-frags/',\n    value: `xywh=pixel:${x},${y},${w},${h}`\n  };\n};","export const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const sanitize = (doc: Element | Document) => {\n  // Cf. https://github.com/mattkrick/sanitize-svg#readme  \n  // for the basic approach\n  const cleanEl = (el: Element) => {\n    Array.from(el.attributes).forEach(attr => {\n      if (attr.name.startsWith('on'))\n        el.removeAttribute(attr.name)\n    });\n  }\n\n  // Remove script tags\n  const scripts = doc.getElementsByTagName('script');\n\n  Array.from(scripts).reverse().forEach(el =>\n    el.parentNode.removeChild(el));\n\n  Array.from(doc.querySelectorAll('*')).forEach(cleanEl);\n\n  return doc;\n}\n\n/** Helper that forces an un-namespaced node to SVG **/\nexport const insertSVGNamespace = (originalDoc: Document): Element => {\n  // Serialize and parse for the namespace to take effect on every node\n  const serializer = new XMLSerializer();\n  const str = serializer.serializeToString(originalDoc.documentElement);\n\n  // Doesn't seem that there's a clean cross-browser way for this...\n  const namespaced = str.replace('<svg>', `<svg xmlns=\"${SVG_NAMESPACE}\">`);\n\n  const parser = new DOMParser();\n  const namespacedDoc = parser.parseFromString(namespaced, \"image/svg+xml\");\n  return namespacedDoc.documentElement;\n}\n","import type { W3CSelector } from '@annotorious/core';\nimport { boundsFromPoints, ShapeType } from '../../core';\nimport type { Ellipse, EllipseGeometry, Polygon, PolygonGeometry, Shape } from '../../core';\nimport { SVG_NAMESPACE, insertSVGNamespace, sanitize } from './SVG';\n\nexport interface SVGSelector extends W3CSelector {\n\n  type: 'SvgSelector';\n\n  value: string;\n  \n}\n\nconst parseSVGXML = (value: string): Element => {\n  const parser = new DOMParser();\n\n  const doc = parser.parseFromString(value, \"image/svg+xml\");\n\n  // SVG needs a namespace declaration - check if it's set or insert if not\n  const isPrefixDeclared = doc.lookupPrefix(SVG_NAMESPACE); // SVG declared via prefix\n  const isDefaultNamespaceSVG = doc.lookupNamespaceURI(null); // SVG declared as default namespace\n\n  if (isPrefixDeclared || isDefaultNamespaceSVG) {\n    return sanitize(doc).firstChild as Element;\n  } else {\n    return sanitize(insertSVGNamespace(doc)).firstChild as Element;\n  }\n}\n\nconst parseSVGPolygon = (value: string): Polygon => {\n  const [a, b, str] = value.match(/(<polygon points=[\"|'])([^(\"|')]*)/) || [];\n\n  if (!str) return;\n\n  const points = str.split(' ').map((p) => p.split(',').map(parseFloat));\n\n  return {\n    type: ShapeType.POLYGON,\n    geometry: {\n      points,\n      bounds: boundsFromPoints(points as [number, number][])\n    }\n  };\n}\n\nconst parseSVGEllipse = (value: string): Ellipse => {\n  const doc = parseSVGXML(value);\n\n  const cx = parseFloat(doc.getAttribute('cx'));\n  const cy = parseFloat(doc.getAttribute('cy'));\n  const rx = parseFloat(doc.getAttribute('rx'));\n  const ry = parseFloat(doc.getAttribute('ry'));\n\n  const bounds = {\n    minX: cx - rx,\n    minY: cy - ry,\n    maxX: cx + rx,\n    maxY: cy + ry\n  };\n\n  return {\n    type: ShapeType.ELLIPSE,\n    geometry: {\n      cx,\n      cy,\n      rx,\n      ry,\n      bounds\n    }\n  };\n}\n\nexport const parseSVGSelector = <T extends Shape>(valueOrSelector: SVGSelector | string): T => {\n  const value = typeof valueOrSelector === 'string' ? valueOrSelector : valueOrSelector.value;\n\n  if (value.includes('<polygon points='))\n    return parseSVGPolygon(value) as unknown as T;\n  else if (value.includes('<ellipse ')) \n    return parseSVGEllipse(value) as unknown as T;\n}\n\nexport const serializeSVGSelector = (shape: Shape): SVGSelector => {\n  let value: string;\n\n  if (shape.type === ShapeType.POLYGON) {\n    const geom = shape.geometry as PolygonGeometry;\n    const { points } = geom;\n    value = `<svg><polygon points=\"${points.map((xy) => xy.join(',')).join(' ')}\" /></svg>`;\n  } else if (shape.type === ShapeType.ELLIPSE) {\n    const geom = shape.geometry as EllipseGeometry;\n    value = `<svg><ellipse cx=\"${geom.cx}\" cy=\"${geom.cy}\" rx=\"${geom.rx}\" ry=\"${geom.ry}\" /></svg>`\n  }\n\n  if (value) {\n    return { type: 'SvgSelector', value };\n  } else {\n    throw `Unsupported shape type: ${shape.type}`;\n  }\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import { noop, safe_not_equal, subscribe, run_all, is_function } from '../internal/index.mjs';\nexport { get_store_value as get } from '../internal/index.mjs';\n\nconst subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier} [start]\n */\nfunction readable(value, start) {\n    return {\n        subscribe: writable(value, start).subscribe\n    };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=} start\n */\nfunction writable(value, start = noop) {\n    let stop;\n    const subscribers = new Set();\n    function set(new_value) {\n        if (safe_not_equal(value, new_value)) {\n            value = new_value;\n            if (stop) { // store is ready\n                const run_queue = !subscriber_queue.length;\n                for (const subscriber of subscribers) {\n                    subscriber[1]();\n                    subscriber_queue.push(subscriber, value);\n                }\n                if (run_queue) {\n                    for (let i = 0; i < subscriber_queue.length; i += 2) {\n                        subscriber_queue[i][0](subscriber_queue[i + 1]);\n                    }\n                    subscriber_queue.length = 0;\n                }\n            }\n        }\n    }\n    function update(fn) {\n        set(fn(value));\n    }\n    function subscribe(run, invalidate = noop) {\n        const subscriber = [run, invalidate];\n        subscribers.add(subscriber);\n        if (subscribers.size === 1) {\n            stop = start(set) || noop;\n        }\n        run(value);\n        return () => {\n            subscribers.delete(subscriber);\n            if (subscribers.size === 0 && stop) {\n                stop();\n                stop = null;\n            }\n        };\n    }\n    return { set, update, subscribe };\n}\nfunction derived(stores, fn, initial_value) {\n    const single = !Array.isArray(stores);\n    const stores_array = single\n        ? [stores]\n        : stores;\n    const auto = fn.length < 2;\n    return readable(initial_value, (set) => {\n        let started = false;\n        const values = [];\n        let pending = 0;\n        let cleanup = noop;\n        const sync = () => {\n            if (pending) {\n                return;\n            }\n            cleanup();\n            const result = fn(single ? values[0] : values, set);\n            if (auto) {\n                set(result);\n            }\n            else {\n                cleanup = is_function(result) ? result : noop;\n            }\n        };\n        const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {\n            values[i] = value;\n            pending &= ~(1 << i);\n            if (started) {\n                sync();\n            }\n        }, () => {\n            pending |= (1 << i);\n        }));\n        started = true;\n        sync();\n        return function stop() {\n            run_all(unsubscribers);\n            cleanup();\n            // We need to set this to false because callbacks can still happen despite having unsubscribed:\n            // Callbacks might already be placed in the queue which doesn't know it should no longer\n            // invoke this derived store.\n            started = false;\n        };\n    });\n}\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * @param store - store to make readonly\n */\nfunction readonly(store) {\n    return {\n        subscribe: store.subscribe.bind(store)\n    };\n}\n\nexport { derived, readable, readonly, writable };\n","import { writable } from 'svelte/store';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport type HoverState<T extends Annotation> = ReturnType<typeof createHoverState<T>>;\n\nexport const createHoverState = <T extends Annotation>(store: Store<T>) => {\n\n  const { subscribe, set } = writable<string>(null);\n\n  let currentHover: string = null;\n\n  subscribe(updated => currentHover = updated);\n\n  // Track store delete and update events\n  store.observe(( { changes }) => {    \n    if (currentHover) {\n      const isDeleted = changes.deleted.some(a => a.id === currentHover);\n      if (isDeleted)\n        set(null);\n    \n      const updated = changes.updated.find(({ oldValue }) => oldValue.id === currentHover);\n      if (updated)\n        set(updated.newValue.id);\n    }\n  });\n\n  return { \n    get current() { return currentHover },\n    subscribe, \n    set \n  };\n\n}\n","import { writable } from 'svelte/store';\nimport type {  Annotation } from '../model';\nimport type { Store } from './Store';\n   \nexport type Selection = {\n\n  selected: { id: string, editable?: boolean }[],\n\n  pointerEvent?: PointerEvent;\n\n}\n\nexport type SelectionState<T extends Annotation> = ReturnType<typeof createSelectionState<T>>;\n\nexport enum PointerSelectAction {\n\n  EDIT = 'EDIT', // Make annotation target(s) editable on pointer select\n  \n  HIGHLIGHT = 'HIGHLIGHT',  // Just hightlight on select, but don't make editable\n\n  NONE = 'NONE' // Click won't select - annotation is completely inert\n\n}\n\nconst EMPTY: Selection = { selected: [] };\n\nexport const createSelectionState = <T extends Annotation>(\n  store: Store<T>,\n  selectAction: PointerSelectAction | ((a: Annotation) => PointerSelectAction) = PointerSelectAction.EDIT\n) => {\n  const { subscribe, set } = writable<Selection>(EMPTY);\n\n  let currentSelection: Selection = EMPTY;\n\n  subscribe(updated => currentSelection = updated);\n\n  const clear = () => set(EMPTY);\n\n  const isEmpty = () => currentSelection.selected?.length === 0;\n\n  const isSelected = (annotationOrId: T | string) => {\n    if (currentSelection.selected.length === 0)\n      return false;\n\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n    return currentSelection.selected.some(i => i.id === id);\n  }\n\n  // TODO enable CTRL select\n  const clickSelect = (id: string, pointerEvent: PointerEvent) => {\n    const annotation = store.getAnnotation(id);\n    if (annotation) {\n      const action = onPointerSelect(annotation, selectAction);\n      if (action === PointerSelectAction.EDIT)\n        set({ selected: [{ id, editable: true }], pointerEvent }); \n      else if (action === PointerSelectAction.HIGHLIGHT)\n        set({ selected: [{ id }], pointerEvent }); \n      else\n        set({ selected: [], pointerEvent });\n    } else {\n      console.warn('Invalid selection: ' + id);\n    }\n  }\n\n  const setSelected = (idOrIds: string | string[], editable: boolean = true) => {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    // Remove invalid\n    const annotations = \n      ids.map(id => store.getAnnotation(id)).filter(a => a); \n\n    set({ selected: annotations.map(({ id }) => ({ id, editable })) });\n    \n    if (annotations.length !== ids.length)\n      console.warn('Invalid selection', idOrIds);\n  }\n\n  const removeFromSelection = (ids: string[]) => {\n    if (currentSelection.selected.length === 0)\n      return false;\n\n    const { selected } = currentSelection;\n\n    // Checks which of the given annotations are actually in the selection\n    const toRemove = selected.filter(({ id  }) => ids.includes(id))\n\n    if (toRemove.length > 0)\n      set({ selected: selected.filter(({ id }) => !ids.includes(id)) });\n  }\n\n  // Track store delete and update events\n  store.observe(({ changes }) =>\n    removeFromSelection(changes.deleted.map(a => a.id)));\n\n  return { \n    clear, \n    clickSelect, \n    get selected() { return currentSelection ? [...currentSelection.selected ] : null},\n    get pointerEvent() { return currentSelection ? currentSelection.pointerEvent : null },\n    isEmpty, \n    isSelected, \n    setSelected, \n    subscribe \n  };\n\n}\n\nexport const onPointerSelect = (\n  annotation: Annotation, \n  action?: PointerSelectAction | ((a: Annotation) => PointerSelectAction)\n): PointerSelectAction => (typeof action === 'function') ?\n    (action(annotation) || PointerSelectAction.EDIT) : \n    (action || PointerSelectAction.EDIT);\n","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation, AnnotationBody, User } from '../model';\n\n/**\n * Returns all users listed as creators or updaters in any parts of this\n * annotation.\n */\nexport const getContributors = (annotation: Annotation): User[] => {\n  const { creator, updatedBy } = annotation.target;\n\n  const bodyCollaborators = annotation.bodies.reduce((users, body) =>  (\n    [...users, body.creator, body.updatedBy]\n  ), [] as User[]);\n\n  return [\n    creator,\n    updatedBy,\n    ...bodyCollaborators\n  ].filter(u => u); // Remove undefined\n}\n\nexport const createBody = (\n  annotation: Annotation, \n  payload: { [key: string]: any },\n  created?: Date,\n  creator?: User\n): AnnotationBody => ({\n  id: uuidv4(),\n  annotation: annotation.id,\n  created: created || new Date(),\n  creator,\n  ...payload\n});","import { dequal } from 'dequal/lite';\nimport type { Update } from '../state';\nimport type { Annotation } from '../model';\n\nconst getAddedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const oldBodyIds = new Set(oldValue.bodies.map(b => b.id));\n  return newValue.bodies.filter(b => !oldBodyIds.has(b.id));\n}\n\nconst getRemovedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const newBodyIds = new Set(newValue.bodies.map(b => b.id));\n  return oldValue.bodies.filter(b => !newBodyIds.has(b.id));\n}\n\nconst getChangedBodies = (oldValue: Annotation, newValue: Annotation) => \n  newValue.bodies\n    .map(newBody => {\n      const oldBody = oldValue.bodies.find(b => b.id === newBody.id);\n      return { newBody, oldBody: oldBody && !dequal(oldBody, newBody) ? oldBody : undefined }\n    })\n    .filter(({ oldBody }) => oldBody);\n\nconst hasTargetChanged = (oldValue: Annotation, newValue: Annotation) => \n  !dequal(oldValue.target, newValue.target);\n\nexport const diffAnnotations = <T extends Annotation = Annotation>(oldValue: T, newValue: T): Update<T> => ({\n  oldValue, \n  newValue,\n  bodiesCreated: getAddedBodies(oldValue, newValue),\n  bodiesDeleted: getRemovedBodies(oldValue, newValue),\n  bodiesUpdated: getChangedBodies(oldValue, newValue),\n  targetUpdated: hasTargetChanged(oldValue, newValue) ? { oldTarget: oldValue.target, newTarget: newValue.target } : undefined\n});","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model';\n\n/** Interface for listening to changes in the annotation store **/\nexport interface StoreObserver<T extends Annotation> { \n\n  onChange: { (event: StoreChangeEvent<T>): void };\n\n  options: StoreObserveOptions;\n\n}\n\n/** A change event fired when the store state changes **/\nexport interface StoreChangeEvent<T extends Annotation> {\n\n  origin: Origin;\n\n  changes: ChangeSet<T>;\n\n  state: T[];\n\n}\n\nexport interface ChangeSet<T extends Annotation> {\n\n  created?: T[];\n\n  deleted?: T[];\n\n  updated?: Update<T>[];\n\n}\n\nexport interface Update<T extends Annotation> {\n\n  oldValue: T;\n\n  newValue: T;\n\n  bodiesCreated?: AnnotationBody[];\n\n  bodiesDeleted?: AnnotationBody[];\n\n  bodiesUpdated?: Array<{ oldBody: AnnotationBody, newBody: AnnotationBody }>;\n\n  targetUpdated?: { oldTarget: AnnotationTarget, newTarget: AnnotationTarget};\n\n}\n\n/** Options to control which events the observer wants to get notified about **/\nexport interface StoreObserveOptions {\n\n  // Observe changes on targets, bodies or both?\n  ignore?: Ignore;\n\n  // Observe changes on one more specific annotations\n  annotations?: string | string[];\n\n  // Observer changes only for a specific origin\n  origin?: Origin\n\n}\n\n/** Allows the observer to ignore certain event types **/\nexport enum Ignore { \n\n  // Don't notify this observer for changes that involve bodies only\n  BODY_ONLY = 'BODY_ONLY',\n\n  // Don't notify for changes on targets only\n  TARGET_ONLY = 'TARGET_ONLY'\n\n}\n\n/** Allows the observer to listen only for events that originated locally or from a remote source **/\nexport enum Origin { \n  \n  LOCAL = 'LOCAL', \n  \n  REMOTE = 'REMOTE' \n\n}\n\n/** Tests if this observer should be notified about this event **/\nexport const shouldNotify = <T extends Annotation>(observer: StoreObserver<T>, event: StoreChangeEvent<T>) => {\n  const { changes, origin } = event;\n\n  const isRelevantOrigin = \n    !observer.options.origin || observer.options.origin === origin;\n\n  if (!isRelevantOrigin)\n    return false;\n\n  if (observer.options.ignore) {\n    const { ignore } = observer.options;\n\n    // Shorthand\n    const has = (arg: any[]) => arg?.length > 0;\n\n    const hasAnnotationChanges =\n      has(changes.created) || has(changes.deleted);\n\n    if (!hasAnnotationChanges) {\n      const hasBodyChanges =\n        changes.updated?.some(u => has(u.bodiesCreated) || has(u.bodiesDeleted) || has(u.bodiesUpdated));\n    \n      const hasTargetChanges = \n        changes.updated?.some(u => u.targetUpdated);\n\n      if (ignore === Ignore.BODY_ONLY && hasBodyChanges && !hasTargetChanges)\n        return false;\n\n      if (ignore === Ignore.TARGET_ONLY && hasTargetChanges && !hasBodyChanges)\n        return false;\n    }\n  }\n\n  if (observer.options.annotations) {\n    // This observer has a filter set on specific annotations - check affected\n    const affectedAnnotations = new Set([\n      ...changes.created.map(a => a.id),\n      ...changes.deleted.map(a => a.id),\n      ...changes.updated.map(({ oldValue }) => oldValue.id)\n    ]);\n\n    const observed = Array.isArray(observer.options.annotations) ?\n      observer.options.annotations : [ observer.options.annotations ];\n\n    return Boolean(observed.find(id => affectedAnnotations.has(id)));\n  } else {\n    return true;\n  }\n\n}\n\nexport const mergeChanges = <T extends Annotation>(event: StoreChangeEvent<T>, toMerge: StoreChangeEvent<T>) => {\n  if (event.origin !== toMerge.origin)\n    throw 'Cannot merge events from different origins';\n\n  return {\n    origin: toMerge.origin,\n    changes: {\n      // TODO filter created that were deleted in the same go\n      created: [...(event.changes.created || []), ...(toMerge.changes.created || []) ],\n      deleted: [...(event.changes.deleted || []), ...(toMerge.changes.deleted || []) ] \n      // TODO merge updates\n    },\n    state: toMerge.state\n  }\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model';\nimport { diffAnnotations } from '../utils';\nimport { Origin, shouldNotify, type Update, type ChangeSet } from './StoreObserver';\nimport type { StoreObserver, StoreChangeEvent, StoreObserveOptions } from './StoreObserver';\n\n// Shorthand\ntype AnnotationBodyIdentifier = { id: string, annotation: string }; \n\nexport type Store<T extends Annotation> = ReturnType<typeof createStore<T>>;\n\nconst isAnnotation = <T extends Annotation>(arg: any): arg is T => arg.id !== undefined;\n\nexport const createStore = <T extends Annotation>() => {\n\n  const annotationIndex = new Map<string, T>();\n\n  const bodyIndex = new Map<string, string>();\n\n  const observers: StoreObserver<T>[] = [];\n\n  const observe = (onChange: { (event: StoreChangeEvent<T>): void }, options: StoreObserveOptions = {}) =>\n    observers.push({ onChange, options });\n\n  const unobserve = (onChange: { (event: StoreChangeEvent<T>): void }) => {\n    const idx = observers.findIndex(observer => observer.onChange == onChange);\n    if (idx > -1)\n      observers.splice(idx, 1);\n  }\n\n  const emit = (origin: Origin, changes: ChangeSet<T>) => {\n    const event: StoreChangeEvent<T> = {\n      origin,\n      changes: {\n        created: changes.created || [],\n        updated: changes.updated || [],\n        deleted: changes.deleted || []\n      },\n      state: [...annotationIndex.values()]\n    };\n\n    observers.forEach(observer => {\n      if (shouldNotify(observer, event))\n        observer.onChange(event);\n    });\n  }\n\n  const addAnnotation = (annotation: T, origin = Origin.LOCAL) => {\n    const existing = annotationIndex.get(annotation.id);\n\n    if (existing) {\n      throw Error(`Cannot add annotation ${annotation.id} - exists already`);\n    } else {\n      annotationIndex.set(annotation.id, annotation);\n\n      annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      emit(origin, { created: [annotation] });\n    }\n  }\n\n  const updateAnnotation = (arg1: string | T, arg2: T | Origin = Origin.LOCAL, arg3 = Origin.LOCAL) => {\n    const origin: Origin = isAnnotation(arg2) ? arg3 : arg2;\n\n    const updated: T = typeof arg1 === 'string' ? arg2 as T : arg1;\n\n    const oldId: string = typeof arg1 === 'string' ? arg1 : arg1.id;\n    const oldValue = annotationIndex.get(oldId);\n\n    if (oldValue) {\n      const update: Update<T> = diffAnnotations(oldValue, updated);\n\n      if (oldId === updated.id) {\n        annotationIndex.set(oldId, updated);\n      } else {\n        annotationIndex.delete(oldId);\n        annotationIndex.set(updated.id, updated);\n      }\n\n      oldValue.bodies.forEach(b => bodyIndex.delete(b.id));\n      updated.bodies.forEach(b => bodyIndex.set(b.id, updated.id));\n\n      emit(origin, { updated: [update] })\n    } else {\n      throw Error(`Cannot update annotation ${oldId} - does not exist`);\n    }\n  }\n\n  const addBody = (body: AnnotationBody, origin = Origin.LOCAL) => {\n    const oldValue = annotationIndex.get(body.annotation);\n    if (oldValue) {\n      const newValue = { \n        ...oldValue,\n        bodies: [ ...oldValue.bodies, body ]\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      bodyIndex.set(body.id, newValue.id);\n\n      const update: Update<T> = {\n        oldValue, newValue, bodiesCreated: [ body ]\n      };\n\n      emit(origin, { updated: [update] });\n    } else {\n      console.warn(`Attempt to add body to missing annotation: ${body.annotation}`);\n    }\n  }\n\n  const all = () => [...annotationIndex.values()];\n\n  const clear = (origin = Origin.LOCAL) => { \n    const all = [...annotationIndex.values()];\n\n    annotationIndex.clear();\n    bodyIndex.clear();\n\n    emit(origin, { deleted: all });\n  }\n\n  const bulkAddAnnotation = (annotations: T[], replace = true, origin = Origin.LOCAL) => {\n    if (replace) {\n      // Delete existing first\n      const deleted = [...annotationIndex.values()];\n      annotationIndex.clear();\n      bodyIndex.clear();\n\n      annotations.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: annotations, deleted });\n    } else {\n      // Don't allow overwriting of existing annotations\n      const existing = annotations.reduce((all, next) => {\n        const existing = annotationIndex.get(next.id);\n        return existing ? [...all, existing ] : all;\n      }, []);\n\n      if (existing.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${existing.map(a => a.id).join(', ')}`);\n\n      annotations.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: annotations });\n    }\n  }\n\n  const deleteOneAnnotation = (annotationOrId: T | string) => {\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n\n    const existing = annotationIndex.get(id);\n    if (existing) {\n      annotationIndex.delete(id);\n      existing.bodies.forEach(b => bodyIndex.delete(b.id));\n      return existing;\n    } else {\n      console.warn(`Attempt to delete missing annotation: ${id}`);\n    }\n  }\n\n  const deleteAnnotation = (annotationOrId: T | string, origin = Origin.LOCAL) => {\n    const deleted = deleteOneAnnotation(annotationOrId);\n    if (deleted)\n      emit(origin, { deleted: [ deleted  ]});\n  }\n\n  const bulkDeleteAnnotation = (annotationsOrIds: (T | string)[], origin = Origin.LOCAL) => {\n    const deleted = annotationsOrIds.reduce((deleted, arg) => {\n      const existing = deleteOneAnnotation(arg);\n      return existing ? [...deleted, existing] : deleted;\n    }, [] as T[]);\n\n    if (deleted.length > 0)\n      emit(origin, { deleted });\n  }\n \n  const deleteBody = (body: AnnotationBodyIdentifier, origin = Origin.LOCAL) => {\n    const oldAnnotation = annotationIndex.get(body.annotation);\n\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === body.id);\n\n      if (oldBody) {\n        bodyIndex.delete(oldBody.id);\n\n        const newAnnotation = {\n          ...oldAnnotation,\n          bodies: oldAnnotation.bodies.filter(b => b.id !== body.id)\n        };\n\n        annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n        const update: Update<T> = {\n          oldValue: oldAnnotation, newValue: newAnnotation, bodiesDeleted: [oldBody]\n        };\n\n        emit(origin, { updated: [update] });\n      } else {\n        console.warn(`Attempt to delete missing body ${body.id} from annotation ${body.annotation}`);\n      }\n    } else {\n      console.warn(`Attempt to delete body from missing annotation ${body.annotation}`);\n    }\n  }\n\n  const getAnnotation = (id: string): T | undefined => {\n    const a = annotationIndex.get(id);\n    return a ? {...a} : undefined;\n  }\n\n  const getBody = (id: string): AnnotationBody | undefined => {\n    const annotationId = bodyIndex.get(id);\n    if (annotationId) {\n      const annotation = getAnnotation(annotationId);\n      const body = annotation.bodies.find(b => b.id === id);\n      if (body) {\n        return body;\n      } else {\n        console.error(`Store integrity error: body ${id} in index, but not in annotation`);\n      }\n    } else {\n      console.warn(`Attempt to retrieve missing body: ${id}`);\n    }\n  }\n\n  const updateOneBody = (oldBodyId: AnnotationBodyIdentifier, newBody: AnnotationBody) => {\n    if (oldBodyId.annotation !== newBody.annotation)\n      throw 'Annotation integrity violation: annotation ID must be the same when updating bodies';\n\n    const oldAnnotation = annotationIndex.get(oldBodyId.annotation);\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === oldBodyId.id);\n\n      const newAnnotation = { \n        ...oldAnnotation,\n        bodies: oldAnnotation.bodies.map(b => b.id === oldBody.id ? newBody : b)\n      };\n\n      annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n      if (oldBody.id !== newBody.id) {\n        bodyIndex.delete(oldBody.id);\n        bodyIndex.set(newBody.id, newAnnotation.id);\n      }\n\n      return {\n        oldValue: oldAnnotation, \n        newValue: newAnnotation,\n        bodiesUpdated: [{ oldBody, newBody }]\n      }\n    } else {\n      console.warn(`Attempt to add body to missing annotation ${oldBodyId.annotation}`);\n    }\n  }\n\n  const updateBody = (oldBodyId: AnnotationBodyIdentifier, newBody: AnnotationBody, origin = Origin.LOCAL) => {\n    const update = updateOneBody(oldBodyId, newBody);\n    emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateBodies = (bodies: AnnotationBody[], origin = Origin.LOCAL) => {\n    const updated = bodies.map(b => updateOneBody({ id: b.id, annotation: b.annotation }, b));\n    emit(origin, { updated });\n  }\n\n  const updateOneTarget = (target: AnnotationTarget): Update<T> => {\n    const oldValue = annotationIndex.get(target.annotation);\n    \n    if (oldValue) {\n      const newValue = { \n        ...oldValue, \n        target: {\n          ...oldValue.target,\n          ...target \n        }\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      return {\n        oldValue, newValue, targetUpdated: { \n          oldTarget: oldValue.target,\n          newTarget: target\n        }\n      };\n    } else {\n      console.warn(`Attempt to update target on missing annotation: ${target.annotation}`);\n    }\n  }\n\n  const updateTarget = (target: AnnotationTarget, origin = Origin.LOCAL) => {\n    const update = updateOneTarget(target);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateTargets = (targets: AnnotationTarget[], origin = Origin.LOCAL) => {\n    const updated = targets.map(updateOneTarget).filter(val => val);\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n\treturn {\n    addAnnotation,\n    addBody,\n    all,\n    bulkAddAnnotation,\n    bulkDeleteAnnotation,\n    bulkUpdateBodies,\n    bulkUpdateTargets,\n    clear,\n    deleteAnnotation,\n    deleteBody,\n    getAnnotation,\n    getBody,\n    observe,\n    unobserve,\n    updateAnnotation,\n    updateBody,\n    updateTarget\n\t};\n\n}","import type { Annotation, Annotator, AnnotatorState } from '../model';\nimport type { Store } from './Store';\nimport type { StoreChangeEvent } from './StoreObserver';\n\ntype Subscriber<T extends Annotation> = (annotation: T[]) => void; \n\nexport interface SvelteStore<T extends Annotation> extends Store<T> {\n\n  subscribe(onChange: Subscriber<T>): void;\n\n}\n\nexport interface SvelteAnnotatorState<T extends Annotation> extends AnnotatorState<T> {\n\n  store: SvelteStore<T>\n\n}\n\nexport interface SvelteAnnotator<T extends Annotation> extends Annotator<T> {\n\n  state: SvelteAnnotatorState<T>\n\n}\n\n/** \n * A simple wrapper around the event-based store implementation\n * that adds a Svelte shim, for use with the reactive '$' notation.\n * Other frameworks might not actually need this. But it's pretty\n * convenient for everyone using Svelte, as well as for the\n * basic (Svelte-based) Annotorious standard implementation.\n */\nexport const toSvelteStore = <T extends Annotation>(store: Store<T>): SvelteStore<T> => {\n\n  const subscribe = (onChange: Subscriber<T>) => {\n\n    // Register a store observer on behalf of the subscriber\n    const shim = (event: StoreChangeEvent<T>) => onChange(event.state);\n    store.observe(shim);\n\n    // Immediately call the subscriber function with the\n    // current store value, according to the Svelte contract.\n    // https://stackoverflow.com/questions/68220955/how-does-svelte-unsubscribe-actually-work\n    onChange(store.all());\n\n    // Return the unsubscribe function\n    return () => store.unobserve(shim);\n  }\n\n  return {\n    ...store,\n    subscribe\n  }\n\n}","import { writable } from 'svelte/store';\n\nexport type ViewportState = ReturnType<typeof createViewportState>;\n\nexport const createViewportState = () => {\n\n  const { subscribe, set } = writable<string[]>([]);\n\n  return { \n    subscribe, \n    set\n  };\n\n}\n","import { dequal } from 'dequal/lite';\nimport type { Annotation, FormatAdapter } from '../model';\nimport { Origin } from '../state';\nimport type { HoverState, SelectionState, Store, ViewportState } from '../state';\nimport type { LifecycleEvents } from './LifecycleEvents';\n\nexport type Lifecycle<I extends Annotation, E extends unknown> = \n  ReturnType<typeof createLifecyleObserver<I, E>>;\n\nexport const createLifecyleObserver = <I extends Annotation, E extends unknown>(\n  store: Store<I>,\n  selectionState: SelectionState<I>, \n  hoverState: HoverState<I>,\n  viewportState?: ViewportState,\n  adapter?: FormatAdapter<I, E>,\n  autoSave?: boolean\n) => {\n  const observers: Map<keyof LifecycleEvents, Function[]> = new Map();\n\n  // The currently selected annotations, in the state when they were selected \n  let initialSelection: I[] = [];\n\n  let currentHover: string | undefined;\n\n  let idleTimeout: ReturnType<typeof setTimeout>;\n\n  const on = <T extends keyof LifecycleEvents>(event: T, callback: LifecycleEvents<E>[T]) => {\n    if (observers.has(event)) {\n      observers.get(event).push(callback);\n    } else {\n      observers.set(event, [callback]);\n    }\n  }\n\n  const off = <T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]) => {\n    const callbacks = observers.get(event);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx > 0)\n        callbacks.splice(callbacks.indexOf(callback), 1);\n    }\n  }\n\n  const emit = (event: keyof LifecycleEvents<E>, arg0: I | I[], arg1?: I | PointerEvent) => {\n    if (observers.has(event)) {\n      setTimeout(() => {\n        observers.get(event).forEach(callback => { \n          if (adapter) {\n            const serialized0 = Array.isArray(arg0) ? \n              arg0.map(a => adapter.serialize(a)) : adapter.serialize(arg0);\n            \n            const serialized1: E | PointerEvent | undefined =\n              arg1 ? arg1 instanceof PointerEvent ? arg1 : adapter.serialize(arg1) : undefined;\n\n            callback(serialized0 as E & E[], serialized1); \n          } else {\n            callback(arg0 as E & E[], arg1 as unknown as E);  \n          }\n        });\n      }, 1);\n    }\n  }\n\n  const onIdleUpdate = () => {\n    const { selected } = selectionState;\n\n    // User idle after activity - fire update events for selected\n    // annotations that changed\n    const updatedSelected = selected.map(({ id }) => store.getAnnotation(id));\n\n    updatedSelected.forEach(updated => {\n      const initial = initialSelection.find(a => a.id === updated.id);\n      if (!initial || !dequal(initial, updated)) {\n        emit('updateAnnotation', updated, initial);\n      }\n    });\n\n    initialSelection = initialSelection.map(initial => {\n      const updated = updatedSelected.find(({ id }) => id === initial.id);\n      return updated ? updated : initial\n    });\n  }\n\n  selectionState.subscribe(({ selected })=> {\n    if (initialSelection.length === 0 && selected.length === 0)\n      return;\n\n    if (initialSelection.length === 0 && selected.length > 0) {\n      // A new selection was made - store the editable annotation as initial state\n      initialSelection = selected.map(({ id }) => store.getAnnotation(id));\n    } else if (initialSelection.length > 0 && selected.length === 0) {\n      // Deselect!\n      initialSelection.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);  \n        \n        if (updatedState && !dequal(updatedState, initial)) {\n          emit('updateAnnotation', updatedState, initial);\n        }\n      });\n\n      initialSelection = [];\n    } else {\n      // Changed selection\n      const initialIds = new Set(initialSelection.map(a => a.id));\n      const selectedIds = new Set(selected.map(({ id }) => id));\n\n      // Fire update events for deselected annotations that have changed\n      const deselected = initialSelection.filter(a => !selectedIds.has(a.id));\n      deselected.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);\n\n        if (updatedState && !dequal(updatedState, initial))\n          emit('updateAnnotation', updatedState, initial);\n      });\n\n      initialSelection = [\n        // Remove annotations that were deselected\n        ...initialSelection.filter(a => selectedIds.has(a.id)),\n        // Add editable annotations that were selected\n        ...selected.filter(({ id }) => !initialIds.has(id))\n          .map(({ id }) => store.getAnnotation(id))\n      ];\n    }\n\n    emit('selectionChanged', initialSelection);\n  });\n\n  hoverState.subscribe(id => {\n    if (!currentHover && id) {\n      emit('mouseEnterAnnotation', store.getAnnotation(id));\n    } else if (currentHover && !id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover));\n    } else if (currentHover && id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover));\n      emit('mouseEnterAnnotation', store.getAnnotation(id));\n    }\n\n    currentHover = id;\n  });\n\n  viewportState?.subscribe(ids => \n    emit('viewportIntersect', ids.map(store.getAnnotation)));\n\n  store.observe(event => {\n    // autoSave option triggers update events on idleness\n    if (autoSave) {\n      if (idleTimeout)\n        clearTimeout(idleTimeout);\n\n      idleTimeout = setTimeout(onIdleUpdate, 1000);\n    }\n\n    // Local CREATE and DELETE events are applied immediately\n    const { created, deleted } = event.changes;\n    created.forEach(a => emit('createAnnotation', a));\n    deleted.forEach(a => emit('deleteAnnotation', a));\n\n    // Updates are only applied immediately if they involve body changes\n    const updatesWithBody = event.changes.updated.filter(u => [\n      ...(u.bodiesCreated || []),\n      ...(u.bodiesDeleted || []),\n      ...(u.bodiesUpdated || [])\n    ].length > 0);\n\n    // Emit an update with the new annototation and the stored initial state\n    updatesWithBody.forEach(({ oldValue, newValue }) => {\n      const initial = initialSelection.find(a => a.id === oldValue.id) || oldValue;\n\n      // Record the update as the new last known state\n      initialSelection = initialSelection\n        .map(a => a.id === oldValue.id ? newValue : a);\n\n      emit('updateAnnotation', newValue, initial);\n    });\n  }, { origin: Origin.LOCAL });\n\n  // Track remote changes - these should update the initial state\n  store.observe(event => {\n    if (initialSelection) {\n      const selectedIds = new Set(initialSelection.map(a => a.id));\n\n      const relevantUpdates = event.changes.updated\n        .filter(({ newValue }) => selectedIds.has(newValue.id))\n        .map(({ newValue }) => newValue);\n\n      if (relevantUpdates.length > 0) {\n        initialSelection = initialSelection.map(selected => {\n          const updated = relevantUpdates.find(updated => updated.id === selected.id);\n          return updated ? updated : selected;\n        })\n      }\n    }\n  }, { origin: Origin.REMOTE });\n\n  return { on, off, emit }\n\n}","import type { Annotation } from './Annotation';\n\nexport interface FormatAdapter<A extends Annotation, T extends unknown> {\n\n  parse(serialized: T): ParseResult<A>;\n\n  serialize(core: A): T;\n\n}\n\nexport interface ParseResult<A extends Annotation> {\n\n  parsed?: A;\n  \n  error?: Error;\n\n}\n\nexport const serializeAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (annotations: A[]) => annotations.map(a => adapter.serialize(a));\n\nexport const parseAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (serialized: T[]) => serialized.reduce((result, next) => {\n      const { parsed, error } = adapter.parse(next);\n\n      return error ? {\n        parsed: result.parsed,\n        failed: [...result.failed, next ]\n      } : {\n        parsed: [...result.parsed, parsed ],\n        failed: result.failed\n      }\n    }, { parsed: [], failed: [] });\n  ","import type { Annotation } from './Annotation';\nimport type { User } from './User';\nimport type { PresenceProvider } from '../presence';\nimport { Origin, type HoverState, type SelectionState, type Store, type ViewportState } from '../state';\nimport type { LifecycleEvents } from '../lifecycle';\nimport { parseAll, type FormatAdapter } from './FormatAdapter';\nimport type { DrawingStyle } from './DrawingStyle';\n\n/**\n * Base annotator interface.\n * I ... internal core data model \n * E ... external adapted representation\n */\nexport interface Annotator<I extends Annotation = Annotation, E extends unknown = Annotation> {\n\n  style: DrawingStyle | ((annotation: I) => DrawingStyle) | undefined;\n\n  addAnnotation(annotation: E): void;\n\n  clearAnnotations(): void;\n\n  destroy(): void;\n\n  getAnnotationById(id: string): E | undefined;\n\n  getAnnotations(): E[];\n\n  getUser(): User;\n\n  loadAnnotations(url: string): Promise<E[]>;\n\n  removeAnnotation(arg: E | string): E;\n\n  setAnnotations(annotations: E[]): void;\n\n  setPresenceProvider?(provider: PresenceProvider): void;\n\n  setSelected(arg?: string | string[]): void;\n\n  setUser(user: User): void;\n\n  updateAnnotation(annotation: E): E;\n  \n  on<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  off<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  state: AnnotatorState<I>;\n\n}\n\nexport interface AnnotatorState<A extends Annotation> {\n\n  store: Store<A>;\n\n  selection: SelectionState<A>;\n\n  hover: HoverState<A>;\n\n  viewport: ViewportState;\n\n}\n\nexport const createBaseAnnotator = <I extends Annotation, E extends unknown>(\n  store: Store<I>, \n  adapter?: FormatAdapter<I, E>\n) => {\n\n  const addAnnotation = (annotation: E) => {\n    if (adapter) {\n      const { parsed, error } = adapter.parse(annotation);\n      if (parsed) {\n        store.addAnnotation(parsed, Origin.REMOTE);\n      } else {\n        console.error(error);\n      }\n    } else {\n      store.addAnnotation(annotation as unknown as I, Origin.REMOTE);\n    }\n  }\n\n  const clearAnnotations = () => store.clear();\n\n  const getAnnotationById = (id: string): E | undefined => {\n    const annotation = store.getAnnotation(id);\n    return (adapter && annotation) ?\n      adapter.serialize(annotation) as E : annotation as unknown as E;\n  }\n\n  const getAnnotations = () =>\n    (adapter ? store.all().map(adapter.serialize) : store.all()) as E[];\n\n  const loadAnnotations = (url: string) =>\n    fetch(url)\n      .then((response) => response.json())\n      .then((annotations) => {\n        setAnnotations(annotations);\n        return annotations;\n      });\n\n  const removeAnnotation = (arg: E | string): E => {\n    if (typeof arg === 'string') {\n      const annotation = store.getAnnotation(arg);\n      store.deleteAnnotation(arg);\n\n      return adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n    } else {\n      const annotation = adapter ? adapter.parse(arg).parsed : (arg as unknown as I);\n      store.deleteAnnotation(annotation);\n      return arg;\n    }\n  }\n\n  const setAnnotations = (annotations: E[]) => {\n    if (adapter) {\n      const { parsed, failed } = parseAll(adapter)(annotations);\n\n      if (failed.length > 0)\n        console.warn(`Discarded ${failed.length} invalid annotations`, failed);\n\n      store.bulkAddAnnotation(parsed, true, Origin.REMOTE);\n    } else {\n      store.bulkAddAnnotation(annotations as unknown as I[], true, Origin.REMOTE);\n    }\n  }\n\n  const updateAnnotation = (updated: E): E => {\n    if (adapter) {\n      const crosswalked = adapter.parse(updated).parsed;\n      const previous = adapter.serialize(store.getAnnotation(crosswalked.id));\n      store.updateAnnotation(crosswalked);\n      return previous;\n    } else {\n      const previous = store.getAnnotation((updated as unknown as I).id);\n      store.updateAnnotation(updated as unknown as I);\n      return previous as unknown as E;\n    }\n  }\n\n  return { \n    addAnnotation,\n    clearAnnotations,\n    getAnnotationById,\n    getAnnotations,\n    loadAnnotations,\n    removeAnnotation,\n    setAnnotations,\n    updateAnnotation\n  }\n\n}","export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n","import { customAlphabet } from 'nanoid';\n\nexport interface User {\n\n  id: string;\n\n  isGuest?: boolean;\n\n  name?: string;\n\n  avatar?: string;\n\n}\n\nexport const createAnonymousGuest = () => {\n  const nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', 20);\n  \n  return { isGuest: true, id: nanoid() }\n}","import type { AnnotationBody } from './Annotation';\n\nexport interface W3CAnnotation {\n\n  '@context': 'http://www.w3.org/ns/anno.jsonld';\n\n  type: 'Annotation';\n\n  id: string;\n\n  body: W3CAnnotationBody | W3CAnnotationBody[]\n\n  target: W3CAnnotationTarget | W3CAnnotationTarget[];\n\n  [key: string]: any;\n\n}\n\nexport interface W3CAnnotationBody {\n\n  id?: string;\n\n  type?: string;\n\n  purpose?: string;\n\n  value?: string;\n\n  source?: string;\n\n  created?: Date;\n\n  creator?: {\n\n    type?: string;\n\n    id: string;\n\n    name?: string;\n\n  };\n\n}\n\nexport interface W3CAnnotationTarget {\n\n  source: string;\n\n  selector?: W3CSelector | W3CSelector[];\n\n}\n\nexport interface W3CSelector {\n\n  type: string;\n\n  conformsTo?: string;\n\n  value: string;\n}\n\n// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\nconst hashCode = (obj: Object): string => {\n  const str = JSON.stringify(obj);\n\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n      let chr = str.charCodeAt(i);\n      hash = (hash << 5) - hash + chr;\n      hash |= 0; // Convert to 32bit integer\n  }\n\n  return `${hash}`;\n}\n\n/**\n * Helper to crosswalk the W3C annotation body to a list of core AnnotationBody objects.\n */\nexport const parseW3CBodies = (\n  body: W3CAnnotationBody | W3CAnnotationBody[], \n  annotationId: string\n): AnnotationBody[] => (Array.isArray(body) ? body : [body]).map(body => {\n\n  // Exctract properties that conform to the internal model, but keep custom props\n  const { id, type, purpose, value, created, creator, ...rest} = body;\n\n  // The internal model strictly requires IDs. (Because multi-user scenarios\n  // will have problems without them.) In the W3C model, bodys *may* have IDs.\n  // We'll create ad-hoc IDs for bodies without IDs, but want to make sure that\n  // generating the ID is idempotent: the same body should always get the same ID.\n  // This will avoid unexpected results when checking for equality.  \n  return {\n    id: id || hashCode(body),\n    annotation: annotationId,\n    type,\n    purpose,\n    value,\n    created,\n    creator: creator ? \n      typeof creator === 'object' ? { ...creator }: creator :\n      undefined,\n    ...rest\n  }\n\n});\n\nexport const serializeW3CBodies = (bodies: AnnotationBody[]): W3CAnnotationBody[] => \n  bodies.map(b => {\n    const w3c = { ...b };\n    delete w3c.annotation;\n    delete w3c.id;\n    return w3c;\n  });\n\n","// SEABORN_BRIGHT\nexport const DEFAULT_PALETTE: Palette = [\n  '#ff7c00', // orange\n  '#1ac938', // green\n  '#e8000b', // red\n  '#8b2be2', // purple\n  '#9f4800', // brown\n  '#f14cc1', // pink\n  '#ffc400', // khaki\n  '#00d7ff', // cyan\n  '#023eff'  // blue\n];\n\nexport type Palette = string[];","import type { User } from '../model';\nimport type { Appearance } from './Appearance';\nimport type { PresentUser } from './PresentUser';\nimport { DEFAULT_PALETTE } from './ColorPalette';\n\nexport interface AppearanceProvider {\n\n  addUser(presenceKey: string, user: User): Appearance;\n\n  removeUser(user: PresentUser): void;\n\n}\n\nexport const defaultColorProvider = () => {\n\n  const unassignedColors = [...DEFAULT_PALETTE];\n\n  const assignRandomColor = () => {\n    const rnd = Math.floor(Math.random() * unassignedColors.length);\n    const color = unassignedColors[rnd];\n\n    unassignedColors.splice(rnd, 1);\n\n    return color;\n  }\n\n  const releaseColor = (color: string) =>\n    unassignedColors.push(color);\n\n  return { assignRandomColor, releaseColor };\n\n}\n\nexport const createDefaultAppearenceProvider = () => {\n\n  const colorProvider = defaultColorProvider();\n\n  const addUser = (presenceKey: string, user: User): Appearance => {\n    const color = colorProvider.assignRandomColor();\n\n    return {\n      label: user.name || user.id,\n      avatar: user.avatar,\n      color\n    };\n  }\n\n  const removeUser = (user: PresentUser) =>\n    colorProvider.releaseColor(user.appearance.color);\n\n  return { addUser, removeUser }\n  \n}","export let createNanoEvents = () => ({\n  emit(event, ...args) {\n    let callbacks = this.events[event] || []\n    for (let i = 0, length = callbacks.length; i < length; i++) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    this.events[event]?.push(cb) || (this.events[event] = [cb])\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n","import { nanoid } from 'nanoid';\nimport { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { User } from '../model';\nimport type { PresentUser } from './PresentUser';\nimport type { PresenceEvents } from './PresenceEvents';\nimport { createDefaultAppearenceProvider } from './AppearanceProvider';\nimport type { AppearanceProvider } from './AppearanceProvider';\n\nexport interface PresenceState {\n\n  // Get users currently present to this room\n  getPresentUsers(): PresentUser[];\n\n  // Notify of a given present user's activity on the given annotations\n  notifyActivity(presenceKey: string, annotationIds: string[]): void;\n\n  // Add a listener for the given presence event\n  on<E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]): Unsubscribe;\n\n  // Initial sync - which users are present under which keys\n  syncUsers(state: { presenceKey: string, user: User }[]): void;\n\n  // Update the selection state for the given prresent user\n  updateSelection(presenceKey: string, selection: string[] | null): void;\n\n}\n\nconst isListEqual = (listA: any[], listB: any[]) => \n  listA.every(a => listA.includes(a)) && listB.every(b => listA.includes(b));\n\n// This client's presence key\nexport const PRESENCE_KEY = nanoid();\n\nexport const createPresenceState = (\n  appearanceProvider: AppearanceProvider = createDefaultAppearenceProvider()\n): PresenceState => {\n\n  const emitter = createNanoEvents<PresenceEvents>();\n\n  const presentUsers = new Map<string, PresentUser>();\n\n  const selectionStates = new Map<string, string[]>();\n\n  const addUser = (presenceKey: string, user: User) => {\n    if (presentUsers.has(presenceKey)) {\n      console.warn('Attempt to add user that is already present', presenceKey, user);\n      return;    \n    }\n\n    const appearance = appearanceProvider.addUser(presenceKey, user);\n\n    presentUsers.set(presenceKey, { \n      ...user,\n      presenceKey,\n      appearance\n    });\n  }\n\n  const removeUser = (presenceKey: string) => {\n    const user = presentUsers.get(presenceKey);\n    if (!user) {\n      console.warn('Attempt to remove user that is not present', presenceKey);\n      return;\n    }\n\n    appearanceProvider.removeUser(user);\n\n    presentUsers.delete(presenceKey);\n  }\n\n  const syncUsers = (state: { presenceKey: string, user: User }[]) => {\n    // const keys = new Set(others.map(s => s.presenceKey));\n    const keys = new Set(state.map(s => s.presenceKey));\n\n    // These users need to be added to the presentUsers list\n    // const toAdd = others.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n    const toAdd = state.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n\n    // These users need to be dropped from the list\n    const toRemove = Array.from(presentUsers.values()).filter(presentUser =>\n      !keys.has(presentUser.presenceKey));\n\n    toAdd.forEach(({ presenceKey, user }) => addUser(presenceKey, user));\n\n    toRemove.forEach(user => {\n      const { presenceKey } = user;\n\n      // If this user has a selection, fire deselect event\n      if (selectionStates.has(presenceKey))\n        emitter.emit('selectionChange', user, null);\n\n      removeUser(presenceKey)\n    });\n\n    if (toAdd.length > 0 || toRemove.length > 0)\n      emitter.emit('presence', getPresentUsers());\n  }\n\n  const notifyActivity = (presenceKey: string, annotationIds: string[]) => {    \n    const user = presentUsers.get(presenceKey);\n    \n    if (!user) {\n      console.warn('Activity notification from user that is not present');\n      return;\n    }\n\n    const currentSelection = selectionStates.get(presenceKey);\n\n    // Was there a selection change we might have missed?\n    if (!currentSelection || !isListEqual(currentSelection, annotationIds)) {\n      selectionStates.set(presenceKey, annotationIds);\n      emitter.emit('selectionChange', user, annotationIds);\n    }\n  }\n\n  const updateSelection = (presenceKey: string, selection: string[] | null) => {\n    const from = presentUsers.get(presenceKey);\n    if (!from) {\n      console.warn('Selection change for user that is not present', presenceKey);\n      return;\n    }\n\n    if (selection)\n      selectionStates.set(presenceKey, selection);\n    else \n      selectionStates.delete(presenceKey);\n\n    emitter.emit('selectionChange', from, selection);\n  }\n\n  const getPresentUsers = () =>\n    [...Array.from(presentUsers.values())];\n    \n  const on = <E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]) =>\n    emitter.on(event, callback);\n\n  return {\n    getPresentUsers,\n    notifyActivity,\n    on,\n    syncUsers,\n    updateSelection\n  }\n\n}","import { v4 as uuidv4 } from 'uuid';\nimport { parseW3CBodies, serializeW3CBodies } from '@annotorious/core';\nimport type { FormatAdapter, ParseResult, W3CAnnotation, W3CAnnotationBody } from '@annotorious/core';\nimport { ShapeType } from '../core';\nimport type { ImageAnnotation, RectangleGeometry } from '../core';\nimport type { FragmentSelector } from './fragment';\nimport { parseFragmentSelector, serializeFragmentSelector } from './fragment';\nimport type { SVGSelector } from './svg';\nimport { parseSVGSelector, serializeSVGSelector } from './svg';\n\nexport type W3CImageFormatAdapter = FormatAdapter<ImageAnnotation, W3CAnnotation>;\n\nexport const W3CImageFormat = (\n  source: string,\n  invertY: boolean = false\n): W3CImageFormatAdapter => {\n\n  const parse = (serialized: W3CAnnotation) =>\n    parseW3CImageAnnotation(serialized, invertY);\n\n  const serialize = (annotation: ImageAnnotation) =>\n    serializeW3CImageAnnotation(annotation, source);\n\n  return { parse, serialize }\n}\n\nexport const parseW3CImageAnnotation = (\n  annotation: W3CAnnotation, \n  invertY: boolean = false\n): ParseResult<ImageAnnotation> => {\n  const annotationId = annotation.id || uuidv4();\n\n  const bodies = parseW3CBodies(annotation.body, annotationId);\n\n  const target = Array.isArray(annotation.target) ? annotation.target[0] : annotation.target;\n\n  const w3cSelector = Array.isArray(target.selector) ? target.selector[0] : target.selector;\n\n  const selector = \n    w3cSelector.type === 'FragmentSelector' ?\n      parseFragmentSelector(w3cSelector as FragmentSelector, invertY) :\n    w3cSelector.type === 'SvgSelector' ?\n      parseSVGSelector(w3cSelector as SVGSelector) : undefined;\n\n  return selector ? { \n    parsed:{\n      id: annotationId,\n      bodies,\n      target: {\n        annotation: annotationId,\n        selector\n      }\n    }\n  } : {\n    error: Error(`Unknown selector type: ${selector.type}`)\n  };\n\n}\n\nexport const serializeW3CImageAnnotation = (\n  annotation: ImageAnnotation, \n  source: string\n): W3CAnnotation => {\n  const shape = annotation.target.selector;\n\n  const selector =\n    shape.type == ShapeType.RECTANGLE ?\n      serializeFragmentSelector(shape.geometry as RectangleGeometry) :\n      serializeSVGSelector(shape);\n\n  return {\n    '@context': 'http://www.w3.org/ns/anno.jsonld',\n    id: annotation.id,\n    type: 'Annotation',\n    body: serializeW3CBodies(annotation.bodies),\n    target: {\n      source,\n      selector\n    }\n  };\n};\n","<script type=\"ts\">\n  import { boundsFromPoints } from '../../../model';\n  import type { Polygon } from '../../../model';\n  import type { Transform } from '../../Transform';\n  import { Editor, Handle } from '..';\n\n  /** Props */\n  export let shape: Polygon;\n  export let computedStyle: string = undefined;\n  export let transform: Transform;\n  export let viewportScale: number = 1;\n\n  $: geom = shape.geometry;\n\n  $: handleSize = 10 / viewportScale;\n\n  const editor = (polygon: Polygon, handle: Handle, delta: [number, number]) => {\n    let points: [number, number][];\n\n    if (handle === Handle.SHAPE) {\n      points = polygon.geometry.points.map(([x, y]) => [x + delta[0], y + delta[1]]);\n    } else {\n      points = polygon.geometry.points.map(([x, y], idx) =>\n        handle === Handle(idx) ? [x + delta[0], y + delta[1]] : [x, y]\n      );\n    }\n\n    const bounds = boundsFromPoints(points);\n\n    return {\n      ...polygon,\n      geometry: { points, bounds }\n    }\n  }\n</script>\n\n<Editor\n  shape={shape}\n  transform={transform}\n  editor={editor}\n  on:change \n  on:grab\n  on:release\n  let:grab={grab}>\n\n  <polygon\n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    on:pointerdown={grab(Handle.SHAPE)}\n    points={geom.points.map(xy => xy.join(',')).join(' ')} />\n\n  <polygon\n    class=\"a9s-inner a9s-shape-handle\"\n    style={computedStyle}\n    on:pointerdown={grab(Handle.SHAPE)}\n    points={geom.points.map(xy => xy.join(',')).join(' ')} />\n\n  {#each geom.points as point, idx}\n    <rect \n      class=\"a9s-corner-handle\"\n      on:pointerdown={grab(Handle(idx))}\n      x={point[0] - handleSize / 2} y={point[1] - handleSize / 2} height={handleSize} width={handleSize} />\n  {/each}\n</Editor>","<script type=\"ts\">\n  import type { Rectangle } from '../../../model';\n  import type { Transform } from '../../Transform';\n  import { Editor, Handle } from '..';\n\n  /** Props */\n  export let shape: Rectangle;\n  export let computedStyle: string = undefined;\n  export let transform: Transform;\n  export let viewportScale: number = 1;\n\n  $: geom = shape.geometry;\n\n  $: handleSize = 10 / viewportScale;\n\n  const editor = (rectangle: Rectangle, handle: Handle, delta: [number, number]) => {\n    const initialBounds = rectangle.geometry.bounds;\n\n    let [x0, y0] = [initialBounds.minX, initialBounds.minY];\n    let [x1, y1] = [initialBounds.maxX, initialBounds.maxY];\n\n    const [dx, dy] = delta;\n\n    if (handle === Handle.SHAPE) {\n      x0 += dx;\n      x1 += dx;\n      y0 += dy;\n      y1 += dy;\n    } else {\n      switch (handle) {\n        case Handle.TOP:\n        case Handle.TOP_LEFT:\n        case Handle.TOP_RIGHT: {\n          y0 += dy;\n          break;\n        }\n\n        case Handle.BOTTOM:\n        case Handle.BOTTOM_LEFT:\n        case Handle.BOTTOM_RIGHT: {\n          y1 += dy;\n          break;\n        }\n      }\n\n      switch (handle) {\n        case Handle.LEFT:\n        case Handle.TOP_LEFT:\n        case Handle.BOTTOM_LEFT: {\n          x0 += dx;\n          break;\n        }\n\n        case Handle.RIGHT:\n        case Handle.TOP_RIGHT:\n        case Handle.BOTTOM_RIGHT: {\n          x1 += dx;\n          break;\n        }\n      }\n    }\n\n    const x = Math.min(x0, x1);\n    const y = Math.min(y0, y1);\n    const w = Math.abs(x1 - x0);\n    const h = Math.abs(y1 - y0);\n\n    return {\n      ...rectangle,\n      geometry: {\n        x, y, w, h,\n        bounds: {\n          minX: x,\n          minY: y,\n          maxX: x + w,\n          maxY: y + h\n        }\n      }\n    };\n  }\n</script>\n\n<Editor\n  shape={shape}\n  transform={transform}\n  editor={editor}\n  on:grab\n  on:change \n  on:release\n  let:grab={grab}>\n\n  <rect \n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    on:pointerdown={grab(Handle.SHAPE)}\n    x={geom.x} y={geom.y} width={geom.w} height={geom.h} />\n\n  <rect \n    class=\"a9s-inner a9s-shape-handle\"\n    style={computedStyle}\n    on:pointerdown={grab(Handle.SHAPE)}\n    x={geom.x} y={geom.y} width={geom.w} height={geom.h} />\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-top\" \n    on:pointerdown={grab(Handle.TOP)}\n    x={geom.x} y={geom.y} height={1} width={geom.w} />\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-right\"\n    on:pointerdown={grab(Handle.RIGHT)}\n    x={geom.x + geom.w} y={geom.y} height={geom.h} width={1}/>\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-bottom\" \n    on:pointerdown={grab(Handle.BOTTOM)}\n    x={geom.x} y={geom.y + geom.h} height={1} width={geom.w} />\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-left\" \n    on:pointerdown={grab(Handle.LEFT)}\n    x={geom.x} y={geom.y} height={geom.h} width={1} />\n\n  <rect \n    class=\"a9s-corner-handle a9s-corner-handle-topleft\"\n    on:pointerdown={grab(Handle.TOP_LEFT)}\n    x={geom.x - handleSize / 2} y={geom.y - handleSize / 2} height={handleSize} width={handleSize} />\n\n  <rect \n    class=\"a9s-corner-handle a9s-corner-handle-topright\"\n    on:pointerdown={grab(Handle.TOP_RIGHT)}\n    x={geom.x + geom.w - handleSize / 2} y={geom.y - handleSize / 2} height={handleSize} width={handleSize} />\n  \n  <rect \n    class=\"a9s-corner-handle a9s-corner-handle-bottomright\"\n    on:pointerdown={grab(Handle.BOTTOM_RIGHT)}\n    x={geom.x + geom.w - handleSize / 2} y={geom.y + geom.h - handleSize / 2} height={handleSize} width={handleSize} />\n    \n  <rect \n    class=\"a9s-corner-handle a9s-corner-handle-bottomleft\"\n    on:pointerdown={grab(Handle.BOTTOM_LEFT)}\n    x={geom.x - handleSize / 2} y={geom.y + geom.h - handleSize / 2} height={handleSize} width={handleSize} />\n</Editor>","import { ShapeType, type Shape } from '../../model';\nimport type { SvelteComponent } from 'svelte';\nimport { PolygonEditor } from './polygon';\nimport { RectangleEditor } from './rectangle';\n\nconst REGISTERED = new Map<ShapeType, typeof SvelteComponent>([\n  [ShapeType.RECTANGLE, RectangleEditor],\n  [ShapeType.POLYGON, PolygonEditor]\n]);\n\nexport const getEditor = (shape: Shape) => REGISTERED.get(shape.type);\n\nexport const registerEditor = (shapeType: ShapeType, editor: typeof SvelteComponent) =>\n  REGISTERED.set(shapeType, editor);","export type Handle = string;\n\nexport const Handle = (value: string | number) => `HANDLE-${value}`;\n\nHandle.SHAPE = 'SHAPE';\n\nHandle.TOP = 'TOP';\n\nHandle.RIGHT = 'RIGHT';\n\nHandle.BOTTOM = 'BOTTOM';\n\nHandle.LEFT = 'LEFT';\n\nHandle.TOP_LEFT = 'TOP_LEFT';\n\nHandle.TOP_RIGHT = 'TOP_RIGHT';\n\nHandle.BOTTOM_RIGHT = 'BOTTOM_RIGHT';\n\nHandle.BOTTOM_LEFT = 'BOTTOM_LEFT';","<script type=\"ts\">\n  import { createEventDispatcher } from 'svelte';\n  import type { Shape } from '../../model';\n  import type { Handle } from './Handle';\n  import type { Transform } from '../Transform';\n\n  const dispatch = createEventDispatcher<{ grab: undefined, release: undefined, change: Shape }>();\n\n  /** Props */\n  export let shape: Shape;\n  export let editor: (shape: Shape, handle: Handle, delta: [number, number]) => Shape;\n  export let transform: Transform;\n\n  let grabbedHandle: Handle = null;\n\n  let origin: [number, number];\n\n  let initialShape: Shape = null;\n\n  const onGrab = (handle: Handle) => (evt: PointerEvent) => {\n    grabbedHandle = handle;\n    origin = transform.elementToImage(evt.offsetX, evt.offsetY);\n    initialShape = shape;\n\n    const target = evt.target as Element;\n    target.setPointerCapture(evt.pointerId);\n\n    dispatch('grab');\n  }\n\n  const onPointerMove = (evt: PointerEvent) => {\n    if (grabbedHandle) {\n      const [x, y] = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n      const delta: [number, number] = [x - origin[0], y - origin[1]];\n\n      shape = editor(initialShape, grabbedHandle, delta);\n      \n      dispatch('change', shape);\n    }\n  }\n\n  const onRelease = (evt: PointerEvent) => {\n    const target = evt.target as Element;\n    target.releasePointerCapture(evt.pointerId);\n\n    grabbedHandle = null;\n\n    initialShape = shape;\n    \n    dispatch('release');\n  }\n</script>\n\n<g\n  class=\"a9s-annotation selected\"\n  on:pointerup={onRelease}\n  on:pointermove={onPointerMove}>\n\n  <slot grab={onGrab} />\n</g>","import type { DrawingStyle } from '@annotorious/core';\nimport type { ImageAnnotation } from '../../model';\n\nexport const computeStyle = (annotation: ImageAnnotation, style?: DrawingStyle | ((a: ImageAnnotation) => DrawingStyle)) => {\n  const computed = typeof style === 'function' ? style(annotation) : style;\n\n  if (computed) {\n    const { fill, fillOpacity } = computed;\n\n    let css = '';\n    \n    if (fill)\n      css += `fill:${fill};stroke:${fill};`;\n    \n    css += `fill-opacity:${fillOpacity || '0.25'};`;\n\n    return css;\n  }\n}","<script lang=\"ts\">\n  import type { DrawingStyle } from '@annotorious/core';\n  import { createEventDispatcher, onMount, type SvelteComponent } from 'svelte';\n  import type { ImageAnnotation, Shape } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  import type { Transform } from '../Transform';\n\n  const dispatch = createEventDispatcher<{ change: Shape }>();\n\n  /** Props */\n  export let annotation: ImageAnnotation;\n  export let editor: typeof SvelteComponent;\n  export let style: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) = undefined;\n  export let target: SVGGElement;\n  export let transform: Transform;\n  export let viewportScale: number;\n\n  let editorComponent: SvelteComponent;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  $: if (editorComponent) editorComponent.$set({ transform });\n\n  $: if (editorComponent) editorComponent.$set({ viewportScale });\n\n  onMount(() => {\n    editorComponent = new editor({\n      target,\n      props: { shape: annotation.target.selector, computedStyle, transform, viewportScale }\n    });\n\n    editorComponent.$on('change', event => {\n      editorComponent.$$set({ shape: event.detail });\n      dispatch('change', event.detail)\n    });\n\n    return () => {\n      editorComponent.$destroy();\n    }\n  });\n</script>","<script lang=\"ts\">\n  import { createEventDispatcher, onMount, type SvelteComponent } from 'svelte';\n  import type { Transform } from '../Transform';\n  import type { Shape } from 'src/model';\n\n  const dispatch = createEventDispatcher<{ create: Shape }>();\n\n  export let target: SVGGElement;\n\n  export let tool: typeof SvelteComponent;\n  \n  export let transform: Transform;\n\n  export let viewportScale: number;\n\n  let toolComponent: SvelteComponent;\n\n  $: if (toolComponent) toolComponent.$set({ transform });\n\n  $: if (toolComponent) toolComponent.$set({ viewportScale });\n\n  onMount(() => {\n    toolComponent = new tool({\n      target,\n      props: { transform, viewportScale }\n    });\n\n    toolComponent.$on('create', \n      event => dispatch('create', event.detail));\n\n    return () => {\n      toolComponent.$destroy();\n    }\n  });\n</script>","<script type=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte';\n  import { ShapeType, type Rectangle } from '../../../model';\n  import type { Transform } from '../..';\n\n  const dispatch = createEventDispatcher<{ create: Rectangle }>();\n  \n  export let transform: Transform;\n  \n  let container: SVGGElement;\n\n  let origin: [x: number, y: number]; \n\n  let anchor: [number, number];\n\n  let x: number, y: number, w: number, h: number;\n\n  const onPointerDown = (evt: PointerEvent) => {\n    origin = transform.elementToImage(evt.offsetX, evt.offsetY);\n    anchor = origin;\n\n    x = origin[0];\n    y = origin[1];\n    w = 1;\n    h = 1;\n  }\n\n  const onPointerMove = (evt: PointerEvent) => {\n    if (origin) {\n      anchor = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n      x = Math.min(anchor[0], origin[0]);\n      y = Math.min(anchor[1], origin[1]);\n      w = Math.abs(anchor[0] - origin[0]);\n      h = Math.abs(anchor[1] - origin[1]);\n    }\n  }\n    \n  const onPointerUp = () => {\n    // Require 4x4 pixels minimum\n    if (w * h > 15) {\n      const shape: Rectangle = {\n        type: ShapeType.RECTANGLE, \n        geometry: {\n          bounds: {\n            minX: x, \n            minY: y,\n            maxX: x + w,\n            maxY: y + h\n          },\n          x, y, w, h\n        }\n      }\n\n      dispatch('create', shape);\n    }\n\n    origin = null;\n    anchor = null;\n  }\n\n  onMount(() => {\n    const svg = container.closest('svg');\n\n    svg.addEventListener('pointerdown', onPointerDown);\n    svg.addEventListener('pointermove', onPointerMove);\n    svg.addEventListener('pointerup', onPointerUp);\n\n    return () => {\n      svg.removeEventListener('pointerdown', onPointerDown);\n      svg.removeEventListener('pointermove', onPointerMove);\n      svg.removeEventListener('pointerup', onPointerUp); \n    }\n  });\n</script>\n\n<g \n  bind:this={container}\n  class=\"a9s-annotation a9s-rubberband\">\n  \n  {#if origin}\n    <rect\n      class=\"a9s-outer\"\n      x={x} \n      y={y} \n      width={w} \n      height={h} />\n\n    <rect\n      class=\"a9s-inner\"\n      x={x} \n      y={y} \n      width={w} \n      height={h} />\n  {/if}\n</g>","export const distance = (a: [number, number], b: [number, number]): number => {\n  const dx = Math.abs(b[0] - a[0]);\n  const dy = Math.abs(b[1] - a[1]);\n\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n}","import { writable } from 'svelte/store';\n\nconst setSize = (image: HTMLImageElement | HTMLCanvasElement, svg: SVGElement) => {\n  const { naturalWidth, naturalHeight } = (image as HTMLImageElement);\n\n  if (!naturalWidth && !naturalHeight) {\n    // Might be because a) the image has not loaded yet, or b) because it's not \n    // an image element (but maybe a CANVAS etc.)! Allow for both possibilities.\n    const { width, height } = image;\n\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n\n    image.addEventListener('load', event => {\n      const img = event.target as HTMLImageElement;\n      svg.setAttribute('viewBox', `0 0 ${img.naturalWidth} ${img.naturalHeight}`);\n    });\n  } else {\n    svg.setAttribute('viewBox', `0 0 ${naturalWidth} ${naturalHeight}`);\n  }\n\n}\n\nexport const enableResponsive = (image: HTMLImageElement | HTMLCanvasElement, svg: SVGSVGElement) => {\n\n  setSize(image, svg);\n\n  const { subscribe, set } = writable(1);\n\n  let resizeObserver: ResizeObserver;\n\n  if (window.ResizeObserver) {\n    resizeObserver = new ResizeObserver(() => {\n      const svgBounds = svg.getBoundingClientRect();\n\n      const { width, height } = svg.viewBox.baseVal;\n  \n      const scale = Math.max(\n        svgBounds.width / width,\n        svgBounds.height / height\n      );\n  \n      set(scale);\n    });\n  \n    resizeObserver.observe(svg.parentElement);\n  }\n\n  const destroy = () => {\n    if (resizeObserver)\n      resizeObserver.disconnect();\n  }\n\n  return { destroy, subscribe };\n\n}\n\n","export const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;","<script type=\"ts\">\n  import { onMount, createEventDispatcher } from 'svelte';\n  import { boundsFromPoints, ShapeType, type Polygon } from '../../../model';\n  import { distance } from '../../utils';\n  import type { Transform } from '../..';\n\n  const dispatch = createEventDispatcher<{ create: Polygon }>();\n\n  export let transform: Transform;\n\n  export let viewportScale = 1;\n\n  let container: SVGGElement;\n\n  let points: [number, number][] = [];\n  \n  let cursor: [number, number] = null;\n\n  let isClosable: boolean = false;\n\n  const CLOSE_DISTANCE = 20;\n\n  $: handleSize = 10 / viewportScale;\n\n  const onPointerDown = (evt: PointerEvent) => {\n    const point = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n    if (points.length === 0)\n      points.push(point);\n\n    cursor = point;\n  }\n\n  const onPointerMove = (evt: PointerEvent) => {\n    if (points.length > 0) {\n      cursor = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n      if (points.length >  2) {\n        const d = distance(cursor, points[0]) * viewportScale;\n        isClosable = d < CLOSE_DISTANCE;\n      }\n    }\n  }\n\n  const onPointerUp = (evt: PointerEvent) => {\n    // Require minimum drag of 4px\n    if (points.length === 1) {\n      const dist = distance(points[0], cursor);\n\n      if (dist <= 4) {\n        // Cancel\n        points = [];\n        cursor = null;\n\n        return;\n      }\n    }\n\n    // Stop click event from propagating if we're drawing\n    evt.stopImmediatePropagation();\n\n    if (isClosable) {\n      const shape: Polygon = {\n        type: ShapeType.POLYGON, \n        geometry: {\n          bounds: boundsFromPoints(points),\n          points: [...points]\n        }\n      }\n\n      points = [];\n      cursor = null;\n    \n      dispatch('create', shape);\n    } else {\n      points.push(cursor);\n    }\n  }\n\n  const onDblClick = () => {\n    const p = [...points, cursor];\n    const shape: Polygon = {\n        type: ShapeType.POLYGON, \n        geometry: {\n          bounds: boundsFromPoints(p),\n          points: p\n        }\n      }\n\n      points = [];\n      cursor = null;\n    \n      dispatch('create', shape);\n  }\n\n  onMount(() => {\n    const svg = container.closest('svg');\n\n    svg.addEventListener('pointerdown', onPointerDown, true);\n    svg.addEventListener('pointermove', onPointerMove);\n    svg.addEventListener('pointerup', onPointerUp, true);\n    svg.addEventListener('dblclick', onDblClick, true);\n\n    return () => {\n      svg.removeEventListener('pointerdown', onPointerDown, true);\n      svg.removeEventListener('pointermove', onPointerMove, true);\n      svg.removeEventListener('pointerup', onPointerUp, true);\n      svg.removeEventListener('dblclick', onDblClick, true);\n    }\n  });\n</script>\n\n<g \n  bind:this={container}\n  class=\"a9s-annotation a9s-rubberband\">\n\n  {#if cursor}\n    {@const coords = (isClosable ? points : [...points, cursor]).map(xy => xy.join(',')).join(' ')}\n      <polygon \n        class=\"a9s-outer\"\n        points={coords} />\n\n      <polygon \n        class=\"a9s-inner\"\n        points={coords} />\n        \n    {#if isClosable}\n      <rect \n        class=\"a9s-corner-handle\"\n        x={points[0][0] - handleSize / 2} \n        y={points[0][1] - handleSize / 2} \n        height={handleSize} \n        width={handleSize} />\n    {/if}\n  {/if}\n</g>","import type { SvelteComponent } from 'svelte';\nimport { RubberbandRectangle } from './rectangle';\nimport { RubberbandPolygon } from './polygon';\n\nexport type DrawingTool = 'rectangle' | 'polygon' | string;\n\nconst REGISTERED = new Map<DrawingTool, typeof SvelteComponent>([\n  ['rectangle', RubberbandRectangle],\n  ['polygon', RubberbandPolygon]\n]);\n\nexport const listTools = () => [...REGISTERED.keys()];\n\nexport const getTool = (name: string) => REGISTERED.get(name);\n  \nexport const registerTool = (name: string, tool: typeof SvelteComponent) =>\n  REGISTERED.set(name, tool);\n","<script type=\"ts\">\n  import type { DrawingStyle } from '@annotorious/core';\n  import type { Geometry, EllipseGeometry, ImageAnnotation } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props */\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) = undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { cx, cy, rx, ry } = geom as EllipseGeometry;\n</script>\n\n<g data-id={annotation.id}>\n  <ellipse\n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    cx={cx} \n    cy={cy} \n    rx={rx} \n    ry={ry} />\n\n  <ellipse\n    class=\"a9s-inner\"\n    style={computedStyle}\n    cx={cx} \n    cy={cy} \n    rx={rx} \n    ry={ry} />\n</g>\n","<script type=\"ts\">\n  import type { DrawingStyle } from '@annotorious/core';\n  import type { Geometry, ImageAnnotation, PolygonGeometry } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props **/\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) = undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { points } = geom as PolygonGeometry;\n</script>\n\n<g data-id={annotation.id}>\n  <polygon \n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    points={points.map(xy => xy.join(',')).join(' ')} />\n\n  <polygon \n    class=\"a9s-inner\"\n    style={computedStyle}\n    points={points.map(xy => xy.join(',')).join(' ')} />\n</g>","<script type=\"ts\">\n  import type { DrawingStyle } from '@annotorious/core';\n  import type { Geometry, ImageAnnotation, RectangleGeometry } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props **/\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) = undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { x, y, w, h } = geom as RectangleGeometry;\n</script>\n\n<g data-id={annotation.id}>\n  <rect\n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    x={x} \n    y={y} \n    width={w} \n    height={h} />\n\n  <rect\n    class=\"a9s-inner\"\n    style={computedStyle}\n    x={x} \n    y={y} \n    width={w} \n    height={h} />\n</g>\n","export interface Transform { \n\n  elementToImage: (offsetX: number, offsetY: number) => [ number, number ] \n\n}\n\nexport const IdentityTransform: Transform = {\n\n  elementToImage:  (offsetX: number, offsetY: number) => ([ offsetX, offsetY ])\n\n}\n\nexport const createSVGTransform = (svg: SVGSVGElement): Transform => ({\n\n  elementToImage: (offsetX: number, offsetY: number) => {\n    const pt = svg.createSVGPoint();\n    pt.x = offsetX;\n    pt.y = offsetY;\n  \n    const { x, y } = pt.matrixTransform(svg.getCTM().inverse());\n    return [x, y];\n  }\n\n});","import { createEventDispatcher } from 'svelte';\nimport type { SvelteImageAnnotationStore } from '../state';\nimport type { ImageAnnotation } from '../model';\nimport { isTouch } from './utils';\nimport type { SvelteStore } from '@annotorious/core';\n\nexport interface SVGAnnotationLayerPointerEvent {\n    \n  originalEvent: PointerEvent;\n  \n  annotation?: ImageAnnotation;\n\n}\n\n// Maximum amount of ms between pointer down and up to make it a click\nconst MAX_CLICK_DURATION = 200;\n\nexport const addEventListeners = (svg: SVGSVGElement, store: SvelteImageAnnotationStore) => {\n\n  const dispatch = createEventDispatcher<{ click: SVGAnnotationLayerPointerEvent}>();\n\n  let lastPointerDown: number;\n\n  const onPointerDown = () =>\n    lastPointerDown = new Date().getTime();\n\n  const onPointerUp = (evt: PointerEvent) => {\n    const duration = new Date().getTime() - lastPointerDown;\n\n    if (duration < MAX_CLICK_DURATION) {\n      const { x, y } = getSVGPoint(evt, svg);\n      const annotation = store.getAt(x, y);\n    \n      if (annotation)\n        dispatch('click', { originalEvent: evt, annotation });\n      else\n        dispatch('click', { originalEvent: evt });\n    }\n  }\n\n  return { onPointerDown, onPointerUp };\n}\n\nconst getSVGPoint = (evt: PointerEvent, svg: SVGSVGElement) => {\n  const pt = svg.createSVGPoint();\n\n  if (isTouch) {\n    const bbox = svg.getBoundingClientRect();\n\n    const x = evt.clientX - bbox.x;\n    const y = evt.clientY - bbox.y;\n\n    const { left, top } = svg.getBoundingClientRect();\n    pt.x = x + left;\n    pt.y = y + top;\n\n    return pt.matrixTransform(svg.getScreenCTM().inverse());\n  } else {\n    pt.x = evt.offsetX;\n    pt.y = evt.offsetY;\n\n    return pt.matrixTransform(svg.getCTM().inverse());\n  }\n}","<script type=\"ts\">\n  import { onMount, type SvelteComponent } from 'svelte';\n  import { v4 as uuidv4 } from 'uuid';\n  import type { DrawingStyle, StoreChangeEvent } from '@annotorious/core';\n  import { ShapeType } from '../model';\n  import type { ImageAnnotation, Shape} from '../model';\n  import { getEditor, EditorMount } from './editors';\n  import { Ellipse, Polygon, Rectangle} from './shapes';\n  import { getTool, ToolMount } from './tools';\n  import { enableResponsive } from './utils';\n  import { createSVGTransform } from './Transform';\n  import { addEventListeners } from './SVGAnnotationLayerPointerEvent';\n  import type { SvelteImageAnnotatorState } from 'src/state';\n\n  /** Props **/\n  export let image: HTMLImageElement | HTMLCanvasElement;\n  export let state: SvelteImageAnnotatorState;\n  export let style: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) = undefined;\n  export let tool: typeof SvelteComponent = getTool('rectangle');\n\n  /** Drawing tool layer **/\n  let drawingEl: SVGGElement;\n\n  /** Responsive scaling **/\n  let svgEl: SVGSVGElement;\n    \n  let scale: ReturnType<typeof enableResponsive>;\n\n  onMount(() => scale = enableResponsive(image, svgEl));\n\n  $: transform = createSVGTransform(svgEl);\n\n  /** Selection tracking */\n  const { selection, store } = state;\n\n  $: ({ onPointerDown, onPointerUp } = addEventListeners(svgEl, store));\n\n  let storeObserver = null;\n\n  let editableAnnotations: ImageAnnotation[] = null;\n\n  $: isEditable = (a: ImageAnnotation) => $selection.selected.find(s => s.id === a.id && s.editable);\n\n  $: trackSelection($selection.selected);\n\n  const trackSelection = (selected: { id: string, editable?: boolean }[]) => {\n    store.unobserve(storeObserver);\n\n    // Track only editable annotations\n    const editableIds = \n      selected.filter(({ editable }) => editable).map(({ id }) => id);\n\n    if (editableIds.length > 0) {\n      // Resolve selected IDs from the store\n      editableAnnotations = editableIds.map(id => store.getAnnotation(id));\n\n      // Track updates on the editable annotations\n      storeObserver = (event: StoreChangeEvent<ImageAnnotation>) => {\n        const { updated } = event.changes;\n        editableAnnotations = updated.map(change => change.newValue);\n      }   \n      \n      store.observe(storeObserver, { annotations: editableIds });\n    } else {\n      editableAnnotations = null;\n    }\n  }\n\n  const onSelectionCreated = <T extends Shape>(evt: CustomEvent<T>) => {\n    const id = uuidv4();\n\n    const annotation: ImageAnnotation = {\n      id,\n      bodies: [],\n      target: {\n        annotation: id,\n        selector: evt.detail,\n        creator: null,\n        created: new Date()\n      }\n    };\n\n    store.addAnnotation(annotation);\n\n    selection.setSelected(annotation.id);\n  }\n\n  const onChangeSelected = (annotation: ImageAnnotation) => (event: CustomEvent<Shape>) => {  \n    const { target } = annotation;\n\n    // We don't consider a shape edit an 'update' if it happens within 10mins\n    const GRACE_PERIOD = 10 * 60 * 1000;\n\n    const isUpdate = \n      // target.creator?.id !== user.id ||\n      !target.created ||\n      new Date().getTime() - target.created.getTime() > GRACE_PERIOD;\n\n    store.updateTarget({\n      ...target,\n      selector: event.detail,\n      created: isUpdate ? target.created : new Date(),\n      updated: isUpdate ? new Date() : null,\n      //updatedBy: isUpdate ? user : null\n    });\n  }\n</script>\n\n<svg\n  bind:this={svgEl}\n  class=\"a9s-annotationlayer\"\n  class:drawing={tool}\n  on:pointerup={onPointerUp}\n  on:pointerdown={onPointerDown}>\n  \n  <g>\n    {#each $store as annotation}\n      {#if !isEditable(annotation)}\n        {@const selector = annotation.target.selector}\n        {#key annotation.id}\n          {#if (selector.type === ShapeType.ELLIPSE)}\n            <Ellipse annotation={annotation} geom={selector.geometry} style={style} />\n          {:else if (selector.type === ShapeType.RECTANGLE)}\n            <Rectangle annotation={annotation} geom={selector.geometry} style={style} />\n          {:else if (selector.type === ShapeType.POLYGON)}\n            <Polygon annotation={annotation} geom={selector.geometry} style={style} />\n          {/if}\n        {/key}\n      {/if}\n    {/each}\n  </g>\n\n  <g \n    bind:this={drawingEl}\n    class=\"drawing\" >\n    {#if drawingEl}\n      {#if editableAnnotations}\n        {#each editableAnnotations as editable}\n          {#key editable.id}\n            <EditorMount\n              target={drawingEl}\n              editor={getEditor(editable.target.selector)}\n              annotation={editable}\n              style={style}\n              transform={transform}\n              viewportScale={$scale}\n              on:change={onChangeSelected(editable)} />\n          {/key}\n        {/each}\n      {:else if tool} \n        {#key tool}\n          <ToolMount \n            target={drawingEl}\n            tool={tool}\n            transform={transform}\n            viewportScale={$scale}\n            on:create={onSelectionCreated} />\n        {/key}\n      {/if}\n    {/if}\n  </g>\n</svg>","\nexport default function quickselect(arr, k, left, right, compare) {\n    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);\n}\n\nfunction quickselectStep(arr, k, left, right, compare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselectStep(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","import RBush from 'rbush';\nimport { ShapeType,computeArea, intersects } from '../model';\nimport type { ImageAnnotationTarget } from '../model';\n\ninterface IndexedTarget {\n\n  minX: number;\n\n  minY: number;\n\n  maxX: number;\n\n  maxY: number;\n\n  target: ImageAnnotationTarget;\n\n}\n\nexport const createSpatialTree = () => {\n\n  const tree = new RBush<IndexedTarget>();\n\n  const index = new Map<string, IndexedTarget>();\n\n  const all = () => [...index.values()];\n\n  const clear = () => {\n    tree.clear();\n    index.clear();\n  }\n\n  const insert = (target: ImageAnnotationTarget) => {\n    const { minX, minY, maxX, maxY } = target.selector.geometry.bounds;\n\n    const t = { minX, minY, maxX, maxY, target };\n\n    tree.insert(t);\n    index.set(target.annotation, t);\n  };\n\n  const remove = (target: ImageAnnotationTarget) => {\n    const item = index.get(target.annotation);\n    tree.remove(item);\n    index.delete(target.annotation);\n  };\n\n  const update = (previous: ImageAnnotationTarget, updated: ImageAnnotationTarget) => {\n    remove(previous);\n    insert(updated);\n  };\n\n  const set = (targets: ImageAnnotationTarget[], replace: boolean = true) => {\n    if (replace) \n      clear();\n\n    const indexedTargets = targets.map(target => {\n      const { minX, minY, maxX, maxY } = target.selector.geometry.bounds;\n      return { minX, minY, maxX, maxY, target };\n    });\n\n    indexedTargets.forEach(t => index.set(t.target.annotation, t));\n    tree.load(indexedTargets);\n  };\n\n  const getAt = (x: number, y: number): ImageAnnotationTarget | null => {\n    const idxHits = tree.search({\n      minX: x,\n      minY: y,\n      maxX: x,\n      maxY: y\n    }).map(item => item.target);\n\n    // Exact hit test on shape (not needed for rectangles!)\n    const exactHits = idxHits.filter(target => {\n      return (target.selector.type === ShapeType.RECTANGLE) ||\n        intersects(target.selector, x, y);\n    });\n\n    // Get smallest shape\n    if (exactHits.length > 0) {\n      exactHits.sort((a, b) => computeArea(a.selector) - computeArea(b.selector));\n      return exactHits[0];\n    }\n  };\n\n  const getIntersecting = (x: number, y: number, width: number, height: number) =>\n    tree.search({\n      minX: x,\n      minY: y,\n      maxX: x + width,\n      maxY: y + height\n    }).map(item => item.target);\n  \n  const size = () => tree.all().length;\n\n  return {\n    all,\n    clear,\n    getAt,\n    getIntersecting,\n    insert,\n    remove,\n    set,\n    size,\n    update\n  }\n\n}\n","import type { ImageAnnotation, ImageAnnotationTarget } from '../model';\nimport type { AnnotoriousOpts } from '../AnnotoriousOpts';\nimport { createSpatialTree } from './spatialTree';\nimport { \n  createViewportState,\n  toSvelteStore,\n  type AnnotatorState, \n  type HoverState,\n  type SelectionState\n} from '@annotorious/core';\nimport { \n  createHoverState, \n  createSelectionState, \n  createStore\n} from '@annotorious/core';\nimport type { \n  ImageAnnotationStore,\n  SvelteImageAnnotationStore, \n  SvelteImageAnnotatorState\n} from './ImageAnnotationStore';\n\nexport type ImageAnnotatorState<T extends ImageAnnotationStore = ImageAnnotationStore> = AnnotatorState<ImageAnnotation> & {\n\n  store: T;\n\n  selection: SelectionState<ImageAnnotation>;\n\n  hover: HoverState<ImageAnnotation>;\n\n}\n\nexport const createImageAnnotatorState = <E extends unknown>(\n  opts: AnnotoriousOpts<ImageAnnotation, E>\n): ImageAnnotatorState<ImageAnnotationStore> => {\n\n  const store = createStore<ImageAnnotation>();\n\n  const tree = createSpatialTree();\n\n  const selection = createSelectionState(store, opts.pointerSelectAction);\n\n  const hover = createHoverState(store);\n\n  const viewport = createViewportState();\n\n  store.observe(({ changes }) => {\n    tree.set(changes.created.map(a => a.target as ImageAnnotationTarget), false);\n    \n    changes.deleted.forEach(a => tree.remove(a.target as ImageAnnotationTarget));\n    \n    changes.updated.forEach(({ oldValue, newValue }) =>\n      tree.update(oldValue.target, newValue.target));\n  });\n\n  const getAt = (x: number, y: number): ImageAnnotation | undefined => {\n    const target = tree.getAt(x, y);\n    return target ? store.getAnnotation(target.annotation) : undefined; \n  }\n\n  const getIntersecting = (x: number, y: number, width: number, height: number) =>\n    tree.getIntersecting(x, y, width, height).map(target => store.getAnnotation(target.annotation));\n\n  return {\n    store: {\n      ...store,\n      getAt,\n      getIntersecting\n    } as ImageAnnotationStore,\n    selection,\n    hover,\n    viewport\n  }\n\n}\n\nexport const createSvelteImageAnnotatorState = <E extends unknown>(  \n  opts: AnnotoriousOpts<ImageAnnotation, E>\n): SvelteImageAnnotatorState => {\n\n  const state = createImageAnnotatorState(opts);\n  \n  return {\n    ...state,\n    store: toSvelteStore(state.store) as SvelteImageAnnotationStore\n  }\n\n}\n  ","export const sampleBrightness = (imageOrCanvas: HTMLElement) => {\n\n  let canvas: HTMLCanvasElement;\n\n  let context: CanvasRenderingContext2D;\n\n  if (imageOrCanvas.nodeName === 'CANVAS') {\n    canvas = imageOrCanvas as HTMLCanvasElement;\n    context = canvas.getContext('2d', { willReadFrequently: true });\n  } else {\n    const img = imageOrCanvas as HTMLImageElement;\n    // Copy image to in-memory canvas for processing\n    canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    context = canvas.getContext('2d', { willReadFrequently: true });\n    context.drawImage(img, 0, 0, img.width, img.height);\n  }\n\n  let totalBrightness = 0;\n\n  // Sample a grid of points spaced 10% width/height apart (= 9 x 9 samples)\n  for (let i = 1; i < 10; i++) {\n    for (let j = 1; j < 10; j++) {\n      const x = Math.round(j * canvas.width / 10);\n      const y = Math.round(i * canvas.height / 10);\n\n      const pixelData = context.getImageData(x, y, 1, 1).data;\n      const brightness = (0.299 * pixelData[0] + 0.587 * pixelData[1] + 0.114 * pixelData[2]) / 255;\n      totalBrightness += brightness;\n    }\n  }\n\n  return totalBrightness / 81;\n}\n\nexport const setTheme = (imageOrCanvas: HTMLElement, container: HTMLElement) => {\n  const brightness = sampleBrightness(imageOrCanvas);\n\n  const theme = brightness > 0.6 ? 'dark' : 'light'\n\n  console.log(`[Annotorious] Image brightness: ${brightness.toFixed(1)}. Setting ${theme} theme.`);\n\n  container.setAttribute('data-theme', theme);\n}","import { PointerSelectAction } from '@annotorious/core';\nimport type { Annotation, DrawingStyle, FormatAdapter } from '@annotorious/core';\nimport type { ImageAnnotation } from './model';\n\nexport interface AnnotoriousOpts<I extends Annotation = ImageAnnotation, E extends unknown = ImageAnnotation> {\n\n  adapter?: FormatAdapter<I, E>;\n\n  autoSave?: boolean;\n\n  pointerSelectAction?: PointerSelectAction | ((a: I) => PointerSelectAction);\n\n  readOnly?: boolean;\n\n  style?: DrawingStyle | ((annotation: I) => DrawingStyle);\n\n}\n\nexport const fillDefaults = <I extends ImageAnnotation = ImageAnnotation, E extends unknown = ImageAnnotation> (\n  opts: AnnotoriousOpts<I, E>\n): AnnotoriousOpts<I, E> => {\n\n  return {\n    ...opts,\n    pointerSelectAction: opts.pointerSelectAction || PointerSelectAction.EDIT\n  };\n\n};\n\n\n\n\n","import type { SvelteComponent } from 'svelte';\nimport type { Annotator, DrawingStyle, User } from '@annotorious/core';\nimport { createAnonymousGuest, createBaseAnnotator, createLifecyleObserver } from '@annotorious/core';\nimport { registerEditor } from './annotation/editors';\nimport { getTool, registerTool, type DrawingTool } from './annotation/tools';\nimport { SVGAnnotationLayer } from './annotation';\nimport type { SVGAnnotationLayerPointerEvent } from './annotation';\nimport type { ImageAnnotation, ShapeType } from './model';\nimport { createSvelteImageAnnotatorState } from './state';\nimport { setTheme } from './themes';\nimport { fillDefaults } from './AnnotoriousOpts';\nimport type { AnnotoriousOpts } from './AnnotoriousOpts';\n\nimport './Annotorious.css';\nimport './themes/dark/index.css';\nimport './themes/light/index.css';\n\nexport interface ImageAnnotator<E extends unknown = ImageAnnotation> extends Annotator<ImageAnnotation, E> { \n\n  registerDrawingTool(name: string, tool: typeof SvelteComponent): void;\n\n  registerShapeEditor(shapeType: ShapeType, editor: typeof SvelteComponent): void;\n\n  setDrawingTool(tool: DrawingTool): void; \n\n}\n\nexport const createImageAnnotator = <E extends unknown = ImageAnnotation>(\n  image: string | HTMLImageElement | HTMLCanvasElement, \n  options: AnnotoriousOpts<ImageAnnotation, E> = {}\n): ImageAnnotator<E> => {\n\n  if (!image)\n    throw 'Missing argument: image';\n\n  const img = (typeof image === 'string' ? \n    document.getElementById(image) : image) as HTMLImageElement | HTMLCanvasElement;\n\n  const opts = fillDefaults<ImageAnnotation, E>(options);\n\n  const state = createSvelteImageAnnotatorState(opts);\n\n  const { hover, selection, store } = state;\n\n  const lifecycle = createLifecyleObserver<ImageAnnotation, E>(\n    store, selection, hover, undefined, opts.adapter, opts.autoSave);\n\n  let _style = opts.style;\n\n  let currentUser: User = opts.readOnly ? null : createAnonymousGuest();\n\n  // We'll wrap the image in a container DIV.\n  const container = document.createElement('DIV');\n  container.style.position = 'relative';\n  container.style.display = 'inline-block';\n\n  // Wrapper div has unwanted margin at the bottom otherwise!\n  img.style.display = 'block';\n\n  img.parentNode.insertBefore(container, img);\n  container.appendChild(img);\n\n  setTheme(img, container);\n\n  const annotationLayer = new SVGAnnotationLayer({\n    target: container,\n    props: { image: img, state, style: _style }\n  });\n\n  annotationLayer.$on('click', (evt: CustomEvent<SVGAnnotationLayerPointerEvent>) => {\n    const { originalEvent, annotation } = evt.detail;\n    if (annotation)\n      selection.clickSelect(annotation.id, originalEvent);\n    else if (!selection.isEmpty())\n      selection.clear();\n  });\n\n  /*************************/\n  /*      External API     */\n  /******++++++*************/\n\n  // Most of the external API functions are covered in the base annotator\n  const base = createBaseAnnotator<ImageAnnotation, E>(store, opts.adapter);\n\n  const setStyle = (style: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) | undefined) => {\n    _style = style;\n    annotationLayer.$set({ style });\n  }\n\n  const destroy = () => {\n    // Destroy Svelte annotation layer\n    annotationLayer.$destroy();\n\n    // Unwrap the image\n    container.parentNode.insertBefore(img, container);\n    container.parentNode.removeChild(container);\n  }\n\n  const registerDrawingTool = (name: string, tool: typeof SvelteComponent) =>\n    registerTool(name, tool);\n\n  const registerShapeEditor = (shapeType: ShapeType, editor: typeof SvelteComponent) =>\n    registerEditor(shapeType, editor);\n\n  const getUser = () => currentUser;\n\n  const setDrawingTool = (tool: DrawingTool) => {\n    const t = getTool(tool) as typeof SvelteComponent;\n    annotationLayer.$set({ tool: t })\n  }\n\n  const setSelected = (arg?: string | string[]) => {\n    if (arg) {\n      selection.setSelected(arg);\n    } else {\n      selection.clear();\n    }\n  }\n\n  const setUser = (user: User) => {\n    currentUser = user;\n    // annotationLayer.$set({ user });\n  }\n\n  return {\n    ...base,\n    get style() { return _style },\n    set style(s: DrawingStyle | ((annotation: ImageAnnotation) => DrawingStyle) | undefined) { setStyle(s) },\n    destroy,\n    getUser,\n    on: lifecycle.on,\n    off: lifecycle.off,\n    registerDrawingTool,\n    registerShapeEditor,\n    setDrawingTool,\n    setSelected,\n    setUser,\n    state\n  }\n\n}"],"names":["noop","assign","tar","src","k","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","a","b","is_empty","obj","subscribe","store","callbacks","unsub","component_subscribe","component","callback","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","get_slot_changes","dirty","lets","merged","len","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","get_all_dirty_from_scope","length","append","target","node","insert","anchor","detach","destroy_each","iterations","detaching","svg_element","name","text","data","space","empty","listen","event","handler","options","attr","attribute","value","children","element","toggle_class","toggle","custom_event","type","detail","bubbles","cancelable","e","current_component","set_current_component","get_current_component","onMount","createEventDispatcher","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","add_render_callback","seen_callbacks","flushidx","saved_component","update","$$","flush_render_callbacks","filtered","targets","c","outroing","outros","group_outros","check_outros","transition_in","block","local","transition_out","create_component","mount_component","customElement","fragment","after_update","new_on_destroy","destroy_component","make_dirty","init","instance","create_fragment","not_equal","props","append_styles","parent_component","ready","ret","rest","nodes","SvelteComponent","index","$$props","ShapeType","Utils","registerShapeUtil","util","computeArea","shape","intersects","x","y","boundsFromPoints","points","minX","minY","maxX","maxY","EllipseUtil","cx","cy","rx","ry","rot","cos","sin","dx","dy","tdx","tdy","PolygonUtil","polygon","area","j","inside","xi","yi","xj","yj","RectangleUtil","rect","parseFragmentSelector","fragmentOrSelector","invertY","regex","matches","_","prefix","unit","d","w","h","serializeFragmentSelector","geometry","SVG_NAMESPACE","sanitize","doc","cleanEl","el","scripts","insertSVGNamespace","originalDoc","namespaced","parseSVGXML","isPrefixDeclared","isDefaultNamespaceSVG","parseSVGPolygon","str","p","parseSVGEllipse","bounds","parseSVGSelector","valueOrSelector","serializeSVGSelector","geom","xy","getRandomValues","rnds8","rng","byteToHex","unsafeStringify","arr","offset","randomUUID","native","v4","buf","rnds","has","dequal","foo","bar","ctor","subscriber_queue","writable","start","stop","subscribers","set","new_value","run_queue","subscriber","invalidate","createHoverState","currentHover","updated","changes","oldValue","PointerSelectAction","EMPTY","createSelectionState","selectAction","currentSelection","clear","isEmpty","_a","isSelected","annotationOrId","id","clickSelect","pointerEvent","annotation","action","onPointerSelect","setSelected","idOrIds","editable","ids","annotations","removeFromSelection","selected","getContributors","creator","updatedBy","bodyCollaborators","users","body","u","createBody","payload","created","uuidv4","getAddedBodies","newValue","oldBodyIds","getRemovedBodies","newBodyIds","getChangedBodies","newBody","oldBody","hasTargetChanged","diffAnnotations","Origin","shouldNotify","observer","_b","origin","ignore","arg","hasBodyChanges","hasTargetChanges","affectedAnnotations","isAnnotation","createStore","annotationIndex","bodyIndex","observers","observe","onChange","unobserve","idx","emit","addAnnotation","updateAnnotation","arg1","arg2","arg3","oldId","addBody","all","bulkAddAnnotation","replace","deleted","existing","next","deleteOneAnnotation","deleteAnnotation","bulkDeleteAnnotation","annotationsOrIds","deleteBody","oldAnnotation","newAnnotation","getAnnotation","getBody","annotationId","updateOneBody","oldBodyId","updateBody","bulkUpdateBodies","bodies","updateOneTarget","val","toSvelteStore","shim","createViewportState","createLifecyleObserver","selectionState","hoverState","viewportState","adapter","autoSave","initialSelection","idleTimeout","on","off","arg0","serialized0","serialized1","onIdleUpdate","updatedSelected","initial","updatedState","initialIds","selectedIds","relevantUpdates","serializeAll","parseAll","serialized","result","parsed","error","createBaseAnnotator","clearAnnotations","getAnnotationById","getAnnotations","loadAnnotations","url","response","setAnnotations","removeAnnotation","failed","crosswalked","previous","random","bytes","customRandom","alphabet","defaultSize","getRandom","mask","step","size","customAlphabet","nanoid","byte","createAnonymousGuest","hashCode","hash","chr","parseW3CBodies","purpose","serializeW3CBodies","w3c","DEFAULT_PALETTE","defaultColorProvider","unassignedColors","rnd","color","createDefaultAppearenceProvider","colorProvider","presenceKey","user","createNanoEvents","args","cb","isListEqual","listA","listB","PRESENCE_KEY","createPresenceState","appearanceProvider","emitter","presentUsers","selectionStates","addUser","appearance","removeUser","syncUsers","state","keys","s","toAdd","toRemove","presentUser","getPresentUsers","notifyActivity","annotationIds","updateSelection","selection","from","W3CImageFormat","source","parseW3CImageAnnotation","serializeW3CImageAnnotation","w3cSelector","selector","rect_x_value","rect_y_value","Handle","each_value","polygon0","polygon0_points_value","func","polygon1","polygon1_points_value","func_1","grab","computedStyle","transform","viewportScale","editor","handle","delta","$$invalidate","handleSize","rect0","rect0_x_value","rect0_y_value","rect0_width_value","rect0_height_value","rect1","rect1_x_value","rect1_y_value","rect1_width_value","rect1_height_value","rect2","rect2_x_value","rect2_y_value","rect2_width_value","rect3","rect3_x_value","rect3_y_value","rect3_height_value","rect4","rect4_x_value","rect4_y_value","rect4_width_value","rect5","rect5_x_value","rect5_y_value","rect5_height_value","rect6","rect6_x_value","rect6_y_value","rect7","rect7_y_value","rect9","rect9_x_value","rect8","rectangle","initialBounds","x0","y0","x1","y1","REGISTERED","RectangleEditor","PolygonEditor","getEditor","registerEditor","shapeType","g","dispatch","grabbedHandle","initialShape","onGrab","evt","onPointerMove","onRelease","computeStyle","style","computed","fill","fillOpacity","css","editorComponent","tool","toolComponent","create_if_block","container","onPointerDown","onPointerUp","svg","$$value","distance","setSize","image","naturalWidth","naturalHeight","width","height","img","enableResponsive","resizeObserver","svgBounds","scale","isTouch","child_ctx","create_if_block_1","get_if_ctx","CLOSE_DISTANCE","cursor","isClosable","point","onDblClick","RubberbandRectangle","RubberbandPolygon","listTools","getTool","registerTool","g_data_id_value","ellipse0","ellipse1","IdentityTransform","offsetX","offsetY","createSVGTransform","pt","MAX_CLICK_DURATION","addEventListeners","lastPointerDown","getSVGPoint","bbox","left","top","previous_key","polygon_changes","rectangle_changes","ellipse_changes","show_if","each_blocks","editormount_changes","g0","g1","drawingEl","svgEl","storeObserver","editableAnnotations","trackSelection","editableIds","change","onSelectionCreated","onChangeSelected","GRACE_PERIOD","isUpdate","isEditable","$selection","quickselect","right","compare","quickselectStep","defaultCompare","n","m","z","sd","newLeft","newRight","t","swap","tmp","RBush","maxEntries","toBBox","nodesToSearch","child","childBBox","contains","tmpNode","item","createNode","equalsFn","path","indexes","parent","goingUp","findItem","items","N","M","calcBBox","N2","N1","multiSelect","right2","right3","level","minArea","minEnlargement","targetNode","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","splitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","xMargin","yMargin","leftBBox","rightBBox","margin","bboxMargin","siblings","destNode","stack","mid","createSpatialTree","tree","remove","exactHits","indexedTargets","createImageAnnotatorState","opts","hover","viewport","createSvelteImageAnnotatorState","sampleBrightness","imageOrCanvas","canvas","context","totalBrightness","pixelData","brightness","setTheme","theme","fillDefaults","createImageAnnotator","lifecycle","_style","currentUser","annotationLayer","SVGAnnotationLayer","originalEvent","base","setStyle","destroy","registerDrawingTool","registerShapeEditor","getUser","setDrawingTool","setUser"],"mappings":"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","x_google_ignoreList":[0,9,10,11,12,13,14,26,31,54,55]}