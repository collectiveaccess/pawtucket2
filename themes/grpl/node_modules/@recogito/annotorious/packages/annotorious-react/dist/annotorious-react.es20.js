import Ki from "openseadragon";
var Bs = Object.prototype.hasOwnProperty;
function We(r, e) {
  var t, i;
  if (r === e)
    return !0;
  if (r && e && (t = r.constructor) === e.constructor) {
    if (t === Date)
      return r.getTime() === e.getTime();
    if (t === RegExp)
      return r.toString() === e.toString();
    if (t === Array) {
      if ((i = r.length) === e.length)
        for (; i-- && We(r[i], e[i]); )
          ;
      return i === -1;
    }
    if (!t || typeof r == "object") {
      i = 0;
      for (t in r)
        if (Bs.call(r, t) && ++i && !Bs.call(e, t) || !(t in e) || !We(r[t], e[t]))
          return !1;
      return Object.keys(e).length === i;
    }
  }
  return r !== r && e !== e;
}
function jt() {
}
function ul(r, e) {
  for (const t in e)
    r[t] = e[t];
  return r;
}
function Bh(r) {
  return r();
}
function Gs() {
  return /* @__PURE__ */ Object.create(null);
}
function Pe(r) {
  r.forEach(Bh);
}
function Ft(r) {
  return typeof r == "function";
}
function Vt(r, e) {
  return r != r ? e == e : r !== e || r && typeof r == "object" || typeof r == "function";
}
function ll(r) {
  return Object.keys(r).length === 0;
}
function cl(r, ...e) {
  if (r == null)
    return jt;
  const t = r.subscribe(...e);
  return t.unsubscribe ? () => t.unsubscribe() : t;
}
function Gh(r, e, t) {
  r.$$.on_destroy.push(cl(e, t));
}
function Uh(r, e, t, i) {
  if (r) {
    const n = kh(r, e, t, i);
    return r[0](n);
  }
}
function kh(r, e, t, i) {
  return r[1] && i ? ul(t.ctx.slice(), r[1](i(e))) : t.ctx;
}
function Xh(r, e, t, i) {
  if (r[2] && i) {
    const n = r[2](i(t));
    if (e.dirty === void 0)
      return n;
    if (typeof n == "object") {
      const o = [], s = Math.max(e.dirty.length, n.length);
      for (let a = 0; a < s; a += 1)
        o[a] = e.dirty[a] | n[a];
      return o;
    }
    return e.dirty | n;
  }
  return e.dirty;
}
function jh(r, e, t, i, n, o) {
  if (n) {
    const s = kh(e, t, i, o);
    r.p(s, n);
  }
}
function Hh(r) {
  if (r.ctx.length > 32) {
    const e = [], t = r.ctx.length / 32;
    for (let i = 0; i < t; i++)
      e[i] = -1;
    return e;
  }
  return -1;
}
const Yh = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : global;
function $e(r, e) {
  r.appendChild(e);
}
function Y(r, e, t) {
  r.insertBefore(e, t || null);
}
function H(r) {
  r.parentNode && r.parentNode.removeChild(r);
}
function ps(r, e) {
  for (let t = 0; t < r.length; t += 1)
    r[t] && r[t].d(e);
}
function st(r) {
  return document.createElementNS("http://www.w3.org/2000/svg", r);
}
function ds(r) {
  return document.createTextNode(r);
}
function Zt() {
  return ds(" ");
}
function Me() {
  return ds("");
}
function Ut(r, e, t, i) {
  return r.addEventListener(e, t, i), () => r.removeEventListener(e, t, i);
}
function A(r, e, t) {
  t == null ? r.removeAttribute(e) : r.getAttribute(e) !== t && r.setAttribute(e, t);
}
function pl(r) {
  return Array.from(r.childNodes);
}
function dl(r, e) {
  e = "" + e, r.data !== e && (r.data = e);
}
function Us(r, e, t) {
  r.classList[t ? "add" : "remove"](e);
}
function fl(r, e, { bubbles: t = !1, cancelable: i = !1 } = {}) {
  const n = document.createEvent("CustomEvent");
  return n.initCustomEvent(r, t, i, e), n;
}
function Zi(r, e) {
  return new r(e);
}
let Kr;
function Vr(r) {
  Kr = r;
}
function fs() {
  if (!Kr)
    throw new Error("Function called outside component initialization");
  return Kr;
}
function mn(r) {
  fs().$$.on_mount.push(r);
}
function yl(r) {
  fs().$$.on_destroy.push(r);
}
function _n() {
  const r = fs();
  return (e, t, { cancelable: i = !1 } = {}) => {
    const n = r.$$.callbacks[e];
    if (n) {
      const o = fl(e, t, { cancelable: i });
      return n.slice().forEach((s) => {
        s.call(r, o);
      }), !o.defaultPrevented;
    }
    return !0;
  };
}
function vr(r, e) {
  const t = r.$$.callbacks[e.type];
  t && t.slice().forEach((i) => i.call(this, e));
}
const pr = [], Zr = [];
let br = [];
const ks = [], ml = /* @__PURE__ */ Promise.resolve();
let go = !1;
function _l() {
  go || (go = !0, ml.then(Vh));
}
function vo(r) {
  br.push(r);
}
const En = /* @__PURE__ */ new Set();
let or = 0;
function Vh() {
  if (or !== 0)
    return;
  const r = Kr;
  do {
    try {
      for (; or < pr.length; ) {
        const e = pr[or];
        or++, Vr(e), gl(e.$$);
      }
    } catch (e) {
      throw pr.length = 0, or = 0, e;
    }
    for (Vr(null), pr.length = 0, or = 0; Zr.length; )
      Zr.pop()();
    for (let e = 0; e < br.length; e += 1) {
      const t = br[e];
      En.has(t) || (En.add(t), t());
    }
    br.length = 0;
  } while (pr.length);
  for (; ks.length; )
    ks.pop()();
  go = !1, En.clear(), Vr(r);
}
function gl(r) {
  if (r.fragment !== null) {
    r.update(), Pe(r.before_update);
    const e = r.dirty;
    r.dirty = [-1], r.fragment && r.fragment.p(r.ctx, e), r.after_update.forEach(vo);
  }
}
function vl(r) {
  const e = [], t = [];
  br.forEach((i) => r.indexOf(i) === -1 ? e.push(i) : t.push(i)), t.forEach((i) => i()), br = e;
}
const zi = /* @__PURE__ */ new Set();
let ze;
function De() {
  ze = {
    r: 0,
    c: [],
    p: ze
    // parent group
  };
}
function Ce() {
  ze.r || Pe(ze.c), ze = ze.p;
}
function at(r, e) {
  r && r.i && (zi.delete(r), r.i(e));
}
function ft(r, e, t, i) {
  if (r && r.o) {
    if (zi.has(r))
      return;
    zi.add(r), ze.c.push(() => {
      zi.delete(r), i && (t && r.d(1), i());
    }), r.o(e);
  } else
    i && i();
}
function zt(r) {
  r && r.c();
}
function Ht(r, e, t, i) {
  const { fragment: n, after_update: o } = r.$$;
  n && n.m(e, t), i || vo(() => {
    const s = r.$$.on_mount.map(Bh).filter(Ft);
    r.$$.on_destroy ? r.$$.on_destroy.push(...s) : Pe(s), r.$$.on_mount = [];
  }), o.forEach(vo);
}
function Yt(r, e) {
  const t = r.$$;
  t.fragment !== null && (vl(t.after_update), Pe(t.on_destroy), t.fragment && t.fragment.d(e), t.on_destroy = t.fragment = null, t.ctx = []);
}
function bl(r, e) {
  r.$$.dirty[0] === -1 && (pr.push(r), _l(), r.$$.dirty.fill(0)), r.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Wt(r, e, t, i, n, o, s, a = [-1]) {
  const h = Kr;
  Vr(r);
  const u = r.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: o,
    update: jt,
    not_equal: n,
    bound: Gs(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (h ? h.$$.context : [])),
    // everything else
    callbacks: Gs(),
    dirty: a,
    skip_bound: !1,
    root: e.target || h.$$.root
  };
  s && s(u.root);
  let l = !1;
  if (u.ctx = t ? t(r, e.props || {}, (c, p, ...d) => {
    const f = d.length ? d[0] : p;
    return u.ctx && n(u.ctx[c], u.ctx[c] = f) && (!u.skip_bound && u.bound[c] && u.bound[c](f), l && bl(r, c)), p;
  }) : [], u.update(), l = !0, Pe(u.before_update), u.fragment = i ? i(u.ctx) : !1, e.target) {
    if (e.hydrate) {
      const c = pl(e.target);
      u.fragment && u.fragment.l(c), c.forEach(H);
    } else
      u.fragment && u.fragment.c();
    e.intro && at(r.$$.fragment), Ht(r, e.target, e.anchor, e.customElement), Vh();
  }
  Vr(h);
}
class $t {
  $destroy() {
    Yt(this, 1), this.$destroy = jt;
  }
  $on(e, t) {
    if (!Ft(t))
      return jt;
    const i = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return i.push(t), () => {
      const n = i.indexOf(t);
      n !== -1 && i.splice(n, 1);
    };
  }
  $set(e) {
    this.$$set && !ll(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
const sr = [];
function ys(r, e = jt) {
  let t;
  const i = /* @__PURE__ */ new Set();
  function n(a) {
    if (Vt(r, a) && (r = a, t)) {
      const h = !sr.length;
      for (const u of i)
        u[1](), sr.push(u, r);
      if (h) {
        for (let u = 0; u < sr.length; u += 2)
          sr[u][0](sr[u + 1]);
        sr.length = 0;
      }
    }
  }
  function o(a) {
    n(a(r));
  }
  function s(a, h = jt) {
    const u = [a, h];
    return i.add(u), i.size === 1 && (t = e(n) || jt), a(r), () => {
      i.delete(u), i.size === 0 && t && (t(), t = null);
    };
  }
  return { set: n, update: o, subscribe: s };
}
const xl = (r) => {
  const { subscribe: e, set: t } = ys(null);
  let i = null;
  return e((n) => i = n), r.observe(({ changes: n }) => {
    if (i) {
      n.deleted.some((s) => s.id === i) && t(null);
      const o = n.updated.find(({ oldValue: s }) => s.id === i);
      o && t(o.newValue.id);
    }
  }), {
    get current() {
      return i;
    },
    subscribe: e,
    set: t
  };
};
var zh = /* @__PURE__ */ ((r) => (r.EDIT = "EDIT", r.HIGHLIGHT = "HIGHLIGHT", r.NONE = "NONE", r))(zh || {});
const An = { selected: [] }, Tl = (r, e = "EDIT") => {
  const { subscribe: t, set: i } = ys(An);
  let n = An;
  t((c) => n = c);
  const o = () => i(An), s = () => {
    var c;
    return ((c = n.selected) == null ? void 0 : c.length) === 0;
  }, a = (c) => {
    if (n.selected.length === 0)
      return !1;
    const p = typeof c == "string" ? c : c.id;
    return n.selected.some((d) => d.id === p);
  }, h = (c, p) => {
    const d = r.getAnnotation(c);
    if (d) {
      const f = El(d, e);
      i(f === "EDIT" ? { selected: [{ id: c, editable: !0 }], pointerEvent: p } : f === "HIGHLIGHT" ? { selected: [{ id: c }], pointerEvent: p } : { selected: [], pointerEvent: p });
    } else
      console.warn("Invalid selection: " + c);
  }, u = (c, p = !0) => {
    const d = Array.isArray(c) ? c : [c], f = d.map((y) => r.getAnnotation(y)).filter((y) => y);
    i({ selected: f.map(({ id: y }) => ({ id: y, editable: p })) }), f.length !== d.length && console.warn("Invalid selection", c);
  }, l = (c) => {
    if (n.selected.length === 0)
      return !1;
    const { selected: p } = n;
    p.filter(({ id: d }) => c.includes(d)).length > 0 && i({ selected: p.filter(({ id: d }) => !c.includes(d)) });
  };
  return r.observe(({ changes: c }) => l(c.deleted.map((p) => p.id))), {
    clear: o,
    clickSelect: h,
    get selected() {
      return n ? [...n.selected] : null;
    },
    get pointerEvent() {
      return n ? n.pointerEvent : null;
    },
    isEmpty: s,
    isSelected: a,
    setSelected: u,
    subscribe: t
  };
}, El = (r, e) => typeof e == "function" ? e(r) || "EDIT" : e || "EDIT";
let yi;
const Al = new Uint8Array(16);
function Sl() {
  if (!yi && (yi = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !yi))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return yi(Al);
}
const Ct = [];
for (let r = 0; r < 256; ++r)
  Ct.push((r + 256).toString(16).slice(1));
function Rl(r, e = 0) {
  return Ct[r[e + 0]] + Ct[r[e + 1]] + Ct[r[e + 2]] + Ct[r[e + 3]] + "-" + Ct[r[e + 4]] + Ct[r[e + 5]] + "-" + Ct[r[e + 6]] + Ct[r[e + 7]] + "-" + Ct[r[e + 8]] + Ct[r[e + 9]] + "-" + Ct[r[e + 10]] + Ct[r[e + 11]] + Ct[r[e + 12]] + Ct[r[e + 13]] + Ct[r[e + 14]] + Ct[r[e + 15]];
}
const Ol = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Xs = {
  randomUUID: Ol
};
function wl(r, e, t) {
  if (Xs.randomUUID && !e && !r)
    return Xs.randomUUID();
  r = r || {};
  const i = r.random || (r.rng || Sl)();
  if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, e) {
    t = t || 0;
    for (let n = 0; n < 16; ++n)
      e[t + n] = i[n];
    return e;
  }
  return Rl(i);
}
const Il = (r, e) => {
  const t = new Set(r.bodies.map((i) => i.id));
  return e.bodies.filter((i) => !t.has(i.id));
}, Pl = (r, e) => {
  const t = new Set(e.bodies.map((i) => i.id));
  return r.bodies.filter((i) => !t.has(i.id));
}, Ml = (r, e) => e.bodies.map((t) => {
  const i = r.bodies.find((n) => n.id === t.id);
  return { newBody: t, oldBody: i && !We(i, t) ? i : void 0 };
}).filter(({ oldBody: t }) => t), Dl = (r, e) => !We(r.target, e.target), Cl = (r, e) => ({
  oldValue: r,
  newValue: e,
  bodiesCreated: Il(r, e),
  bodiesDeleted: Pl(r, e),
  bodiesUpdated: Ml(r, e),
  targetUpdated: Dl(r, e) ? { oldTarget: r.target, newTarget: e.target } : void 0
});
var Ot = /* @__PURE__ */ ((r) => (r.LOCAL = "LOCAL", r.REMOTE = "REMOTE", r))(Ot || {});
const Fl = (r, e) => {
  var t, i;
  const { changes: n, origin: o } = e;
  if (!(!r.options.origin || r.options.origin === o))
    return !1;
  if (r.options.ignore) {
    const { ignore: s } = r.options, a = (h) => (h == null ? void 0 : h.length) > 0;
    if (!(a(n.created) || a(n.deleted))) {
      const h = (t = n.updated) == null ? void 0 : t.some((l) => a(l.bodiesCreated) || a(l.bodiesDeleted) || a(l.bodiesUpdated)), u = (i = n.updated) == null ? void 0 : i.some((l) => l.targetUpdated);
      if (s === "BODY_ONLY" && h && !u || s === "TARGET_ONLY" && u && !h)
        return !1;
    }
  }
  if (r.options.annotations) {
    const s = /* @__PURE__ */ new Set([
      ...n.created.map((a) => a.id),
      ...n.deleted.map((a) => a.id),
      ...n.updated.map(({ oldValue: a }) => a.id)
    ]);
    return !!(Array.isArray(r.options.annotations) ? r.options.annotations : [r.options.annotations]).find((a) => s.has(a));
  } else
    return !0;
}, Nl = (r) => r.id !== void 0, Ll = () => {
  const r = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), t = [], i = (v, T = {}) => t.push({ onChange: v, options: T }), n = (v) => {
    const T = t.findIndex((S) => S.onChange == v);
    T > -1 && t.splice(T, 1);
  }, o = (v, T) => {
    const S = {
      origin: v,
      changes: {
        created: T.created || [],
        updated: T.updated || [],
        deleted: T.deleted || []
      },
      state: [...r.values()]
    };
    t.forEach((R) => {
      Fl(R, S) && R.onChange(S);
    });
  }, s = (v, T = Ot.LOCAL) => {
    if (r.get(v.id))
      throw Error(`Cannot add annotation ${v.id} - exists already`);
    r.set(v.id, v), v.bodies.forEach((S) => e.set(S.id, v.id)), o(T, { created: [v] });
  }, a = (v, T = Ot.LOCAL, S = Ot.LOCAL) => {
    const R = Nl(T) ? S : T, O = typeof v == "string" ? T : v, w = typeof v == "string" ? v : v.id, C = r.get(w);
    if (C) {
      const B = Cl(C, O);
      w === O.id ? r.set(w, O) : (r.delete(w), r.set(O.id, O)), C.bodies.forEach((V) => e.delete(V.id)), O.bodies.forEach((V) => e.set(V.id, O.id)), o(R, { updated: [B] });
    } else
      throw Error(`Cannot update annotation ${w} - does not exist`);
  }, h = (v, T = Ot.LOCAL) => {
    const S = r.get(v.annotation);
    if (S) {
      const R = {
        ...S,
        bodies: [...S.bodies, v]
      };
      r.set(S.id, R), e.set(v.id, R.id), o(T, { updated: [{
        oldValue: S,
        newValue: R,
        bodiesCreated: [v]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${v.annotation}`);
  }, u = () => [...r.values()], l = (v = Ot.LOCAL) => {
    const T = [...r.values()];
    r.clear(), e.clear(), o(v, { deleted: T });
  }, c = (v, T = !0, S = Ot.LOCAL) => {
    if (T) {
      const R = [...r.values()];
      r.clear(), e.clear(), v.forEach((O) => {
        r.set(O.id, O), O.bodies.forEach((w) => e.set(w.id, O.id));
      }), o(S, { created: v, deleted: R });
    } else {
      const R = v.reduce((O, w) => {
        const C = r.get(w.id);
        return C ? [...O, C] : O;
      }, []);
      if (R.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${R.map((O) => O.id).join(", ")}`);
      v.forEach((O) => {
        r.set(O.id, O), O.bodies.forEach((w) => e.set(w.id, O.id));
      }), o(S, { created: v });
    }
  }, p = (v) => {
    const T = typeof v == "string" ? v : v.id, S = r.get(T);
    if (S)
      return r.delete(T), S.bodies.forEach((R) => e.delete(R.id)), S;
    console.warn(`Attempt to delete missing annotation: ${T}`);
  }, d = (v, T = Ot.LOCAL) => {
    const S = p(v);
    S && o(T, { deleted: [S] });
  }, f = (v, T = Ot.LOCAL) => {
    const S = v.reduce((R, O) => {
      const w = p(O);
      return w ? [...R, w] : R;
    }, []);
    S.length > 0 && o(T, { deleted: S });
  }, y = (v, T = Ot.LOCAL) => {
    const S = r.get(v.annotation);
    if (S) {
      const R = S.bodies.find((O) => O.id === v.id);
      if (R) {
        e.delete(R.id);
        const O = {
          ...S,
          bodies: S.bodies.filter((w) => w.id !== v.id)
        };
        r.set(S.id, O), o(T, { updated: [{
          oldValue: S,
          newValue: O,
          bodiesDeleted: [R]
        }] });
      } else
        console.warn(`Attempt to delete missing body ${v.id} from annotation ${v.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${v.annotation}`);
  }, m = (v) => {
    const T = r.get(v);
    return T ? { ...T } : void 0;
  }, _ = (v) => {
    const T = e.get(v);
    if (T) {
      const S = m(T).bodies.find((R) => R.id === v);
      if (S)
        return S;
      console.error(`Store integrity error: body ${v} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${v}`);
  }, g = (v, T) => {
    if (v.annotation !== T.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const S = r.get(v.annotation);
    if (S) {
      const R = S.bodies.find((w) => w.id === v.id), O = {
        ...S,
        bodies: S.bodies.map((w) => w.id === R.id ? T : w)
      };
      return r.set(S.id, O), R.id !== T.id && (e.delete(R.id), e.set(T.id, O.id)), {
        oldValue: S,
        newValue: O,
        bodiesUpdated: [{ oldBody: R, newBody: T }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${v.annotation}`);
  }, b = (v, T, S = Ot.LOCAL) => {
    const R = g(v, T);
    o(S, { updated: [R] });
  }, x = (v, T = Ot.LOCAL) => {
    const S = v.map((R) => g({ id: R.id, annotation: R.annotation }, R));
    o(T, { updated: S });
  }, E = (v) => {
    const T = r.get(v.annotation);
    if (T) {
      const S = {
        ...T,
        target: {
          ...T.target,
          ...v
        }
      };
      return r.set(T.id, S), {
        oldValue: T,
        newValue: S,
        targetUpdated: {
          oldTarget: T.target,
          newTarget: v
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${v.annotation}`);
  };
  return {
    addAnnotation: s,
    addBody: h,
    all: u,
    bulkAddAnnotation: c,
    bulkDeleteAnnotation: f,
    bulkUpdateBodies: x,
    bulkUpdateTargets: (v, T = Ot.LOCAL) => {
      const S = v.map(E).filter((R) => R);
      S.length > 0 && o(T, { updated: S });
    },
    clear: l,
    deleteAnnotation: d,
    deleteBody: y,
    getAnnotation: m,
    getBody: _,
    observe: i,
    unobserve: n,
    updateAnnotation: a,
    updateBody: b,
    updateTarget: (v, T = Ot.LOCAL) => {
      const S = E(v);
      S && o(T, { updated: [S] });
    }
  };
}, Bl = () => {
  const { subscribe: r, set: e } = ys([]);
  return {
    subscribe: r,
    set: e
  };
}, Gl = (r, e, t, i, n, o) => {
  const s = /* @__PURE__ */ new Map();
  let a = [], h, u;
  const l = (f, y) => {
    s.has(f) ? s.get(f).push(y) : s.set(f, [y]);
  }, c = (f, y) => {
    const m = s.get(f);
    m && m.indexOf(y) > 0 && m.splice(m.indexOf(y), 1);
  }, p = (f, y, m) => {
    s.has(f) && setTimeout(() => {
      s.get(f).forEach((_) => {
        if (n) {
          const g = Array.isArray(y) ? y.map((x) => n.serialize(x)) : n.serialize(y), b = m ? m instanceof PointerEvent ? m : n.serialize(m) : void 0;
          _(g, b);
        } else
          _(y, m);
      });
    }, 1);
  }, d = () => {
    const { selected: f } = e, y = f.map(({ id: m }) => r.getAnnotation(m));
    y.forEach((m) => {
      const _ = a.find((g) => g.id === m.id);
      (!_ || !We(_, m)) && p("updateAnnotation", m, _);
    }), a = a.map((m) => y.find(({ id: g }) => g === m.id) || m);
  };
  return e.subscribe(({ selected: f }) => {
    if (!(a.length === 0 && f.length === 0)) {
      if (a.length === 0 && f.length > 0)
        a = f.map(({ id: y }) => r.getAnnotation(y));
      else if (a.length > 0 && f.length === 0)
        a.forEach((y) => {
          const m = r.getAnnotation(y.id);
          m && !We(m, y) && p("updateAnnotation", m, y);
        }), a = [];
      else {
        const y = new Set(a.map((_) => _.id)), m = new Set(f.map(({ id: _ }) => _));
        a.filter((_) => !m.has(_.id)).forEach((_) => {
          const g = r.getAnnotation(_.id);
          g && !We(g, _) && p("updateAnnotation", g, _);
        }), a = [
          // Remove annotations that were deselected
          ...a.filter((_) => m.has(_.id)),
          // Add editable annotations that were selected
          ...f.filter(({ id: _ }) => !y.has(_)).map(({ id: _ }) => r.getAnnotation(_))
        ];
      }
      p("selectionChanged", a);
    }
  }), t.subscribe((f) => {
    !h && f ? p("mouseEnterAnnotation", r.getAnnotation(f)) : h && !f ? p("mouseLeaveAnnotation", r.getAnnotation(h)) : h && f && (p("mouseLeaveAnnotation", r.getAnnotation(h)), p("mouseEnterAnnotation", r.getAnnotation(f))), h = f;
  }), i == null || i.subscribe((f) => p("viewportIntersect", f.map(r.getAnnotation))), r.observe((f) => {
    o && (u && clearTimeout(u), u = setTimeout(d, 1e3));
    const { created: y, deleted: m } = f.changes;
    y.forEach((_) => p("createAnnotation", _)), m.forEach((_) => p("deleteAnnotation", _)), f.changes.updated.filter((_) => [
      ..._.bodiesCreated || [],
      ..._.bodiesDeleted || [],
      ..._.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: _, newValue: g }) => {
      const b = a.find((x) => x.id === _.id) || _;
      a = a.map((x) => x.id === _.id ? g : x), p("updateAnnotation", g, b);
    });
  }, { origin: Ot.LOCAL }), r.observe((f) => {
    if (a) {
      const y = new Set(a.map((_) => _.id)), m = f.changes.updated.filter(({ newValue: _ }) => y.has(_.id)).map(({ newValue: _ }) => _);
      m.length > 0 && (a = a.map((_) => m.find((b) => b.id === _.id) || _));
    }
  }, { origin: Ot.REMOTE }), { on: l, off: c, emit: p };
}, Ul = (r) => (e) => e.reduce((t, i) => {
  const { parsed: n, error: o } = r.parse(i);
  return o ? {
    parsed: t.parsed,
    failed: [...t.failed, i]
  } : {
    parsed: [...t.parsed, n],
    failed: t.failed
  };
}, { parsed: [], failed: [] }), kl = (r, e) => {
  const t = (u) => {
    if (e) {
      const { parsed: l, error: c } = e.parse(u);
      l ? r.addAnnotation(l, Ot.REMOTE) : console.error(c);
    } else
      r.addAnnotation(u, Ot.REMOTE);
  }, i = () => r.clear(), n = (u) => {
    const l = r.getAnnotation(u);
    return e && l ? e.serialize(l) : l;
  }, o = () => e ? r.all().map(e.serialize) : r.all(), s = (u) => fetch(u).then((l) => l.json()).then((l) => (h(l), l)), a = (u) => {
    if (typeof u == "string") {
      const l = r.getAnnotation(u);
      return r.deleteAnnotation(u), e ? e.serialize(l) : l;
    } else {
      const l = e ? e.parse(u).parsed : u;
      return r.deleteAnnotation(l), u;
    }
  }, h = (u) => {
    if (e) {
      const { parsed: l, failed: c } = Ul(e)(u);
      c.length > 0 && console.warn(`Discarded ${c.length} invalid annotations`, c), r.bulkAddAnnotation(l, !0, Ot.REMOTE);
    } else
      r.bulkAddAnnotation(u, !0, Ot.REMOTE);
  };
  return {
    addAnnotation: t,
    clearAnnotations: i,
    getAnnotationById: n,
    getAnnotations: o,
    loadAnnotations: s,
    removeAnnotation: a,
    setAnnotations: h,
    updateAnnotation: (u) => {
      if (e) {
        const l = e.parse(u).parsed, c = e.serialize(r.getAnnotation(l.id));
        return r.updateAnnotation(l), c;
      } else {
        const l = r.getAnnotation(u.id);
        return r.updateAnnotation(u), l;
      }
    }
  };
};
let Xl = (r) => crypto.getRandomValues(new Uint8Array(r)), jl = (r, e, t) => {
  let i = (2 << Math.log(r.length - 1) / Math.LN2) - 1, n = -~(1.6 * i * e / r.length);
  return (o = e) => {
    let s = "";
    for (; ; ) {
      let a = t(n), h = n;
      for (; h--; )
        if (s += r[a[h] & i] || "", s.length === o)
          return s;
    }
  };
}, Hl = (r, e = 21) => jl(r, e, Xl), Yl = (r = 21) => crypto.getRandomValues(new Uint8Array(r)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
const Vl = () => ({ isGuest: !0, id: Hl("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() });
Yl();
var kt = /* @__PURE__ */ ((r) => (r.ELLIPSE = "ELLIPSE", r.POLYGON = "POLYGON", r.RECTANGLE = "RECTANGLE", r))(kt || {});
const ms = {}, _s = (r, e) => ms[r] = e, js = (r) => ms[r.type].area(r), zl = (r, e, t) => ms[r.type].intersects(r, e, t), bo = (r) => {
  let e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0;
  return r.forEach(([o, s]) => {
    e = Math.min(e, o), t = Math.min(t, s), i = Math.max(i, o), n = Math.max(n, s);
  }), { minX: e, minY: t, maxX: i, maxY: n };
}, Wl = {
  area: (r) => Math.PI * r.geometry.rx * r.geometry.ry,
  intersects: (r, e, t) => {
    const { cx: i, cy: n, rx: o, ry: s } = r.geometry, a = 0, h = Math.cos(a), u = Math.sin(a), l = e - i, c = t - n, p = h * l + u * c, d = u * l - h * c;
    return p * p / (o * o) + d * d / (s * s) <= 1;
  }
};
_s(kt.ELLIPSE, Wl);
const $l = {
  area: (r) => {
    const { points: e } = r.geometry;
    let t = 0, i = e.length - 1;
    for (let n = 0; n < e.length; n++)
      t += (e[i][0] + e[n][0]) * (e[i][1] - e[n][1]), i = n;
    return Math.abs(0.5 * t);
  },
  intersects: (r, e, t) => {
    const { points: i } = r.geometry;
    let n = !1;
    for (let o = 0, s = i.length - 1; o < i.length; s = o++) {
      const a = i[o][0], h = i[o][1], u = i[s][0], l = i[s][1];
      h > t != l > t && e < (u - a) * (t - h) / (l - h) + a && (n = !n);
    }
    return n;
  }
};
_s(kt.POLYGON, $l);
const ql = {
  area: (r) => r.geometry.w * r.geometry.h,
  intersects: (r, e, t) => e >= r.geometry.x && e <= r.geometry.x + r.geometry.w && t >= r.geometry.y && t <= r.geometry.y + r.geometry.h
};
_s(kt.RECTANGLE, ql);
function Hs(r, e, t) {
  const i = r.slice();
  return i[11] = e[t], i[13] = t, i;
}
function Ys(r) {
  let e, t, i, n, o;
  return {
    c() {
      e = st("rect"), A(e, "class", "a9s-corner-handle"), A(e, "x", t = /*point*/
      r[11][0] - /*handleSize*/
      r[3] / 2), A(e, "y", i = /*point*/
      r[11][1] - /*handleSize*/
      r[3] / 2), A(
        e,
        "height",
        /*handleSize*/
        r[3]
      ), A(
        e,
        "width",
        /*handleSize*/
        r[3]
      );
    },
    m(s, a) {
      Y(s, e, a), n || (o = Ut(e, "pointerdown", function() {
        Ft(
          /*grab*/
          r[10](j(
            /*idx*/
            r[13]
          ))
        ) && r[10](j(
          /*idx*/
          r[13]
        )).apply(this, arguments);
      }), n = !0);
    },
    p(s, a) {
      r = s, a & /*geom, handleSize*/
      24 && t !== (t = /*point*/
      r[11][0] - /*handleSize*/
      r[3] / 2) && A(e, "x", t), a & /*geom, handleSize*/
      24 && i !== (i = /*point*/
      r[11][1] - /*handleSize*/
      r[3] / 2) && A(e, "y", i), a & /*handleSize*/
      8 && A(
        e,
        "height",
        /*handleSize*/
        r[3]
      ), a & /*handleSize*/
      8 && A(
        e,
        "width",
        /*handleSize*/
        r[3]
      );
    },
    d(s) {
      s && H(e), n = !1, o();
    }
  };
}
function Kl(r) {
  let e, t, i, n, o, s, a, h, u, l, c = (
    /*geom*/
    r[4].points
  ), p = [];
  for (let d = 0; d < c.length; d += 1)
    p[d] = Ys(Hs(r, c, d));
  return {
    c() {
      e = st("polygon"), n = Zt(), o = st("polygon"), a = Zt();
      for (let d = 0; d < p.length; d += 1)
        p[d].c();
      h = Me(), A(e, "class", "a9s-outer"), A(e, "style", t = /*computedStyle*/
      r[1] ? "display:none;" : void 0), A(e, "points", i = /*geom*/
      r[4].points.map(Vs).join(" ")), A(o, "class", "a9s-inner a9s-shape-handle"), A(
        o,
        "style",
        /*computedStyle*/
        r[1]
      ), A(o, "points", s = /*geom*/
      r[4].points.map(zs).join(" "));
    },
    m(d, f) {
      Y(d, e, f), Y(d, n, f), Y(d, o, f), Y(d, a, f);
      for (let y = 0; y < p.length; y += 1)
        p[y] && p[y].m(d, f);
      Y(d, h, f), u || (l = [
        Ut(e, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.SHAPE)
          ) && r[10](j.SHAPE).apply(this, arguments);
        }),
        Ut(o, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.SHAPE)
          ) && r[10](j.SHAPE).apply(this, arguments);
        })
      ], u = !0);
    },
    p(d, f) {
      if (r = d, f & /*computedStyle*/
      2 && t !== (t = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && A(e, "style", t), f & /*geom*/
      16 && i !== (i = /*geom*/
      r[4].points.map(Vs).join(" ")) && A(e, "points", i), f & /*computedStyle*/
      2 && A(
        o,
        "style",
        /*computedStyle*/
        r[1]
      ), f & /*geom*/
      16 && s !== (s = /*geom*/
      r[4].points.map(zs).join(" ")) && A(o, "points", s), f & /*geom, handleSize, grab, Handle*/
      1048) {
        c = /*geom*/
        r[4].points;
        let y;
        for (y = 0; y < c.length; y += 1) {
          const m = Hs(r, c, y);
          p[y] ? p[y].p(m, f) : (p[y] = Ys(m), p[y].c(), p[y].m(h.parentNode, h));
        }
        for (; y < p.length; y += 1)
          p[y].d(1);
        p.length = c.length;
      }
    },
    d(d) {
      d && H(e), d && H(n), d && H(o), d && H(a), ps(p, d), d && H(h), u = !1, Pe(l);
    }
  };
}
function Zl(r) {
  let e, t;
  return e = new Wh({
    props: {
      shape: (
        /*shape*/
        r[0]
      ),
      transform: (
        /*transform*/
        r[2]
      ),
      editor: (
        /*editor*/
        r[5]
      ),
      $$slots: {
        default: [
          Kl,
          ({ grab: i }) => ({ 10: i }),
          ({ grab: i }) => i ? 1024 : 0
        ]
      },
      $$scope: { ctx: r }
    }
  }), e.$on(
    "change",
    /*change_handler*/
    r[7]
  ), e.$on(
    "grab",
    /*grab_handler*/
    r[8]
  ), e.$on(
    "release",
    /*release_handler*/
    r[9]
  ), {
    c() {
      zt(e.$$.fragment);
    },
    m(i, n) {
      Ht(e, i, n), t = !0;
    },
    p(i, [n]) {
      const o = {};
      n & /*shape*/
      1 && (o.shape = /*shape*/
      i[0]), n & /*transform*/
      4 && (o.transform = /*transform*/
      i[2]), n & /*$$scope, geom, handleSize, grab, computedStyle*/
      17434 && (o.$$scope = { dirty: n, ctx: i }), e.$set(o);
    },
    i(i) {
      t || (at(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ft(e.$$.fragment, i), t = !1;
    },
    d(i) {
      Yt(e, i);
    }
  };
}
const Vs = (r) => r.join(","), zs = (r) => r.join(",");
function Jl(r, e, t) {
  let i, n, { shape: o } = e, { computedStyle: s = void 0 } = e, { transform: a } = e, { viewportScale: h = 1 } = e;
  const u = (d, f, y) => {
    let m;
    f === j.SHAPE ? m = d.geometry.points.map(([g, b]) => [g + y[0], b + y[1]]) : m = d.geometry.points.map(([g, b], x) => f === j(x) ? [g + y[0], b + y[1]] : [g, b]);
    const _ = bo(m);
    return { ...d, geometry: { points: m, bounds: _ } };
  };
  function l(d) {
    vr.call(this, r, d);
  }
  function c(d) {
    vr.call(this, r, d);
  }
  function p(d) {
    vr.call(this, r, d);
  }
  return r.$$set = (d) => {
    "shape" in d && t(0, o = d.shape), "computedStyle" in d && t(1, s = d.computedStyle), "transform" in d && t(2, a = d.transform), "viewportScale" in d && t(6, h = d.viewportScale);
  }, r.$$.update = () => {
    r.$$.dirty & /*shape*/
    1 && t(4, i = o.geometry), r.$$.dirty & /*viewportScale*/
    64 && t(3, n = 10 / h);
  }, [
    o,
    s,
    a,
    n,
    i,
    u,
    h,
    l,
    c,
    p
  ];
}
class Ql extends $t {
  constructor(e) {
    super(), Wt(this, e, Jl, Zl, Vt, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 6
    });
  }
}
function tc(r) {
  let e, t, i, n, o, s, a, h, u, l, c, p, d, f, y, m, _, g, b, x, E, v, T, S, R, O, w, C, B, V, F, D, z, ot, K, M, I, X, Z, Q, mt, q, lt, vt, At, tt, nt, ht, pt, J;
  return {
    c() {
      e = st("rect"), a = Zt(), h = st("rect"), d = Zt(), f = st("rect"), g = Zt(), b = st("rect"), T = Zt(), S = st("rect"), C = Zt(), B = st("rect"), z = Zt(), ot = st("rect"), I = Zt(), X = st("rect"), mt = Zt(), q = st("rect"), At = Zt(), tt = st("rect"), A(e, "class", "a9s-outer"), A(e, "style", t = /*computedStyle*/
      r[1] ? "display:none;" : void 0), A(e, "x", i = /*geom*/
      r[4].x), A(e, "y", n = /*geom*/
      r[4].y), A(e, "width", o = /*geom*/
      r[4].w), A(e, "height", s = /*geom*/
      r[4].h), A(h, "class", "a9s-inner a9s-shape-handle"), A(
        h,
        "style",
        /*computedStyle*/
        r[1]
      ), A(h, "x", u = /*geom*/
      r[4].x), A(h, "y", l = /*geom*/
      r[4].y), A(h, "width", c = /*geom*/
      r[4].w), A(h, "height", p = /*geom*/
      r[4].h), A(f, "class", "a9s-edge-handle a9s-edge-handle-top"), A(f, "x", y = /*geom*/
      r[4].x), A(f, "y", m = /*geom*/
      r[4].y), A(f, "height", 1), A(f, "width", _ = /*geom*/
      r[4].w), A(b, "class", "a9s-edge-handle a9s-edge-handle-right"), A(b, "x", x = /*geom*/
      r[4].x + /*geom*/
      r[4].w), A(b, "y", E = /*geom*/
      r[4].y), A(b, "height", v = /*geom*/
      r[4].h), A(b, "width", 1), A(S, "class", "a9s-edge-handle a9s-edge-handle-bottom"), A(S, "x", R = /*geom*/
      r[4].x), A(S, "y", O = /*geom*/
      r[4].y + /*geom*/
      r[4].h), A(S, "height", 1), A(S, "width", w = /*geom*/
      r[4].w), A(B, "class", "a9s-edge-handle a9s-edge-handle-left"), A(B, "x", V = /*geom*/
      r[4].x), A(B, "y", F = /*geom*/
      r[4].y), A(B, "height", D = /*geom*/
      r[4].h), A(B, "width", 1), A(ot, "class", "a9s-corner-handle a9s-corner-handle-topleft"), A(ot, "x", K = /*geom*/
      r[4].x - /*handleSize*/
      r[3] / 2), A(ot, "y", M = /*geom*/
      r[4].y - /*handleSize*/
      r[3] / 2), A(
        ot,
        "height",
        /*handleSize*/
        r[3]
      ), A(
        ot,
        "width",
        /*handleSize*/
        r[3]
      ), A(X, "class", "a9s-corner-handle a9s-corner-handle-topright"), A(X, "x", Z = /*geom*/
      r[4].x + /*geom*/
      r[4].w - /*handleSize*/
      r[3] / 2), A(X, "y", Q = /*geom*/
      r[4].y - /*handleSize*/
      r[3] / 2), A(
        X,
        "height",
        /*handleSize*/
        r[3]
      ), A(
        X,
        "width",
        /*handleSize*/
        r[3]
      ), A(q, "class", "a9s-corner-handle a9s-corner-handle-bottomright"), A(q, "x", lt = /*geom*/
      r[4].x + /*geom*/
      r[4].w - /*handleSize*/
      r[3] / 2), A(q, "y", vt = /*geom*/
      r[4].y + /*geom*/
      r[4].h - /*handleSize*/
      r[3] / 2), A(
        q,
        "height",
        /*handleSize*/
        r[3]
      ), A(
        q,
        "width",
        /*handleSize*/
        r[3]
      ), A(tt, "class", "a9s-corner-handle a9s-corner-handle-bottomleft"), A(tt, "x", nt = /*geom*/
      r[4].x - /*handleSize*/
      r[3] / 2), A(tt, "y", ht = /*geom*/
      r[4].y + /*geom*/
      r[4].h - /*handleSize*/
      r[3] / 2), A(
        tt,
        "height",
        /*handleSize*/
        r[3]
      ), A(
        tt,
        "width",
        /*handleSize*/
        r[3]
      );
    },
    m(G, N) {
      Y(G, e, N), Y(G, a, N), Y(G, h, N), Y(G, d, N), Y(G, f, N), Y(G, g, N), Y(G, b, N), Y(G, T, N), Y(G, S, N), Y(G, C, N), Y(G, B, N), Y(G, z, N), Y(G, ot, N), Y(G, I, N), Y(G, X, N), Y(G, mt, N), Y(G, q, N), Y(G, At, N), Y(G, tt, N), pt || (J = [
        Ut(e, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.SHAPE)
          ) && r[10](j.SHAPE).apply(this, arguments);
        }),
        Ut(h, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.SHAPE)
          ) && r[10](j.SHAPE).apply(this, arguments);
        }),
        Ut(f, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.TOP)
          ) && r[10](j.TOP).apply(this, arguments);
        }),
        Ut(b, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.RIGHT)
          ) && r[10](j.RIGHT).apply(this, arguments);
        }),
        Ut(S, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.BOTTOM)
          ) && r[10](j.BOTTOM).apply(this, arguments);
        }),
        Ut(B, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.LEFT)
          ) && r[10](j.LEFT).apply(this, arguments);
        }),
        Ut(ot, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.TOP_LEFT)
          ) && r[10](j.TOP_LEFT).apply(this, arguments);
        }),
        Ut(X, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.TOP_RIGHT)
          ) && r[10](j.TOP_RIGHT).apply(this, arguments);
        }),
        Ut(q, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.BOTTOM_RIGHT)
          ) && r[10](j.BOTTOM_RIGHT).apply(this, arguments);
        }),
        Ut(tt, "pointerdown", function() {
          Ft(
            /*grab*/
            r[10](j.BOTTOM_LEFT)
          ) && r[10](j.BOTTOM_LEFT).apply(this, arguments);
        })
      ], pt = !0);
    },
    p(G, N) {
      r = G, N & /*computedStyle*/
      2 && t !== (t = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && A(e, "style", t), N & /*geom*/
      16 && i !== (i = /*geom*/
      r[4].x) && A(e, "x", i), N & /*geom*/
      16 && n !== (n = /*geom*/
      r[4].y) && A(e, "y", n), N & /*geom*/
      16 && o !== (o = /*geom*/
      r[4].w) && A(e, "width", o), N & /*geom*/
      16 && s !== (s = /*geom*/
      r[4].h) && A(e, "height", s), N & /*computedStyle*/
      2 && A(
        h,
        "style",
        /*computedStyle*/
        r[1]
      ), N & /*geom*/
      16 && u !== (u = /*geom*/
      r[4].x) && A(h, "x", u), N & /*geom*/
      16 && l !== (l = /*geom*/
      r[4].y) && A(h, "y", l), N & /*geom*/
      16 && c !== (c = /*geom*/
      r[4].w) && A(h, "width", c), N & /*geom*/
      16 && p !== (p = /*geom*/
      r[4].h) && A(h, "height", p), N & /*geom*/
      16 && y !== (y = /*geom*/
      r[4].x) && A(f, "x", y), N & /*geom*/
      16 && m !== (m = /*geom*/
      r[4].y) && A(f, "y", m), N & /*geom*/
      16 && _ !== (_ = /*geom*/
      r[4].w) && A(f, "width", _), N & /*geom*/
      16 && x !== (x = /*geom*/
      r[4].x + /*geom*/
      r[4].w) && A(b, "x", x), N & /*geom*/
      16 && E !== (E = /*geom*/
      r[4].y) && A(b, "y", E), N & /*geom*/
      16 && v !== (v = /*geom*/
      r[4].h) && A(b, "height", v), N & /*geom*/
      16 && R !== (R = /*geom*/
      r[4].x) && A(S, "x", R), N & /*geom*/
      16 && O !== (O = /*geom*/
      r[4].y + /*geom*/
      r[4].h) && A(S, "y", O), N & /*geom*/
      16 && w !== (w = /*geom*/
      r[4].w) && A(S, "width", w), N & /*geom*/
      16 && V !== (V = /*geom*/
      r[4].x) && A(B, "x", V), N & /*geom*/
      16 && F !== (F = /*geom*/
      r[4].y) && A(B, "y", F), N & /*geom*/
      16 && D !== (D = /*geom*/
      r[4].h) && A(B, "height", D), N & /*geom, handleSize*/
      24 && K !== (K = /*geom*/
      r[4].x - /*handleSize*/
      r[3] / 2) && A(ot, "x", K), N & /*geom, handleSize*/
      24 && M !== (M = /*geom*/
      r[4].y - /*handleSize*/
      r[3] / 2) && A(ot, "y", M), N & /*handleSize*/
      8 && A(
        ot,
        "height",
        /*handleSize*/
        r[3]
      ), N & /*handleSize*/
      8 && A(
        ot,
        "width",
        /*handleSize*/
        r[3]
      ), N & /*geom, handleSize*/
      24 && Z !== (Z = /*geom*/
      r[4].x + /*geom*/
      r[4].w - /*handleSize*/
      r[3] / 2) && A(X, "x", Z), N & /*geom, handleSize*/
      24 && Q !== (Q = /*geom*/
      r[4].y - /*handleSize*/
      r[3] / 2) && A(X, "y", Q), N & /*handleSize*/
      8 && A(
        X,
        "height",
        /*handleSize*/
        r[3]
      ), N & /*handleSize*/
      8 && A(
        X,
        "width",
        /*handleSize*/
        r[3]
      ), N & /*geom, handleSize*/
      24 && lt !== (lt = /*geom*/
      r[4].x + /*geom*/
      r[4].w - /*handleSize*/
      r[3] / 2) && A(q, "x", lt), N & /*geom, handleSize*/
      24 && vt !== (vt = /*geom*/
      r[4].y + /*geom*/
      r[4].h - /*handleSize*/
      r[3] / 2) && A(q, "y", vt), N & /*handleSize*/
      8 && A(
        q,
        "height",
        /*handleSize*/
        r[3]
      ), N & /*handleSize*/
      8 && A(
        q,
        "width",
        /*handleSize*/
        r[3]
      ), N & /*geom, handleSize*/
      24 && nt !== (nt = /*geom*/
      r[4].x - /*handleSize*/
      r[3] / 2) && A(tt, "x", nt), N & /*geom, handleSize*/
      24 && ht !== (ht = /*geom*/
      r[4].y + /*geom*/
      r[4].h - /*handleSize*/
      r[3] / 2) && A(tt, "y", ht), N & /*handleSize*/
      8 && A(
        tt,
        "height",
        /*handleSize*/
        r[3]
      ), N & /*handleSize*/
      8 && A(
        tt,
        "width",
        /*handleSize*/
        r[3]
      );
    },
    d(G) {
      G && H(e), G && H(a), G && H(h), G && H(d), G && H(f), G && H(g), G && H(b), G && H(T), G && H(S), G && H(C), G && H(B), G && H(z), G && H(ot), G && H(I), G && H(X), G && H(mt), G && H(q), G && H(At), G && H(tt), pt = !1, Pe(J);
    }
  };
}
function ec(r) {
  let e, t;
  return e = new Wh({
    props: {
      shape: (
        /*shape*/
        r[0]
      ),
      transform: (
        /*transform*/
        r[2]
      ),
      editor: (
        /*editor*/
        r[5]
      ),
      $$slots: {
        default: [
          tc,
          ({ grab: i }) => ({ 10: i }),
          ({ grab: i }) => i ? 1024 : 0
        ]
      },
      $$scope: { ctx: r }
    }
  }), e.$on(
    "grab",
    /*grab_handler*/
    r[7]
  ), e.$on(
    "change",
    /*change_handler*/
    r[8]
  ), e.$on(
    "release",
    /*release_handler*/
    r[9]
  ), {
    c() {
      zt(e.$$.fragment);
    },
    m(i, n) {
      Ht(e, i, n), t = !0;
    },
    p(i, [n]) {
      const o = {};
      n & /*shape*/
      1 && (o.shape = /*shape*/
      i[0]), n & /*transform*/
      4 && (o.transform = /*transform*/
      i[2]), n & /*$$scope, geom, handleSize, grab, computedStyle*/
      3098 && (o.$$scope = { dirty: n, ctx: i }), e.$set(o);
    },
    i(i) {
      t || (at(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ft(e.$$.fragment, i), t = !1;
    },
    d(i) {
      Yt(e, i);
    }
  };
}
function rc(r, e, t) {
  let i, n, { shape: o } = e, { computedStyle: s = void 0 } = e, { transform: a } = e, { viewportScale: h = 1 } = e;
  const u = (d, f, y) => {
    const m = d.geometry.bounds;
    let [_, g] = [m.minX, m.minY], [b, x] = [m.maxX, m.maxY];
    const [E, v] = y;
    if (f === j.SHAPE)
      _ += E, b += E, g += v, x += v;
    else {
      switch (f) {
        case j.TOP:
        case j.TOP_LEFT:
        case j.TOP_RIGHT: {
          g += v;
          break;
        }
        case j.BOTTOM:
        case j.BOTTOM_LEFT:
        case j.BOTTOM_RIGHT: {
          x += v;
          break;
        }
      }
      switch (f) {
        case j.LEFT:
        case j.TOP_LEFT:
        case j.BOTTOM_LEFT: {
          _ += E;
          break;
        }
        case j.RIGHT:
        case j.TOP_RIGHT:
        case j.BOTTOM_RIGHT: {
          b += E;
          break;
        }
      }
    }
    const T = Math.min(_, b), S = Math.min(g, x), R = Math.abs(b - _), O = Math.abs(x - g);
    return {
      ...d,
      geometry: {
        x: T,
        y: S,
        w: R,
        h: O,
        bounds: {
          minX: T,
          minY: S,
          maxX: T + R,
          maxY: S + O
        }
      }
    };
  };
  function l(d) {
    vr.call(this, r, d);
  }
  function c(d) {
    vr.call(this, r, d);
  }
  function p(d) {
    vr.call(this, r, d);
  }
  return r.$$set = (d) => {
    "shape" in d && t(0, o = d.shape), "computedStyle" in d && t(1, s = d.computedStyle), "transform" in d && t(2, a = d.transform), "viewportScale" in d && t(6, h = d.viewportScale);
  }, r.$$.update = () => {
    r.$$.dirty & /*shape*/
    1 && t(4, i = o.geometry), r.$$.dirty & /*viewportScale*/
    64 && t(3, n = 10 / h);
  }, [
    o,
    s,
    a,
    n,
    i,
    u,
    h,
    l,
    c,
    p
  ];
}
class ic extends $t {
  constructor(e) {
    super(), Wt(this, e, rc, ec, Vt, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 6
    });
  }
}
const nc = /* @__PURE__ */ new Map([
  [kt.RECTANGLE, ic],
  [kt.POLYGON, Ql]
]), Ws = (r) => nc.get(r.type), j = (r) => `HANDLE-${r}`;
j.SHAPE = "SHAPE";
j.TOP = "TOP";
j.RIGHT = "RIGHT";
j.BOTTOM = "BOTTOM";
j.LEFT = "LEFT";
j.TOP_LEFT = "TOP_LEFT";
j.TOP_RIGHT = "TOP_RIGHT";
j.BOTTOM_RIGHT = "BOTTOM_RIGHT";
j.BOTTOM_LEFT = "BOTTOM_LEFT";
const oc = (r) => ({}), $s = (r) => ({ grab: (
  /*onGrab*/
  r[0]
) });
function sc(r) {
  let e, t, i, n;
  const o = (
    /*#slots*/
    r[7].default
  ), s = Uh(
    o,
    r,
    /*$$scope*/
    r[6],
    $s
  );
  return {
    c() {
      e = st("g"), s && s.c(), A(e, "class", "a9s-annotation selected");
    },
    m(a, h) {
      Y(a, e, h), s && s.m(e, null), t = !0, i || (n = [
        Ut(
          e,
          "pointerup",
          /*onRelease*/
          r[2]
        ),
        Ut(
          e,
          "pointermove",
          /*onPointerMove*/
          r[1]
        )
      ], i = !0);
    },
    p(a, [h]) {
      s && s.p && (!t || h & /*$$scope*/
      64) && jh(
        s,
        o,
        a,
        /*$$scope*/
        a[6],
        t ? Xh(
          o,
          /*$$scope*/
          a[6],
          h,
          oc
        ) : Hh(
          /*$$scope*/
          a[6]
        ),
        $s
      );
    },
    i(a) {
      t || (at(s, a), t = !0);
    },
    o(a) {
      ft(s, a), t = !1;
    },
    d(a) {
      a && H(e), s && s.d(a), i = !1, Pe(n);
    }
  };
}
function ac(r, e, t) {
  let { $$slots: i = {}, $$scope: n } = e;
  const o = _n();
  let { shape: s } = e, { editor: a } = e, { transform: h } = e, u = null, l, c = null;
  const p = (y) => (m) => {
    u = y, l = h.elementToImage(m.offsetX, m.offsetY), c = s, m.target.setPointerCapture(m.pointerId), o("grab");
  }, d = (y) => {
    if (u) {
      const [m, _] = h.elementToImage(y.offsetX, y.offsetY), g = [m - l[0], _ - l[1]];
      t(3, s = a(c, u, g)), o("change", s);
    }
  }, f = (y) => {
    y.target.releasePointerCapture(y.pointerId), u = null, c = s, o("release");
  };
  return r.$$set = (y) => {
    "shape" in y && t(3, s = y.shape), "editor" in y && t(4, a = y.editor), "transform" in y && t(5, h = y.transform), "$$scope" in y && t(6, n = y.$$scope);
  }, [p, d, f, s, a, h, n, i];
}
class Wh extends $t {
  constructor(e) {
    super(), Wt(this, e, ac, sc, Vt, { shape: 3, editor: 4, transform: 5 });
  }
}
function qs(r) {
  let e, t;
  return {
    c() {
      e = st("rect"), t = st("rect"), A(e, "class", "a9s-outer"), A(
        e,
        "x",
        /*x*/
        r[2]
      ), A(
        e,
        "y",
        /*y*/
        r[3]
      ), A(
        e,
        "width",
        /*w*/
        r[4]
      ), A(
        e,
        "height",
        /*h*/
        r[5]
      ), A(t, "class", "a9s-inner"), A(
        t,
        "x",
        /*x*/
        r[2]
      ), A(
        t,
        "y",
        /*y*/
        r[3]
      ), A(
        t,
        "width",
        /*w*/
        r[4]
      ), A(
        t,
        "height",
        /*h*/
        r[5]
      );
    },
    m(i, n) {
      Y(i, e, n), Y(i, t, n);
    },
    p(i, n) {
      n & /*x*/
      4 && A(
        e,
        "x",
        /*x*/
        i[2]
      ), n & /*y*/
      8 && A(
        e,
        "y",
        /*y*/
        i[3]
      ), n & /*w*/
      16 && A(
        e,
        "width",
        /*w*/
        i[4]
      ), n & /*h*/
      32 && A(
        e,
        "height",
        /*h*/
        i[5]
      ), n & /*x*/
      4 && A(
        t,
        "x",
        /*x*/
        i[2]
      ), n & /*y*/
      8 && A(
        t,
        "y",
        /*y*/
        i[3]
      ), n & /*w*/
      16 && A(
        t,
        "width",
        /*w*/
        i[4]
      ), n & /*h*/
      32 && A(
        t,
        "height",
        /*h*/
        i[5]
      );
    },
    d(i) {
      i && H(e), i && H(t);
    }
  };
}
function hc(r) {
  let e, t = (
    /*origin*/
    r[1] && qs(r)
  );
  return {
    c() {
      e = st("g"), t && t.c(), A(e, "class", "a9s-annotation a9s-rubberband");
    },
    m(i, n) {
      Y(i, e, n), t && t.m(e, null), r[7](e);
    },
    p(i, [n]) {
      i[1] ? t ? t.p(i, n) : (t = qs(i), t.c(), t.m(e, null)) : t && (t.d(1), t = null);
    },
    i: jt,
    o: jt,
    d(i) {
      i && H(e), t && t.d(), r[7](null);
    }
  };
}
function uc(r, e, t) {
  const i = _n();
  let { transform: n } = e, o, s, a, h, u, l, c;
  const p = (m) => {
    t(1, s = n.elementToImage(m.offsetX, m.offsetY)), a = s, t(2, h = s[0]), t(3, u = s[1]), t(4, l = 1), t(5, c = 1);
  }, d = (m) => {
    s && (a = n.elementToImage(m.offsetX, m.offsetY), t(2, h = Math.min(a[0], s[0])), t(3, u = Math.min(a[1], s[1])), t(4, l = Math.abs(a[0] - s[0])), t(5, c = Math.abs(a[1] - s[1])));
  }, f = () => {
    if (l * c > 15) {
      const m = {
        type: kt.RECTANGLE,
        geometry: {
          bounds: {
            minX: h,
            minY: u,
            maxX: h + l,
            maxY: u + c
          },
          x: h,
          y: u,
          w: l,
          h: c
        }
      };
      i("create", m);
    }
    t(1, s = null), a = null;
  };
  mn(() => {
    const m = o.closest("svg");
    return m.addEventListener("pointerdown", p), m.addEventListener("pointermove", d), m.addEventListener("pointerup", f), () => {
      m.removeEventListener("pointerdown", p), m.removeEventListener("pointermove", d), m.removeEventListener("pointerup", f);
    };
  });
  function y(m) {
    Zr[m ? "unshift" : "push"](() => {
      o = m, t(0, o);
    });
  }
  return r.$$set = (m) => {
    "transform" in m && t(6, n = m.transform);
  }, [o, s, h, u, l, c, n, y];
}
class lc extends $t {
  constructor(e) {
    super(), Wt(this, e, uc, hc, Vt, { transform: 6 });
  }
}
const Ks = (r, e) => {
  const t = Math.abs(e[0] - r[0]), i = Math.abs(e[1] - r[1]);
  return Math.sqrt(Math.pow(t, 2) + Math.pow(i, 2));
};
function Sn(r) {
  const e = r.slice(), t = (
    /*isClosable*/
    (e[3] ? (
      /*points*/
      e[1]
    ) : [
      .../*points*/
      e[1],
      /*cursor*/
      e[2]
    ]).map((i) => i.join(",")).join(" ")
  );
  return e[13] = t, e;
}
function Zs(r) {
  let e, t, i, n, o, s = (
    /*isClosable*/
    r[3] && Js(r)
  );
  return {
    c() {
      e = st("polygon"), i = st("polygon"), s && s.c(), o = Me(), A(e, "class", "a9s-outer"), A(e, "points", t = /*coords*/
      r[13]), A(i, "class", "a9s-inner"), A(i, "points", n = /*coords*/
      r[13]);
    },
    m(a, h) {
      Y(a, e, h), Y(a, i, h), s && s.m(a, h), Y(a, o, h);
    },
    p(a, h) {
      h & /*isClosable, points, cursor*/
      14 && t !== (t = /*coords*/
      a[13]) && A(e, "points", t), h & /*isClosable, points, cursor*/
      14 && n !== (n = /*coords*/
      a[13]) && A(i, "points", n), /*isClosable*/
      a[3] ? s ? s.p(a, h) : (s = Js(a), s.c(), s.m(o.parentNode, o)) : s && (s.d(1), s = null);
    },
    d(a) {
      a && H(e), a && H(i), s && s.d(a), a && H(o);
    }
  };
}
function Js(r) {
  let e, t, i;
  return {
    c() {
      e = st("rect"), A(e, "class", "a9s-corner-handle"), A(e, "x", t = /*points*/
      r[1][0][0] - /*handleSize*/
      r[4] / 2), A(e, "y", i = /*points*/
      r[1][0][1] - /*handleSize*/
      r[4] / 2), A(
        e,
        "height",
        /*handleSize*/
        r[4]
      ), A(
        e,
        "width",
        /*handleSize*/
        r[4]
      );
    },
    m(n, o) {
      Y(n, e, o);
    },
    p(n, o) {
      o & /*points, handleSize*/
      18 && t !== (t = /*points*/
      n[1][0][0] - /*handleSize*/
      n[4] / 2) && A(e, "x", t), o & /*points, handleSize*/
      18 && i !== (i = /*points*/
      n[1][0][1] - /*handleSize*/
      n[4] / 2) && A(e, "y", i), o & /*handleSize*/
      16 && A(
        e,
        "height",
        /*handleSize*/
        n[4]
      ), o & /*handleSize*/
      16 && A(
        e,
        "width",
        /*handleSize*/
        n[4]
      );
    },
    d(n) {
      n && H(e);
    }
  };
}
function cc(r) {
  let e, t = (
    /*cursor*/
    r[2] && Zs(Sn(r))
  );
  return {
    c() {
      e = st("g"), t && t.c(), A(e, "class", "a9s-annotation a9s-rubberband");
    },
    m(i, n) {
      Y(i, e, n), t && t.m(e, null), r[7](e);
    },
    p(i, [n]) {
      i[2] ? t ? t.p(Sn(i), n) : (t = Zs(Sn(i)), t.c(), t.m(e, null)) : t && (t.d(1), t = null);
    },
    i: jt,
    o: jt,
    d(i) {
      i && H(e), t && t.d(), r[7](null);
    }
  };
}
const pc = 20;
function dc(r, e, t) {
  let i;
  const n = _n();
  let { transform: o } = e, { viewportScale: s = 1 } = e, a, h = [], u = null, l = !1;
  const c = (m) => {
    const _ = o.elementToImage(m.offsetX, m.offsetY);
    h.length === 0 && h.push(_), t(2, u = _);
  }, p = (m) => {
    if (h.length > 0 && (t(2, u = o.elementToImage(m.offsetX, m.offsetY)), h.length > 2)) {
      const _ = Ks(u, h[0]) * s;
      t(3, l = _ < pc);
    }
  }, d = (m) => {
    if (h.length === 1 && Ks(h[0], u) <= 4) {
      t(1, h = []), t(2, u = null);
      return;
    }
    if (m.stopImmediatePropagation(), l) {
      const _ = {
        type: kt.POLYGON,
        geometry: {
          bounds: bo(h),
          points: [...h]
        }
      };
      t(1, h = []), t(2, u = null), n("create", _);
    } else
      h.push(u);
  }, f = () => {
    const m = [...h, u], _ = {
      type: kt.POLYGON,
      geometry: { bounds: bo(m), points: m }
    };
    t(1, h = []), t(2, u = null), n("create", _);
  };
  mn(() => {
    const m = a.closest("svg");
    return m.addEventListener("pointerdown", c, !0), m.addEventListener("pointermove", p), m.addEventListener("pointerup", d, !0), m.addEventListener("dblclick", f, !0), () => {
      m.removeEventListener("pointerdown", c, !0), m.removeEventListener("pointermove", p, !0), m.removeEventListener("pointerup", d, !0), m.removeEventListener("dblclick", f, !0);
    };
  });
  function y(m) {
    Zr[m ? "unshift" : "push"](() => {
      a = m, t(0, a);
    });
  }
  return r.$$set = (m) => {
    "transform" in m && t(5, o = m.transform), "viewportScale" in m && t(6, s = m.viewportScale);
  }, r.$$.update = () => {
    r.$$.dirty & /*viewportScale*/
    64 && t(4, i = 10 / s);
  }, [
    a,
    h,
    u,
    l,
    i,
    o,
    s,
    y
  ];
}
class fc extends $t {
  constructor(e) {
    super(), Wt(this, e, dc, cc, Vt, { transform: 5, viewportScale: 6 });
  }
}
const $h = /* @__PURE__ */ new Map([
  ["rectangle", lc],
  ["polygon", fc]
]), yc = () => [...$h.keys()], mc = (r) => $h.get(r);
function _c(r, e, t, i, n) {
  qh(r, e, t || 0, i || r.length - 1, n || gc);
}
function qh(r, e, t, i, n) {
  for (; i > t; ) {
    if (i - t > 600) {
      var o = i - t + 1, s = e - t + 1, a = Math.log(o), h = 0.5 * Math.exp(2 * a / 3), u = 0.5 * Math.sqrt(a * h * (o - h) / o) * (s - o / 2 < 0 ? -1 : 1), l = Math.max(t, Math.floor(e - s * h / o + u)), c = Math.min(i, Math.floor(e + (o - s) * h / o + u));
      qh(r, e, l, c, n);
    }
    var p = r[e], d = t, f = i;
    for (Fr(r, t, e), n(r[i], p) > 0 && Fr(r, t, i); d < f; ) {
      for (Fr(r, d, f), d++, f--; n(r[d], p) < 0; )
        d++;
      for (; n(r[f], p) > 0; )
        f--;
    }
    n(r[t], p) === 0 ? Fr(r, t, f) : (f++, Fr(r, f, i)), f <= e && (t = f + 1), e <= f && (i = f - 1);
  }
}
function Fr(r, e, t) {
  var i = r[e];
  r[e] = r[t], r[t] = i;
}
function gc(r, e) {
  return r < e ? -1 : r > e ? 1 : 0;
}
class vc {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const i = [];
    if (!_i(e, t))
      return i;
    const n = this.toBBox, o = [];
    for (; t; ) {
      for (let s = 0; s < t.children.length; s++) {
        const a = t.children[s], h = t.leaf ? n(a) : a;
        _i(e, h) && (t.leaf ? i.push(a) : On(e, h) ? this._all(a, i) : o.push(a));
      }
      t = o.pop();
    }
    return i;
  }
  collides(e) {
    let t = this.data;
    if (!_i(e, t))
      return !1;
    const i = [];
    for (; t; ) {
      for (let n = 0; n < t.children.length; n++) {
        const o = t.children[n], s = t.leaf ? this.toBBox(o) : o;
        if (_i(e, s)) {
          if (t.leaf || On(e, s))
            return !0;
          i.push(o);
        }
      }
      t = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length))
      return this;
    if (e.length < this._minEntries) {
      for (let i = 0; i < e.length; i++)
        this.insert(e[i]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = t;
    else if (this.data.height === t.height)
      this._splitRoot(this.data, t);
    else {
      if (this.data.height < t.height) {
        const i = this.data;
        this.data = t, t = i;
      }
      this._insert(t, this.data.height - t.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = dr([]), this;
  }
  remove(e, t) {
    if (!e)
      return this;
    let i = this.data;
    const n = this.toBBox(e), o = [], s = [];
    let a, h, u;
    for (; i || o.length; ) {
      if (i || (i = o.pop(), h = o[o.length - 1], a = s.pop(), u = !0), i.leaf) {
        const l = bc(e, i.children, t);
        if (l !== -1)
          return i.children.splice(l, 1), o.push(i), this._condense(o), this;
      }
      !u && !i.leaf && On(i, n) ? (o.push(i), s.push(a), a = 0, h = i, i = i.children[0]) : h ? (a++, i = h.children[a], u = !1) : i = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, t) {
    const i = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : i.push(...e.children), e = i.pop();
    return t;
  }
  _build(e, t, i, n) {
    const o = i - t + 1;
    let s = this._maxEntries, a;
    if (o <= s)
      return a = dr(e.slice(t, i + 1)), ar(a, this.toBBox), a;
    n || (n = Math.ceil(Math.log(o) / Math.log(s)), s = Math.ceil(o / Math.pow(s, n - 1))), a = dr([]), a.leaf = !1, a.height = n;
    const h = Math.ceil(o / s), u = h * Math.ceil(Math.sqrt(s));
    Qs(e, t, i, u, this.compareMinX);
    for (let l = t; l <= i; l += u) {
      const c = Math.min(l + u - 1, i);
      Qs(e, l, c, h, this.compareMinY);
      for (let p = l; p <= c; p += h) {
        const d = Math.min(p + h - 1, c);
        a.children.push(this._build(e, p, d, n - 1));
      }
    }
    return ar(a, this.toBBox), a;
  }
  _chooseSubtree(e, t, i, n) {
    for (; n.push(t), !(t.leaf || n.length - 1 === i); ) {
      let o = 1 / 0, s = 1 / 0, a;
      for (let h = 0; h < t.children.length; h++) {
        const u = t.children[h], l = Rn(u), c = Ec(e, u) - l;
        c < s ? (s = c, o = l < o ? l : o, a = u) : c === s && l < o && (o = l, a = u);
      }
      t = a || t.children[0];
    }
    return t;
  }
  _insert(e, t, i) {
    const n = i ? e : this.toBBox(e), o = [], s = this._chooseSubtree(n, this.data, t, o);
    for (s.children.push(e), Yr(s, n); t >= 0 && o[t].children.length > this._maxEntries; )
      this._split(o, t), t--;
    this._adjustParentBBoxes(n, o, t);
  }
  // split overflowed node into two
  _split(e, t) {
    const i = e[t], n = i.children.length, o = this._minEntries;
    this._chooseSplitAxis(i, o, n);
    const s = this._chooseSplitIndex(i, o, n), a = dr(i.children.splice(s, i.children.length - s));
    a.height = i.height, a.leaf = i.leaf, ar(i, this.toBBox), ar(a, this.toBBox), t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(e, t) {
    this.data = dr([e, t]), this.data.height = e.height + 1, this.data.leaf = !1, ar(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, i) {
    let n, o = 1 / 0, s = 1 / 0;
    for (let a = t; a <= i - t; a++) {
      const h = Hr(e, 0, a, this.toBBox), u = Hr(e, a, i, this.toBBox), l = Ac(h, u), c = Rn(h) + Rn(u);
      l < o ? (o = l, n = a, s = c < s ? c : s) : l === o && c < s && (s = c, n = a);
    }
    return n || i - t;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, t, i) {
    const n = e.leaf ? this.compareMinX : xc, o = e.leaf ? this.compareMinY : Tc, s = this._allDistMargin(e, t, i, n), a = this._allDistMargin(e, t, i, o);
    s < a && e.children.sort(n);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, t, i, n) {
    e.children.sort(n);
    const o = this.toBBox, s = Hr(e, 0, t, o), a = Hr(e, i - t, i, o);
    let h = mi(s) + mi(a);
    for (let u = t; u < i - t; u++) {
      const l = e.children[u];
      Yr(s, e.leaf ? o(l) : l), h += mi(s);
    }
    for (let u = i - t - 1; u >= t; u--) {
      const l = e.children[u];
      Yr(a, e.leaf ? o(l) : l), h += mi(a);
    }
    return h;
  }
  _adjustParentBBoxes(e, t, i) {
    for (let n = i; n >= 0; n--)
      Yr(t[n], e);
  }
  _condense(e) {
    for (let t = e.length - 1, i; t >= 0; t--)
      e[t].children.length === 0 ? t > 0 ? (i = e[t - 1].children, i.splice(i.indexOf(e[t]), 1)) : this.clear() : ar(e[t], this.toBBox);
  }
}
function bc(r, e, t) {
  if (!t)
    return e.indexOf(r);
  for (let i = 0; i < e.length; i++)
    if (t(r, e[i]))
      return i;
  return -1;
}
function ar(r, e) {
  Hr(r, 0, r.children.length, e, r);
}
function Hr(r, e, t, i, n) {
  n || (n = dr(null)), n.minX = 1 / 0, n.minY = 1 / 0, n.maxX = -1 / 0, n.maxY = -1 / 0;
  for (let o = e; o < t; o++) {
    const s = r.children[o];
    Yr(n, r.leaf ? i(s) : s);
  }
  return n;
}
function Yr(r, e) {
  return r.minX = Math.min(r.minX, e.minX), r.minY = Math.min(r.minY, e.minY), r.maxX = Math.max(r.maxX, e.maxX), r.maxY = Math.max(r.maxY, e.maxY), r;
}
function xc(r, e) {
  return r.minX - e.minX;
}
function Tc(r, e) {
  return r.minY - e.minY;
}
function Rn(r) {
  return (r.maxX - r.minX) * (r.maxY - r.minY);
}
function mi(r) {
  return r.maxX - r.minX + (r.maxY - r.minY);
}
function Ec(r, e) {
  return (Math.max(e.maxX, r.maxX) - Math.min(e.minX, r.minX)) * (Math.max(e.maxY, r.maxY) - Math.min(e.minY, r.minY));
}
function Ac(r, e) {
  const t = Math.max(r.minX, e.minX), i = Math.max(r.minY, e.minY), n = Math.min(r.maxX, e.maxX), o = Math.min(r.maxY, e.maxY);
  return Math.max(0, n - t) * Math.max(0, o - i);
}
function On(r, e) {
  return r.minX <= e.minX && r.minY <= e.minY && e.maxX <= r.maxX && e.maxY <= r.maxY;
}
function _i(r, e) {
  return e.minX <= r.maxX && e.minY <= r.maxY && e.maxX >= r.minX && e.maxY >= r.minY;
}
function dr(r) {
  return {
    children: r,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Qs(r, e, t, i, n) {
  const o = [e, t];
  for (; o.length; ) {
    if (t = o.pop(), e = o.pop(), t - e <= i)
      continue;
    const s = e + Math.ceil((t - e) / i / 2) * i;
    _c(r, s, e, t, n), o.push(e, s, s, t);
  }
}
const Sc = () => {
  const r = new vc(), e = /* @__PURE__ */ new Map(), t = () => [...e.values()], i = () => {
    r.clear(), e.clear();
  }, n = (s) => {
    const { minX: a, minY: h, maxX: u, maxY: l } = s.selector.geometry.bounds, c = { minX: a, minY: h, maxX: u, maxY: l, target: s };
    r.insert(c), e.set(s.annotation, c);
  }, o = (s) => {
    const a = e.get(s.annotation);
    r.remove(a), e.delete(s.annotation);
  };
  return {
    all: t,
    clear: i,
    getAt: (s, a) => {
      const h = r.search({
        minX: s,
        minY: a,
        maxX: s,
        maxY: a
      }).map((u) => u.target).filter((u) => u.selector.type === kt.RECTANGLE || zl(u.selector, s, a));
      if (h.length > 0)
        return h.sort((u, l) => js(u.selector) - js(l.selector)), h[0];
    },
    getIntersecting: (s, a, h, u) => r.search({
      minX: s,
      minY: a,
      maxX: s + h,
      maxY: a + u
    }).map((l) => l.target),
    insert: n,
    remove: o,
    set: (s, a = !0) => {
      a && i();
      const h = s.map((u) => {
        const { minX: l, minY: c, maxX: p, maxY: d } = u.selector.geometry.bounds;
        return { minX: l, minY: c, maxX: p, maxY: d, target: u };
      });
      h.forEach((u) => e.set(u.target.annotation, u)), r.load(h);
    },
    size: () => r.all().length,
    update: (s, a) => {
      o(s), n(a);
    }
  };
}, Rc = (r) => {
  const e = Ll(), t = Sc(), i = Tl(e, r.pointerSelectAction), n = xl(e), o = Bl();
  return e.observe(({ changes: s }) => {
    t.set(s.created.map((a) => a.target), !1), s.deleted.forEach((a) => t.remove(a.target)), s.updated.forEach(({ oldValue: a, newValue: h }) => t.update(a.target, h.target));
  }), {
    store: {
      ...e,
      getAt: (s, a) => {
        const h = t.getAt(s, a);
        return h ? e.getAnnotation(h.annotation) : void 0;
      },
      getIntersecting: (s, a, h, u) => t.getIntersecting(s, a, h, u).map((l) => e.getAnnotation(l.annotation))
    },
    selection: i,
    hover: n,
    viewport: o
  };
}, Oc = (r) => {
  let e, t;
  if (r.nodeName === "CANVAS")
    e = r, t = e.getContext("2d", { willReadFrequently: !0 });
  else {
    const n = r;
    e = document.createElement("canvas"), e.width = n.width, e.height = n.height, t = e.getContext("2d", { willReadFrequently: !0 }), t.drawImage(n, 0, 0, n.width, n.height);
  }
  let i = 0;
  for (let n = 1; n < 10; n++)
    for (let o = 1; o < 10; o++) {
      const s = Math.round(o * e.width / 10), a = Math.round(n * e.height / 10), h = t.getImageData(s, a, 1, 1).data, u = (0.299 * h[0] + 0.587 * h[1] + 0.114 * h[2]) / 255;
      i += u;
    }
  return i / 81;
}, wc = (r, e) => {
  const t = Oc(r), i = t > 0.6 ? "dark" : "light";
  console.log(`[Annotorious] Image brightness: ${t.toFixed(1)}. Setting ${i} theme.`), e.setAttribute("data-theme", i);
}, Ic = (r) => ({
  ...r,
  pointerSelectAction: r.pointerSelectAction || zh.EDIT
});
function Pc(r) {
  var e = this.constructor;
  return this.then(
    function(t) {
      return e.resolve(r()).then(function() {
        return t;
      });
    },
    function(t) {
      return e.resolve(r()).then(function() {
        return e.reject(t);
      });
    }
  );
}
function Mc(r) {
  var e = this;
  return new e(function(t, i) {
    if (!(r && typeof r.length < "u"))
      return i(
        new TypeError(
          typeof r + " " + r + " is not iterable(cannot read property Symbol(Symbol.iterator))"
        )
      );
    var n = Array.prototype.slice.call(r);
    if (n.length === 0)
      return t([]);
    var o = n.length;
    function s(h, u) {
      if (u && (typeof u == "object" || typeof u == "function")) {
        var l = u.then;
        if (typeof l == "function") {
          l.call(
            u,
            function(c) {
              s(h, c);
            },
            function(c) {
              n[h] = { status: "rejected", reason: c }, --o === 0 && t(n);
            }
          );
          return;
        }
      }
      n[h] = { status: "fulfilled", value: u }, --o === 0 && t(n);
    }
    for (var a = 0; a < n.length; a++)
      s(a, n[a]);
  });
}
function Kh(r, e) {
  this.name = "AggregateError", this.errors = r, this.message = e || "";
}
Kh.prototype = Error.prototype;
function Dc(r) {
  var e = this;
  return new e(function(t, i) {
    if (!(r && typeof r.length < "u"))
      return i(new TypeError("Promise.any accepts an array"));
    var n = Array.prototype.slice.call(r);
    if (n.length === 0)
      return i();
    for (var o = [], s = 0; s < n.length; s++)
      try {
        e.resolve(n[s]).then(t).catch(function(a) {
          o.push(a), o.length === n.length && i(
            new Kh(
              o,
              "All promises were rejected"
            )
          );
        });
      } catch (a) {
        i(a);
      }
  });
}
var Cc = setTimeout;
function Zh(r) {
  return !!(r && typeof r.length < "u");
}
function Fc() {
}
function Nc(r, e) {
  return function() {
    r.apply(e, arguments);
  };
}
function Tt(r) {
  if (!(this instanceof Tt))
    throw new TypeError("Promises must be constructed via new");
  if (typeof r != "function")
    throw new TypeError("not a function");
  this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], Qh(r, this);
}
function Jh(r, e) {
  for (; r._state === 3; )
    r = r._value;
  if (r._state === 0) {
    r._deferreds.push(e);
    return;
  }
  r._handled = !0, Tt._immediateFn(function() {
    var t = r._state === 1 ? e.onFulfilled : e.onRejected;
    if (t === null) {
      (r._state === 1 ? xo : Jr)(e.promise, r._value);
      return;
    }
    var i;
    try {
      i = t(r._value);
    } catch (n) {
      Jr(e.promise, n);
      return;
    }
    xo(e.promise, i);
  });
}
function xo(r, e) {
  try {
    if (e === r)
      throw new TypeError("A promise cannot be resolved with itself.");
    if (e && (typeof e == "object" || typeof e == "function")) {
      var t = e.then;
      if (e instanceof Tt) {
        r._state = 3, r._value = e, To(r);
        return;
      } else if (typeof t == "function") {
        Qh(Nc(t, e), r);
        return;
      }
    }
    r._state = 1, r._value = e, To(r);
  } catch (i) {
    Jr(r, i);
  }
}
function Jr(r, e) {
  r._state = 2, r._value = e, To(r);
}
function To(r) {
  r._state === 2 && r._deferreds.length === 0 && Tt._immediateFn(function() {
    r._handled || Tt._unhandledRejectionFn(r._value);
  });
  for (var e = 0, t = r._deferreds.length; e < t; e++)
    Jh(r, r._deferreds[e]);
  r._deferreds = null;
}
function Lc(r, e, t) {
  this.onFulfilled = typeof r == "function" ? r : null, this.onRejected = typeof e == "function" ? e : null, this.promise = t;
}
function Qh(r, e) {
  var t = !1;
  try {
    r(
      function(i) {
        t || (t = !0, xo(e, i));
      },
      function(i) {
        t || (t = !0, Jr(e, i));
      }
    );
  } catch (i) {
    if (t)
      return;
    t = !0, Jr(e, i);
  }
}
Tt.prototype.catch = function(r) {
  return this.then(null, r);
};
Tt.prototype.then = function(r, e) {
  var t = new this.constructor(Fc);
  return Jh(this, new Lc(r, e, t)), t;
};
Tt.prototype.finally = Pc;
Tt.all = function(r) {
  return new Tt(function(e, t) {
    if (!Zh(r))
      return t(new TypeError("Promise.all accepts an array"));
    var i = Array.prototype.slice.call(r);
    if (i.length === 0)
      return e([]);
    var n = i.length;
    function o(a, h) {
      try {
        if (h && (typeof h == "object" || typeof h == "function")) {
          var u = h.then;
          if (typeof u == "function") {
            u.call(
              h,
              function(l) {
                o(a, l);
              },
              t
            );
            return;
          }
        }
        i[a] = h, --n === 0 && e(i);
      } catch (l) {
        t(l);
      }
    }
    for (var s = 0; s < i.length; s++)
      o(s, i[s]);
  });
};
Tt.any = Dc;
Tt.allSettled = Mc;
Tt.resolve = function(r) {
  return r && typeof r == "object" && r.constructor === Tt ? r : new Tt(function(e) {
    e(r);
  });
};
Tt.reject = function(r) {
  return new Tt(function(e, t) {
    t(r);
  });
};
Tt.race = function(r) {
  return new Tt(function(e, t) {
    if (!Zh(r))
      return t(new TypeError("Promise.race accepts an array"));
    for (var i = 0, n = r.length; i < n; i++)
      Tt.resolve(r[i]).then(e, t);
  });
};
Tt._immediateFn = // @ts-ignore
typeof setImmediate == "function" && function(r) {
  setImmediate(r);
} || function(r) {
  Cc(r, 0);
};
Tt._unhandledRejectionFn = function(r) {
  typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", r);
};
var wn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gs(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
function Bc(r) {
  if (r.__esModule)
    return r;
  var e = r.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(r).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(r, i);
    Object.defineProperty(t, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return r[i];
      }
    });
  }), t;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ta = Object.getOwnPropertySymbols, Gc = Object.prototype.hasOwnProperty, Uc = Object.prototype.propertyIsEnumerable;
function kc(r) {
  if (r == null)
    throw new TypeError("Object.assign cannot be called with null or undefined");
  return Object(r);
}
function Xc() {
  try {
    if (!Object.assign)
      return !1;
    var r = new String("abc");
    if (r[5] = "de", Object.getOwnPropertyNames(r)[0] === "5")
      return !1;
    for (var e = {}, t = 0; t < 10; t++)
      e["_" + String.fromCharCode(t)] = t;
    var i = Object.getOwnPropertyNames(e).map(function(o) {
      return e[o];
    });
    if (i.join("") !== "0123456789")
      return !1;
    var n = {};
    return "abcdefghijklmnopqrst".split("").forEach(function(o) {
      n[o] = o;
    }), Object.keys(Object.assign({}, n)).join("") === "abcdefghijklmnopqrst";
  } catch {
    return !1;
  }
}
var jc = Xc() ? Object.assign : function(r, e) {
  for (var t, i = kc(r), n, o = 1; o < arguments.length; o++) {
    t = Object(arguments[o]);
    for (var s in t)
      Gc.call(t, s) && (i[s] = t[s]);
    if (ta) {
      n = ta(t);
      for (var a = 0; a < n.length; a++)
        Uc.call(t, n[a]) && (i[n[a]] = t[n[a]]);
    }
  }
  return i;
};
const Hc = /* @__PURE__ */ gs(jc);
/*!
 * @pixi/polyfill - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/polyfill is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
typeof globalThis > "u" && (typeof self < "u" ? self.globalThis = self : typeof global < "u" && (global.globalThis = global));
globalThis.Promise || (globalThis.Promise = Tt);
Object.assign || (Object.assign = Hc);
var Yc = 16;
Date.now && Date.prototype.getTime || (Date.now = function() {
  return (/* @__PURE__ */ new Date()).getTime();
});
if (!(globalThis.performance && globalThis.performance.now)) {
  var Vc = Date.now();
  globalThis.performance || (globalThis.performance = {}), globalThis.performance.now = function() {
    return Date.now() - Vc;
  };
}
var In = Date.now(), ea = ["ms", "moz", "webkit", "o"];
for (var Pn = 0; Pn < ea.length && !globalThis.requestAnimationFrame; ++Pn) {
  var Mn = ea[Pn];
  globalThis.requestAnimationFrame = globalThis[Mn + "RequestAnimationFrame"], globalThis.cancelAnimationFrame = globalThis[Mn + "CancelAnimationFrame"] || globalThis[Mn + "CancelRequestAnimationFrame"];
}
globalThis.requestAnimationFrame || (globalThis.requestAnimationFrame = function(r) {
  if (typeof r != "function")
    throw new TypeError(r + "is not a function");
  var e = Date.now(), t = Yc + In - e;
  return t < 0 && (t = 0), In = e, globalThis.self.setTimeout(function() {
    In = Date.now(), r(performance.now());
  }, t);
});
globalThis.cancelAnimationFrame || (globalThis.cancelAnimationFrame = function(r) {
  return clearTimeout(r);
});
Math.sign || (Math.sign = function(r) {
  return r = Number(r), r === 0 || isNaN(r) ? r : r > 0 ? 1 : -1;
});
Number.isInteger || (Number.isInteger = function(r) {
  return typeof r == "number" && isFinite(r) && Math.floor(r) === r;
});
globalThis.ArrayBuffer || (globalThis.ArrayBuffer = Array);
globalThis.Float32Array || (globalThis.Float32Array = Array);
globalThis.Uint32Array || (globalThis.Uint32Array = Array);
globalThis.Uint16Array || (globalThis.Uint16Array = Array);
globalThis.Uint8Array || (globalThis.Uint8Array = Array);
globalThis.Int32Array || (globalThis.Int32Array = Array);
/*!
 * @pixi/constants - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var be;
(function(r) {
  r[r.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", r[r.WEBGL = 1] = "WEBGL", r[r.WEBGL2 = 2] = "WEBGL2";
})(be || (be = {}));
var Qr;
(function(r) {
  r[r.UNKNOWN = 0] = "UNKNOWN", r[r.WEBGL = 1] = "WEBGL", r[r.CANVAS = 2] = "CANVAS";
})(Qr || (Qr = {}));
var Ji;
(function(r) {
  r[r.COLOR = 16384] = "COLOR", r[r.DEPTH = 256] = "DEPTH", r[r.STENCIL = 1024] = "STENCIL";
})(Ji || (Ji = {}));
var k;
(function(r) {
  r[r.NORMAL = 0] = "NORMAL", r[r.ADD = 1] = "ADD", r[r.MULTIPLY = 2] = "MULTIPLY", r[r.SCREEN = 3] = "SCREEN", r[r.OVERLAY = 4] = "OVERLAY", r[r.DARKEN = 5] = "DARKEN", r[r.LIGHTEN = 6] = "LIGHTEN", r[r.COLOR_DODGE = 7] = "COLOR_DODGE", r[r.COLOR_BURN = 8] = "COLOR_BURN", r[r.HARD_LIGHT = 9] = "HARD_LIGHT", r[r.SOFT_LIGHT = 10] = "SOFT_LIGHT", r[r.DIFFERENCE = 11] = "DIFFERENCE", r[r.EXCLUSION = 12] = "EXCLUSION", r[r.HUE = 13] = "HUE", r[r.SATURATION = 14] = "SATURATION", r[r.COLOR = 15] = "COLOR", r[r.LUMINOSITY = 16] = "LUMINOSITY", r[r.NORMAL_NPM = 17] = "NORMAL_NPM", r[r.ADD_NPM = 18] = "ADD_NPM", r[r.SCREEN_NPM = 19] = "SCREEN_NPM", r[r.NONE = 20] = "NONE", r[r.SRC_OVER = 0] = "SRC_OVER", r[r.SRC_IN = 21] = "SRC_IN", r[r.SRC_OUT = 22] = "SRC_OUT", r[r.SRC_ATOP = 23] = "SRC_ATOP", r[r.DST_OVER = 24] = "DST_OVER", r[r.DST_IN = 25] = "DST_IN", r[r.DST_OUT = 26] = "DST_OUT", r[r.DST_ATOP = 27] = "DST_ATOP", r[r.ERASE = 26] = "ERASE", r[r.SUBTRACT = 28] = "SUBTRACT", r[r.XOR = 29] = "XOR";
})(k || (k = {}));
var te;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(te || (te = {}));
var P;
(function(r) {
  r[r.RGBA = 6408] = "RGBA", r[r.RGB = 6407] = "RGB", r[r.RG = 33319] = "RG", r[r.RED = 6403] = "RED", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.ALPHA = 6406] = "ALPHA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(P || (P = {}));
var qe;
(function(r) {
  r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(qe || (qe = {}));
var U;
(function(r) {
  r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.BYTE = 5120] = "BYTE", r[r.SHORT = 5122] = "SHORT", r[r.INT = 5124] = "INT", r[r.FLOAT = 5126] = "FLOAT", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(U || (U = {}));
var Qi;
(function(r) {
  r[r.FLOAT = 0] = "FLOAT", r[r.INT = 1] = "INT", r[r.UINT = 2] = "UINT";
})(Qi || (Qi = {}));
var he;
(function(r) {
  r[r.NEAREST = 0] = "NEAREST", r[r.LINEAR = 1] = "LINEAR";
})(he || (he = {}));
var le;
(function(r) {
  r[r.CLAMP = 33071] = "CLAMP", r[r.REPEAT = 10497] = "REPEAT", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(le || (le = {}));
var ie;
(function(r) {
  r[r.OFF = 0] = "OFF", r[r.POW2 = 1] = "POW2", r[r.ON = 2] = "ON", r[r.ON_MANUAL = 3] = "ON_MANUAL";
})(ie || (ie = {}));
var ne;
(function(r) {
  r[r.NPM = 0] = "NPM", r[r.UNPACK = 1] = "UNPACK", r[r.PMA = 2] = "PMA", r[r.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", r[r.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", r[r.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", r[r.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ne || (ne = {}));
var Qt;
(function(r) {
  r[r.NO = 0] = "NO", r[r.YES = 1] = "YES", r[r.AUTO = 2] = "AUTO", r[r.BLEND = 0] = "BLEND", r[r.CLEAR = 1] = "CLEAR", r[r.BLIT = 2] = "BLIT";
})(Qt || (Qt = {}));
var tn;
(function(r) {
  r[r.AUTO = 0] = "AUTO", r[r.MANUAL = 1] = "MANUAL";
})(tn || (tn = {}));
var Xt;
(function(r) {
  r.LOW = "lowp", r.MEDIUM = "mediump", r.HIGH = "highp";
})(Xt || (Xt = {}));
var Rt;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.SCISSOR = 1] = "SCISSOR", r[r.STENCIL = 2] = "STENCIL", r[r.SPRITE = 3] = "SPRITE", r[r.COLOR = 4] = "COLOR";
})(Rt || (Rt = {}));
var ra;
(function(r) {
  r[r.RED = 1] = "RED", r[r.GREEN = 2] = "GREEN", r[r.BLUE = 4] = "BLUE", r[r.ALPHA = 8] = "ALPHA";
})(ra || (ra = {}));
var gt;
(function(r) {
  r[r.NONE = 0] = "NONE", r[r.LOW = 2] = "LOW", r[r.MEDIUM = 4] = "MEDIUM", r[r.HIGH = 8] = "HIGH";
})(gt || (gt = {}));
var ce;
(function(r) {
  r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(ce || (ce = {}));
/*!
 * @pixi/settings - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var zc = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(r, e) {
    var t = document.createElement("canvas");
    return t.width = r, t.height = e, t;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var r;
    return (r = document.baseURI) !== null && r !== void 0 ? r : window.location.href;
  },
  fetch: function(r, e) {
    return fetch(r, e);
  }
}, Dn = /iPhone/i, ia = /iPod/i, na = /iPad/i, oa = /\biOS-universal(?:.+)Mac\b/i, Cn = /\bAndroid(?:.+)Mobile\b/i, sa = /Android/i, hr = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, gi = /Silk/i, fe = /Windows Phone/i, aa = /\bWindows(?:.+)ARM\b/i, ha = /BlackBerry/i, ua = /BB10/i, la = /Opera Mini/i, ca = /\b(CriOS|Chrome)(?:.+)Mobile/i, pa = /Mobile(?:.+)Firefox\b/i, da = function(r) {
  return typeof r < "u" && r.platform === "MacIntel" && typeof r.maxTouchPoints == "number" && r.maxTouchPoints > 1 && typeof MSStream > "u";
};
function Wc(r) {
  return function(e) {
    return e.test(r);
  };
}
function $c(r) {
  var e = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !r && typeof navigator < "u" ? e = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof r == "string" ? e.userAgent = r : r && r.userAgent && (e = {
    userAgent: r.userAgent,
    platform: r.platform,
    maxTouchPoints: r.maxTouchPoints || 0
  });
  var t = e.userAgent, i = t.split("[FBAN");
  typeof i[1] < "u" && (t = i[0]), i = t.split("Twitter"), typeof i[1] < "u" && (t = i[0]);
  var n = Wc(t), o = {
    apple: {
      phone: n(Dn) && !n(fe),
      ipod: n(ia),
      tablet: !n(Dn) && (n(na) || da(e)) && !n(fe),
      universal: n(oa),
      device: (n(Dn) || n(ia) || n(na) || n(oa) || da(e)) && !n(fe)
    },
    amazon: {
      phone: n(hr),
      tablet: !n(hr) && n(gi),
      device: n(hr) || n(gi)
    },
    android: {
      phone: !n(fe) && n(hr) || !n(fe) && n(Cn),
      tablet: !n(fe) && !n(hr) && !n(Cn) && (n(gi) || n(sa)),
      device: !n(fe) && (n(hr) || n(gi) || n(Cn) || n(sa)) || n(/\bokhttp\b/i)
    },
    windows: {
      phone: n(fe),
      tablet: n(aa),
      device: n(fe) || n(aa)
    },
    other: {
      blackberry: n(ha),
      blackberry10: n(ua),
      opera: n(la),
      firefox: n(pa),
      chrome: n(ca),
      device: n(ha) || n(ua) || n(la) || n(pa) || n(ca)
    },
    any: !1,
    phone: !1,
    tablet: !1
  };
  return o.any = o.apple.device || o.android.device || o.windows.device || o.other.device, o.phone = o.apple.phone || o.android.phone || o.windows.phone, o.tablet = o.apple.tablet || o.android.tablet || o.windows.tablet, o;
}
var ue = $c(globalThis.navigator);
function qc() {
  return !ue.apple.device;
}
function Kc(r) {
  var e = !0;
  if (ue.tablet || ue.phone) {
    if (ue.apple.device) {
      var t = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (t) {
        var i = parseInt(t[1], 10);
        i < 11 && (e = !1);
      }
    }
    if (ue.android.device) {
      var t = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (t) {
        var i = parseInt(t[1], 10);
        i < 7 && (e = !1);
      }
    }
  }
  return e ? r : 4;
}
var L = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: zc,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: ie.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: gt.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: Kc(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {boolean} [antialias=false] - {@link PIXI.IRendererOptions.antialias}
   * @property {boolean} [autoDensity=false] - {@link PIXI.IRendererOptions.autoDensity}
   * @property {number} [backgroundAlpha=1] - {@link PIXI.IRendererOptions.backgroundAlpha}
   * @property {number} [backgroundColor=0x000000] - {@link PIXI.IRendererOptions.backgroundColor}
   * @property {boolean} [clearBeforeRender=true] - {@link PIXI.IRendererOptions.clearBeforeRender}
   * @property {number} [height=600] - {@link PIXI.IRendererOptions.height}
   * @property {boolean} [preserveDrawingBuffer=false] - {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @property {boolean|'notMultiplied'} [useContextAlpha=true] - {@link PIXI.IRendererOptions.useContextAlpha}
   * @property {HTMLCanvasElement} [view=null] - {@link PIXI.IRendererOptions.view}
   * @property {number} [width=800] - {@link PIXI.IRendererOptions.width}
   */
  RENDER_OPTIONS: {
    view: null,
    width: 800,
    height: 600,
    autoDensity: !1,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: !0,
    clearBeforeRender: !0,
    antialias: !1,
    preserveDrawingBuffer: !1
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: tn.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: le.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: he.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: Xt.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: ue.apple.device ? Xt.HIGH : Xt.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: qc(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: !1,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: !1
}, tu = { exports: {} };
(function(r) {
  var e = Object.prototype.hasOwnProperty, t = "~";
  function i() {
  }
  Object.create && (i.prototype = /* @__PURE__ */ Object.create(null), new i().__proto__ || (t = !1));
  function n(h, u, l) {
    this.fn = h, this.context = u, this.once = l || !1;
  }
  function o(h, u, l, c, p) {
    if (typeof l != "function")
      throw new TypeError("The listener must be a function");
    var d = new n(l, c || h, p), f = t ? t + u : u;
    return h._events[f] ? h._events[f].fn ? h._events[f] = [h._events[f], d] : h._events[f].push(d) : (h._events[f] = d, h._eventsCount++), h;
  }
  function s(h, u) {
    --h._eventsCount === 0 ? h._events = new i() : delete h._events[u];
  }
  function a() {
    this._events = new i(), this._eventsCount = 0;
  }
  a.prototype.eventNames = function() {
    var h = [], u, l;
    if (this._eventsCount === 0)
      return h;
    for (l in u = this._events)
      e.call(u, l) && h.push(t ? l.slice(1) : l);
    return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(u)) : h;
  }, a.prototype.listeners = function(h) {
    var u = t ? t + h : h, l = this._events[u];
    if (!l)
      return [];
    if (l.fn)
      return [l.fn];
    for (var c = 0, p = l.length, d = new Array(p); c < p; c++)
      d[c] = l[c].fn;
    return d;
  }, a.prototype.listenerCount = function(h) {
    var u = t ? t + h : h, l = this._events[u];
    return l ? l.fn ? 1 : l.length : 0;
  }, a.prototype.emit = function(h, u, l, c, p, d) {
    var f = t ? t + h : h;
    if (!this._events[f])
      return !1;
    var y = this._events[f], m = arguments.length, _, g;
    if (y.fn) {
      switch (y.once && this.removeListener(h, y.fn, void 0, !0), m) {
        case 1:
          return y.fn.call(y.context), !0;
        case 2:
          return y.fn.call(y.context, u), !0;
        case 3:
          return y.fn.call(y.context, u, l), !0;
        case 4:
          return y.fn.call(y.context, u, l, c), !0;
        case 5:
          return y.fn.call(y.context, u, l, c, p), !0;
        case 6:
          return y.fn.call(y.context, u, l, c, p, d), !0;
      }
      for (g = 1, _ = new Array(m - 1); g < m; g++)
        _[g - 1] = arguments[g];
      y.fn.apply(y.context, _);
    } else {
      var b = y.length, x;
      for (g = 0; g < b; g++)
        switch (y[g].once && this.removeListener(h, y[g].fn, void 0, !0), m) {
          case 1:
            y[g].fn.call(y[g].context);
            break;
          case 2:
            y[g].fn.call(y[g].context, u);
            break;
          case 3:
            y[g].fn.call(y[g].context, u, l);
            break;
          case 4:
            y[g].fn.call(y[g].context, u, l, c);
            break;
          default:
            if (!_)
              for (x = 1, _ = new Array(m - 1); x < m; x++)
                _[x - 1] = arguments[x];
            y[g].fn.apply(y[g].context, _);
        }
    }
    return !0;
  }, a.prototype.on = function(h, u, l) {
    return o(this, h, u, l, !1);
  }, a.prototype.once = function(h, u, l) {
    return o(this, h, u, l, !0);
  }, a.prototype.removeListener = function(h, u, l, c) {
    var p = t ? t + h : h;
    if (!this._events[p])
      return this;
    if (!u)
      return s(this, p), this;
    var d = this._events[p];
    if (d.fn)
      d.fn === u && (!c || d.once) && (!l || d.context === l) && s(this, p);
    else {
      for (var f = 0, y = [], m = d.length; f < m; f++)
        (d[f].fn !== u || c && !d[f].once || l && d[f].context !== l) && y.push(d[f]);
      y.length ? this._events[p] = y.length === 1 ? y[0] : y : s(this, p);
    }
    return this;
  }, a.prototype.removeAllListeners = function(h) {
    var u;
    return h ? (u = t ? t + h : h, this._events[u] && s(this, u)) : (this._events = new i(), this._eventsCount = 0), this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, r.exports = a;
})(tu);
var Zc = tu.exports;
const hi = /* @__PURE__ */ gs(Zc);
var vs = { exports: {} };
vs.exports = gn;
vs.exports.default = gn;
function gn(r, e, t) {
  t = t || 2;
  var i = e && e.length, n = i ? e[0] * t : r.length, o = eu(r, 0, n, t, !0), s = [];
  if (!o || o.next === o.prev)
    return s;
  var a, h, u, l, c, p, d;
  if (i && (o = rp(r, e, o, t)), r.length > 80 * t) {
    a = u = r[0], h = l = r[1];
    for (var f = t; f < n; f += t)
      c = r[f], p = r[f + 1], c < a && (a = c), p < h && (h = p), c > u && (u = c), p > l && (l = p);
    d = Math.max(u - a, l - h), d = d !== 0 ? 32767 / d : 0;
  }
  return ti(o, s, t, a, h, d, 0), s;
}
function eu(r, e, t, i, n) {
  var o, s;
  if (n === So(r, e, t, i) > 0)
    for (o = e; o < t; o += i)
      s = fa(o, r[o], r[o + 1], s);
  else
    for (o = t - i; o >= e; o -= i)
      s = fa(o, r[o], r[o + 1], s);
  return s && vn(s, s.next) && (ri(s), s = s.next), s;
}
function Qe(r, e) {
  if (!r)
    return r;
  e || (e = r);
  var t = r, i;
  do
    if (i = !1, !t.steiner && (vn(t, t.next) || xt(t.prev, t, t.next) === 0)) {
      if (ri(t), t = e = t.prev, t === t.next)
        break;
      i = !0;
    } else
      t = t.next;
  while (i || t !== e);
  return e;
}
function ti(r, e, t, i, n, o, s) {
  if (r) {
    !s && o && ap(r, i, n, o);
    for (var a = r, h, u; r.prev !== r.next; ) {
      if (h = r.prev, u = r.next, o ? Qc(r, i, n, o) : Jc(r)) {
        e.push(h.i / t | 0), e.push(r.i / t | 0), e.push(u.i / t | 0), ri(r), r = u.next, a = u.next;
        continue;
      }
      if (r = u, r === a) {
        s ? s === 1 ? (r = tp(Qe(r), e, t), ti(r, e, t, i, n, o, 2)) : s === 2 && ep(r, e, t, i, n, o) : ti(Qe(r), e, t, i, n, o, 1);
        break;
      }
    }
  }
}
function Jc(r) {
  var e = r.prev, t = r, i = r.next;
  if (xt(e, t, i) >= 0)
    return !1;
  for (var n = e.x, o = t.x, s = i.x, a = e.y, h = t.y, u = i.y, l = n < o ? n < s ? n : s : o < s ? o : s, c = a < h ? a < u ? a : u : h < u ? h : u, p = n > o ? n > s ? n : s : o > s ? o : s, d = a > h ? a > u ? a : u : h > u ? h : u, f = i.next; f !== e; ) {
    if (f.x >= l && f.x <= p && f.y >= c && f.y <= d && yr(n, a, o, h, s, u, f.x, f.y) && xt(f.prev, f, f.next) >= 0)
      return !1;
    f = f.next;
  }
  return !0;
}
function Qc(r, e, t, i) {
  var n = r.prev, o = r, s = r.next;
  if (xt(n, o, s) >= 0)
    return !1;
  for (var a = n.x, h = o.x, u = s.x, l = n.y, c = o.y, p = s.y, d = a < h ? a < u ? a : u : h < u ? h : u, f = l < c ? l < p ? l : p : c < p ? c : p, y = a > h ? a > u ? a : u : h > u ? h : u, m = l > c ? l > p ? l : p : c > p ? c : p, _ = Eo(d, f, e, t, i), g = Eo(y, m, e, t, i), b = r.prevZ, x = r.nextZ; b && b.z >= _ && x && x.z <= g; ) {
    if (b.x >= d && b.x <= y && b.y >= f && b.y <= m && b !== n && b !== s && yr(a, l, h, c, u, p, b.x, b.y) && xt(b.prev, b, b.next) >= 0 || (b = b.prevZ, x.x >= d && x.x <= y && x.y >= f && x.y <= m && x !== n && x !== s && yr(a, l, h, c, u, p, x.x, x.y) && xt(x.prev, x, x.next) >= 0))
      return !1;
    x = x.nextZ;
  }
  for (; b && b.z >= _; ) {
    if (b.x >= d && b.x <= y && b.y >= f && b.y <= m && b !== n && b !== s && yr(a, l, h, c, u, p, b.x, b.y) && xt(b.prev, b, b.next) >= 0)
      return !1;
    b = b.prevZ;
  }
  for (; x && x.z <= g; ) {
    if (x.x >= d && x.x <= y && x.y >= f && x.y <= m && x !== n && x !== s && yr(a, l, h, c, u, p, x.x, x.y) && xt(x.prev, x, x.next) >= 0)
      return !1;
    x = x.nextZ;
  }
  return !0;
}
function tp(r, e, t) {
  var i = r;
  do {
    var n = i.prev, o = i.next.next;
    !vn(n, o) && ru(n, i, i.next, o) && ei(n, o) && ei(o, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(o.i / t | 0), ri(i), ri(i.next), i = r = o), i = i.next;
  } while (i !== r);
  return Qe(i);
}
function ep(r, e, t, i, n, o) {
  var s = r;
  do {
    for (var a = s.next.next; a !== s.prev; ) {
      if (s.i !== a.i && lp(s, a)) {
        var h = iu(s, a);
        s = Qe(s, s.next), h = Qe(h, h.next), ti(s, e, t, i, n, o, 0), ti(h, e, t, i, n, o, 0);
        return;
      }
      a = a.next;
    }
    s = s.next;
  } while (s !== r);
}
function rp(r, e, t, i) {
  var n = [], o, s, a, h, u;
  for (o = 0, s = e.length; o < s; o++)
    a = e[o] * i, h = o < s - 1 ? e[o + 1] * i : r.length, u = eu(r, a, h, i, !1), u === u.next && (u.steiner = !0), n.push(up(u));
  for (n.sort(ip), o = 0; o < n.length; o++)
    t = np(n[o], t);
  return t;
}
function ip(r, e) {
  return r.x - e.x;
}
function np(r, e) {
  var t = op(r, e);
  if (!t)
    return e;
  var i = iu(t, r);
  return Qe(i, i.next), Qe(t, t.next);
}
function op(r, e) {
  var t = e, i = r.x, n = r.y, o = -1 / 0, s;
  do {
    if (n <= t.y && n >= t.next.y && t.next.y !== t.y) {
      var a = t.x + (n - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (a <= i && a > o && (o = a, s = t.x < t.next.x ? t : t.next, a === i))
        return s;
    }
    t = t.next;
  } while (t !== e);
  if (!s)
    return null;
  var h = s, u = s.x, l = s.y, c = 1 / 0, p;
  t = s;
  do
    i >= t.x && t.x >= u && i !== t.x && yr(n < l ? i : o, n, u, l, n < l ? o : i, n, t.x, t.y) && (p = Math.abs(n - t.y) / (i - t.x), ei(t, r) && (p < c || p === c && (t.x > s.x || t.x === s.x && sp(s, t))) && (s = t, c = p)), t = t.next;
  while (t !== h);
  return s;
}
function sp(r, e) {
  return xt(r.prev, r, e.prev) < 0 && xt(e.next, r, r.next) < 0;
}
function ap(r, e, t, i) {
  var n = r;
  do
    n.z === 0 && (n.z = Eo(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
  while (n !== r);
  n.prevZ.nextZ = null, n.prevZ = null, hp(n);
}
function hp(r) {
  var e, t, i, n, o, s, a, h, u = 1;
  do {
    for (t = r, r = null, o = null, s = 0; t; ) {
      for (s++, i = t, a = 0, e = 0; e < u && (a++, i = i.nextZ, !!i); e++)
        ;
      for (h = u; a > 0 || h > 0 && i; )
        a !== 0 && (h === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, a--) : (n = i, i = i.nextZ, h--), o ? o.nextZ = n : r = n, n.prevZ = o, o = n;
      t = i;
    }
    o.nextZ = null, u *= 2;
  } while (s > 1);
  return r;
}
function Eo(r, e, t, i, n) {
  return r = (r - t) * n | 0, e = (e - i) * n | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
}
function up(r) {
  var e = r, t = r;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== r);
  return t;
}
function yr(r, e, t, i, n, o, s, a) {
  return (n - s) * (e - a) >= (r - s) * (o - a) && (r - s) * (i - a) >= (t - s) * (e - a) && (t - s) * (o - a) >= (n - s) * (i - a);
}
function lp(r, e) {
  return r.next.i !== e.i && r.prev.i !== e.i && !cp(r, e) && // dones't intersect other edges
  (ei(r, e) && ei(e, r) && pp(r, e) && // locally visible
  (xt(r.prev, r, e.prev) || xt(r, e.prev, e)) || // does not create opposite-facing sectors
  vn(r, e) && xt(r.prev, r, r.next) > 0 && xt(e.prev, e, e.next) > 0);
}
function xt(r, e, t) {
  return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
}
function vn(r, e) {
  return r.x === e.x && r.y === e.y;
}
function ru(r, e, t, i) {
  var n = bi(xt(r, e, t)), o = bi(xt(r, e, i)), s = bi(xt(t, i, r)), a = bi(xt(t, i, e));
  return !!(n !== o && s !== a || n === 0 && vi(r, t, e) || o === 0 && vi(r, i, e) || s === 0 && vi(t, r, i) || a === 0 && vi(t, e, i));
}
function vi(r, e, t) {
  return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y);
}
function bi(r) {
  return r > 0 ? 1 : r < 0 ? -1 : 0;
}
function cp(r, e) {
  var t = r;
  do {
    if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && ru(t, t.next, r, e))
      return !0;
    t = t.next;
  } while (t !== r);
  return !1;
}
function ei(r, e) {
  return xt(r.prev, r, r.next) < 0 ? xt(r, e, r.next) >= 0 && xt(r, r.prev, e) >= 0 : xt(r, e, r.prev) < 0 || xt(r, r.next, e) < 0;
}
function pp(r, e) {
  var t = r, i = !1, n = (r.x + e.x) / 2, o = (r.y + e.y) / 2;
  do
    t.y > o != t.next.y > o && t.next.y !== t.y && n < (t.next.x - t.x) * (o - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== r);
  return i;
}
function iu(r, e) {
  var t = new Ao(r.i, r.x, r.y), i = new Ao(e.i, e.x, e.y), n = r.next, o = e.prev;
  return r.next = e, e.prev = r, t.next = n, n.prev = t, i.next = t, t.prev = i, o.next = i, i.prev = o, i;
}
function fa(r, e, t, i) {
  var n = new Ao(r, e, t);
  return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
}
function ri(r) {
  r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
}
function Ao(r, e, t) {
  this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1;
}
gn.deviation = function(r, e, t, i) {
  var n = e && e.length, o = n ? e[0] * t : r.length, s = Math.abs(So(r, 0, o, t));
  if (n)
    for (var a = 0, h = e.length; a < h; a++) {
      var u = e[a] * t, l = a < h - 1 ? e[a + 1] * t : r.length;
      s -= Math.abs(So(r, u, l, t));
    }
  var c = 0;
  for (a = 0; a < i.length; a += 3) {
    var p = i[a] * t, d = i[a + 1] * t, f = i[a + 2] * t;
    c += Math.abs(
      (r[p] - r[f]) * (r[d + 1] - r[p + 1]) - (r[p] - r[d]) * (r[f + 1] - r[p + 1])
    );
  }
  return s === 0 && c === 0 ? 0 : Math.abs((c - s) / s);
};
function So(r, e, t, i) {
  for (var n = 0, o = e, s = t - i; o < t; o += i)
    n += (r[s] - r[o]) * (r[o + 1] + r[s + 1]), s = o;
  return n;
}
gn.flatten = function(r) {
  for (var e = r[0][0].length, t = { vertices: [], holes: [], dimensions: e }, i = 0, n = 0; n < r.length; n++) {
    for (var o = 0; o < r[n].length; o++)
      for (var s = 0; s < e; s++)
        t.vertices.push(r[n][o][s]);
    n > 0 && (i += r[n - 1].length, t.holes.push(i));
  }
  return t;
};
var dp = vs.exports;
const nu = /* @__PURE__ */ gs(dp);
var en = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
en.exports;
(function(r, e) {
  (function(t) {
    var i = e && !e.nodeType && e, n = r && !r.nodeType && r, o = typeof wn == "object" && wn;
    (o.global === o || o.window === o || o.self === o) && (t = o);
    var s, a = 2147483647, h = 36, u = 1, l = 26, c = 38, p = 700, d = 72, f = 128, y = "-", m = /^xn--/, _ = /[^\x20-\x7E]/, g = /[\x2E\u3002\uFF0E\uFF61]/g, b = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, x = h - u, E = Math.floor, v = String.fromCharCode, T;
    function S(M) {
      throw new RangeError(b[M]);
    }
    function R(M, I) {
      for (var X = M.length, Z = []; X--; )
        Z[X] = I(M[X]);
      return Z;
    }
    function O(M, I) {
      var X = M.split("@"), Z = "";
      X.length > 1 && (Z = X[0] + "@", M = X[1]), M = M.replace(g, ".");
      var Q = M.split("."), mt = R(Q, I).join(".");
      return Z + mt;
    }
    function w(M) {
      for (var I = [], X = 0, Z = M.length, Q, mt; X < Z; )
        Q = M.charCodeAt(X++), Q >= 55296 && Q <= 56319 && X < Z ? (mt = M.charCodeAt(X++), (mt & 64512) == 56320 ? I.push(((Q & 1023) << 10) + (mt & 1023) + 65536) : (I.push(Q), X--)) : I.push(Q);
      return I;
    }
    function C(M) {
      return R(M, function(I) {
        var X = "";
        return I > 65535 && (I -= 65536, X += v(I >>> 10 & 1023 | 55296), I = 56320 | I & 1023), X += v(I), X;
      }).join("");
    }
    function B(M) {
      return M - 48 < 10 ? M - 22 : M - 65 < 26 ? M - 65 : M - 97 < 26 ? M - 97 : h;
    }
    function V(M, I) {
      return M + 22 + 75 * (M < 26) - ((I != 0) << 5);
    }
    function F(M, I, X) {
      var Z = 0;
      for (M = X ? E(M / p) : M >> 1, M += E(M / I); M > x * l >> 1; Z += h)
        M = E(M / x);
      return E(Z + (x + 1) * M / (M + c));
    }
    function D(M) {
      var I = [], X = M.length, Z, Q = 0, mt = f, q = d, lt, vt, At, tt, nt, ht, pt, J, G;
      for (lt = M.lastIndexOf(y), lt < 0 && (lt = 0), vt = 0; vt < lt; ++vt)
        M.charCodeAt(vt) >= 128 && S("not-basic"), I.push(M.charCodeAt(vt));
      for (At = lt > 0 ? lt + 1 : 0; At < X; ) {
        for (tt = Q, nt = 1, ht = h; At >= X && S("invalid-input"), pt = B(M.charCodeAt(At++)), (pt >= h || pt > E((a - Q) / nt)) && S("overflow"), Q += pt * nt, J = ht <= q ? u : ht >= q + l ? l : ht - q, !(pt < J); ht += h)
          G = h - J, nt > E(a / G) && S("overflow"), nt *= G;
        Z = I.length + 1, q = F(Q - tt, Z, tt == 0), E(Q / Z) > a - mt && S("overflow"), mt += E(Q / Z), Q %= Z, I.splice(Q++, 0, mt);
      }
      return C(I);
    }
    function z(M) {
      var I, X, Z, Q, mt, q, lt, vt, At, tt, nt, ht = [], pt, J, G, N;
      for (M = w(M), pt = M.length, I = f, X = 0, mt = d, q = 0; q < pt; ++q)
        nt = M[q], nt < 128 && ht.push(v(nt));
      for (Z = Q = ht.length, Q && ht.push(y); Z < pt; ) {
        for (lt = a, q = 0; q < pt; ++q)
          nt = M[q], nt >= I && nt < lt && (lt = nt);
        for (J = Z + 1, lt - I > E((a - X) / J) && S("overflow"), X += (lt - I) * J, I = lt, q = 0; q < pt; ++q)
          if (nt = M[q], nt < I && ++X > a && S("overflow"), nt == I) {
            for (vt = X, At = h; tt = At <= mt ? u : At >= mt + l ? l : At - mt, !(vt < tt); At += h)
              N = vt - tt, G = h - tt, ht.push(
                v(V(tt + N % G, 0))
              ), vt = E(N / G);
            ht.push(v(V(vt, 0))), mt = F(X, J, Z == Q), X = 0, ++Z;
          }
        ++X, ++I;
      }
      return ht.join("");
    }
    function ot(M) {
      return O(M, function(I) {
        return m.test(I) ? D(I.slice(4).toLowerCase()) : I;
      });
    }
    function K(M) {
      return O(M, function(I) {
        return _.test(I) ? "xn--" + z(I) : I;
      });
    }
    if (s = {
      /**
       * A string representing the current Punycode.js version number.
       * @memberOf punycode
       * @type String
       */
      version: "1.4.1",
      /**
       * An object of methods to convert from JavaScript's internal character
       * representation (UCS-2) to Unicode code points, and back.
       * @see <https://mathiasbynens.be/notes/javascript-encoding>
       * @memberOf punycode
       * @type Object
       */
      ucs2: {
        decode: w,
        encode: C
      },
      decode: D,
      encode: z,
      toASCII: K,
      toUnicode: ot
    }, i && n)
      if (r.exports == i)
        n.exports = s;
      else
        for (T in s)
          s.hasOwnProperty(T) && (i[T] = s[T]);
    else
      t.punycode = s;
  })(wn);
})(en, en.exports);
var fp = en.exports, yp = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var r = {}, e = Symbol("test"), t = Object(e);
  if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(t) !== "[object Symbol]")
    return !1;
  var i = 42;
  r[e] = i;
  for (e in r)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(r).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r).length !== 0)
    return !1;
  var n = Object.getOwnPropertySymbols(r);
  if (n.length !== 1 || n[0] !== e || !Object.prototype.propertyIsEnumerable.call(r, e))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var o = Object.getOwnPropertyDescriptor(r, e);
    if (o.value !== i || o.enumerable !== !0)
      return !1;
  }
  return !0;
}, ya = typeof Symbol < "u" && Symbol, mp = yp, _p = function() {
  return typeof ya != "function" || typeof Symbol != "function" || typeof ya("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : mp();
}, ma = {
  foo: {}
}, gp = Object, vp = function() {
  return { __proto__: ma }.foo === ma.foo && !({ __proto__: null } instanceof gp);
}, bp = "Function.prototype.bind called on incompatible ", Fn = Array.prototype.slice, xp = Object.prototype.toString, Tp = "[object Function]", Ep = function(r) {
  var e = this;
  if (typeof e != "function" || xp.call(e) !== Tp)
    throw new TypeError(bp + e);
  for (var t = Fn.call(arguments, 1), i, n = function() {
    if (this instanceof i) {
      var u = e.apply(
        this,
        t.concat(Fn.call(arguments))
      );
      return Object(u) === u ? u : this;
    } else
      return e.apply(
        r,
        t.concat(Fn.call(arguments))
      );
  }, o = Math.max(0, e.length - t.length), s = [], a = 0; a < o; a++)
    s.push("$" + a);
  if (i = Function("binder", "return function (" + s.join(",") + "){ return binder.apply(this,arguments); }")(n), e.prototype) {
    var h = function() {
    };
    h.prototype = e.prototype, i.prototype = new h(), h.prototype = null;
  }
  return i;
}, Ap = Ep, ou = Function.prototype.bind || Ap, _a = {}.hasOwnProperty, Nn = Function.prototype.call, Sp = Nn.bind ? Nn.bind(_a) : function(r, e) {
  return Nn.call(_a, r, e);
}, et, Sr = SyntaxError, su = Function, xr = TypeError, Ln = function(r) {
  try {
    return su('"use strict"; return (' + r + ").constructor;")();
  } catch {
  }
}, Ke = Object.getOwnPropertyDescriptor;
if (Ke)
  try {
    Ke({}, "");
  } catch {
    Ke = null;
  }
var Bn = function() {
  throw new xr();
}, Rp = Ke ? function() {
  try {
    return arguments.callee, Bn;
  } catch {
    try {
      return Ke(arguments, "callee").get;
    } catch {
      return Bn;
    }
  }
}() : Bn, ur = _p(), Op = vp(), Mt = Object.getPrototypeOf || (Op ? function(r) {
  return r.__proto__;
} : null), fr = {}, wp = typeof Uint8Array > "u" || !Mt ? et : Mt(Uint8Array), Ze = {
  "%AggregateError%": typeof AggregateError > "u" ? et : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? et : ArrayBuffer,
  "%ArrayIteratorPrototype%": ur && Mt ? Mt([][Symbol.iterator]()) : et,
  "%AsyncFromSyncIteratorPrototype%": et,
  "%AsyncFunction%": fr,
  "%AsyncGenerator%": fr,
  "%AsyncGeneratorFunction%": fr,
  "%AsyncIteratorPrototype%": fr,
  "%Atomics%": typeof Atomics > "u" ? et : Atomics,
  "%BigInt%": typeof BigInt > "u" ? et : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? et : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? et : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? et : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? et : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? et : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? et : FinalizationRegistry,
  "%Function%": su,
  "%GeneratorFunction%": fr,
  "%Int8Array%": typeof Int8Array > "u" ? et : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? et : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? et : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": ur && Mt ? Mt(Mt([][Symbol.iterator]())) : et,
  "%JSON%": typeof JSON == "object" ? JSON : et,
  "%Map%": typeof Map > "u" ? et : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !ur || !Mt ? et : Mt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? et : Promise,
  "%Proxy%": typeof Proxy > "u" ? et : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? et : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? et : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !ur || !Mt ? et : Mt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? et : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": ur && Mt ? Mt(""[Symbol.iterator]()) : et,
  "%Symbol%": ur ? Symbol : et,
  "%SyntaxError%": Sr,
  "%ThrowTypeError%": Rp,
  "%TypedArray%": wp,
  "%TypeError%": xr,
  "%Uint8Array%": typeof Uint8Array > "u" ? et : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? et : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? et : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? et : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? et : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? et : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? et : WeakSet
};
if (Mt)
  try {
    null.error;
  } catch (r) {
    var Ip = Mt(Mt(r));
    Ze["%Error.prototype%"] = Ip;
  }
var Pp = function r(e) {
  var t;
  if (e === "%AsyncFunction%")
    t = Ln("async function () {}");
  else if (e === "%GeneratorFunction%")
    t = Ln("function* () {}");
  else if (e === "%AsyncGeneratorFunction%")
    t = Ln("async function* () {}");
  else if (e === "%AsyncGenerator%") {
    var i = r("%AsyncGeneratorFunction%");
    i && (t = i.prototype);
  } else if (e === "%AsyncIteratorPrototype%") {
    var n = r("%AsyncGenerator%");
    n && Mt && (t = Mt(n.prototype));
  }
  return Ze[e] = t, t;
}, ga = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, ui = ou, rn = Sp, Mp = ui.call(Function.call, Array.prototype.concat), Dp = ui.call(Function.apply, Array.prototype.splice), va = ui.call(Function.call, String.prototype.replace), nn = ui.call(Function.call, String.prototype.slice), Cp = ui.call(Function.call, RegExp.prototype.exec), Fp = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Np = /\\(\\)?/g, Lp = function(r) {
  var e = nn(r, 0, 1), t = nn(r, -1);
  if (e === "%" && t !== "%")
    throw new Sr("invalid intrinsic syntax, expected closing `%`");
  if (t === "%" && e !== "%")
    throw new Sr("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return va(r, Fp, function(n, o, s, a) {
    i[i.length] = s ? va(a, Np, "$1") : o || n;
  }), i;
}, Bp = function(r, e) {
  var t = r, i;
  if (rn(ga, t) && (i = ga[t], t = "%" + i[0] + "%"), rn(Ze, t)) {
    var n = Ze[t];
    if (n === fr && (n = Pp(t)), typeof n > "u" && !e)
      throw new xr("intrinsic " + r + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: t,
      value: n
    };
  }
  throw new Sr("intrinsic " + r + " does not exist!");
}, bs = function(r, e) {
  if (typeof r != "string" || r.length === 0)
    throw new xr("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof e != "boolean")
    throw new xr('"allowMissing" argument must be a boolean');
  if (Cp(/^%?[^%]*%?$/, r) === null)
    throw new Sr("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var t = Lp(r), i = t.length > 0 ? t[0] : "", n = Bp("%" + i + "%", e), o = n.name, s = n.value, a = !1, h = n.alias;
  h && (i = h[0], Dp(t, Mp([0, 1], h)));
  for (var u = 1, l = !0; u < t.length; u += 1) {
    var c = t[u], p = nn(c, 0, 1), d = nn(c, -1);
    if ((p === '"' || p === "'" || p === "`" || d === '"' || d === "'" || d === "`") && p !== d)
      throw new Sr("property names with quotes must have matching quotes");
    if ((c === "constructor" || !l) && (a = !0), i += "." + c, o = "%" + i + "%", rn(Ze, o))
      s = Ze[o];
    else if (s != null) {
      if (!(c in s)) {
        if (!e)
          throw new xr("base intrinsic for " + r + " exists, but the property is not available.");
        return;
      }
      if (Ke && u + 1 >= t.length) {
        var f = Ke(s, c);
        l = !!f, l && "get" in f && !("originalValue" in f.get) ? s = f.get : s = s[c];
      } else
        l = rn(s, c), s = s[c];
      l && !a && (Ze[o] = s);
    }
  }
  return s;
}, au = { exports: {} };
(function(r) {
  var e = ou, t = bs, i = t("%Function.prototype.apply%"), n = t("%Function.prototype.call%"), o = t("%Reflect.apply%", !0) || e.call(n, i), s = t("%Object.getOwnPropertyDescriptor%", !0), a = t("%Object.defineProperty%", !0), h = t("%Math.max%");
  if (a)
    try {
      a({}, "a", { value: 1 });
    } catch {
      a = null;
    }
  r.exports = function(l) {
    var c = o(e, n, arguments);
    if (s && a) {
      var p = s(c, "length");
      p.configurable && a(
        c,
        "length",
        { value: 1 + h(0, l.length - (arguments.length - 1)) }
      );
    }
    return c;
  };
  var u = function() {
    return o(e, i, arguments);
  };
  a ? a(r.exports, "apply", { value: u }) : r.exports.apply = u;
})(au);
var Gp = au.exports, hu = bs, uu = Gp, Up = uu(hu("String.prototype.indexOf")), kp = function(r, e) {
  var t = hu(r, !!e);
  return typeof t == "function" && Up(r, ".prototype.") > -1 ? uu(t) : t;
};
const Xp = {}, jp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Xp
}, Symbol.toStringTag, { value: "Module" })), Hp = /* @__PURE__ */ Bc(jp);
var xs = typeof Map == "function" && Map.prototype, Gn = Object.getOwnPropertyDescriptor && xs ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, on = xs && Gn && typeof Gn.get == "function" ? Gn.get : null, ba = xs && Map.prototype.forEach, Ts = typeof Set == "function" && Set.prototype, Un = Object.getOwnPropertyDescriptor && Ts ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, sn = Ts && Un && typeof Un.get == "function" ? Un.get : null, xa = Ts && Set.prototype.forEach, Yp = typeof WeakMap == "function" && WeakMap.prototype, zr = Yp ? WeakMap.prototype.has : null, Vp = typeof WeakSet == "function" && WeakSet.prototype, Wr = Vp ? WeakSet.prototype.has : null, zp = typeof WeakRef == "function" && WeakRef.prototype, Ta = zp ? WeakRef.prototype.deref : null, Wp = Boolean.prototype.valueOf, $p = Object.prototype.toString, qp = Function.prototype.toString, Kp = String.prototype.match, Es = String.prototype.slice, Re = String.prototype.replace, Zp = String.prototype.toUpperCase, Ea = String.prototype.toLowerCase, lu = RegExp.prototype.test, Aa = Array.prototype.concat, ae = Array.prototype.join, Jp = Array.prototype.slice, Sa = Math.floor, Ro = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, kn = Object.getOwnPropertySymbols, Oo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, Rr = typeof Symbol == "function" && typeof Symbol.iterator == "object", Gt = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Rr || "symbol") ? Symbol.toStringTag : null, cu = Object.prototype.propertyIsEnumerable, Ra = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(r) {
  return r.__proto__;
} : null);
function Oa(r, e) {
  if (r === 1 / 0 || r === -1 / 0 || r !== r || r && r > -1e3 && r < 1e3 || lu.call(/e/, e))
    return e;
  var t = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof r == "number") {
    var i = r < 0 ? -Sa(-r) : Sa(r);
    if (i !== r) {
      var n = String(i), o = Es.call(e, n.length + 1);
      return Re.call(n, t, "$&_") + "." + Re.call(Re.call(o, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Re.call(e, t, "$&_");
}
var wo = Hp, wa = wo.custom, Ia = du(wa) ? wa : null, Qp = function r(e, t, i, n) {
  var o = t || {};
  if (Se(o, "quoteStyle") && o.quoteStyle !== "single" && o.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (Se(o, "maxStringLength") && (typeof o.maxStringLength == "number" ? o.maxStringLength < 0 && o.maxStringLength !== 1 / 0 : o.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var s = Se(o, "customInspect") ? o.customInspect : !0;
  if (typeof s != "boolean" && s !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (Se(o, "indent") && o.indent !== null && o.indent !== "	" && !(parseInt(o.indent, 10) === o.indent && o.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (Se(o, "numericSeparator") && typeof o.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var a = o.numericSeparator;
  if (typeof e > "u")
    return "undefined";
  if (e === null)
    return "null";
  if (typeof e == "boolean")
    return e ? "true" : "false";
  if (typeof e == "string")
    return yu(e, o);
  if (typeof e == "number") {
    if (e === 0)
      return 1 / 0 / e > 0 ? "0" : "-0";
    var h = String(e);
    return a ? Oa(e, h) : h;
  }
  if (typeof e == "bigint") {
    var u = String(e) + "n";
    return a ? Oa(e, u) : u;
  }
  var l = typeof o.depth > "u" ? 5 : o.depth;
  if (typeof i > "u" && (i = 0), i >= l && l > 0 && typeof e == "object")
    return Io(e) ? "[Array]" : "[Object]";
  var c = _d(o, i);
  if (typeof n > "u")
    n = [];
  else if (fu(n, e) >= 0)
    return "[Circular]";
  function p(B, V, F) {
    if (V && (n = Jp.call(n), n.push(V)), F) {
      var D = {
        depth: o.depth
      };
      return Se(o, "quoteStyle") && (D.quoteStyle = o.quoteStyle), r(B, D, i + 1, n);
    }
    return r(B, o, i + 1, n);
  }
  if (typeof e == "function" && !Pa(e)) {
    var d = hd(e), f = xi(e, p);
    return "[Function" + (d ? ": " + d : " (anonymous)") + "]" + (f.length > 0 ? " { " + ae.call(f, ", ") + " }" : "");
  }
  if (du(e)) {
    var y = Rr ? Re.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : Oo.call(e);
    return typeof e == "object" && !Rr ? Nr(y) : y;
  }
  if (fd(e)) {
    for (var m = "<" + Ea.call(String(e.nodeName)), _ = e.attributes || [], g = 0; g < _.length; g++)
      m += " " + _[g].name + "=" + pu(td(_[g].value), "double", o);
    return m += ">", e.childNodes && e.childNodes.length && (m += "..."), m += "</" + Ea.call(String(e.nodeName)) + ">", m;
  }
  if (Io(e)) {
    if (e.length === 0)
      return "[]";
    var b = xi(e, p);
    return c && !md(b) ? "[" + Po(b, c) + "]" : "[ " + ae.call(b, ", ") + " ]";
  }
  if (rd(e)) {
    var x = xi(e, p);
    return !("cause" in Error.prototype) && "cause" in e && !cu.call(e, "cause") ? "{ [" + String(e) + "] " + ae.call(Aa.call("[cause]: " + p(e.cause), x), ", ") + " }" : x.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + ae.call(x, ", ") + " }";
  }
  if (typeof e == "object" && s) {
    if (Ia && typeof e[Ia] == "function" && wo)
      return wo(e, { depth: l - i });
    if (s !== "symbol" && typeof e.inspect == "function")
      return e.inspect();
  }
  if (ud(e)) {
    var E = [];
    return ba && ba.call(e, function(B, V) {
      E.push(p(V, e, !0) + " => " + p(B, e));
    }), Ma("Map", on.call(e), E, c);
  }
  if (pd(e)) {
    var v = [];
    return xa && xa.call(e, function(B) {
      v.push(p(B, e));
    }), Ma("Set", sn.call(e), v, c);
  }
  if (ld(e))
    return Xn("WeakMap");
  if (dd(e))
    return Xn("WeakSet");
  if (cd(e))
    return Xn("WeakRef");
  if (nd(e))
    return Nr(p(Number(e)));
  if (sd(e))
    return Nr(p(Ro.call(e)));
  if (od(e))
    return Nr(Wp.call(e));
  if (id(e))
    return Nr(p(String(e)));
  if (!ed(e) && !Pa(e)) {
    var T = xi(e, p), S = Ra ? Ra(e) === Object.prototype : e instanceof Object || e.constructor === Object, R = e instanceof Object ? "" : "null prototype", O = !S && Gt && Object(e) === e && Gt in e ? Es.call(Fe(e), 8, -1) : R ? "Object" : "", w = S || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "", C = w + (O || R ? "[" + ae.call(Aa.call([], O || [], R || []), ": ") + "] " : "");
    return T.length === 0 ? C + "{}" : c ? C + "{" + Po(T, c) + "}" : C + "{ " + ae.call(T, ", ") + " }";
  }
  return String(e);
};
function pu(r, e, t) {
  var i = (t.quoteStyle || e) === "double" ? '"' : "'";
  return i + r + i;
}
function td(r) {
  return Re.call(String(r), /"/g, "&quot;");
}
function Io(r) {
  return Fe(r) === "[object Array]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function ed(r) {
  return Fe(r) === "[object Date]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function Pa(r) {
  return Fe(r) === "[object RegExp]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function rd(r) {
  return Fe(r) === "[object Error]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function id(r) {
  return Fe(r) === "[object String]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function nd(r) {
  return Fe(r) === "[object Number]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function od(r) {
  return Fe(r) === "[object Boolean]" && (!Gt || !(typeof r == "object" && Gt in r));
}
function du(r) {
  if (Rr)
    return r && typeof r == "object" && r instanceof Symbol;
  if (typeof r == "symbol")
    return !0;
  if (!r || typeof r != "object" || !Oo)
    return !1;
  try {
    return Oo.call(r), !0;
  } catch {
  }
  return !1;
}
function sd(r) {
  if (!r || typeof r != "object" || !Ro)
    return !1;
  try {
    return Ro.call(r), !0;
  } catch {
  }
  return !1;
}
var ad = Object.prototype.hasOwnProperty || function(r) {
  return r in this;
};
function Se(r, e) {
  return ad.call(r, e);
}
function Fe(r) {
  return $p.call(r);
}
function hd(r) {
  if (r.name)
    return r.name;
  var e = Kp.call(qp.call(r), /^function\s*([\w$]+)/);
  return e ? e[1] : null;
}
function fu(r, e) {
  if (r.indexOf)
    return r.indexOf(e);
  for (var t = 0, i = r.length; t < i; t++)
    if (r[t] === e)
      return t;
  return -1;
}
function ud(r) {
  if (!on || !r || typeof r != "object")
    return !1;
  try {
    on.call(r);
    try {
      sn.call(r);
    } catch {
      return !0;
    }
    return r instanceof Map;
  } catch {
  }
  return !1;
}
function ld(r) {
  if (!zr || !r || typeof r != "object")
    return !1;
  try {
    zr.call(r, zr);
    try {
      Wr.call(r, Wr);
    } catch {
      return !0;
    }
    return r instanceof WeakMap;
  } catch {
  }
  return !1;
}
function cd(r) {
  if (!Ta || !r || typeof r != "object")
    return !1;
  try {
    return Ta.call(r), !0;
  } catch {
  }
  return !1;
}
function pd(r) {
  if (!sn || !r || typeof r != "object")
    return !1;
  try {
    sn.call(r);
    try {
      on.call(r);
    } catch {
      return !0;
    }
    return r instanceof Set;
  } catch {
  }
  return !1;
}
function dd(r) {
  if (!Wr || !r || typeof r != "object")
    return !1;
  try {
    Wr.call(r, Wr);
    try {
      zr.call(r, zr);
    } catch {
      return !0;
    }
    return r instanceof WeakSet;
  } catch {
  }
  return !1;
}
function fd(r) {
  return !r || typeof r != "object" ? !1 : typeof HTMLElement < "u" && r instanceof HTMLElement ? !0 : typeof r.nodeName == "string" && typeof r.getAttribute == "function";
}
function yu(r, e) {
  if (r.length > e.maxStringLength) {
    var t = r.length - e.maxStringLength, i = "... " + t + " more character" + (t > 1 ? "s" : "");
    return yu(Es.call(r, 0, e.maxStringLength), e) + i;
  }
  var n = Re.call(Re.call(r, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, yd);
  return pu(n, "single", e);
}
function yd(r) {
  var e = r.charCodeAt(0), t = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[e];
  return t ? "\\" + t : "\\x" + (e < 16 ? "0" : "") + Zp.call(e.toString(16));
}
function Nr(r) {
  return "Object(" + r + ")";
}
function Xn(r) {
  return r + " { ? }";
}
function Ma(r, e, t, i) {
  var n = i ? Po(t, i) : ae.call(t, ", ");
  return r + " (" + e + ") {" + n + "}";
}
function md(r) {
  for (var e = 0; e < r.length; e++)
    if (fu(r[e], `
`) >= 0)
      return !1;
  return !0;
}
function _d(r, e) {
  var t;
  if (r.indent === "	")
    t = "	";
  else if (typeof r.indent == "number" && r.indent > 0)
    t = ae.call(Array(r.indent + 1), " ");
  else
    return null;
  return {
    base: t,
    prev: ae.call(Array(e + 1), t)
  };
}
function Po(r, e) {
  if (r.length === 0)
    return "";
  var t = `
` + e.prev + e.base;
  return t + ae.call(r, "," + t) + `
` + e.prev;
}
function xi(r, e) {
  var t = Io(r), i = [];
  if (t) {
    i.length = r.length;
    for (var n = 0; n < r.length; n++)
      i[n] = Se(r, n) ? e(r[n], r) : "";
  }
  var o = typeof kn == "function" ? kn(r) : [], s;
  if (Rr) {
    s = {};
    for (var a = 0; a < o.length; a++)
      s["$" + o[a]] = o[a];
  }
  for (var h in r)
    Se(r, h) && (t && String(Number(h)) === h && h < r.length || Rr && s["$" + h] instanceof Symbol || (lu.call(/[^\w$]/, h) ? i.push(e(h, r) + ": " + e(r[h], r)) : i.push(h + ": " + e(r[h], r))));
  if (typeof kn == "function")
    for (var u = 0; u < o.length; u++)
      cu.call(r, o[u]) && i.push("[" + e(o[u]) + "]: " + e(r[o[u]], r));
  return i;
}
var As = bs, Dr = kp, gd = Qp, vd = As("%TypeError%"), Ti = As("%WeakMap%", !0), Ei = As("%Map%", !0), bd = Dr("WeakMap.prototype.get", !0), xd = Dr("WeakMap.prototype.set", !0), Td = Dr("WeakMap.prototype.has", !0), Ed = Dr("Map.prototype.get", !0), Ad = Dr("Map.prototype.set", !0), Sd = Dr("Map.prototype.has", !0), Ss = function(r, e) {
  for (var t = r, i; (i = t.next) !== null; t = i)
    if (i.key === e)
      return t.next = i.next, i.next = r.next, r.next = i, i;
}, Rd = function(r, e) {
  var t = Ss(r, e);
  return t && t.value;
}, Od = function(r, e, t) {
  var i = Ss(r, e);
  i ? i.value = t : r.next = {
    // eslint-disable-line no-param-reassign
    key: e,
    next: r.next,
    value: t
  };
}, wd = function(r, e) {
  return !!Ss(r, e);
}, Id = function() {
  var r, e, t, i = {
    assert: function(n) {
      if (!i.has(n))
        throw new vd("Side channel does not contain " + gd(n));
    },
    get: function(n) {
      if (Ti && n && (typeof n == "object" || typeof n == "function")) {
        if (r)
          return bd(r, n);
      } else if (Ei) {
        if (e)
          return Ed(e, n);
      } else if (t)
        return Rd(t, n);
    },
    has: function(n) {
      if (Ti && n && (typeof n == "object" || typeof n == "function")) {
        if (r)
          return Td(r, n);
      } else if (Ei) {
        if (e)
          return Sd(e, n);
      } else if (t)
        return wd(t, n);
      return !1;
    },
    set: function(n, o) {
      Ti && n && (typeof n == "object" || typeof n == "function") ? (r || (r = new Ti()), xd(r, n, o)) : Ei ? (e || (e = new Ei()), Ad(e, n, o)) : (t || (t = { key: {}, next: null }), Od(t, n, o));
    }
  };
  return i;
}, Pd = String.prototype.replace, Md = /%20/g, jn = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, Rs = {
  default: jn.RFC3986,
  formatters: {
    RFC1738: function(r) {
      return Pd.call(r, Md, "+");
    },
    RFC3986: function(r) {
      return String(r);
    }
  },
  RFC1738: jn.RFC1738,
  RFC3986: jn.RFC3986
}, Dd = Rs, Hn = Object.prototype.hasOwnProperty, Ve = Array.isArray, se = function() {
  for (var r = [], e = 0; e < 256; ++e)
    r.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
  return r;
}(), Cd = function(r) {
  for (; r.length > 1; ) {
    var e = r.pop(), t = e.obj[e.prop];
    if (Ve(t)) {
      for (var i = [], n = 0; n < t.length; ++n)
        typeof t[n] < "u" && i.push(t[n]);
      e.obj[e.prop] = i;
    }
  }
}, mu = function(r, e) {
  for (var t = e && e.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < r.length; ++i)
    typeof r[i] < "u" && (t[i] = r[i]);
  return t;
}, Fd = function r(e, t, i) {
  if (!t)
    return e;
  if (typeof t != "object") {
    if (Ve(e))
      e.push(t);
    else if (e && typeof e == "object")
      (i && (i.plainObjects || i.allowPrototypes) || !Hn.call(Object.prototype, t)) && (e[t] = !0);
    else
      return [e, t];
    return e;
  }
  if (!e || typeof e != "object")
    return [e].concat(t);
  var n = e;
  return Ve(e) && !Ve(t) && (n = mu(e, i)), Ve(e) && Ve(t) ? (t.forEach(function(o, s) {
    if (Hn.call(e, s)) {
      var a = e[s];
      a && typeof a == "object" && o && typeof o == "object" ? e[s] = r(a, o, i) : e.push(o);
    } else
      e[s] = o;
  }), e) : Object.keys(t).reduce(function(o, s) {
    var a = t[s];
    return Hn.call(o, s) ? o[s] = r(o[s], a, i) : o[s] = a, o;
  }, n);
}, Nd = function(r, e) {
  return Object.keys(e).reduce(function(t, i) {
    return t[i] = e[i], t;
  }, r);
}, Ld = function(r, e, t) {
  var i = r.replace(/\+/g, " ");
  if (t === "iso-8859-1")
    return i.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(i);
  } catch {
    return i;
  }
}, Bd = function(r, e, t, i, n) {
  if (r.length === 0)
    return r;
  var o = r;
  if (typeof r == "symbol" ? o = Symbol.prototype.toString.call(r) : typeof r != "string" && (o = String(r)), t === "iso-8859-1")
    return escape(o).replace(/%u[0-9a-f]{4}/gi, function(u) {
      return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
    });
  for (var s = "", a = 0; a < o.length; ++a) {
    var h = o.charCodeAt(a);
    if (h === 45 || h === 46 || h === 95 || h === 126 || h >= 48 && h <= 57 || h >= 65 && h <= 90 || h >= 97 && h <= 122 || n === Dd.RFC1738 && (h === 40 || h === 41)) {
      s += o.charAt(a);
      continue;
    }
    if (h < 128) {
      s = s + se[h];
      continue;
    }
    if (h < 2048) {
      s = s + (se[192 | h >> 6] + se[128 | h & 63]);
      continue;
    }
    if (h < 55296 || h >= 57344) {
      s = s + (se[224 | h >> 12] + se[128 | h >> 6 & 63] + se[128 | h & 63]);
      continue;
    }
    a += 1, h = 65536 + ((h & 1023) << 10 | o.charCodeAt(a) & 1023), s += se[240 | h >> 18] + se[128 | h >> 12 & 63] + se[128 | h >> 6 & 63] + se[128 | h & 63];
  }
  return s;
}, Gd = function(r) {
  for (var e = [{ obj: { o: r }, prop: "o" }], t = [], i = 0; i < e.length; ++i)
    for (var n = e[i], o = n.obj[n.prop], s = Object.keys(o), a = 0; a < s.length; ++a) {
      var h = s[a], u = o[h];
      typeof u == "object" && u !== null && t.indexOf(u) === -1 && (e.push({ obj: o, prop: h }), t.push(u));
    }
  return Cd(e), r;
}, Ud = function(r) {
  return Object.prototype.toString.call(r) === "[object RegExp]";
}, kd = function(r) {
  return !r || typeof r != "object" ? !1 : !!(r.constructor && r.constructor.isBuffer && r.constructor.isBuffer(r));
}, Xd = function(r, e) {
  return [].concat(r, e);
}, jd = function(r, e) {
  if (Ve(r)) {
    for (var t = [], i = 0; i < r.length; i += 1)
      t.push(e(r[i]));
    return t;
  }
  return e(r);
}, _u = {
  arrayToObject: mu,
  assign: Nd,
  combine: Xd,
  compact: Gd,
  decode: Ld,
  encode: Bd,
  isBuffer: kd,
  isRegExp: Ud,
  maybeMap: jd,
  merge: Fd
}, gu = Id, Wi = _u, $r = Rs, Hd = Object.prototype.hasOwnProperty, Da = {
  brackets: function(r) {
    return r + "[]";
  },
  comma: "comma",
  indices: function(r, e) {
    return r + "[" + e + "]";
  },
  repeat: function(r) {
    return r;
  }
}, _e = Array.isArray, Yd = Array.prototype.push, vu = function(r, e) {
  Yd.apply(r, _e(e) ? e : [e]);
}, Vd = Date.prototype.toISOString, Ca = $r.default, Bt = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: Wi.encode,
  encodeValuesOnly: !1,
  format: Ca,
  formatter: $r.formatters[Ca],
  // deprecated
  indices: !1,
  serializeDate: function(r) {
    return Vd.call(r);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, zd = function(r) {
  return typeof r == "string" || typeof r == "number" || typeof r == "boolean" || typeof r == "symbol" || typeof r == "bigint";
}, Yn = {}, Wd = function r(e, t, i, n, o, s, a, h, u, l, c, p, d, f, y, m) {
  for (var _ = e, g = m, b = 0, x = !1; (g = g.get(Yn)) !== void 0 && !x; ) {
    var E = g.get(e);
    if (b += 1, typeof E < "u") {
      if (E === b)
        throw new RangeError("Cyclic object value");
      x = !0;
    }
    typeof g.get(Yn) > "u" && (b = 0);
  }
  if (typeof h == "function" ? _ = h(t, _) : _ instanceof Date ? _ = c(_) : i === "comma" && _e(_) && (_ = Wi.maybeMap(_, function(D) {
    return D instanceof Date ? c(D) : D;
  })), _ === null) {
    if (o)
      return a && !f ? a(t, Bt.encoder, y, "key", p) : t;
    _ = "";
  }
  if (zd(_) || Wi.isBuffer(_)) {
    if (a) {
      var v = f ? t : a(t, Bt.encoder, y, "key", p);
      return [d(v) + "=" + d(a(_, Bt.encoder, y, "value", p))];
    }
    return [d(t) + "=" + d(String(_))];
  }
  var T = [];
  if (typeof _ > "u")
    return T;
  var S;
  if (i === "comma" && _e(_))
    f && a && (_ = Wi.maybeMap(_, a)), S = [{ value: _.length > 0 ? _.join(",") || null : void 0 }];
  else if (_e(h))
    S = h;
  else {
    var R = Object.keys(_);
    S = u ? R.sort(u) : R;
  }
  for (var O = n && _e(_) && _.length === 1 ? t + "[]" : t, w = 0; w < S.length; ++w) {
    var C = S[w], B = typeof C == "object" && typeof C.value < "u" ? C.value : _[C];
    if (!(s && B === null)) {
      var V = _e(_) ? typeof i == "function" ? i(O, C) : O : O + (l ? "." + C : "[" + C + "]");
      m.set(e, b);
      var F = gu();
      F.set(Yn, m), vu(T, r(
        B,
        V,
        i,
        n,
        o,
        s,
        i === "comma" && f && _e(_) ? null : a,
        h,
        u,
        l,
        c,
        p,
        d,
        f,
        y,
        F
      ));
    }
  }
  return T;
}, $d = function(r) {
  if (!r)
    return Bt;
  if (r.encoder !== null && typeof r.encoder < "u" && typeof r.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var e = r.charset || Bt.charset;
  if (typeof r.charset < "u" && r.charset !== "utf-8" && r.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var t = $r.default;
  if (typeof r.format < "u") {
    if (!Hd.call($r.formatters, r.format))
      throw new TypeError("Unknown format option provided.");
    t = r.format;
  }
  var i = $r.formatters[t], n = Bt.filter;
  return (typeof r.filter == "function" || _e(r.filter)) && (n = r.filter), {
    addQueryPrefix: typeof r.addQueryPrefix == "boolean" ? r.addQueryPrefix : Bt.addQueryPrefix,
    allowDots: typeof r.allowDots > "u" ? Bt.allowDots : !!r.allowDots,
    charset: e,
    charsetSentinel: typeof r.charsetSentinel == "boolean" ? r.charsetSentinel : Bt.charsetSentinel,
    delimiter: typeof r.delimiter > "u" ? Bt.delimiter : r.delimiter,
    encode: typeof r.encode == "boolean" ? r.encode : Bt.encode,
    encoder: typeof r.encoder == "function" ? r.encoder : Bt.encoder,
    encodeValuesOnly: typeof r.encodeValuesOnly == "boolean" ? r.encodeValuesOnly : Bt.encodeValuesOnly,
    filter: n,
    format: t,
    formatter: i,
    serializeDate: typeof r.serializeDate == "function" ? r.serializeDate : Bt.serializeDate,
    skipNulls: typeof r.skipNulls == "boolean" ? r.skipNulls : Bt.skipNulls,
    sort: typeof r.sort == "function" ? r.sort : null,
    strictNullHandling: typeof r.strictNullHandling == "boolean" ? r.strictNullHandling : Bt.strictNullHandling
  };
}, qd = function(r, e) {
  var t = r, i = $d(e), n, o;
  typeof i.filter == "function" ? (o = i.filter, t = o("", t)) : _e(i.filter) && (o = i.filter, n = o);
  var s = [];
  if (typeof t != "object" || t === null)
    return "";
  var a;
  e && e.arrayFormat in Da ? a = e.arrayFormat : e && "indices" in e ? a = e.indices ? "indices" : "repeat" : a = "indices";
  var h = Da[a];
  if (e && "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var u = h === "comma" && e && e.commaRoundTrip;
  n || (n = Object.keys(t)), i.sort && n.sort(i.sort);
  for (var l = gu(), c = 0; c < n.length; ++c) {
    var p = n[c];
    i.skipNulls && t[p] === null || vu(s, Wd(
      t[p],
      p,
      h,
      u,
      i.strictNullHandling,
      i.skipNulls,
      i.encode ? i.encoder : null,
      i.filter,
      i.sort,
      i.allowDots,
      i.serializeDate,
      i.format,
      i.formatter,
      i.encodeValuesOnly,
      i.charset,
      l
    ));
  }
  var d = s.join(i.delimiter), f = i.addQueryPrefix === !0 ? "?" : "";
  return i.charsetSentinel && (i.charset === "iso-8859-1" ? f += "utf8=%26%2310003%3B&" : f += "utf8=%E2%9C%93&"), d.length > 0 ? f + d : "";
}, Or = _u, Mo = Object.prototype.hasOwnProperty, Kd = Array.isArray, Pt = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: Or.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, Zd = function(r) {
  return r.replace(/&#(\d+);/g, function(e, t) {
    return String.fromCharCode(parseInt(t, 10));
  });
}, bu = function(r, e) {
  return r && typeof r == "string" && e.comma && r.indexOf(",") > -1 ? r.split(",") : r;
}, Jd = "utf8=%26%2310003%3B", Qd = "utf8=%E2%9C%93", tf = function(r, e) {
  var t = { __proto__: null }, i = e.ignoreQueryPrefix ? r.replace(/^\?/, "") : r, n = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, o = i.split(e.delimiter, n), s = -1, a, h = e.charset;
  if (e.charsetSentinel)
    for (a = 0; a < o.length; ++a)
      o[a].indexOf("utf8=") === 0 && (o[a] === Qd ? h = "utf-8" : o[a] === Jd && (h = "iso-8859-1"), s = a, a = o.length);
  for (a = 0; a < o.length; ++a)
    if (a !== s) {
      var u = o[a], l = u.indexOf("]="), c = l === -1 ? u.indexOf("=") : l + 1, p, d;
      c === -1 ? (p = e.decoder(u, Pt.decoder, h, "key"), d = e.strictNullHandling ? null : "") : (p = e.decoder(u.slice(0, c), Pt.decoder, h, "key"), d = Or.maybeMap(
        bu(u.slice(c + 1), e),
        function(f) {
          return e.decoder(f, Pt.decoder, h, "value");
        }
      )), d && e.interpretNumericEntities && h === "iso-8859-1" && (d = Zd(d)), u.indexOf("[]=") > -1 && (d = Kd(d) ? [d] : d), Mo.call(t, p) ? t[p] = Or.combine(t[p], d) : t[p] = d;
    }
  return t;
}, ef = function(r, e, t, i) {
  for (var n = i ? e : bu(e, t), o = r.length - 1; o >= 0; --o) {
    var s, a = r[o];
    if (a === "[]" && t.parseArrays)
      s = [].concat(n);
    else {
      s = t.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var h = a.charAt(0) === "[" && a.charAt(a.length - 1) === "]" ? a.slice(1, -1) : a, u = parseInt(h, 10);
      !t.parseArrays && h === "" ? s = { 0: n } : !isNaN(u) && a !== h && String(u) === h && u >= 0 && t.parseArrays && u <= t.arrayLimit ? (s = [], s[u] = n) : h !== "__proto__" && (s[h] = n);
    }
    n = s;
  }
  return n;
}, rf = function(r, e, t, i) {
  if (r) {
    var n = t.allowDots ? r.replace(/\.([^.[]+)/g, "[$1]") : r, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, a = t.depth > 0 && o.exec(n), h = a ? n.slice(0, a.index) : n, u = [];
    if (h) {
      if (!t.plainObjects && Mo.call(Object.prototype, h) && !t.allowPrototypes)
        return;
      u.push(h);
    }
    for (var l = 0; t.depth > 0 && (a = s.exec(n)) !== null && l < t.depth; ) {
      if (l += 1, !t.plainObjects && Mo.call(Object.prototype, a[1].slice(1, -1)) && !t.allowPrototypes)
        return;
      u.push(a[1]);
    }
    return a && u.push("[" + n.slice(a.index) + "]"), ef(u, e, t, i);
  }
}, nf = function(r) {
  if (!r)
    return Pt;
  if (r.decoder !== null && r.decoder !== void 0 && typeof r.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof r.charset < "u" && r.charset !== "utf-8" && r.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var e = typeof r.charset > "u" ? Pt.charset : r.charset;
  return {
    allowDots: typeof r.allowDots > "u" ? Pt.allowDots : !!r.allowDots,
    allowPrototypes: typeof r.allowPrototypes == "boolean" ? r.allowPrototypes : Pt.allowPrototypes,
    allowSparse: typeof r.allowSparse == "boolean" ? r.allowSparse : Pt.allowSparse,
    arrayLimit: typeof r.arrayLimit == "number" ? r.arrayLimit : Pt.arrayLimit,
    charset: e,
    charsetSentinel: typeof r.charsetSentinel == "boolean" ? r.charsetSentinel : Pt.charsetSentinel,
    comma: typeof r.comma == "boolean" ? r.comma : Pt.comma,
    decoder: typeof r.decoder == "function" ? r.decoder : Pt.decoder,
    delimiter: typeof r.delimiter == "string" || Or.isRegExp(r.delimiter) ? r.delimiter : Pt.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof r.depth == "number" || r.depth === !1 ? +r.depth : Pt.depth,
    ignoreQueryPrefix: r.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof r.interpretNumericEntities == "boolean" ? r.interpretNumericEntities : Pt.interpretNumericEntities,
    parameterLimit: typeof r.parameterLimit == "number" ? r.parameterLimit : Pt.parameterLimit,
    parseArrays: r.parseArrays !== !1,
    plainObjects: typeof r.plainObjects == "boolean" ? r.plainObjects : Pt.plainObjects,
    strictNullHandling: typeof r.strictNullHandling == "boolean" ? r.strictNullHandling : Pt.strictNullHandling
  };
}, of = function(r, e) {
  var t = nf(e);
  if (r === "" || r === null || typeof r > "u")
    return t.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i = typeof r == "string" ? tf(r, t) : r, n = t.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, o = Object.keys(i), s = 0; s < o.length; ++s) {
    var a = o[s], h = rf(a, i[a], t, typeof r == "string");
    n = Or.merge(n, h, t);
  }
  return t.allowSparse === !0 ? n : Or.compact(n);
}, sf = qd, af = of, hf = Rs, uf = {
  formats: hf,
  parse: af,
  stringify: sf
}, lf = fp;
function ee() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
var cf = /^([a-z0-9.+-]+:)/i, pf = /:[0-9]*$/, df = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, ff = [
  "<",
  ">",
  '"',
  "`",
  " ",
  "\r",
  `
`,
  "	"
], yf = [
  "{",
  "}",
  "|",
  "\\",
  "^",
  "`"
].concat(ff), Do = ["'"].concat(yf), Fa = [
  "%",
  "/",
  "?",
  ";",
  "#"
].concat(Do), Na = [
  "/",
  "?",
  "#"
], mf = 255, La = /^[+a-z0-9A-Z_-]{0,63}$/, _f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, gf = {
  javascript: !0,
  "javascript:": !0
}, Co = {
  javascript: !0,
  "javascript:": !0
}, Tr = {
  http: !0,
  https: !0,
  ftp: !0,
  gopher: !0,
  file: !0,
  "http:": !0,
  "https:": !0,
  "ftp:": !0,
  "gopher:": !0,
  "file:": !0
}, Fo = uf;
function bn(r, e, t) {
  if (r && typeof r == "object" && r instanceof ee)
    return r;
  var i = new ee();
  return i.parse(r, e, t), i;
}
ee.prototype.parse = function(r, e, t) {
  if (typeof r != "string")
    throw new TypeError("Parameter 'url' must be a string, not " + typeof r);
  var i = r.indexOf("?"), n = i !== -1 && i < r.indexOf("#") ? "?" : "#", o = r.split(n), s = /\\/g;
  o[0] = o[0].replace(s, "/"), r = o.join(n);
  var a = r;
  if (a = a.trim(), !t && r.split("#").length === 1) {
    var h = df.exec(a);
    if (h)
      return this.path = a, this.href = a, this.pathname = h[1], h[2] ? (this.search = h[2], e ? this.query = Fo.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : e && (this.search = "", this.query = {}), this;
  }
  var u = cf.exec(a);
  if (u) {
    u = u[0];
    var l = u.toLowerCase();
    this.protocol = l, a = a.substr(u.length);
  }
  if (t || u || a.match(/^\/\/[^@/]+@[^@/]+/)) {
    var c = a.substr(0, 2) === "//";
    c && !(u && Co[u]) && (a = a.substr(2), this.slashes = !0);
  }
  if (!Co[u] && (c || u && !Tr[u])) {
    for (var p = -1, d = 0; d < Na.length; d++) {
      var f = a.indexOf(Na[d]);
      f !== -1 && (p === -1 || f < p) && (p = f);
    }
    var y, m;
    p === -1 ? m = a.lastIndexOf("@") : m = a.lastIndexOf("@", p), m !== -1 && (y = a.slice(0, m), a = a.slice(m + 1), this.auth = decodeURIComponent(y)), p = -1;
    for (var d = 0; d < Fa.length; d++) {
      var f = a.indexOf(Fa[d]);
      f !== -1 && (p === -1 || f < p) && (p = f);
    }
    p === -1 && (p = a.length), this.host = a.slice(0, p), a = a.slice(p), this.parseHost(), this.hostname = this.hostname || "";
    var _ = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!_)
      for (var g = this.hostname.split(/\./), d = 0, b = g.length; d < b; d++) {
        var x = g[d];
        if (x && !x.match(La)) {
          for (var E = "", v = 0, T = x.length; v < T; v++)
            x.charCodeAt(v) > 127 ? E += "x" : E += x[v];
          if (!E.match(La)) {
            var S = g.slice(0, d), R = g.slice(d + 1), O = x.match(_f);
            O && (S.push(O[1]), R.unshift(O[2])), R.length && (a = "/" + R.join(".") + a), this.hostname = S.join(".");
            break;
          }
        }
      }
    this.hostname.length > mf ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), _ || (this.hostname = lf.toASCII(this.hostname));
    var w = this.port ? ":" + this.port : "", C = this.hostname || "";
    this.host = C + w, this.href += this.host, _ && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a));
  }
  if (!gf[l])
    for (var d = 0, b = Do.length; d < b; d++) {
      var B = Do[d];
      if (a.indexOf(B) !== -1) {
        var V = encodeURIComponent(B);
        V === B && (V = escape(B)), a = a.split(B).join(V);
      }
    }
  var F = a.indexOf("#");
  F !== -1 && (this.hash = a.substr(F), a = a.slice(0, F));
  var D = a.indexOf("?");
  if (D !== -1 ? (this.search = a.substr(D), this.query = a.substr(D + 1), e && (this.query = Fo.parse(this.query)), a = a.slice(0, D)) : e && (this.search = "", this.query = {}), a && (this.pathname = a), Tr[l] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    var w = this.pathname || "", z = this.search || "";
    this.path = w + z;
  }
  return this.href = this.format(), this;
};
function vf(r) {
  return typeof r == "string" && (r = bn(r)), r instanceof ee ? r.format() : ee.prototype.format.call(r);
}
ee.prototype.format = function() {
  var r = this.auth || "";
  r && (r = encodeURIComponent(r), r = r.replace(/%3A/i, ":"), r += "@");
  var e = this.protocol || "", t = this.pathname || "", i = this.hash || "", n = !1, o = "";
  this.host ? n = r + this.host : this.hostname && (n = r + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (o = Fo.stringify(this.query, {
    arrayFormat: "repeat",
    addQueryPrefix: !1
  }));
  var s = this.search || o && "?" + o || "";
  return e && e.substr(-1) !== ":" && (e += ":"), this.slashes || (!e || Tr[e]) && n !== !1 ? (n = "//" + (n || ""), t && t.charAt(0) !== "/" && (t = "/" + t)) : n || (n = ""), i && i.charAt(0) !== "#" && (i = "#" + i), s && s.charAt(0) !== "?" && (s = "?" + s), t = t.replace(/[?#]/g, function(a) {
    return encodeURIComponent(a);
  }), s = s.replace("#", "%23"), e + n + t + s + i;
};
function bf(r, e) {
  return bn(r, !1, !0).resolve(e);
}
ee.prototype.resolve = function(r) {
  return this.resolveObject(bn(r, !1, !0)).format();
};
ee.prototype.resolveObject = function(r) {
  if (typeof r == "string") {
    var e = new ee();
    e.parse(r, !1, !0), r = e;
  }
  for (var t = new ee(), i = Object.keys(this), n = 0; n < i.length; n++) {
    var o = i[n];
    t[o] = this[o];
  }
  if (t.hash = r.hash, r.href === "")
    return t.href = t.format(), t;
  if (r.slashes && !r.protocol) {
    for (var s = Object.keys(r), a = 0; a < s.length; a++) {
      var h = s[a];
      h !== "protocol" && (t[h] = r[h]);
    }
    return Tr[t.protocol] && t.hostname && !t.pathname && (t.pathname = "/", t.path = t.pathname), t.href = t.format(), t;
  }
  if (r.protocol && r.protocol !== t.protocol) {
    if (!Tr[r.protocol]) {
      for (var u = Object.keys(r), l = 0; l < u.length; l++) {
        var c = u[l];
        t[c] = r[c];
      }
      return t.href = t.format(), t;
    }
    if (t.protocol = r.protocol, !r.host && !Co[r.protocol]) {
      for (var b = (r.pathname || "").split("/"); b.length && !(r.host = b.shift()); )
        ;
      r.host || (r.host = ""), r.hostname || (r.hostname = ""), b[0] !== "" && b.unshift(""), b.length < 2 && b.unshift(""), t.pathname = b.join("/");
    } else
      t.pathname = r.pathname;
    if (t.search = r.search, t.query = r.query, t.host = r.host || "", t.auth = r.auth, t.hostname = r.hostname || r.host, t.port = r.port, t.pathname || t.search) {
      var p = t.pathname || "", d = t.search || "";
      t.path = p + d;
    }
    return t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
  }
  var f = t.pathname && t.pathname.charAt(0) === "/", y = r.host || r.pathname && r.pathname.charAt(0) === "/", m = y || f || t.host && r.pathname, _ = m, g = t.pathname && t.pathname.split("/") || [], b = r.pathname && r.pathname.split("/") || [], x = t.protocol && !Tr[t.protocol];
  if (x && (t.hostname = "", t.port = null, t.host && (g[0] === "" ? g[0] = t.host : g.unshift(t.host)), t.host = "", r.protocol && (r.hostname = null, r.port = null, r.host && (b[0] === "" ? b[0] = r.host : b.unshift(r.host)), r.host = null), m = m && (b[0] === "" || g[0] === "")), y)
    t.host = r.host || r.host === "" ? r.host : t.host, t.hostname = r.hostname || r.hostname === "" ? r.hostname : t.hostname, t.search = r.search, t.query = r.query, g = b;
  else if (b.length)
    g || (g = []), g.pop(), g = g.concat(b), t.search = r.search, t.query = r.query;
  else if (r.search != null) {
    if (x) {
      t.host = g.shift(), t.hostname = t.host;
      var E = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
      E && (t.auth = E.shift(), t.hostname = E.shift(), t.host = t.hostname);
    }
    return t.search = r.search, t.query = r.query, (t.pathname !== null || t.search !== null) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
  }
  if (!g.length)
    return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
  for (var v = g.slice(-1)[0], T = (t.host || r.host || g.length > 1) && (v === "." || v === "..") || v === "", S = 0, R = g.length; R >= 0; R--)
    v = g[R], v === "." ? g.splice(R, 1) : v === ".." ? (g.splice(R, 1), S++) : S && (g.splice(R, 1), S--);
  if (!m && !_)
    for (; S--; S)
      g.unshift("..");
  m && g[0] !== "" && (!g[0] || g[0].charAt(0) !== "/") && g.unshift(""), T && g.join("/").substr(-1) !== "/" && g.push("");
  var O = g[0] === "" || g[0] && g[0].charAt(0) === "/";
  if (x) {
    t.hostname = O ? "" : g.length ? g.shift() : "", t.host = t.hostname;
    var E = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : !1;
    E && (t.auth = E.shift(), t.hostname = E.shift(), t.host = t.hostname);
  }
  return m = m || t.host && g.length, m && !O && g.unshift(""), g.length > 0 ? t.pathname = g.join("/") : (t.pathname = null, t.path = null), (t.pathname !== null || t.search !== null) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = r.auth || t.auth, t.slashes = t.slashes || r.slashes, t.href = t.format(), t;
};
ee.prototype.parseHost = function() {
  var r = this.host, e = pf.exec(r);
  e && (e = e[0], e !== ":" && (this.port = e.substr(1)), r = r.substr(0, r.length - e.length)), r && (this.hostname = r);
};
var xf = bn, Tf = bf, Ef = vf;
/*!
 * @pixi/utils - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var mr = {
  parse: xf,
  format: Ef,
  resolve: Tf
};
L.RETINA_PREFIX = /@([0-9\.]+)x/;
L.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var Ba = !1, Ga = "6.5.10";
function Af(r) {
  var e;
  if (!Ba) {
    if (L.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var t = [
        `
 %c %c %c PixiJS ` + Ga + " - ✰ " + r + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (e = globalThis.console).log.apply(e, t);
    } else
      globalThis.console && globalThis.console.log("PixiJS " + Ga + " - " + r + " - http://www.pixijs.com/");
    Ba = !0;
  }
}
var Vn;
function Sf() {
  return typeof Vn > "u" && (Vn = function() {
    var r = {
      stencil: !0,
      failIfMajorPerformanceCaveat: L.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!L.ADAPTER.getWebGLRenderingContext())
        return !1;
      var e = L.ADAPTER.createCanvas(), t = e.getContext("webgl", r) || e.getContext("experimental-webgl", r), i = !!(t && t.getContextAttributes().stencil);
      if (t) {
        var n = t.getExtension("WEBGL_lose_context");
        n && n.loseContext();
      }
      return t = null, i;
    } catch {
      return !1;
    }
  }()), Vn;
}
var Rf = "#f0f8ff", Of = "#faebd7", wf = "#00ffff", If = "#7fffd4", Pf = "#f0ffff", Mf = "#f5f5dc", Df = "#ffe4c4", Cf = "#000000", Ff = "#ffebcd", Nf = "#0000ff", Lf = "#8a2be2", Bf = "#a52a2a", Gf = "#deb887", Uf = "#5f9ea0", kf = "#7fff00", Xf = "#d2691e", jf = "#ff7f50", Hf = "#6495ed", Yf = "#fff8dc", Vf = "#dc143c", zf = "#00ffff", Wf = "#00008b", $f = "#008b8b", qf = "#b8860b", Kf = "#a9a9a9", Zf = "#006400", Jf = "#a9a9a9", Qf = "#bdb76b", ty = "#8b008b", ey = "#556b2f", ry = "#ff8c00", iy = "#9932cc", ny = "#8b0000", oy = "#e9967a", sy = "#8fbc8f", ay = "#483d8b", hy = "#2f4f4f", uy = "#2f4f4f", ly = "#00ced1", cy = "#9400d3", py = "#ff1493", dy = "#00bfff", fy = "#696969", yy = "#696969", my = "#1e90ff", _y = "#b22222", gy = "#fffaf0", vy = "#228b22", by = "#ff00ff", xy = "#dcdcdc", Ty = "#f8f8ff", Ey = "#daa520", Ay = "#ffd700", Sy = "#808080", Ry = "#008000", Oy = "#adff2f", wy = "#808080", Iy = "#f0fff0", Py = "#ff69b4", My = "#cd5c5c", Dy = "#4b0082", Cy = "#fffff0", Fy = "#f0e68c", Ny = "#fff0f5", Ly = "#e6e6fa", By = "#7cfc00", Gy = "#fffacd", Uy = "#add8e6", ky = "#f08080", Xy = "#e0ffff", jy = "#fafad2", Hy = "#d3d3d3", Yy = "#90ee90", Vy = "#d3d3d3", zy = "#ffb6c1", Wy = "#ffa07a", $y = "#20b2aa", qy = "#87cefa", Ky = "#778899", Zy = "#778899", Jy = "#b0c4de", Qy = "#ffffe0", tm = "#00ff00", em = "#32cd32", rm = "#faf0e6", im = "#ff00ff", nm = "#800000", om = "#66cdaa", sm = "#0000cd", am = "#ba55d3", hm = "#9370db", um = "#3cb371", lm = "#7b68ee", cm = "#00fa9a", pm = "#48d1cc", dm = "#c71585", fm = "#191970", ym = "#f5fffa", mm = "#ffe4e1", _m = "#ffe4b5", gm = "#ffdead", vm = "#000080", bm = "#fdf5e6", xm = "#808000", Tm = "#6b8e23", Em = "#ffa500", Am = "#ff4500", Sm = "#da70d6", Rm = "#eee8aa", Om = "#98fb98", wm = "#afeeee", Im = "#db7093", Pm = "#ffefd5", Mm = "#ffdab9", Dm = "#cd853f", Cm = "#ffc0cb", Fm = "#dda0dd", Nm = "#b0e0e6", Lm = "#800080", Bm = "#663399", Gm = "#ff0000", Um = "#bc8f8f", km = "#4169e1", Xm = "#8b4513", jm = "#fa8072", Hm = "#f4a460", Ym = "#2e8b57", Vm = "#fff5ee", zm = "#a0522d", Wm = "#c0c0c0", $m = "#87ceeb", qm = "#6a5acd", Km = "#708090", Zm = "#708090", Jm = "#fffafa", Qm = "#00ff7f", t_ = "#4682b4", e_ = "#d2b48c", r_ = "#008080", i_ = "#d8bfd8", n_ = "#ff6347", o_ = "#40e0d0", s_ = "#ee82ee", a_ = "#f5deb3", h_ = "#ffffff", u_ = "#f5f5f5", l_ = "#ffff00", c_ = "#9acd32", p_ = {
  aliceblue: Rf,
  antiquewhite: Of,
  aqua: wf,
  aquamarine: If,
  azure: Pf,
  beige: Mf,
  bisque: Df,
  black: Cf,
  blanchedalmond: Ff,
  blue: Nf,
  blueviolet: Lf,
  brown: Bf,
  burlywood: Gf,
  cadetblue: Uf,
  chartreuse: kf,
  chocolate: Xf,
  coral: jf,
  cornflowerblue: Hf,
  cornsilk: Yf,
  crimson: Vf,
  cyan: zf,
  darkblue: Wf,
  darkcyan: $f,
  darkgoldenrod: qf,
  darkgray: Kf,
  darkgreen: Zf,
  darkgrey: Jf,
  darkkhaki: Qf,
  darkmagenta: ty,
  darkolivegreen: ey,
  darkorange: ry,
  darkorchid: iy,
  darkred: ny,
  darksalmon: oy,
  darkseagreen: sy,
  darkslateblue: ay,
  darkslategray: hy,
  darkslategrey: uy,
  darkturquoise: ly,
  darkviolet: cy,
  deeppink: py,
  deepskyblue: dy,
  dimgray: fy,
  dimgrey: yy,
  dodgerblue: my,
  firebrick: _y,
  floralwhite: gy,
  forestgreen: vy,
  fuchsia: by,
  gainsboro: xy,
  ghostwhite: Ty,
  goldenrod: Ey,
  gold: Ay,
  gray: Sy,
  green: Ry,
  greenyellow: Oy,
  grey: wy,
  honeydew: Iy,
  hotpink: Py,
  indianred: My,
  indigo: Dy,
  ivory: Cy,
  khaki: Fy,
  lavenderblush: Ny,
  lavender: Ly,
  lawngreen: By,
  lemonchiffon: Gy,
  lightblue: Uy,
  lightcoral: ky,
  lightcyan: Xy,
  lightgoldenrodyellow: jy,
  lightgray: Hy,
  lightgreen: Yy,
  lightgrey: Vy,
  lightpink: zy,
  lightsalmon: Wy,
  lightseagreen: $y,
  lightskyblue: qy,
  lightslategray: Ky,
  lightslategrey: Zy,
  lightsteelblue: Jy,
  lightyellow: Qy,
  lime: tm,
  limegreen: em,
  linen: rm,
  magenta: im,
  maroon: nm,
  mediumaquamarine: om,
  mediumblue: sm,
  mediumorchid: am,
  mediumpurple: hm,
  mediumseagreen: um,
  mediumslateblue: lm,
  mediumspringgreen: cm,
  mediumturquoise: pm,
  mediumvioletred: dm,
  midnightblue: fm,
  mintcream: ym,
  mistyrose: mm,
  moccasin: _m,
  navajowhite: gm,
  navy: vm,
  oldlace: bm,
  olive: xm,
  olivedrab: Tm,
  orange: Em,
  orangered: Am,
  orchid: Sm,
  palegoldenrod: Rm,
  palegreen: Om,
  paleturquoise: wm,
  palevioletred: Im,
  papayawhip: Pm,
  peachpuff: Mm,
  peru: Dm,
  pink: Cm,
  plum: Fm,
  powderblue: Nm,
  purple: Lm,
  rebeccapurple: Bm,
  red: Gm,
  rosybrown: Um,
  royalblue: km,
  saddlebrown: Xm,
  salmon: jm,
  sandybrown: Hm,
  seagreen: Ym,
  seashell: Vm,
  sienna: zm,
  silver: Wm,
  skyblue: $m,
  slateblue: qm,
  slategray: Km,
  slategrey: Zm,
  snow: Jm,
  springgreen: Qm,
  steelblue: t_,
  tan: e_,
  teal: r_,
  thistle: i_,
  tomato: n_,
  turquoise: o_,
  violet: s_,
  wheat: a_,
  white: h_,
  whitesmoke: u_,
  yellow: l_,
  yellowgreen: c_
};
function wr(r, e) {
  return e === void 0 && (e = []), e[0] = (r >> 16 & 255) / 255, e[1] = (r >> 8 & 255) / 255, e[2] = (r & 255) / 255, e;
}
function xu(r) {
  var e = r.toString(16);
  return e = "000000".substring(0, 6 - e.length) + e, "#" + e;
}
function Ir(r) {
  return typeof r == "string" && (r = p_[r.toLowerCase()] || r, r[0] === "#" && (r = r.slice(1))), parseInt(r, 16);
}
function d_() {
  for (var r = [], e = [], t = 0; t < 32; t++)
    r[t] = t, e[t] = t;
  r[k.NORMAL_NPM] = k.NORMAL, r[k.ADD_NPM] = k.ADD, r[k.SCREEN_NPM] = k.SCREEN, e[k.NORMAL] = k.NORMAL_NPM, e[k.ADD] = k.ADD_NPM, e[k.SCREEN] = k.SCREEN_NPM;
  var i = [];
  return i.push(e), i.push(r), i;
}
var Tu = d_();
function Eu(r, e) {
  return Tu[e ? 1 : 0][r];
}
function f_(r, e, t, i) {
  return t = t || new Float32Array(4), i || i === void 0 ? (t[0] = r[0] * e, t[1] = r[1] * e, t[2] = r[2] * e) : (t[0] = r[0], t[1] = r[1], t[2] = r[2]), t[3] = e, t;
}
function Os(r, e) {
  if (e === 1)
    return (e * 255 << 24) + r;
  if (e === 0)
    return 0;
  var t = r >> 16 & 255, i = r >> 8 & 255, n = r & 255;
  return t = t * e + 0.5 | 0, i = i * e + 0.5 | 0, n = n * e + 0.5 | 0, (e * 255 << 24) + (t << 16) + (i << 8) + n;
}
function Au(r, e, t, i) {
  return t = t || new Float32Array(4), t[0] = (r >> 16 & 255) / 255, t[1] = (r >> 8 & 255) / 255, t[2] = (r & 255) / 255, (i || i === void 0) && (t[0] *= e, t[1] *= e, t[2] *= e), t[3] = e, t;
}
function y_(r, e) {
  e === void 0 && (e = null);
  var t = r * 6;
  if (e = e || new Uint16Array(t), e.length !== t)
    throw new Error("Out buffer length is incorrect, got " + e.length + " and expected " + t);
  for (var i = 0, n = 0; i < t; i += 6, n += 4)
    e[i + 0] = n + 0, e[i + 1] = n + 1, e[i + 2] = n + 2, e[i + 3] = n + 0, e[i + 4] = n + 2, e[i + 5] = n + 3;
  return e;
}
function Su(r) {
  if (r.BYTES_PER_ELEMENT === 4)
    return r instanceof Float32Array ? "Float32Array" : r instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (r.BYTES_PER_ELEMENT === 2) {
    if (r instanceof Uint16Array)
      return "Uint16Array";
  } else if (r.BYTES_PER_ELEMENT === 1 && r instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function an(r) {
  return r += r === 0 ? 1 : 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;
}
function Ua(r) {
  return !(r & r - 1) && !!r;
}
function ka(r) {
  var e = (r > 65535 ? 1 : 0) << 4;
  r >>>= e;
  var t = (r > 255 ? 1 : 0) << 3;
  return r >>>= t, e |= t, t = (r > 15 ? 1 : 0) << 2, r >>>= t, e |= t, t = (r > 3 ? 1 : 0) << 1, r >>>= t, e |= t, e | r >> 1;
}
function Er(r, e, t) {
  var i = r.length, n;
  if (!(e >= i || t === 0)) {
    t = e + t > i ? i - e : t;
    var o = i - t;
    for (n = e; n < o; ++n)
      r[n] = r[n + t];
    r.length = o;
  }
}
function _r(r) {
  return r === 0 ? 0 : r < 0 ? -1 : 1;
}
var m_ = 0;
function tr() {
  return ++m_;
}
var Xa = {};
function re(r, e, t) {
  if (t === void 0 && (t = 3), !Xa[e]) {
    var i = new Error().stack;
    typeof i > "u" ? console.warn("PixiJS Deprecation Warning: ", e + `
Deprecated since v` + r) : (i = i.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + `
Deprecated since v` + r), console.warn(i), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + `
Deprecated since v` + r), console.warn(i))), Xa[e] = !0;
  }
}
var ja = {}, me = /* @__PURE__ */ Object.create(null), Le = /* @__PURE__ */ Object.create(null), Ha = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.canvas = L.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = i || L.RESOLUTION, this.resize(e, t);
    }
    return r.prototype.clear = function() {
      this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }, r.prototype.resize = function(e, t) {
      this.canvas.width = Math.round(e * this.resolution), this.canvas.height = Math.round(t * this.resolution);
    }, r.prototype.destroy = function() {
      this.context = null, this.canvas = null;
    }, Object.defineProperty(r.prototype, "width", {
      /**
       * The width of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.width;
      },
      set: function(e) {
        this.canvas.width = Math.round(e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "height", {
      /**
       * The height of the canvas buffer in pixels.
       * @member {number}
       */
      get: function() {
        return this.canvas.height;
      },
      set: function(e) {
        this.canvas.height = Math.round(e);
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
function __(r) {
  var e = r.width, t = r.height, i = r.getContext("2d", {
    willReadFrequently: !0
  }), n = i.getImageData(0, 0, e, t), o = n.data, s = o.length, a = {
    top: null,
    left: null,
    right: null,
    bottom: null
  }, h = null, u, l, c;
  for (u = 0; u < s; u += 4)
    o[u + 3] !== 0 && (l = u / 4 % e, c = ~~(u / 4 / e), a.top === null && (a.top = c), (a.left === null || l < a.left) && (a.left = l), (a.right === null || a.right < l) && (a.right = l + 1), (a.bottom === null || a.bottom < c) && (a.bottom = c));
  return a.top !== null && (e = a.right - a.left, t = a.bottom - a.top + 1, h = i.getImageData(a.left, a.top, e, t)), {
    height: t,
    width: e,
    data: h
  };
}
var Ai;
function g_(r, e) {
  if (e === void 0 && (e = globalThis.location), r.indexOf("data:") === 0)
    return "";
  e = e || globalThis.location, Ai || (Ai = document.createElement("a")), Ai.href = r;
  var t = mr.parse(Ai.href), i = !t.port && e.port === "" || t.port === e.port;
  return t.hostname !== e.hostname || !i || t.protocol !== e.protocol ? "anonymous" : "";
}
function hn(r, e) {
  var t = L.RETINA_PREFIX.exec(r);
  return t ? parseFloat(t[1]) : e !== void 0 ? e : 1;
}
/*!
 * @pixi/math - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var un = Math.PI * 2, v_ = 180 / Math.PI, b_ = Math.PI / 180, Dt;
(function(r) {
  r[r.POLY = 0] = "POLY", r[r.RECT = 1] = "RECT", r[r.CIRC = 2] = "CIRC", r[r.ELIP = 3] = "ELIP", r[r.RREC = 4] = "RREC";
})(Dt || (Dt = {}));
var _t = (
  /** @class */
  function() {
    function r(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), this.x = 0, this.y = 0, this.x = e, this.y = t;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y);
    }, r.prototype.copyFrom = function(e) {
      return this.set(e.x, e.y), this;
    }, r.prototype.copyTo = function(e) {
      return e.set(this.x, this.y), e;
    }, r.prototype.equals = function(e) {
      return e.x === this.x && e.y === this.y;
    }, r.prototype.set = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = e), this.x = e, this.y = t, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, r;
  }()
), Si = [new _t(), new _t(), new _t(), new _t()], it = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), this.x = Number(e), this.y = Number(t), this.width = Number(i), this.height = Number(n), this.type = Dt.RECT;
    }
    return Object.defineProperty(r.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new r(0, 0, 0, 0);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.copyFrom = function(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }, r.prototype.copyTo = function(e) {
      return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
    }, r.prototype.contains = function(e, t) {
      return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
    }, r.prototype.intersects = function(e, t) {
      if (!t) {
        var i = this.x < e.x ? e.x : this.x, n = this.right > e.right ? e.right : this.right;
        if (n <= i)
          return !1;
        var o = this.y < e.y ? e.y : this.y, s = this.bottom > e.bottom ? e.bottom : this.bottom;
        return s > o;
      }
      var a = this.left, h = this.right, u = this.top, l = this.bottom;
      if (h <= a || l <= u)
        return !1;
      var c = Si[0].set(e.left, e.top), p = Si[1].set(e.left, e.bottom), d = Si[2].set(e.right, e.top), f = Si[3].set(e.right, e.bottom);
      if (d.x <= c.x || p.y <= c.y)
        return !1;
      var y = Math.sign(t.a * t.d - t.b * t.c);
      if (y === 0 || (t.apply(c, c), t.apply(p, p), t.apply(d, d), t.apply(f, f), Math.max(c.x, p.x, d.x, f.x) <= a || Math.min(c.x, p.x, d.x, f.x) >= h || Math.max(c.y, p.y, d.y, f.y) <= u || Math.min(c.y, p.y, d.y, f.y) >= l))
        return !1;
      var m = y * (p.y - c.y), _ = y * (c.x - p.x), g = m * a + _ * u, b = m * h + _ * u, x = m * a + _ * l, E = m * h + _ * l;
      if (Math.max(g, b, x, E) <= m * c.x + _ * c.y || Math.min(g, b, x, E) >= m * f.x + _ * f.y)
        return !1;
      var v = y * (c.y - d.y), T = y * (d.x - c.x), S = v * a + T * u, R = v * h + T * u, O = v * a + T * l, w = v * h + T * l;
      return !(Math.max(S, R, O, w) <= v * c.x + T * c.y || Math.min(S, R, O, w) >= v * f.x + T * f.y);
    }, r.prototype.pad = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = e), this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
    }, r.prototype.fit = function(e) {
      var t = Math.max(this.x, e.x), i = Math.min(this.x + this.width, e.x + e.width), n = Math.max(this.y, e.y), o = Math.min(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = Math.max(i - t, 0), this.y = n, this.height = Math.max(o - n, 0), this;
    }, r.prototype.ceil = function(e, t) {
      e === void 0 && (e = 1), t === void 0 && (t = 1e-3);
      var i = Math.ceil((this.x + this.width - t) * e) / e, n = Math.ceil((this.y + this.height - t) * e) / e;
      return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = i - this.x, this.height = n - this.y, this;
    }, r.prototype.enlarge = function(e) {
      var t = Math.min(this.x, e.x), i = Math.max(this.x + this.width, e.x + e.width), n = Math.min(this.y, e.y), o = Math.max(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = i - t, this.y = n, this.height = o - n, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, r;
  }()
), x_ = (
  /** @class */
  function() {
    function r(e, t, i) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 0), this.x = e, this.y = t, this.radius = i, this.type = Dt.CIRC;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.radius);
    }, r.prototype.contains = function(e, t) {
      if (this.radius <= 0)
        return !1;
      var i = this.radius * this.radius, n = this.x - e, o = this.y - t;
      return n *= n, o *= o, n + o <= i;
    }, r.prototype.getBounds = function() {
      return new it(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }, r.prototype.toString = function() {
      return "[@pixi/math:Circle x=" + this.x + " y=" + this.y + " radius=" + this.radius + "]";
    }, r;
  }()
), T_ = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), this.x = e, this.y = t, this.width = i, this.height = n, this.type = Dt.ELIP;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height);
    }, r.prototype.contains = function(e, t) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      var i = (e - this.x) / this.width, n = (t - this.y) / this.height;
      return i *= i, n *= n, i + n <= 1;
    }, r.prototype.getBounds = function() {
      return new it(this.x - this.width, this.y - this.height, this.width, this.height);
    }, r.prototype.toString = function() {
      return "[@pixi/math:Ellipse x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, r;
  }()
), $i = (
  /** @class */
  function() {
    function r() {
      for (var e = arguments, t = [], i = 0; i < arguments.length; i++)
        t[i] = e[i];
      var n = Array.isArray(t[0]) ? t[0] : t;
      if (typeof n[0] != "number") {
        for (var o = [], s = 0, a = n.length; s < a; s++)
          o.push(n[s].x, n[s].y);
        n = o;
      }
      this.points = n, this.type = Dt.POLY, this.closeStroke = !0;
    }
    return r.prototype.clone = function() {
      var e = this.points.slice(), t = new r(e);
      return t.closeStroke = this.closeStroke, t;
    }, r.prototype.contains = function(e, t) {
      for (var i = !1, n = this.points.length / 2, o = 0, s = n - 1; o < n; s = o++) {
        var a = this.points[o * 2], h = this.points[o * 2 + 1], u = this.points[s * 2], l = this.points[s * 2 + 1], c = h > t != l > t && e < (u - a) * ((t - h) / (l - h)) + a;
        c && (i = !i);
      }
      return i;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Polygon" + ("closeStroke=" + this.closeStroke) + ("points=" + this.points.reduce(function(e, t) {
        return e + ", " + t;
      }, "") + "]");
    }, r;
  }()
), E_ = (
  /** @class */
  function() {
    function r(e, t, i, n, o) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), i === void 0 && (i = 0), n === void 0 && (n = 0), o === void 0 && (o = 20), this.x = e, this.y = t, this.width = i, this.height = n, this.radius = o, this.type = Dt.RREC;
    }
    return r.prototype.clone = function() {
      return new r(this.x, this.y, this.width, this.height, this.radius);
    }, r.prototype.contains = function(e, t) {
      if (this.width <= 0 || this.height <= 0)
        return !1;
      if (e >= this.x && e <= this.x + this.width && t >= this.y && t <= this.y + this.height) {
        var i = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (t >= this.y + i && t <= this.y + this.height - i || e >= this.x + i && e <= this.x + this.width - i)
          return !0;
        var n = e - (this.x + i), o = t - (this.y + i), s = i * i;
        if (n * n + o * o <= s || (n = e - (this.x + this.width - i), n * n + o * o <= s) || (o = t - (this.y + this.height - i), n * n + o * o <= s) || (n = e - (this.x + i), n * n + o * o <= s))
          return !0;
      }
      return !1;
    }, r.prototype.toString = function() {
      return "[@pixi/math:RoundedRectangle x=" + this.x + " y=" + this.y + ("width=" + this.width + " height=" + this.height + " radius=" + this.radius + "]");
    }, r;
  }()
), gr = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      i === void 0 && (i = 0), n === void 0 && (n = 0), this._x = i, this._y = n, this.cb = e, this.scope = t;
    }
    return r.prototype.clone = function(e, t) {
      return e === void 0 && (e = this.cb), t === void 0 && (t = this.scope), new r(e, t, this._x, this._y);
    }, r.prototype.set = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = e), (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this.cb.call(this.scope)), this;
    }, r.prototype.copyFrom = function(e) {
      return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this.cb.call(this.scope)), this;
    }, r.prototype.copyTo = function(e) {
      return e.set(this._x, this._y), e;
    }, r.prototype.equals = function(e) {
      return e.x === this._x && e.y === this._y;
    }, r.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(r.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(e) {
        this._x !== e && (this._x = e, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(e) {
        this._y !== e && (this._y = e, this.cb.call(this.scope));
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), It = (
  /** @class */
  function() {
    function r(e, t, i, n, o, s) {
      e === void 0 && (e = 1), t === void 0 && (t = 0), i === void 0 && (i = 0), n === void 0 && (n = 1), o === void 0 && (o = 0), s === void 0 && (s = 0), this.array = null, this.a = e, this.b = t, this.c = i, this.d = n, this.tx = o, this.ty = s;
    }
    return r.prototype.fromArray = function(e) {
      this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
    }, r.prototype.set = function(e, t, i, n, o, s) {
      return this.a = e, this.b = t, this.c = i, this.d = n, this.tx = o, this.ty = s, this;
    }, r.prototype.toArray = function(e, t) {
      this.array || (this.array = new Float32Array(9));
      var i = t || this.array;
      return e ? (i[0] = this.a, i[1] = this.b, i[2] = 0, i[3] = this.c, i[4] = this.d, i[5] = 0, i[6] = this.tx, i[7] = this.ty, i[8] = 1) : (i[0] = this.a, i[1] = this.c, i[2] = this.tx, i[3] = this.b, i[4] = this.d, i[5] = this.ty, i[6] = 0, i[7] = 0, i[8] = 1), i;
    }, r.prototype.apply = function(e, t) {
      t = t || new _t();
      var i = e.x, n = e.y;
      return t.x = this.a * i + this.c * n + this.tx, t.y = this.b * i + this.d * n + this.ty, t;
    }, r.prototype.applyInverse = function(e, t) {
      t = t || new _t();
      var i = 1 / (this.a * this.d + this.c * -this.b), n = e.x, o = e.y;
      return t.x = this.d * i * n + -this.c * i * o + (this.ty * this.c - this.tx * this.d) * i, t.y = this.a * i * o + -this.b * i * n + (-this.ty * this.a + this.tx * this.b) * i, t;
    }, r.prototype.translate = function(e, t) {
      return this.tx += e, this.ty += t, this;
    }, r.prototype.scale = function(e, t) {
      return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
    }, r.prototype.rotate = function(e) {
      var t = Math.cos(e), i = Math.sin(e), n = this.a, o = this.c, s = this.tx;
      return this.a = n * t - this.b * i, this.b = n * i + this.b * t, this.c = o * t - this.d * i, this.d = o * i + this.d * t, this.tx = s * t - this.ty * i, this.ty = s * i + this.ty * t, this;
    }, r.prototype.append = function(e) {
      var t = this.a, i = this.b, n = this.c, o = this.d;
      return this.a = e.a * t + e.b * n, this.b = e.a * i + e.b * o, this.c = e.c * t + e.d * n, this.d = e.c * i + e.d * o, this.tx = e.tx * t + e.ty * n + this.tx, this.ty = e.tx * i + e.ty * o + this.ty, this;
    }, r.prototype.setTransform = function(e, t, i, n, o, s, a, h, u) {
      return this.a = Math.cos(a + u) * o, this.b = Math.sin(a + u) * o, this.c = -Math.sin(a - h) * s, this.d = Math.cos(a - h) * s, this.tx = e - (i * this.a + n * this.c), this.ty = t - (i * this.b + n * this.d), this;
    }, r.prototype.prepend = function(e) {
      var t = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        var i = this.a, n = this.c;
        this.a = i * e.a + this.b * e.c, this.b = i * e.b + this.b * e.d, this.c = n * e.a + this.d * e.c, this.d = n * e.b + this.d * e.d;
      }
      return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
    }, r.prototype.decompose = function(e) {
      var t = this.a, i = this.b, n = this.c, o = this.d, s = e.pivot, a = -Math.atan2(-n, o), h = Math.atan2(i, t), u = Math.abs(a + h);
      return u < 1e-5 || Math.abs(un - u) < 1e-5 ? (e.rotation = h, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = a, e.skew.y = h), e.scale.x = Math.sqrt(t * t + i * i), e.scale.y = Math.sqrt(n * n + o * o), e.position.x = this.tx + (s.x * t + s.y * n), e.position.y = this.ty + (s.x * i + s.y * o), e;
    }, r.prototype.invert = function() {
      var e = this.a, t = this.b, i = this.c, n = this.d, o = this.tx, s = e * n - t * i;
      return this.a = n / s, this.b = -t / s, this.c = -i / s, this.d = e / s, this.tx = (i * this.ty - n * o) / s, this.ty = -(e * this.ty - t * o) / s, this;
    }, r.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, r.prototype.clone = function() {
      var e = new r();
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }, r.prototype.copyTo = function(e) {
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }, r.prototype.copyFrom = function(e) {
      return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(r, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new r();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new r();
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), Xe = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], je = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], He = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], Ye = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], No = [], Ru = [], Ri = Math.sign;
function A_() {
  for (var r = 0; r < 16; r++) {
    var e = [];
    No.push(e);
    for (var t = 0; t < 16; t++)
      for (var i = Ri(Xe[r] * Xe[t] + He[r] * je[t]), n = Ri(je[r] * Xe[t] + Ye[r] * je[t]), o = Ri(Xe[r] * He[t] + He[r] * Ye[t]), s = Ri(je[r] * He[t] + Ye[r] * Ye[t]), a = 0; a < 16; a++)
        if (Xe[a] === i && je[a] === n && He[a] === o && Ye[a] === s) {
          e.push(a);
          break;
        }
  }
  for (var r = 0; r < 16; r++) {
    var h = new It();
    h.set(Xe[r], je[r], He[r], Ye[r], 0, 0), Ru.push(h);
  }
}
A_();
var bt = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(r) {
    return Xe[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(r) {
    return je[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(r) {
    return He[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(r) {
    return Ye[r];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(r) {
    return r & 8 ? r & 15 : -r & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(r, e) {
    return No[r][e];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(r, e) {
    return No[r][bt.inv(e)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(r) {
    return r ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(r) {
    return (r & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(r, e) {
    return Math.abs(r) * 2 <= Math.abs(e) ? e >= 0 ? bt.S : bt.N : Math.abs(e) * 2 <= Math.abs(r) ? r > 0 ? bt.E : bt.W : e > 0 ? r > 0 ? bt.SE : bt.SW : r > 0 ? bt.NE : bt.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(r, e, t, i) {
    t === void 0 && (t = 0), i === void 0 && (i = 0);
    var n = Ru[bt.inv(e)];
    n.tx = t, n.ty = i, r.append(n);
  }
}, Ou = (
  /** @class */
  function() {
    function r() {
      this.worldTransform = new It(), this.localTransform = new It(), this.position = new gr(this.onChange, this, 0, 0), this.scale = new gr(this.onChange, this, 1, 1), this.pivot = new gr(this.onChange, this, 0, 0), this.skew = new gr(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return r.prototype.onChange = function() {
      this._localID++;
    }, r.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, r.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    }, r.prototype.updateLocalTransform = function() {
      var e = this.localTransform;
      this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, r.prototype.updateTransform = function(e) {
      var t = this.localTransform;
      if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
        var i = e.worldTransform, n = this.worldTransform;
        n.a = t.a * i.a + t.b * i.c, n.b = t.a * i.b + t.b * i.d, n.c = t.c * i.a + t.d * i.c, n.d = t.c * i.b + t.d * i.d, n.tx = t.tx * i.a + t.ty * i.c + i.tx, n.ty = t.tx * i.b + t.ty * i.d + i.ty, this._parentID = e._worldID, this._worldID++;
      }
    }, r.prototype.setFromMatrix = function(e) {
      e.decompose(this), this._localID++;
    }, Object.defineProperty(r.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(e) {
        this._rotation !== e && (this._rotation = e, this.updateSkew());
      },
      enumerable: !1,
      configurable: !0
    }), r.IDENTITY = new r(), r;
  }()
);
/*!
 * @pixi/display - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
L.SORTABLE_CHILDREN = !1;
var ln = (
  /** @class */
  function() {
    function r() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return r.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, r.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, r.prototype.getRectangle = function(e) {
      return this.minX > this.maxX || this.minY > this.maxY ? it.EMPTY : (e = e || new it(0, 0, 1, 1), e.x = this.minX, e.y = this.minY, e.width = this.maxX - this.minX, e.height = this.maxY - this.minY, e);
    }, r.prototype.addPoint = function(e) {
      this.minX = Math.min(this.minX, e.x), this.maxX = Math.max(this.maxX, e.x), this.minY = Math.min(this.minY, e.y), this.maxY = Math.max(this.maxY, e.y);
    }, r.prototype.addPointMatrix = function(e, t) {
      var i = e.a, n = e.b, o = e.c, s = e.d, a = e.tx, h = e.ty, u = i * t.x + o * t.y + a, l = n * t.x + s * t.y + h;
      this.minX = Math.min(this.minX, u), this.maxX = Math.max(this.maxX, u), this.minY = Math.min(this.minY, l), this.maxY = Math.max(this.maxY, l);
    }, r.prototype.addQuad = function(e) {
      var t = this.minX, i = this.minY, n = this.maxX, o = this.maxY, s = e[0], a = e[1];
      t = s < t ? s : t, i = a < i ? a : i, n = s > n ? s : n, o = a > o ? a : o, s = e[2], a = e[3], t = s < t ? s : t, i = a < i ? a : i, n = s > n ? s : n, o = a > o ? a : o, s = e[4], a = e[5], t = s < t ? s : t, i = a < i ? a : i, n = s > n ? s : n, o = a > o ? a : o, s = e[6], a = e[7], t = s < t ? s : t, i = a < i ? a : i, n = s > n ? s : n, o = a > o ? a : o, this.minX = t, this.minY = i, this.maxX = n, this.maxY = o;
    }, r.prototype.addFrame = function(e, t, i, n, o) {
      this.addFrameMatrix(e.worldTransform, t, i, n, o);
    }, r.prototype.addFrameMatrix = function(e, t, i, n, o) {
      var s = e.a, a = e.b, h = e.c, u = e.d, l = e.tx, c = e.ty, p = this.minX, d = this.minY, f = this.maxX, y = this.maxY, m = s * t + h * i + l, _ = a * t + u * i + c;
      p = m < p ? m : p, d = _ < d ? _ : d, f = m > f ? m : f, y = _ > y ? _ : y, m = s * n + h * i + l, _ = a * n + u * i + c, p = m < p ? m : p, d = _ < d ? _ : d, f = m > f ? m : f, y = _ > y ? _ : y, m = s * t + h * o + l, _ = a * t + u * o + c, p = m < p ? m : p, d = _ < d ? _ : d, f = m > f ? m : f, y = _ > y ? _ : y, m = s * n + h * o + l, _ = a * n + u * o + c, p = m < p ? m : p, d = _ < d ? _ : d, f = m > f ? m : f, y = _ > y ? _ : y, this.minX = p, this.minY = d, this.maxX = f, this.maxY = y;
    }, r.prototype.addVertexData = function(e, t, i) {
      for (var n = this.minX, o = this.minY, s = this.maxX, a = this.maxY, h = t; h < i; h += 2) {
        var u = e[h], l = e[h + 1];
        n = u < n ? u : n, o = l < o ? l : o, s = u > s ? u : s, a = l > a ? l : a;
      }
      this.minX = n, this.minY = o, this.maxX = s, this.maxY = a;
    }, r.prototype.addVertices = function(e, t, i, n) {
      this.addVerticesMatrix(e.worldTransform, t, i, n);
    }, r.prototype.addVerticesMatrix = function(e, t, i, n, o, s) {
      o === void 0 && (o = 0), s === void 0 && (s = o);
      for (var a = e.a, h = e.b, u = e.c, l = e.d, c = e.tx, p = e.ty, d = this.minX, f = this.minY, y = this.maxX, m = this.maxY, _ = i; _ < n; _ += 2) {
        var g = t[_], b = t[_ + 1], x = a * g + u * b + c, E = l * b + h * g + p;
        d = Math.min(d, x - o), y = Math.max(y, x + o), f = Math.min(f, E - s), m = Math.max(m, E + s);
      }
      this.minX = d, this.minY = f, this.maxX = y, this.maxY = m;
    }, r.prototype.addBounds = function(e) {
      var t = this.minX, i = this.minY, n = this.maxX, o = this.maxY;
      this.minX = e.minX < t ? e.minX : t, this.minY = e.minY < i ? e.minY : i, this.maxX = e.maxX > n ? e.maxX : n, this.maxY = e.maxY > o ? e.maxY : o;
    }, r.prototype.addBoundsMask = function(e, t) {
      var i = e.minX > t.minX ? e.minX : t.minX, n = e.minY > t.minY ? e.minY : t.minY, o = e.maxX < t.maxX ? e.maxX : t.maxX, s = e.maxY < t.maxY ? e.maxY : t.maxY;
      if (i <= o && n <= s) {
        var a = this.minX, h = this.minY, u = this.maxX, l = this.maxY;
        this.minX = i < a ? i : a, this.minY = n < h ? n : h, this.maxX = o > u ? o : u, this.maxY = s > l ? s : l;
      }
    }, r.prototype.addBoundsMatrix = function(e, t) {
      this.addFrameMatrix(t, e.minX, e.minY, e.maxX, e.maxY);
    }, r.prototype.addBoundsArea = function(e, t) {
      var i = e.minX > t.x ? e.minX : t.x, n = e.minY > t.y ? e.minY : t.y, o = e.maxX < t.x + t.width ? e.maxX : t.x + t.width, s = e.maxY < t.y + t.height ? e.maxY : t.y + t.height;
      if (i <= o && n <= s) {
        var a = this.minX, h = this.minY, u = this.maxX, l = this.maxY;
        this.minX = i < a ? i : a, this.minY = n < h ? n : h, this.maxX = o > u ? o : u, this.maxY = s > l ? s : l;
      }
    }, r.prototype.pad = function(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = e), this.isEmpty() || (this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t);
    }, r.prototype.addFramePad = function(e, t, i, n, o, s) {
      e -= o, t -= s, i += o, n += s, this.minX = this.minX < e ? this.minX : e, this.maxX = this.maxX > i ? this.maxX : i, this.minY = this.minY < t ? this.minY : t, this.maxY = this.maxY > n ? this.maxY : n;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Lo = function(r, e) {
  return Lo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Lo(r, e);
};
function ws(r, e) {
  Lo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var St = (
  /** @class */
  function(r) {
    ws(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.tempDisplayObjectParent = null, t.transform = new Ou(), t.alpha = 1, t.visible = !0, t.renderable = !0, t.cullable = !1, t.cullArea = null, t.parent = null, t.worldAlpha = 1, t._lastSortedIndex = 0, t._zIndex = 0, t.filterArea = null, t.filters = null, t._enabledFilters = null, t._bounds = new ln(), t._localBounds = null, t._boundsID = 0, t._boundsRect = null, t._localBoundsRect = null, t._mask = null, t._maskRefCount = 0, t._destroyed = !1, t.isSprite = !1, t.isMask = !1, t;
    }
    return e.mixin = function(t) {
      for (var i = Object.keys(t), n = 0; n < i.length; ++n) {
        var o = i[n];
        Object.defineProperty(e.prototype, o, Object.getOwnPropertyDescriptor(t, o));
      }
    }, Object.defineProperty(e.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, e.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, e.prototype.getBounds = function(t, i) {
      return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), i || (this._boundsRect || (this._boundsRect = new it()), i = this._boundsRect), this._bounds.getRectangle(i);
    }, e.prototype.getLocalBounds = function(t) {
      t || (this._localBoundsRect || (this._localBoundsRect = new it()), t = this._localBoundsRect), this._localBounds || (this._localBounds = new ln());
      var i = this.transform, n = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var o = this._bounds, s = this._boundsID;
      this._bounds = this._localBounds;
      var a = this.getBounds(!1, t);
      return this.parent = n, this.transform = i, this._bounds = o, this._bounds.updateID += this._boundsID - s, a;
    }, e.prototype.toGlobal = function(t, i, n) {
      return n === void 0 && (n = !1), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, i);
    }, e.prototype.toLocal = function(t, i, n, o) {
      return i && (t = i.toGlobal(t, n, o)), o || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, n);
    }, e.prototype.setParent = function(t) {
      if (!t || !t.addChild)
        throw new Error("setParent: Argument must be a Container");
      return t.addChild(this), t;
    }, e.prototype.setTransform = function(t, i, n, o, s, a, h, u, l) {
      return t === void 0 && (t = 0), i === void 0 && (i = 0), n === void 0 && (n = 1), o === void 0 && (o = 1), s === void 0 && (s = 0), a === void 0 && (a = 0), h === void 0 && (h = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), this.position.x = t, this.position.y = i, this.scale.x = n || 1, this.scale.y = o || 1, this.rotation = s, this.skew.x = a, this.skew.y = h, this.pivot.x = u, this.pivot.y = l, this;
    }, e.prototype.destroy = function(t) {
      this.parent && this.parent.removeChild(this), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new wu()), this.tempDisplayObjectParent;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.enableTempParent = function() {
      var t = this.parent;
      return this.parent = this._tempDisplayObjectParent, t;
    }, e.prototype.disableTempParent = function(t) {
      this.parent = t;
    }, Object.defineProperty(e.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(t) {
        this.transform.position.x = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(t) {
        this.transform.position.y = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(t) {
        this.transform.position.copyFrom(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(t) {
        this.transform.scale.copyFrom(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(t) {
        this.transform.pivot.copyFrom(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(t) {
        this.transform.skew.copyFrom(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(t) {
        this.transform.rotation = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * v_;
      },
      set: function(t) {
        this.transform.rotation = t * b_;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(t) {
        this._zIndex = t, this.parent && (this.parent.sortDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var t = this;
        do {
          if (!t.visible)
            return !1;
          t = t.parent;
        } while (t);
        return !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(t) {
        if (this._mask !== t) {
          if (this._mask) {
            var i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            i && (i._maskRefCount--, i._maskRefCount === 0 && (i.renderable = !0, i.isMask = !1));
          }
          if (this._mask = t, this._mask) {
            var i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            i && (i._maskRefCount === 0 && (i.renderable = !1, i.isMask = !0), i._maskRefCount++);
          }
        }
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(hi)
), wu = (
  /** @class */
  function(r) {
    ws(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.sortDirty = null, t;
    }
    return e;
  }(St)
);
St.prototype.displayObjectUpdateTransform = St.prototype.updateTransform;
function S_(r, e) {
  return r.zIndex === e.zIndex ? r._lastSortedIndex - e._lastSortedIndex : r.zIndex - e.zIndex;
}
var pe = (
  /** @class */
  function(r) {
    ws(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.children = [], t.sortableChildren = L.SORTABLE_CHILDREN, t.sortDirty = !1, t;
    }
    return e.prototype.onChildrenChange = function(t) {
    }, e.prototype.addChild = function() {
      for (var t = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = t[n];
      if (i.length > 1)
        for (var o = 0; o < i.length; o++)
          this.addChild(i[o]);
      else {
        var s = i[0];
        s.parent && s.parent.removeChild(s), s.parent = this, this.sortDirty = !0, s.transform._parentID = -1, this.children.push(s), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", s, this, this.children.length - 1), s.emit("added", this);
      }
      return i[0];
    }, e.prototype.addChildAt = function(t, i) {
      if (i < 0 || i > this.children.length)
        throw new Error(t + "addChildAt: The index " + i + " supplied is out of bounds " + this.children.length);
      return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.splice(i, 0, t), this._boundsID++, this.onChildrenChange(i), t.emit("added", this), this.emit("childAdded", t, this, i), t;
    }, e.prototype.swapChildren = function(t, i) {
      if (t !== i) {
        var n = this.getChildIndex(t), o = this.getChildIndex(i);
        this.children[n] = i, this.children[o] = t, this.onChildrenChange(n < o ? n : o);
      }
    }, e.prototype.getChildIndex = function(t) {
      var i = this.children.indexOf(t);
      if (i === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return i;
    }, e.prototype.setChildIndex = function(t, i) {
      if (i < 0 || i >= this.children.length)
        throw new Error("The index " + i + " supplied is out of bounds " + this.children.length);
      var n = this.getChildIndex(t);
      Er(this.children, n, 1), this.children.splice(i, 0, t), this.onChildrenChange(i);
    }, e.prototype.getChildAt = function(t) {
      if (t < 0 || t >= this.children.length)
        throw new Error("getChildAt: Index (" + t + ") does not exist.");
      return this.children[t];
    }, e.prototype.removeChild = function() {
      for (var t = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = t[n];
      if (i.length > 1)
        for (var o = 0; o < i.length; o++)
          this.removeChild(i[o]);
      else {
        var s = i[0], a = this.children.indexOf(s);
        if (a === -1)
          return null;
        s.parent = null, s.transform._parentID = -1, Er(this.children, a, 1), this._boundsID++, this.onChildrenChange(a), s.emit("removed", this), this.emit("childRemoved", s, this, a);
      }
      return i[0];
    }, e.prototype.removeChildAt = function(t) {
      var i = this.getChildAt(t);
      return i.parent = null, i.transform._parentID = -1, Er(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), i.emit("removed", this), this.emit("childRemoved", i, this, t), i;
    }, e.prototype.removeChildren = function(t, i) {
      t === void 0 && (t = 0), i === void 0 && (i = this.children.length);
      var n = t, o = i, s = o - n, a;
      if (s > 0 && s <= o) {
        a = this.children.splice(n, s);
        for (var h = 0; h < a.length; ++h)
          a[h].parent = null, a[h].transform && (a[h].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(t);
        for (var h = 0; h < a.length; ++h)
          a[h].emit("removed", this), this.emit("childRemoved", a[h], this, h);
        return a;
      } else if (s === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, e.prototype.sortChildren = function() {
      for (var t = !1, i = 0, n = this.children.length; i < n; ++i) {
        var o = this.children[i];
        o._lastSortedIndex = i, !t && o.zIndex !== 0 && (t = !0);
      }
      t && this.children.length > 1 && this.children.sort(S_), this.sortDirty = !1;
    }, e.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var t = 0, i = this.children.length; t < i; ++t) {
        var n = this.children[t];
        n.visible && n.updateTransform();
      }
    }, e.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var t = 0; t < this.children.length; t++) {
        var i = this.children[t];
        if (!(!i.visible || !i.renderable))
          if (i.calculateBounds(), i._mask) {
            var n = i._mask.isMaskData ? i._mask.maskObject : i._mask;
            n ? (n.calculateBounds(), this._bounds.addBoundsMask(i._bounds, n._bounds)) : this._bounds.addBounds(i._bounds);
          } else
            i.filterArea ? this._bounds.addBoundsArea(i._bounds, i.filterArea) : this._bounds.addBounds(i._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, e.prototype.getLocalBounds = function(t, i) {
      i === void 0 && (i = !1);
      var n = r.prototype.getLocalBounds.call(this, t);
      if (!i)
        for (var o = 0, s = this.children.length; o < s; ++o) {
          var a = this.children[o];
          a.visible && a.updateTransform();
        }
      return n;
    }, e.prototype._calculateBounds = function() {
    }, e.prototype._renderWithCulling = function(t) {
      var i = t.renderTexture.sourceFrame;
      if (i.width > 0 && i.height > 0) {
        var n, o;
        if (this.cullArea ? (n = this.cullArea, o = this.worldTransform) : this._render !== e.prototype._render && (n = this.getBounds(!0)), n && i.intersects(n, o))
          this._render(t);
        else if (this.cullArea)
          return;
        for (var s = 0, a = this.children.length; s < a; ++s) {
          var h = this.children[s], u = h.cullable;
          h.cullable = u || !this.cullArea, h.render(t), h.cullable = u;
        }
      }
    }, e.prototype.render = function(t) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(t);
        else if (this.cullable)
          this._renderWithCulling(t);
        else {
          this._render(t);
          for (var i = 0, n = this.children.length; i < n; ++i)
            this.children[i].render(t);
        }
    }, e.prototype.renderAdvanced = function(t) {
      var i = this.filters, n = this._mask;
      if (i) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var o = 0; o < i.length; o++)
          i[o].enabled && this._enabledFilters.push(i[o]);
      }
      var s = i && this._enabledFilters && this._enabledFilters.length || n && (!n.isMaskData || n.enabled && (n.autoDetect || n.type !== Rt.NONE));
      if (s && t.batch.flush(), i && this._enabledFilters && this._enabledFilters.length && t.filter.push(this, this._enabledFilters), n && t.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(t);
      else {
        this._render(t);
        for (var o = 0, a = this.children.length; o < a; ++o)
          this.children[o].render(t);
      }
      s && t.batch.flush(), n && t.mask.pop(this), i && this._enabledFilters && this._enabledFilters.length && t.filter.pop();
    }, e.prototype._render = function(t) {
    }, e.prototype.destroy = function(t) {
      r.prototype.destroy.call(this), this.sortDirty = !1;
      var i = typeof t == "boolean" ? t : t && t.children, n = this.removeChildren(0, this.children.length);
      if (i)
        for (var o = 0; o < n.length; ++o)
          n[o].destroy(t);
    }, Object.defineProperty(e.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(t) {
        var i = this.getLocalBounds().width;
        i !== 0 ? this.scale.x = t / i : this.scale.x = 1, this._width = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(t) {
        var i = this.getLocalBounds().height;
        i !== 0 ? this.scale.y = t / i : this.scale.y = 1, this._height = t;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(St)
);
pe.prototype.containerUpdateTransform = pe.prototype.updateTransform;
/*!
 * @pixi/extensions - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var qr = function() {
  return qr = Object.assign || function(r) {
    for (var e = arguments, t, i = 1, n = arguments.length; i < n; i++) {
      t = e[i];
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);
    }
    return r;
  }, qr.apply(this, arguments);
}, dt;
(function(r) {
  r.Application = "application", r.RendererPlugin = "renderer-webgl-plugin", r.CanvasRendererPlugin = "renderer-canvas-plugin", r.Loader = "loader", r.LoadParser = "load-parser", r.ResolveParser = "resolve-parser", r.CacheParser = "cache-parser", r.DetectionParser = "detection-parser";
})(dt || (dt = {}));
var Ya = function(r) {
  if (typeof r == "function" || typeof r == "object" && r.extension) {
    if (!r.extension)
      throw new Error("Extension class must have an extension object");
    var e = typeof r.extension != "object" ? { type: r.extension } : r.extension;
    r = qr(qr({}, e), { ref: r });
  }
  if (typeof r == "object")
    r = qr({}, r);
  else
    throw new Error("Invalid extension type");
  return typeof r.type == "string" && (r.type = [r.type]), r;
}, Te = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var r = arguments, e = this, t = [], i = 0; i < arguments.length; i++)
      t[i] = r[i];
    return t.map(Ya).forEach(function(n) {
      n.type.forEach(function(o) {
        var s, a;
        return (a = (s = e._removeHandlers)[o]) === null || a === void 0 ? void 0 : a.call(s, n);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var r = arguments, e = this, t = [], i = 0; i < arguments.length; i++)
      t[i] = r[i];
    return t.map(Ya).forEach(function(n) {
      n.type.forEach(function(o) {
        var s = e._addHandlers, a = e._queue;
        s[o] ? s[o](n) : (a[o] = a[o] || [], a[o].push(n));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(r, e, t) {
    var i = this._addHandlers = this._addHandlers || {}, n = this._removeHandlers = this._removeHandlers || {};
    if (i[r] || n[r])
      throw new Error("Extension type " + r + " already has a handler");
    i[r] = e, n[r] = t;
    var o = this._queue;
    return o[r] && (o[r].forEach(function(s) {
      return e(s);
    }), delete o[r]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(r, e) {
    return this.handle(r, function(t) {
      e[t.name] = t.ref;
    }, function(t) {
      delete e[t.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(r, e) {
    return this.handle(r, function(t) {
      var i, n;
      e.includes(t.ref) || (e.push(t.ref), r === dt.Loader && ((n = (i = t.ref).add) === null || n === void 0 || n.call(i)));
    }, function(t) {
      var i = e.indexOf(t.ref);
      i !== -1 && e.splice(i, 1);
    });
  }
};
/*!
 * @pixi/runner - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Nt = (
  /** @class */
  function() {
    function r(e) {
      this.items = [], this._name = e, this._aliasCount = 0;
    }
    return r.prototype.emit = function(e, t, i, n, o, s, a, h) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var u = this, l = u.name, c = u.items;
      this._aliasCount++;
      for (var p = 0, d = c.length; p < d; p++)
        c[p][l](e, t, i, n, o, s, a, h);
      return c === this.items && this._aliasCount--, this;
    }, r.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, r.prototype.add = function(e) {
      return e[this._name] && (this.ensureNonAliasedItems(), this.remove(e), this.items.push(e)), this;
    }, r.prototype.remove = function(e) {
      var t = this.items.indexOf(e);
      return t !== -1 && (this.ensureNonAliasedItems(), this.items.splice(t, 1)), this;
    }, r.prototype.contains = function(e) {
      return this.items.indexOf(e) !== -1;
    }, r.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, r.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(r.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
Object.defineProperties(Nt.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Nt.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Nt.prototype.emit }
});
/*!
 * @pixi/ticker - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
L.TARGET_FPMS = 0.06;
var xe;
(function(r) {
  r[r.INTERACTION = 50] = "INTERACTION", r[r.HIGH = 25] = "HIGH", r[r.NORMAL = 0] = "NORMAL", r[r.LOW = -25] = "LOW", r[r.UTILITY = -50] = "UTILITY";
})(xe || (xe = {}));
var zn = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      t === void 0 && (t = null), i === void 0 && (i = 0), n === void 0 && (n = !1), this.next = null, this.previous = null, this._destroyed = !1, this.fn = e, this.context = t, this.priority = i, this.once = n;
    }
    return r.prototype.match = function(e, t) {
      return t === void 0 && (t = null), this.fn === e && this.context === t;
    }, r.prototype.emit = function(e) {
      this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
      var t = this.next;
      return this.once && this.destroy(!0), this._destroyed && (this.next = null), t;
    }, r.prototype.connect = function(e) {
      this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
    }, r.prototype.destroy = function(e) {
      e === void 0 && (e = !1), this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var t = this.next;
      return this.next = e ? null : t, this.previous = null, t;
    }, r;
  }()
), Lt = (
  /** @class */
  function() {
    function r() {
      var e = this;
      this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new zn(null, null, 1 / 0), this.deltaMS = 1 / L.TARGET_FPMS, this.elapsedMS = 1 / L.TARGET_FPMS, this._tick = function(t) {
        e._requestId = null, e.started && (e.update(t), e.started && e._requestId === null && e._head.next && (e._requestId = requestAnimationFrame(e._tick)));
      };
    }
    return r.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, r.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, r.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, r.prototype.add = function(e, t, i) {
      return i === void 0 && (i = xe.NORMAL), this._addListener(new zn(e, t, i));
    }, r.prototype.addOnce = function(e, t, i) {
      return i === void 0 && (i = xe.NORMAL), this._addListener(new zn(e, t, i, !0));
    }, r.prototype._addListener = function(e) {
      var t = this._head.next, i = this._head;
      if (!t)
        e.connect(i);
      else {
        for (; t; ) {
          if (e.priority > t.priority) {
            e.connect(i);
            break;
          }
          i = t, t = t.next;
        }
        e.previous || e.connect(i);
      }
      return this._startIfPossible(), this;
    }, r.prototype.remove = function(e, t) {
      for (var i = this._head.next; i; )
        i.match(e, t) ? i = i.destroy() : i = i.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(r.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head)
          return 0;
        for (var e = 0, t = this._head; t = t.next; )
          e++;
        return e;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.start = function() {
      this.started || (this.started = !0, this._requestIfNeeded());
    }, r.prototype.stop = function() {
      this.started && (this.started = !1, this._cancelIfNeeded());
    }, r.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var e = this._head.next; e; )
          e = e.destroy(!0);
        this._head.destroy(), this._head = null;
      }
    }, r.prototype.update = function(e) {
      e === void 0 && (e = performance.now());
      var t;
      if (e > this.lastTime) {
        if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
          var i = e - this._lastFrame | 0;
          if (i < this._minElapsedMS)
            return;
          this._lastFrame = e - i % this._minElapsedMS;
        }
        this.deltaMS = t, this.deltaTime = this.deltaMS * L.TARGET_FPMS;
        for (var n = this._head, o = n.next; o; )
          o = o.emit(this.deltaTime);
        n.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }, Object.defineProperty(r.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(e) {
        var t = Math.min(this.maxFPS, e), i = Math.min(Math.max(0, t) / 1e3, L.TARGET_FPMS);
        this._maxElapsedMS = 1 / i;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      },
      set: function(e) {
        if (e === 0)
          this._minElapsedMS = 0;
        else {
          var t = Math.max(this.minFPS, e);
          this._minElapsedMS = 1 / (t / 1e3);
        }
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!r._shared) {
          var e = r._shared = new r();
          e.autoStart = !0, e._protected = !0;
        }
        return r._shared;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!r._system) {
          var e = r._system = new r();
          e.autoStart = !0, e._protected = !0;
        }
        return r._system;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), R_ = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(e) {
      var t = this;
      e = Object.assign({
        autoStart: !0,
        sharedTicker: !1
      }, e), Object.defineProperty(this, "ticker", {
        set: function(i) {
          this._ticker && this._ticker.remove(this.render, this), this._ticker = i, i && i.add(this.render, this, xe.LOW);
        },
        get: function() {
          return this._ticker;
        }
      }), this.stop = function() {
        t._ticker.stop();
      }, this.start = function() {
        t._ticker.start();
      }, this._ticker = null, this.ticker = e.sharedTicker ? Lt.shared : new Lt(), e.autoStart && this.start();
    }, r.destroy = function() {
      if (this._ticker) {
        var e = this._ticker;
        this.ticker = null, e.destroy();
      }
    }, r.extension = dt.Application, r;
  }()
);
/*!
 * @pixi/core - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
L.PREFER_ENV = ue.any ? be.WEBGL : be.WEBGL2;
L.STRICT_TEXTURE_CACHE = !1;
var Bo = [];
function Iu(r, e) {
  if (!r)
    return null;
  var t = "";
  if (typeof r == "string") {
    var i = /\.(\w{3,4})(?:$|\?|#)/i.exec(r);
    i && (t = i[1].toLowerCase());
  }
  for (var n = Bo.length - 1; n >= 0; --n) {
    var o = Bo[n];
    if (o.test && o.test(r, t))
      return new o(r, e);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Go = function(r, e) {
  return Go = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Go(r, e);
};
function yt(r, e) {
  Go(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Uo = function() {
  return Uo = Object.assign || function(r) {
    for (var e = arguments, t, i = 1, n = arguments.length; i < n; i++) {
      t = e[i];
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o]);
    }
    return r;
  }, Uo.apply(this, arguments);
};
function O_(r, e) {
  var t = {};
  for (var i in r)
    Object.prototype.hasOwnProperty.call(r, i) && e.indexOf(i) < 0 && (t[i] = r[i]);
  if (r != null && typeof Object.getOwnPropertySymbols == "function")
    for (var n = 0, i = Object.getOwnPropertySymbols(r); n < i.length; n++)
      e.indexOf(i[n]) < 0 && Object.prototype.propertyIsEnumerable.call(r, i[n]) && (t[i[n]] = r[i[n]]);
  return t;
}
var ii = (
  /** @class */
  function() {
    function r(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), this._width = e, this._height = t, this.destroyed = !1, this.internal = !1, this.onResize = new Nt("setRealSize"), this.onUpdate = new Nt("update"), this.onError = new Nt("onError");
    }
    return r.prototype.bind = function(e) {
      this.onResize.add(e), this.onUpdate.add(e), this.onError.add(e), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, r.prototype.unbind = function(e) {
      this.onResize.remove(e), this.onUpdate.remove(e), this.onError.remove(e);
    }, r.prototype.resize = function(e, t) {
      (e !== this._width || t !== this._height) && (this._width = e, this._height = t, this.onResize.emit(e, t));
    }, Object.defineProperty(r.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, r.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(r.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.style = function(e, t, i) {
      return !1;
    }, r.prototype.dispose = function() {
    }, r.prototype.destroy = function() {
      this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, r.test = function(e, t) {
      return !1;
    }, r;
  }()
), li = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this, o = i || {}, s = o.width, a = o.height;
      if (!s || !a)
        throw new Error("BufferResource width or height invalid");
      return n = r.call(this, s, a) || this, n.data = t, n;
    }
    return e.prototype.upload = function(t, i, n) {
      var o = t.gl;
      o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === ne.UNPACK);
      var s = i.realWidth, a = i.realHeight;
      return n.width === s && n.height === a ? o.texSubImage2D(i.target, 0, 0, 0, s, a, i.format, n.type, this.data) : (n.width = s, n.height = a, o.texImage2D(i.target, 0, n.internalFormat, s, a, 0, i.format, n.type, this.data)), !0;
    }, e.prototype.dispose = function() {
      this.data = null;
    }, e.test = function(t) {
      return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array;
    }, e;
  }(ii)
), w_ = {
  scaleMode: he.NEAREST,
  format: P.RGBA,
  alphaMode: ne.NPM
}, rt = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      t === void 0 && (t = null), i === void 0 && (i = null);
      var n = r.call(this) || this;
      i = i || {};
      var o = i.alphaMode, s = i.mipmap, a = i.anisotropicLevel, h = i.scaleMode, u = i.width, l = i.height, c = i.wrapMode, p = i.format, d = i.type, f = i.target, y = i.resolution, m = i.resourceOptions;
      return t && !(t instanceof ii) && (t = Iu(t, m), t.internal = !0), n.resolution = y || L.RESOLUTION, n.width = Math.round((u || 0) * n.resolution) / n.resolution, n.height = Math.round((l || 0) * n.resolution) / n.resolution, n._mipmap = s !== void 0 ? s : L.MIPMAP_TEXTURES, n.anisotropicLevel = a !== void 0 ? a : L.ANISOTROPIC_LEVEL, n._wrapMode = c || L.WRAP_MODE, n._scaleMode = h !== void 0 ? h : L.SCALE_MODE, n.format = p || P.RGBA, n.type = d || U.UNSIGNED_BYTE, n.target = f || qe.TEXTURE_2D, n.alphaMode = o !== void 0 ? o : ne.UNPACK, n.uid = tr(), n.touched = 0, n.isPowerOfTwo = !1, n._refreshPOT(), n._glTextures = {}, n.dirtyId = 0, n.dirtyStyleId = 0, n.cacheId = null, n.valid = u > 0 && l > 0, n.textureCacheIds = [], n.destroyed = !1, n.resource = null, n._batchEnabled = 0, n._batchLocation = 0, n.parentTextureArray = null, n.setResource(t), n;
    }
    return Object.defineProperty(e.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(t) {
        this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(t) {
        this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(t) {
        this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++);
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.setStyle = function(t, i) {
      var n;
      return t !== void 0 && t !== this.scaleMode && (this.scaleMode = t, n = !0), i !== void 0 && i !== this.mipmap && (this.mipmap = i, n = !0), n && this.dirtyStyleId++, this;
    }, e.prototype.setSize = function(t, i, n) {
      return n = n || this.resolution, this.setRealSize(t * n, i * n, n);
    }, e.prototype.setRealSize = function(t, i, n) {
      return this.resolution = n || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(i) / this.resolution, this._refreshPOT(), this.update(), this;
    }, e.prototype._refreshPOT = function() {
      this.isPowerOfTwo = Ua(this.realWidth) && Ua(this.realHeight);
    }, e.prototype.setResolution = function(t) {
      var i = this.resolution;
      return i === t ? this : (this.resolution = t, this.valid && (this.width = Math.round(this.width * i) / t, this.height = Math.round(this.height * i) / t, this.emit("update", this)), this._refreshPOT(), this);
    }, e.prototype.setResource = function(t) {
      if (this.resource === t)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return t.bind(this), this.resource = t, this;
    }, e.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
    }, e.prototype.onError = function(t) {
      this.emit("error", this, t);
    }, e.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete Le[this.cacheId], delete me[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0;
    }, e.prototype.dispose = function() {
      this.emit("dispose", this);
    }, e.prototype.castToBaseTexture = function() {
      return this;
    }, e.from = function(t, i, n) {
      n === void 0 && (n = L.STRICT_TEXTURE_CACHE);
      var o = typeof t == "string", s = null;
      if (o)
        s = t;
      else {
        if (!t._pixiId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          t._pixiId = a + "_" + tr();
        }
        s = t._pixiId;
      }
      var h = Le[s];
      if (o && n && !h)
        throw new Error('The cacheId "' + s + '" does not exist in BaseTextureCache.');
      return h || (h = new e(t, i), h.cacheId = s, e.addToCache(h, s)), h;
    }, e.fromBuffer = function(t, i, n, o) {
      t = t || new Float32Array(i * n * 4);
      var s = new li(t, { width: i, height: n }), a = t instanceof Float32Array ? U.FLOAT : U.UNSIGNED_BYTE;
      return new e(s, Object.assign({}, w_, o || { width: i, height: n, type: a }));
    }, e.addToCache = function(t, i) {
      i && (t.textureCacheIds.indexOf(i) === -1 && t.textureCacheIds.push(i), Le[i] && console.warn("BaseTexture added to the cache with an id [" + i + "] that already had an entry"), Le[i] = t);
    }, e.removeFromCache = function(t) {
      if (typeof t == "string") {
        var i = Le[t];
        if (i) {
          var n = i.textureCacheIds.indexOf(t);
          return n > -1 && i.textureCacheIds.splice(n, 1), delete Le[t], i;
        }
      } else if (t && t.textureCacheIds) {
        for (var o = 0; o < t.textureCacheIds.length; ++o)
          delete Le[t.textureCacheIds[o]];
        return t.textureCacheIds.length = 0, t;
      }
      return null;
    }, e._globalBatch = 0, e;
  }(hi)
), Pu = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this, o = i || {}, s = o.width, a = o.height;
      n = r.call(this, s, a) || this, n.items = [], n.itemDirtyIds = [];
      for (var h = 0; h < t; h++) {
        var u = new rt();
        n.items.push(u), n.itemDirtyIds.push(-2);
      }
      return n.length = t, n._load = null, n.baseTexture = null, n;
    }
    return e.prototype.initFromArray = function(t, i) {
      for (var n = 0; n < this.length; n++)
        t[n] && (t[n].castToBaseTexture ? this.addBaseTextureAt(t[n].castToBaseTexture(), n) : t[n] instanceof ii ? this.addResourceAt(t[n], n) : this.addResourceAt(Iu(t[n], i), n));
    }, e.prototype.dispose = function() {
      for (var t = 0, i = this.length; t < i; t++)
        this.items[t].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, e.prototype.addResourceAt = function(t, i) {
      if (!this.items[i])
        throw new Error("Index " + i + " is out of bounds");
      return t.valid && !this.valid && this.resize(t.width, t.height), this.items[i].setResource(t), this;
    }, e.prototype.bind = function(t) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      r.prototype.bind.call(this, t);
      for (var i = 0; i < this.length; i++)
        this.items[i].parentTextureArray = t, this.items[i].on("update", t.update, t);
    }, e.prototype.unbind = function(t) {
      r.prototype.unbind.call(this, t);
      for (var i = 0; i < this.length; i++)
        this.items[i].parentTextureArray = null, this.items[i].off("update", t.update, t);
    }, e.prototype.load = function() {
      var t = this;
      if (this._load)
        return this._load;
      var i = this.items.map(function(o) {
        return o.resource;
      }).filter(function(o) {
        return o;
      }), n = i.map(function(o) {
        return o.load();
      });
      return this._load = Promise.all(n).then(function() {
        var o = t.items[0], s = o.realWidth, a = o.realHeight;
        return t.resize(s, a), Promise.resolve(t);
      }), this._load;
    }, e;
  }(ii)
), I_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this, o = i || {}, s = o.width, a = o.height, h, u;
      return Array.isArray(t) ? (h = t, u = t.length) : u = t, n = r.call(this, u, { width: s, height: a }) || this, h && n.initFromArray(h, i), n;
    }
    return e.prototype.addBaseTextureAt = function(t, i) {
      if (t.resource)
        this.addResourceAt(t.resource, i);
      else
        throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }, e.prototype.bind = function(t) {
      r.prototype.bind.call(this, t), t.target = qe.TEXTURE_2D_ARRAY;
    }, e.prototype.upload = function(t, i, n) {
      var o = this, s = o.length, a = o.itemDirtyIds, h = o.items, u = t.gl;
      n.dirtyId < 0 && u.texImage3D(u.TEXTURE_2D_ARRAY, 0, n.internalFormat, this._width, this._height, s, 0, i.format, n.type, null);
      for (var l = 0; l < s; l++) {
        var c = h[l];
        a[l] < c.dirtyId && (a[l] = c.dirtyId, c.valid && u.texSubImage3D(
          u.TEXTURE_2D_ARRAY,
          0,
          0,
          // xoffset
          0,
          // yoffset
          l,
          // zoffset
          c.resource.width,
          c.resource.height,
          1,
          i.format,
          n.type,
          c.resource.source
        ));
      }
      return !0;
    }, e;
  }(Pu)
), Ie = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      var i = this, n = t, o = n.naturalWidth || n.videoWidth || n.width, s = n.naturalHeight || n.videoHeight || n.height;
      return i = r.call(this, o, s) || this, i.source = t, i.noSubImage = !1, i;
    }
    return e.crossOrigin = function(t, i, n) {
      n === void 0 && i.indexOf("data:") !== 0 ? t.crossOrigin = g_(i) : n !== !1 && (t.crossOrigin = typeof n == "string" ? n : "anonymous");
    }, e.prototype.upload = function(t, i, n, o) {
      var s = t.gl, a = i.realWidth, h = i.realHeight;
      if (o = o || this.source, o instanceof HTMLImageElement) {
        if (!o.complete || o.naturalWidth === 0)
          return !1;
      } else if (o instanceof HTMLVideoElement && o.readyState <= 1)
        return !1;
      return s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === ne.UNPACK), !this.noSubImage && i.target === s.TEXTURE_2D && n.width === a && n.height === h ? s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, i.format, n.type, o) : (n.width = a, n.height = h, s.texImage2D(i.target, 0, n.internalFormat, i.format, n.type, o)), !0;
    }, e.prototype.update = function() {
      if (!this.destroyed) {
        var t = this.source, i = t.naturalWidth || t.videoWidth || t.width, n = t.naturalHeight || t.videoHeight || t.height;
        this.resize(i, n), r.prototype.update.call(this);
      }
    }, e.prototype.dispose = function() {
      this.source = null;
    }, e;
  }(ii)
), P_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.test = function(t) {
      var i = globalThis.OffscreenCanvas;
      return i && t instanceof i ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement;
    }, e;
  }(Ie)
), M_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this, o = i || {}, s = o.width, a = o.height, h = o.autoLoad, u = o.linkBaseTexture;
      if (t && t.length !== e.SIDES)
        throw new Error("Invalid length. Got " + t.length + ", expected 6");
      n = r.call(this, 6, { width: s, height: a }) || this;
      for (var l = 0; l < e.SIDES; l++)
        n.items[l].target = qe.TEXTURE_CUBE_MAP_POSITIVE_X + l;
      return n.linkBaseTexture = u !== !1, t && n.initFromArray(t, i), h !== !1 && n.load(), n;
    }
    return e.prototype.bind = function(t) {
      r.prototype.bind.call(this, t), t.target = qe.TEXTURE_CUBE_MAP;
    }, e.prototype.addBaseTextureAt = function(t, i, n) {
      if (!this.items[i])
        throw new Error("Index " + i + " is out of bounds");
      if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0)
        if (t.resource)
          this.addResourceAt(t.resource, i);
        else
          throw new Error("CubeResource does not support copying of renderTexture.");
      else
        t.target = qe.TEXTURE_CUBE_MAP_POSITIVE_X + i, t.parentTextureArray = this.baseTexture, this.items[i] = t;
      return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[i] = t, this;
    }, e.prototype.upload = function(t, i, n) {
      for (var o = this.itemDirtyIds, s = 0; s < e.SIDES; s++) {
        var a = this.items[s];
        (o[s] < a.dirtyId || n.dirtyId < i.dirtyId) && (a.valid && a.resource ? (a.resource.upload(t, a, n), o[s] = a.dirtyId) : o[s] < -1 && (t.gl.texImage2D(a.target, 0, n.internalFormat, i.realWidth, i.realHeight, 0, i.format, n.type, null), o[s] = -1));
      }
      return !0;
    }, e.test = function(t) {
      return Array.isArray(t) && t.length === e.SIDES;
    }, e.SIDES = 6, e;
  }(Pu)
), Mu = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this;
      if (i = i || {}, !(t instanceof HTMLImageElement)) {
        var o = new Image();
        Ie.crossOrigin(o, t, i.crossorigin), o.src = t, t = o;
      }
      return n = r.call(this, t) || this, !t.complete && n._width && n._height && (n._width = 0, n._height = 0), n.url = t.src, n._process = null, n.preserveBitmap = !1, n.createBitmap = (i.createBitmap !== void 0 ? i.createBitmap : L.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, n.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null, n.bitmap = null, n._load = null, i.autoLoad !== !1 && n.load(), n;
    }
    return e.prototype.load = function(t) {
      var i = this;
      return this._load ? this._load : (t !== void 0 && (this.createBitmap = t), this._load = new Promise(function(n, o) {
        var s = i.source;
        i.url = s.src;
        var a = function() {
          i.destroyed || (s.onload = null, s.onerror = null, i.resize(s.width, s.height), i._load = null, i.createBitmap ? n(i.process()) : n(i));
        };
        s.complete && s.src ? a() : (s.onload = a, s.onerror = function(h) {
          o(h), i.onError.emit(h);
        });
      }), this._load);
    }, e.prototype.process = function() {
      var t = this, i = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var n = globalThis.createImageBitmap, o = !i.crossOrigin || i.crossOrigin === "anonymous";
      return this._process = fetch(i.src, {
        mode: o ? "cors" : "no-cors"
      }).then(function(s) {
        return s.blob();
      }).then(function(s) {
        return n(s, 0, 0, i.width, i.height, {
          premultiplyAlpha: t.alphaMode === null || t.alphaMode === ne.UNPACK ? "premultiply" : "none"
        });
      }).then(function(s) {
        return t.destroyed ? Promise.reject() : (t.bitmap = s, t.update(), t._process = null, Promise.resolve(t));
      }), this._process;
    }, e.prototype.upload = function(t, i, n) {
      if (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode), !this.createBitmap)
        return r.prototype.upload.call(this, t, i, n);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return !1;
      if (r.prototype.upload.call(this, t, i, n, this.bitmap), !this.preserveBitmap) {
        var o = !0, s = i._glTextures;
        for (var a in s) {
          var h = s[a];
          if (h !== n && h.dirtyId !== i.dirtyId) {
            o = !1;
            break;
          }
        }
        o && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return !0;
    }, e.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, r.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, e.test = function(t) {
      return typeof t == "string" || t instanceof HTMLImageElement;
    }, e;
  }(Ie)
), D_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this;
      return i = i || {}, n = r.call(this, L.ADAPTER.createCanvas()) || this, n._width = 0, n._height = 0, n.svg = t, n.scale = i.scale || 1, n._overrideWidth = i.width, n._overrideHeight = i.height, n._resolve = null, n._crossorigin = i.crossorigin, n._load = null, i.autoLoad !== !1 && n.load(), n;
    }
    return e.prototype.load = function() {
      var t = this;
      return this._load ? this._load : (this._load = new Promise(function(i) {
        if (t._resolve = function() {
          t.resize(t.source.width, t.source.height), i(t);
        }, e.SVG_XML.test(t.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg)));
        }
        t._loadSvg();
      }), this._load);
    }, e.prototype._loadSvg = function() {
      var t = this, i = new Image();
      Ie.crossOrigin(i, this.svg, this._crossorigin), i.src = this.svg, i.onerror = function(n) {
        t._resolve && (i.onerror = null, t.onError.emit(n));
      }, i.onload = function() {
        if (t._resolve) {
          var n = i.width, o = i.height;
          if (!n || !o)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var s = n * t.scale, a = o * t.scale;
          (t._overrideWidth || t._overrideHeight) && (s = t._overrideWidth || t._overrideHeight / o * n, a = t._overrideHeight || t._overrideWidth / n * o), s = Math.round(s), a = Math.round(a);
          var h = t.source;
          h.width = s, h.height = a, h._pixiId = "canvas_" + tr(), h.getContext("2d").drawImage(i, 0, 0, n, o, 0, 0, s, a), t._resolve(), t._resolve = null;
        }
      };
    }, e.getSize = function(t) {
      var i = e.SVG_SIZE.exec(t), n = {};
      return i && (n[i[1]] = Math.round(parseFloat(i[3])), n[i[5]] = Math.round(parseFloat(i[7]))), n;
    }, e.prototype.dispose = function() {
      r.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, e.test = function(t, i) {
      return i === "svg" || typeof t == "string" && t.startsWith("data:image/svg+xml") || typeof t == "string" && e.SVG_XML.test(t);
    }, e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e;
  }(Ie)
), C_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = this;
      if (i = i || {}, !(t instanceof HTMLVideoElement)) {
        var o = document.createElement("video");
        o.setAttribute("preload", "auto"), o.setAttribute("webkit-playsinline", ""), o.setAttribute("playsinline", ""), typeof t == "string" && (t = [t]);
        var s = t[0].src || t[0];
        Ie.crossOrigin(o, s, i.crossorigin);
        for (var a = 0; a < t.length; ++a) {
          var h = document.createElement("source"), u = t[a], l = u.src, c = u.mime;
          l = l || t[a];
          var p = l.split("?").shift().toLowerCase(), d = p.slice(p.lastIndexOf(".") + 1);
          c = c || e.MIME_TYPES[d] || "video/" + d, h.src = l, h.type = c, o.appendChild(h);
        }
        t = o;
      }
      return n = r.call(this, t) || this, n.noSubImage = !0, n._autoUpdate = !0, n._isConnectedToTicker = !1, n._updateFPS = i.updateFPS || 0, n._msToNextUpdate = 0, n.autoPlay = i.autoPlay !== !1, n._load = null, n._resolve = null, n._onCanPlay = n._onCanPlay.bind(n), n._onError = n._onError.bind(n), i.autoLoad !== !1 && n.load(), n;
    }
    return e.prototype.update = function(t) {
      if (!this.destroyed) {
        var i = Lt.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - i), (!this._updateFPS || this._msToNextUpdate <= 0) && (r.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, e.prototype.load = function() {
      var t = this;
      if (this._load)
        return this._load;
      var i = this.source;
      return (i.readyState === i.HAVE_ENOUGH_DATA || i.readyState === i.HAVE_FUTURE_DATA) && i.width && i.height && (i.complete = !0), i.addEventListener("play", this._onPlayStart.bind(this)), i.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (i.addEventListener("canplay", this._onCanPlay), i.addEventListener("canplaythrough", this._onCanPlay), i.addEventListener("error", this._onError, !0)), this._load = new Promise(function(n) {
        t.valid ? n(t) : (t._resolve = n, i.load());
      }), this._load;
    }, e.prototype._onError = function(t) {
      this.source.removeEventListener("error", this._onError, !0), this.onError.emit(t);
    }, e.prototype._isSourcePlaying = function() {
      var t = this.source;
      return !t.paused && !t.ended && this._isSourceReady();
    }, e.prototype._isSourceReady = function() {
      var t = this.source;
      return t.readyState > 2;
    }, e.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Lt.shared.add(this.update, this), this._isConnectedToTicker = !0);
    }, e.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1);
    }, e.prototype._onCanPlay = function() {
      var t = this.source;
      t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
      var i = this.valid;
      this.resize(t.videoWidth, t.videoHeight), !i && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play();
    }, e.prototype.dispose = function() {
      this._isConnectedToTicker && (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1);
      var t = this.source;
      t && (t.removeEventListener("error", this._onError, !0), t.pause(), t.src = "", t.load()), r.prototype.dispose.call(this);
    }, Object.defineProperty(e.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(t) {
        t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Lt.shared.add(this.update, this), this._isConnectedToTicker = !0));
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(t) {
        t !== this._updateFPS && (this._updateFPS = t);
      },
      enumerable: !1,
      configurable: !0
    }), e.test = function(t, i) {
      return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || e.TYPES.indexOf(i) > -1;
    }, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    }, e;
  }(Ie)
), F_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.test = function(t) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && t instanceof ImageBitmap;
    }, e;
  }(Ie)
);
Bo.push(Mu, F_, P_, C_, D_, li, M_, I_);
var N_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.upload = function(t, i, n) {
      var o = t.gl;
      o.pixelStorei(o.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === ne.UNPACK);
      var s = i.realWidth, a = i.realHeight;
      return n.width === s && n.height === a ? o.texSubImage2D(i.target, 0, 0, 0, s, a, i.format, n.type, this.data) : (n.width = s, n.height = a, o.texImage2D(i.target, 0, n.internalFormat, s, a, 0, i.format, n.type, this.data)), !0;
    }, e;
  }(li)
), ko = (
  /** @class */
  function() {
    function r(e, t) {
      this.width = Math.round(e || 100), this.height = Math.round(t || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Nt("disposeFramebuffer"), this.multisample = gt.NONE;
    }
    return Object.defineProperty(r.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.addColorTexture = function(e, t) {
      return e === void 0 && (e = 0), this.colorTextures[e] = t || new rt(null, {
        scaleMode: he.NEAREST,
        resolution: 1,
        mipmap: ie.OFF,
        width: this.width,
        height: this.height
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.addDepthTexture = function(e) {
      return this.depthTexture = e || new rt(new N_(null, { width: this.width, height: this.height }), {
        scaleMode: he.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: ie.OFF,
        format: P.DEPTH_COMPONENT,
        type: U.UNSIGNED_SHORT
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.enableDepth = function() {
      return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.enableStencil = function() {
      return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this;
    }, r.prototype.resize = function(e, t) {
      if (e = Math.round(e), t = Math.round(t), !(e === this.width && t === this.height)) {
        this.width = e, this.height = t, this.dirtyId++, this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
          var n = this.colorTextures[i], o = n.resolution;
          n.setSize(e / o, t / o);
        }
        if (this.depthTexture) {
          var o = this.depthTexture.resolution;
          this.depthTexture.setSize(e / o, t / o);
        }
      }
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, r;
  }()
), Du = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      t === void 0 && (t = {});
      var i = this;
      if (typeof t == "number") {
        var n = arguments[0], o = arguments[1], s = arguments[2], a = arguments[3];
        t = { width: n, height: o, scaleMode: s, resolution: a };
      }
      return t.width = t.width || 100, t.height = t.height || 100, t.multisample = t.multisample !== void 0 ? t.multisample : gt.NONE, i = r.call(this, null, t) || this, i.mipmap = ie.OFF, i.valid = !0, i.clearColor = [0, 0, 0, 0], i.framebuffer = new ko(i.realWidth, i.realHeight).addColorTexture(0, i), i.framebuffer.multisample = t.multisample, i.maskStack = [], i.filterStack = [{}], i;
    }
    return e.prototype.resize = function(t, i) {
      this.framebuffer.resize(t * this.resolution, i * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, e.prototype.dispose = function() {
      this.framebuffer.dispose(), r.prototype.dispose.call(this);
    }, e.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, e;
  }(rt)
), Cu = (
  /** @class */
  function() {
    function r() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return r.prototype.set = function(e, t, i) {
      var n = t.width, o = t.height;
      if (i) {
        var s = e.width / 2 / n, a = e.height / 2 / o, h = e.x / n + s, u = e.y / o + a;
        i = bt.add(i, bt.NW), this.x0 = h + s * bt.uX(i), this.y0 = u + a * bt.uY(i), i = bt.add(i, 2), this.x1 = h + s * bt.uX(i), this.y1 = u + a * bt.uY(i), i = bt.add(i, 2), this.x2 = h + s * bt.uX(i), this.y2 = u + a * bt.uY(i), i = bt.add(i, 2), this.x3 = h + s * bt.uX(i), this.y3 = u + a * bt.uY(i);
      } else
        this.x0 = e.x / n, this.y0 = e.y / o, this.x1 = (e.x + e.width) / n, this.y1 = e.y / o, this.x2 = (e.x + e.width) / n, this.y2 = (e.y + e.height) / o, this.x3 = e.x / n, this.y3 = (e.y + e.height) / o;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, r.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    }, r;
  }()
), Va = new Cu();
function Oi(r) {
  r.destroy = function() {
  }, r.on = function() {
  }, r.once = function() {
  }, r.emit = function() {
  };
}
var W = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i, n, o, s, a) {
      var h = r.call(this) || this;
      if (h.noFrame = !1, i || (h.noFrame = !0, i = new it(0, 0, 1, 1)), t instanceof e && (t = t.baseTexture), h.baseTexture = t, h._frame = i, h.trim = o, h.valid = !1, h._uvs = Va, h.uvMatrix = null, h.orig = n || i, h._rotate = Number(s || 0), s === !0)
        h._rotate = 2;
      else if (h._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return h.defaultAnchor = a ? new _t(a.x, a.y) : new _t(0, 0), h._updateID = 0, h.textureCacheIds = [], t.valid ? h.noFrame ? t.valid && h.onBaseTextureUpdated(t) : h.frame = i : t.once("loaded", h.onBaseTextureUpdated, h), h.noFrame && t.on("update", h.onBaseTextureUpdated, h), h;
    }
    return e.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, e.prototype.onBaseTextureUpdated = function(t) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, e.prototype.destroy = function(t) {
      if (this.baseTexture) {
        if (t) {
          var i = this.baseTexture.resource;
          i && i.url && me[i.url] && e.removeFromCache(i.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, e.removeFromCache(this), this.textureCacheIds = null;
    }, e.prototype.clone = function() {
      var t = this._frame.clone(), i = this._frame === this.orig ? t : this.orig.clone(), n = new e(this.baseTexture, !this.noFrame && t, i, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (n._frame = t), n;
    }, e.prototype.updateUvs = function() {
      this._uvs === Va && (this._uvs = new Cu()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, e.from = function(t, i, n) {
      i === void 0 && (i = {}), n === void 0 && (n = L.STRICT_TEXTURE_CACHE);
      var o = typeof t == "string", s = null;
      if (o)
        s = t;
      else if (t instanceof rt) {
        if (!t.cacheId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          t.cacheId = a + "-" + tr(), rt.addToCache(t, t.cacheId);
        }
        s = t.cacheId;
      } else {
        if (!t._pixiId) {
          var a = i && i.pixiIdPrefix || "pixiid";
          t._pixiId = a + "_" + tr();
        }
        s = t._pixiId;
      }
      var h = me[s];
      if (o && n && !h)
        throw new Error('The cacheId "' + s + '" does not exist in TextureCache.');
      return !h && !(t instanceof rt) ? (i.resolution || (i.resolution = hn(t)), h = new e(new rt(t, i)), h.baseTexture.cacheId = s, rt.addToCache(h.baseTexture, s), e.addToCache(h, s)) : !h && t instanceof rt && (h = new e(t), e.addToCache(h, s)), h;
    }, e.fromURL = function(t, i) {
      var n = Object.assign({ autoLoad: !1 }, i == null ? void 0 : i.resourceOptions), o = e.from(t, Object.assign({ resourceOptions: n }, i), !1), s = o.baseTexture.resource;
      return o.baseTexture.valid ? Promise.resolve(o) : s.load().then(function() {
        return Promise.resolve(o);
      });
    }, e.fromBuffer = function(t, i, n, o) {
      return new e(rt.fromBuffer(t, i, n, o));
    }, e.fromLoader = function(t, i, n, o) {
      var s = new rt(t, Object.assign({
        scaleMode: L.SCALE_MODE,
        resolution: hn(i)
      }, o)), a = s.resource;
      a instanceof Mu && (a.url = i);
      var h = new e(s);
      return n || (n = i), rt.addToCache(h.baseTexture, n), e.addToCache(h, n), n !== i && (rt.addToCache(h.baseTexture, i), e.addToCache(h, i)), h.baseTexture.valid ? Promise.resolve(h) : new Promise(function(u) {
        h.baseTexture.once("loaded", function() {
          return u(h);
        });
      });
    }, e.addToCache = function(t, i) {
      i && (t.textureCacheIds.indexOf(i) === -1 && t.textureCacheIds.push(i), me[i] && console.warn("Texture added to the cache with an id [" + i + "] that already had an entry"), me[i] = t);
    }, e.removeFromCache = function(t) {
      if (typeof t == "string") {
        var i = me[t];
        if (i) {
          var n = i.textureCacheIds.indexOf(t);
          return n > -1 && i.textureCacheIds.splice(n, 1), delete me[t], i;
        }
      } else if (t && t.textureCacheIds) {
        for (var o = 0; o < t.textureCacheIds.length; ++o)
          me[t.textureCacheIds[o]] === t && delete me[t.textureCacheIds[o]];
        return t.textureCacheIds.length = 0, t;
      }
      return null;
    }, Object.defineProperty(e.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(t) {
        this._frame = t, this.noFrame = !1;
        var i = t.x, n = t.y, o = t.width, s = t.height, a = i + o > this.baseTexture.width, h = n + s > this.baseTexture.height;
        if (a || h) {
          var u = a && h ? "and" : "or", l = "X: " + i + " + " + o + " = " + (i + o) + " > " + this.baseTexture.width, c = "Y: " + n + " + " + s + " = " + (n + s) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (l + " " + u + " " + c));
        }
        this.valid = o && s && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = t), this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(t) {
        this._rotate = t, this.valid && this.updateUvs();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(e, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        return e._EMPTY || (e._EMPTY = new e(new rt()), Oi(e._EMPTY), Oi(e._EMPTY.baseTexture)), e._EMPTY;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!e._WHITE) {
          var t = L.ADAPTER.createCanvas(16, 16), i = t.getContext("2d");
          t.width = 16, t.height = 16, i.fillStyle = "white", i.fillRect(0, 0, 16, 16), e._WHITE = new e(rt.from(t)), Oi(e._WHITE), Oi(e._WHITE.baseTexture);
        }
        return e._WHITE;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(hi)
), er = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      var n = r.call(this, t, i) || this;
      return n.valid = !0, n.filterFrame = null, n.filterPoolKey = null, n.updateUvs(), n;
    }
    return Object.defineProperty(e.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(t) {
        this.framebuffer.multisample = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.resize = function(t, i, n) {
      n === void 0 && (n = !0);
      var o = this.baseTexture.resolution, s = Math.round(t * o) / o, a = Math.round(i * o) / o;
      this.valid = s > 0 && a > 0, this._frame.width = this.orig.width = s, this._frame.height = this.orig.height = a, n && this.baseTexture.resize(s, a), this.updateUvs();
    }, e.prototype.setResolution = function(t) {
      var i = this.baseTexture;
      i.resolution !== t && (i.setResolution(t), this.resize(i.width, i.height, !1));
    }, e.create = function(t) {
      for (var i = arguments, n = [], o = 1; o < arguments.length; o++)
        n[o - 1] = i[o];
      return typeof t == "number" && (re("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t = {
        width: t,
        height: n[0],
        scaleMode: n[1],
        resolution: n[2]
      }), new e(new Du(t));
    }, e;
  }(W)
), L_ = (
  /** @class */
  function() {
    function r(e) {
      this.texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return r.prototype.createTexture = function(e, t, i) {
      i === void 0 && (i = gt.NONE);
      var n = new Du(Object.assign({
        width: e,
        height: t,
        resolution: 1,
        multisample: i
      }, this.textureOptions));
      return new er(n);
    }, r.prototype.getOptimalTexture = function(e, t, i, n) {
      i === void 0 && (i = 1), n === void 0 && (n = gt.NONE);
      var o;
      e = Math.ceil(e * i - 1e-6), t = Math.ceil(t * i - 1e-6), !this.enableFullScreen || e !== this._pixelsWidth || t !== this._pixelsHeight ? (e = an(e), t = an(t), o = ((e & 65535) << 16 | t & 65535) >>> 0, n > 1 && (o += n * 4294967296)) : o = n > 1 ? -n : -1, this.texturePool[o] || (this.texturePool[o] = []);
      var s = this.texturePool[o].pop();
      return s || (s = this.createTexture(e, t, n)), s.filterPoolKey = o, s.setResolution(i), s;
    }, r.prototype.getFilterTexture = function(e, t, i) {
      var n = this.getOptimalTexture(e.width, e.height, t || e.resolution, i || gt.NONE);
      return n.filterFrame = e.filterFrame, n;
    }, r.prototype.returnTexture = function(e) {
      var t = e.filterPoolKey;
      e.filterFrame = null, this.texturePool[t].push(e);
    }, r.prototype.returnFilterTexture = function(e) {
      this.returnTexture(e);
    }, r.prototype.clear = function(e) {
      if (e = e !== !1, e)
        for (var t in this.texturePool) {
          var i = this.texturePool[t];
          if (i)
            for (var n = 0; n < i.length; n++)
              i[n].destroy(!0);
        }
      this.texturePool = {};
    }, r.prototype.setScreenSize = function(e) {
      if (!(e.width === this._pixelsWidth && e.height === this._pixelsHeight)) {
        this.enableFullScreen = e.width > 0 && e.height > 0;
        for (var t in this.texturePool)
          if (Number(t) < 0) {
            var i = this.texturePool[t];
            if (i)
              for (var n = 0; n < i.length; n++)
                i[n].destroy(!0);
            this.texturePool[t] = [];
          }
        this._pixelsWidth = e.width, this._pixelsHeight = e.height;
      }
    }, r.SCREEN_KEY = -1, r;
  }()
), za = (
  /** @class */
  function() {
    function r(e, t, i, n, o, s, a) {
      t === void 0 && (t = 0), i === void 0 && (i = !1), n === void 0 && (n = U.FLOAT), this.buffer = e, this.size = t, this.normalized = i, this.type = n, this.stride = o, this.start = s, this.instance = a;
    }
    return r.prototype.destroy = function() {
      this.buffer = null;
    }, r.from = function(e, t, i, n, o) {
      return new r(e, t, i, n, o);
    }, r;
  }()
), B_ = 0, wt = (
  /** @class */
  function() {
    function r(e, t, i) {
      t === void 0 && (t = !0), i === void 0 && (i = !1), this.data = e || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = i, this.static = t, this.id = B_++, this.disposeRunner = new Nt("disposeBuffer");
    }
    return r.prototype.update = function(e) {
      e instanceof Array && (e = new Float32Array(e)), this.data = e || this.data, this._updateID++;
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(r.prototype, "index", {
      get: function() {
        return this.type === ce.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(e) {
        this.type = e ? ce.ELEMENT_ARRAY_BUFFER : ce.ARRAY_BUFFER;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(e) {
      return e instanceof Array && (e = new Float32Array(e)), new r(e);
    }, r;
  }()
), G_ = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function U_(r, e) {
  for (var t = 0, i = 0, n = {}, o = 0; o < r.length; o++)
    i += e[o], t += r[o].length;
  for (var s = new ArrayBuffer(t * 4), a = null, h = 0, o = 0; o < r.length; o++) {
    var u = e[o], l = r[o], c = Su(l);
    n[c] || (n[c] = new G_[c](s)), a = n[c];
    for (var p = 0; p < l.length; p++) {
      var d = (p / u | 0) * i + h, f = p % u;
      a[d + f] = l[p];
    }
    h += u;
  }
  return new Float32Array(s);
}
var Wa = { 5126: 4, 5123: 2, 5121: 1 }, k_ = 0, X_ = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, ci = (
  /** @class */
  function() {
    function r(e, t) {
      e === void 0 && (e = []), t === void 0 && (t = {}), this.buffers = e, this.indexBuffer = null, this.attributes = t, this.glVertexArrayObjects = {}, this.id = k_++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new Nt("disposeGeometry"), this.refCount = 0;
    }
    return r.prototype.addAttribute = function(e, t, i, n, o, s, a, h) {
      if (i === void 0 && (i = 0), n === void 0 && (n = !1), h === void 0 && (h = !1), !t)
        throw new Error("You must pass a buffer when creating an attribute");
      t instanceof wt || (t instanceof Array && (t = new Float32Array(t)), t = new wt(t));
      var u = e.split("|");
      if (u.length > 1) {
        for (var l = 0; l < u.length; l++)
          this.addAttribute(u[l], t, i, n, o);
        return this;
      }
      var c = this.buffers.indexOf(t);
      return c === -1 && (this.buffers.push(t), c = this.buffers.length - 1), this.attributes[e] = new za(c, i, n, o, s, a, h), this.instanced = this.instanced || h, this;
    }, r.prototype.getAttribute = function(e) {
      return this.attributes[e];
    }, r.prototype.getBuffer = function(e) {
      return this.buffers[this.getAttribute(e).buffer];
    }, r.prototype.addIndex = function(e) {
      return e instanceof wt || (e instanceof Array && (e = new Uint16Array(e)), e = new wt(e)), e.type = ce.ELEMENT_ARRAY_BUFFER, this.indexBuffer = e, this.buffers.indexOf(e) === -1 && this.buffers.push(e), this;
    }, r.prototype.getIndex = function() {
      return this.indexBuffer;
    }, r.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var e = [], t = [], i = new wt(), n;
      for (n in this.attributes) {
        var o = this.attributes[n], s = this.buffers[o.buffer];
        e.push(s.data), t.push(o.size * Wa[o.type] / 4), o.buffer = 0;
      }
      for (i.data = U_(e, t), n = 0; n < this.buffers.length; n++)
        this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
      return this.buffers = [i], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, r.prototype.getSize = function() {
      for (var e in this.attributes) {
        var t = this.attributes[e], i = this.buffers[t.buffer];
        return i.data.length / (t.stride / 4 || t.size);
      }
      return 0;
    }, r.prototype.dispose = function() {
      this.disposeRunner.emit(this, !1);
    }, r.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, r.prototype.clone = function() {
      for (var e = new r(), t = 0; t < this.buffers.length; t++)
        e.buffers[t] = new wt(this.buffers[t].data.slice(0));
      for (var t in this.attributes) {
        var i = this.attributes[t];
        e.attributes[t] = new za(i.buffer, i.size, i.normalized, i.type, i.stride, i.start, i.instance);
      }
      return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = ce.ELEMENT_ARRAY_BUFFER), e;
    }, r.merge = function(e) {
      for (var t = new r(), i = [], n = [], o = [], s, a = 0; a < e.length; a++) {
        s = e[a];
        for (var h = 0; h < s.buffers.length; h++)
          n[h] = n[h] || 0, n[h] += s.buffers[h].data.length, o[h] = 0;
      }
      for (var a = 0; a < s.buffers.length; a++)
        i[a] = new X_[Su(s.buffers[a].data)](n[a]), t.buffers[a] = new wt(i[a]);
      for (var a = 0; a < e.length; a++) {
        s = e[a];
        for (var h = 0; h < s.buffers.length; h++)
          i[h].set(s.buffers[h].data, o[h]), o[h] += s.buffers[h].data.length;
      }
      if (t.attributes = s.attributes, s.indexBuffer) {
        t.indexBuffer = t.buffers[s.buffers.indexOf(s.indexBuffer)], t.indexBuffer.type = ce.ELEMENT_ARRAY_BUFFER;
        for (var u = 0, l = 0, c = 0, p = 0, a = 0; a < s.buffers.length; a++)
          if (s.buffers[a] !== s.indexBuffer) {
            p = a;
            break;
          }
        for (var a in s.attributes) {
          var d = s.attributes[a];
          (d.buffer | 0) === p && (l += d.size * Wa[d.type] / 4);
        }
        for (var a = 0; a < e.length; a++) {
          for (var f = e[a].indexBuffer.data, h = 0; h < f.length; h++)
            t.indexBuffer.data[h + c] += u;
          u += e[a].buffers[p].data.length / l, c += f.length;
        }
      }
      return t;
    }, r;
  }()
), j_ = (
  /** @class */
  function(r) {
    yt(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]), t;
    }
    return e;
  }(ci)
), Fu = (
  /** @class */
  function(r) {
    yt(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]), t.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), t.vertexBuffer = new wt(t.vertices), t.uvBuffer = new wt(t.uvs), t.addAttribute("aVertexPosition", t.vertexBuffer).addAttribute("aTextureCoord", t.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), t;
    }
    return e.prototype.map = function(t, i) {
      var n = 0, o = 0;
      return this.uvs[0] = n, this.uvs[1] = o, this.uvs[2] = n + i.width / t.width, this.uvs[3] = o, this.uvs[4] = n + i.width / t.width, this.uvs[5] = o + i.height / t.height, this.uvs[6] = n, this.uvs[7] = o + i.height / t.height, n = i.x, o = i.y, this.vertices[0] = n, this.vertices[1] = o, this.vertices[2] = n + i.width, this.vertices[3] = o, this.vertices[4] = n + i.width, this.vertices[5] = o + i.height, this.vertices[6] = n, this.vertices[7] = o + i.height, this.invalidate(), this;
    }, e.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, e;
  }(ci)
), H_ = 0, Je = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = H_++, this.static = !!t, this.ubo = !!i, e instanceof wt ? (this.buffer = e, this.buffer.type = ce.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = e, this.ubo && (this.buffer = new wt(new Float32Array(1)), this.buffer.type = ce.UNIFORM_BUFFER, this.autoManage = !0));
    }
    return r.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, r.prototype.add = function(e, t, i) {
      if (!this.ubo)
        this.uniforms[e] = new r(t, i);
      else
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }, r.from = function(e, t, i) {
      return new r(e, t, i);
    }, r.uboFrom = function(e, t) {
      return new r(e, t ?? !0, !0);
    }, r;
  }()
), Y_ = (
  /** @class */
  function() {
    function r() {
      this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = gt.NONE, this.sourceFrame = new it(), this.destinationFrame = new it(), this.bindingSourceFrame = new it(), this.bindingDestinationFrame = new it(), this.filters = [], this.transform = null;
    }
    return r.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, r;
  }()
), wi = [new _t(), new _t(), new _t(), new _t()], Wn = new It(), V_ = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.defaultFilterStack = [{}], this.texturePool = new L_(), this.texturePool.setScreenSize(e.view), this.statePool = [], this.quad = new j_(), this.quadUv = new Fu(), this.tempRect = new it(), this.activeState = {}, this.globalUniforms = new Je({
        outputFrame: new it(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, !0), this.forceClear = !1, this.useMaxPadding = !1;
    }
    return r.prototype.push = function(e, t) {
      for (var i, n, o = this.renderer, s = this.defaultFilterStack, a = this.statePool.pop() || new Y_(), h = this.renderer.renderTexture, u = t[0].resolution, l = t[0].multisample, c = t[0].padding, p = t[0].autoFit, d = (i = t[0].legacy) !== null && i !== void 0 ? i : !0, f = 1; f < t.length; f++) {
        var y = t[f];
        u = Math.min(u, y.resolution), l = Math.min(l, y.multisample), c = this.useMaxPadding ? Math.max(c, y.padding) : c + y.padding, p = p && y.autoFit, d = d || ((n = y.legacy) !== null && n !== void 0 ? n : !0);
      }
      s.length === 1 && (this.defaultFilterStack[0].renderTexture = h.current), s.push(a), a.resolution = u, a.multisample = l, a.legacy = d, a.target = e, a.sourceFrame.copyFrom(e.filterArea || e.getBounds(!0)), a.sourceFrame.pad(c);
      var m = this.tempRect.copyFrom(h.sourceFrame);
      o.projection.transform && this.transformAABB(Wn.copyFrom(o.projection.transform).invert(), m), p ? (a.sourceFrame.fit(m), (a.sourceFrame.width <= 0 || a.sourceFrame.height <= 0) && (a.sourceFrame.width = 0, a.sourceFrame.height = 0)) : a.sourceFrame.intersects(m) || (a.sourceFrame.width = 0, a.sourceFrame.height = 0), this.roundFrame(a.sourceFrame, h.current ? h.current.resolution : o.resolution, h.sourceFrame, h.destinationFrame, o.projection.transform), a.renderTexture = this.getOptimalFilterTexture(a.sourceFrame.width, a.sourceFrame.height, u, l), a.filters = t, a.destinationFrame.width = a.renderTexture.width, a.destinationFrame.height = a.renderTexture.height;
      var _ = this.tempRect;
      _.x = 0, _.y = 0, _.width = a.sourceFrame.width, _.height = a.sourceFrame.height, a.renderTexture.filterFrame = a.sourceFrame, a.bindingSourceFrame.copyFrom(h.sourceFrame), a.bindingDestinationFrame.copyFrom(h.destinationFrame), a.transform = o.projection.transform, o.projection.transform = null, h.bind(a.renderTexture, a.sourceFrame, _), o.framebuffer.clear(0, 0, 0, 0);
    }, r.prototype.pop = function() {
      var e = this.defaultFilterStack, t = e.pop(), i = t.filters;
      this.activeState = t;
      var n = this.globalUniforms.uniforms;
      n.outputFrame = t.sourceFrame, n.resolution = t.resolution;
      var o = n.inputSize, s = n.inputPixel, a = n.inputClamp;
      if (o[0] = t.destinationFrame.width, o[1] = t.destinationFrame.height, o[2] = 1 / o[0], o[3] = 1 / o[1], s[0] = Math.round(o[0] * t.resolution), s[1] = Math.round(o[1] * t.resolution), s[2] = 1 / s[0], s[3] = 1 / s[1], a[0] = 0.5 * s[2], a[1] = 0.5 * s[3], a[2] = t.sourceFrame.width * o[2] - 0.5 * s[2], a[3] = t.sourceFrame.height * o[3] - 0.5 * s[3], t.legacy) {
        var h = n.filterArea;
        h[0] = t.destinationFrame.width, h[1] = t.destinationFrame.height, h[2] = t.sourceFrame.x, h[3] = t.sourceFrame.y, n.filterClamp = n.inputClamp;
      }
      this.globalUniforms.update();
      var u = e[e.length - 1];
      if (this.renderer.framebuffer.blit(), i.length === 1)
        i[0].apply(this, t.renderTexture, u.renderTexture, Qt.BLEND, t), this.returnFilterTexture(t.renderTexture);
      else {
        var l = t.renderTexture, c = this.getOptimalFilterTexture(l.width, l.height, t.resolution);
        c.filterFrame = l.filterFrame;
        var p = 0;
        for (p = 0; p < i.length - 1; ++p) {
          p === 1 && t.multisample > 1 && (c = this.getOptimalFilterTexture(l.width, l.height, t.resolution), c.filterFrame = l.filterFrame), i[p].apply(this, l, c, Qt.CLEAR, t);
          var d = l;
          l = c, c = d;
        }
        i[p].apply(this, l, u.renderTexture, Qt.BLEND, t), p > 1 && t.multisample > 1 && this.returnFilterTexture(t.renderTexture), this.returnFilterTexture(l), this.returnFilterTexture(c);
      }
      t.clear(), this.statePool.push(t);
    }, r.prototype.bindAndClear = function(e, t) {
      t === void 0 && (t = Qt.CLEAR);
      var i = this.renderer, n = i.renderTexture, o = i.state;
      if (e === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, e && e.filterFrame) {
        var s = this.tempRect;
        s.x = 0, s.y = 0, s.width = e.filterFrame.width, s.height = e.filterFrame.height, n.bind(e, e.filterFrame, s);
      } else
        e !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? n.bind(e) : this.renderer.renderTexture.bind(e, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var a = o.stateId & 1 || this.forceClear;
      (t === Qt.CLEAR || t === Qt.BLIT && a) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, r.prototype.applyFilter = function(e, t, i, n) {
      var o = this.renderer;
      o.state.set(e.state), this.bindAndClear(i, n), e.uniforms.uSampler = t, e.uniforms.filterGlobals = this.globalUniforms, o.shader.bind(e), e.legacy = !!e.program.attributeData.aTextureCoord, e.legacy ? (this.quadUv.map(t._frame, t.filterFrame), o.geometry.bind(this.quadUv), o.geometry.draw(te.TRIANGLES)) : (o.geometry.bind(this.quad), o.geometry.draw(te.TRIANGLE_STRIP));
    }, r.prototype.calculateSpriteMatrix = function(e, t) {
      var i = this.activeState, n = i.sourceFrame, o = i.destinationFrame, s = t._texture.orig, a = e.set(o.width, 0, 0, o.height, n.x, n.y), h = t.worldTransform.copyTo(It.TEMP_MATRIX);
      return h.invert(), a.prepend(h), a.scale(1 / s.width, 1 / s.height), a.translate(t.anchor.x, t.anchor.y), a;
    }, r.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(!1);
    }, r.prototype.getOptimalFilterTexture = function(e, t, i, n) {
      return i === void 0 && (i = 1), n === void 0 && (n = gt.NONE), this.texturePool.getOptimalTexture(e, t, i, n);
    }, r.prototype.getFilterTexture = function(e, t, i) {
      if (typeof e == "number") {
        var n = e;
        e = t, t = n;
      }
      e = e || this.activeState.renderTexture;
      var o = this.texturePool.getOptimalTexture(e.width, e.height, t || e.resolution, i || gt.NONE);
      return o.filterFrame = e.filterFrame, o;
    }, r.prototype.returnFilterTexture = function(e) {
      this.texturePool.returnTexture(e);
    }, r.prototype.emptyPool = function() {
      this.texturePool.clear(!0);
    }, r.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, r.prototype.transformAABB = function(e, t) {
      var i = wi[0], n = wi[1], o = wi[2], s = wi[3];
      i.set(t.left, t.top), n.set(t.left, t.bottom), o.set(t.right, t.top), s.set(t.right, t.bottom), e.apply(i, i), e.apply(n, n), e.apply(o, o), e.apply(s, s);
      var a = Math.min(i.x, n.x, o.x, s.x), h = Math.min(i.y, n.y, o.y, s.y), u = Math.max(i.x, n.x, o.x, s.x), l = Math.max(i.y, n.y, o.y, s.y);
      t.x = a, t.y = h, t.width = u - a, t.height = l - h;
    }, r.prototype.roundFrame = function(e, t, i, n, o) {
      if (!(e.width <= 0 || e.height <= 0 || i.width <= 0 || i.height <= 0)) {
        if (o) {
          var s = o.a, a = o.b, h = o.c, u = o.d;
          if ((Math.abs(a) > 1e-4 || Math.abs(h) > 1e-4) && (Math.abs(s) > 1e-4 || Math.abs(u) > 1e-4))
            return;
        }
        o = o ? Wn.copyFrom(o) : Wn.identity(), o.translate(-i.x, -i.y).scale(n.width / i.width, n.height / i.height).translate(n.x, n.y), this.transformAABB(o, e), e.ceil(t), this.transformAABB(o.invert(), e);
      }
    }, r;
  }()
), xn = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e;
    }
    return r.prototype.flush = function() {
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r.prototype.start = function() {
    }, r.prototype.stop = function() {
      this.flush();
    }, r.prototype.render = function(e) {
    }, r;
  }()
), z_ = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.emptyRenderer = new xn(e), this.currentRenderer = this.emptyRenderer;
    }
    return r.prototype.setObjectRenderer = function(e) {
      this.currentRenderer !== e && (this.currentRenderer.stop(), this.currentRenderer = e, this.currentRenderer.start());
    }, r.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, r.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, r.prototype.copyBoundTextures = function(e, t) {
      for (var i = this.renderer.texture.boundTextures, n = t - 1; n >= 0; --n)
        e[n] = i[n] || null, e[n] && (e[n]._batchLocation = n);
    }, r.prototype.boundArray = function(e, t, i, n) {
      for (var o = e.elements, s = e.ids, a = e.count, h = 0, u = 0; u < a; u++) {
        var l = o[u], c = l._batchLocation;
        if (c >= 0 && c < n && t[c] === l) {
          s[u] = c;
          continue;
        }
        for (; h < n; ) {
          var p = t[h];
          if (p && p._batchEnabled === i && p._batchLocation === h) {
            h++;
            continue;
          }
          s[u] = h, l._batchLocation = h, t[h] = l;
          break;
        }
      }
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), $a = 0, W_ = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.webGLVersion = 1, this.extensions = {}, this.supports = {
        uint32Indices: !1
      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), e.view.addEventListener("webglcontextlost", this.handleContextLost, !1), e.view.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
    }
    return Object.defineProperty(r.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.contextChange = function(e) {
      this.gl = e, this.renderer.gl = e, this.renderer.CONTEXT_UID = $a++;
    }, r.prototype.initFromContext = function(e) {
      this.gl = e, this.validateContext(e), this.renderer.gl = e, this.renderer.CONTEXT_UID = $a++, this.renderer.runners.contextChange.emit(e);
    }, r.prototype.initFromOptions = function(e) {
      var t = this.createContext(this.renderer.view, e);
      this.initFromContext(t);
    }, r.prototype.createContext = function(e, t) {
      var i;
      if (L.PREFER_ENV >= be.WEBGL2 && (i = e.getContext("webgl2", t)), i)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, i = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), !i)
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = i, this.getExtensions(), this.gl;
    }, r.prototype.getExtensions = function() {
      var e = this.gl, t = {
        loseContext: e.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: e.getExtension("OES_texture_float_linear"),
        s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: e.getExtension("WEBGL_compressed_texture_etc"),
        etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: e.getExtension("WEBGL_compressed_texture_atc"),
        astc: e.getExtension("WEBGL_compressed_texture_astc")
      };
      this.webGLVersion === 1 ? Object.assign(this.extensions, t, {
        drawBuffers: e.getExtension("WEBGL_draw_buffers"),
        depthTexture: e.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: e.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: e.getExtension("OES_texture_float"),
        floatTextureLinear: e.getExtension("OES_texture_float_linear"),
        textureHalfFloat: e.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear")
      }) : this.webGLVersion === 2 && Object.assign(this.extensions, t, {
        // Floats and half-floats
        colorBufferFloat: e.getExtension("EXT_color_buffer_float")
      });
    }, r.prototype.handleContextLost = function(e) {
      var t = this;
      e.preventDefault(), setTimeout(function() {
        t.gl.isContextLost() && t.extensions.loseContext && t.extensions.loseContext.restoreContext();
      }, 0);
    }, r.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, r.prototype.destroy = function() {
      var e = this.renderer.view;
      this.renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, r.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, r.prototype.validateContext = function(e) {
      var t = e.getContextAttributes(), i = "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext;
      i && (this.webGLVersion = 2), t && !t.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var n = i || !!e.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, r;
  }()
), $_ = (
  /** @class */
  function() {
    function r(e) {
      this.framebuffer = e, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = gt.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }
    return r;
  }()
), q_ = new it(), K_ = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.managedFramebuffers = [], this.unknownFramebuffer = new ko(10, 10), this.msaaSamples = null;
    }
    return r.prototype.contextChange = function() {
      this.disposeAll(!0);
      var e = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new it(), this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
        var t = this.renderer.context.extensions.drawBuffers, i = this.renderer.context.extensions.depthTexture;
        L.PREFER_ENV === be.WEBGL_LEGACY && (t = null, i = null), t ? e.drawBuffers = function(n) {
          return t.drawBuffersWEBGL(n);
        } : (this.hasMRT = !1, e.drawBuffers = function() {
        }), i || (this.writeDepthTexture = !1);
      } else
        this.msaaSamples = e.getInternalformatParameter(e.RENDERBUFFER, e.RGBA8, e.SAMPLES);
    }, r.prototype.bind = function(e, t, i) {
      i === void 0 && (i = 0);
      var n = this.gl;
      if (e) {
        var o = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
        this.current !== e && (this.current = e, n.bindFramebuffer(n.FRAMEBUFFER, o.framebuffer)), o.mipLevel !== i && (e.dirtyId++, e.dirtyFormat++, o.mipLevel = i), o.dirtyId !== e.dirtyId && (o.dirtyId = e.dirtyId, o.dirtyFormat !== e.dirtyFormat ? (o.dirtyFormat = e.dirtyFormat, o.dirtySize = e.dirtySize, this.updateFramebuffer(e, i)) : o.dirtySize !== e.dirtySize && (o.dirtySize = e.dirtySize, this.resizeFramebuffer(e)));
        for (var s = 0; s < e.colorTextures.length; s++) {
          var a = e.colorTextures[s];
          this.renderer.texture.unbind(a.parentTextureArray || a);
        }
        if (e.depthTexture && this.renderer.texture.unbind(e.depthTexture), t) {
          var h = t.width >> i, u = t.height >> i, l = h / t.width;
          this.setViewport(t.x * l, t.y * l, h, u);
        } else {
          var h = e.width >> i, u = e.height >> i;
          this.setViewport(0, 0, h, u);
        }
      } else
        this.current && (this.current = null, n.bindFramebuffer(n.FRAMEBUFFER, null)), t ? this.setViewport(t.x, t.y, t.width, t.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, r.prototype.setViewport = function(e, t, i, n) {
      var o = this.viewport;
      e = Math.round(e), t = Math.round(t), i = Math.round(i), n = Math.round(n), (o.width !== i || o.height !== n || o.x !== e || o.y !== t) && (o.x = e, o.y = t, o.width = i, o.height = n, this.gl.viewport(e, t, i, n));
    }, Object.defineProperty(r.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.clear = function(e, t, i, n, o) {
      o === void 0 && (o = Ji.COLOR | Ji.DEPTH);
      var s = this.gl;
      s.clearColor(e, t, i, n), s.clear(o);
    }, r.prototype.initFramebuffer = function(e) {
      var t = this.gl, i = new $_(t.createFramebuffer());
      return i.multisample = this.detectSamples(e.multisample), e.glFramebuffers[this.CONTEXT_UID] = i, this.managedFramebuffers.push(e), e.disposeRunner.add(this), i;
    }, r.prototype.resizeFramebuffer = function(e) {
      var t = this.gl, i = e.glFramebuffers[this.CONTEXT_UID];
      i.msaaBuffer && (t.bindRenderbuffer(t.RENDERBUFFER, i.msaaBuffer), t.renderbufferStorageMultisample(t.RENDERBUFFER, i.multisample, t.RGBA8, e.width, e.height)), i.stencil && (t.bindRenderbuffer(t.RENDERBUFFER, i.stencil), i.msaaBuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, i.multisample, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, e.width, e.height));
      var n = e.colorTextures, o = n.length;
      t.drawBuffers || (o = Math.min(o, 1));
      for (var s = 0; s < o; s++) {
        var a = n[s], h = a.parentTextureArray || a;
        this.renderer.texture.bind(h, 0);
      }
      e.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(e.depthTexture, 0);
    }, r.prototype.updateFramebuffer = function(e, t) {
      var i = this.gl, n = e.glFramebuffers[this.CONTEXT_UID], o = e.colorTextures, s = o.length;
      i.drawBuffers || (s = Math.min(s, 1)), n.multisample > 1 && this.canMultisampleFramebuffer(e) ? (n.msaaBuffer = n.msaaBuffer || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, n.msaaBuffer), i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, i.RGBA8, e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, n.msaaBuffer)) : n.msaaBuffer && (i.deleteRenderbuffer(n.msaaBuffer), n.msaaBuffer = null, n.blitFramebuffer && (n.blitFramebuffer.dispose(), n.blitFramebuffer = null));
      for (var a = [], h = 0; h < s; h++) {
        var u = o[h], l = u.parentTextureArray || u;
        this.renderer.texture.bind(l, 0), !(h === 0 && n.msaaBuffer) && (i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + h, u.target, l._glTextures[this.CONTEXT_UID].texture, t), a.push(i.COLOR_ATTACHMENT0 + h));
      }
      if (a.length > 1 && i.drawBuffers(a), e.depthTexture) {
        var c = this.writeDepthTexture;
        if (c) {
          var p = e.depthTexture;
          this.renderer.texture.bind(p, 0), i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, p._glTextures[this.CONTEXT_UID].texture, t);
        }
      }
      (e.stencil || e.depth) && !(e.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, n.stencil), n.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, n.multisample, i.DEPTH24_STENCIL8, e.width, e.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, e.width, e.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, n.stencil)) : n.stencil && (i.deleteRenderbuffer(n.stencil), n.stencil = null);
    }, r.prototype.canMultisampleFramebuffer = function(e) {
      return this.renderer.context.webGLVersion !== 1 && e.colorTextures.length <= 1 && !e.depthTexture;
    }, r.prototype.detectSamples = function(e) {
      var t = this.msaaSamples, i = gt.NONE;
      if (e <= 1 || t === null)
        return i;
      for (var n = 0; n < t.length; n++)
        if (t[n] <= e) {
          i = t[n];
          break;
        }
      return i === 1 && (i = gt.NONE), i;
    }, r.prototype.blit = function(e, t, i) {
      var n = this, o = n.current, s = n.renderer, a = n.gl, h = n.CONTEXT_UID;
      if (s.context.webGLVersion === 2 && o) {
        var u = o.glFramebuffers[h];
        if (u) {
          if (!e) {
            if (!u.msaaBuffer)
              return;
            var l = o.colorTextures[0];
            if (!l)
              return;
            u.blitFramebuffer || (u.blitFramebuffer = new ko(o.width, o.height), u.blitFramebuffer.addColorTexture(0, l)), e = u.blitFramebuffer, e.colorTextures[0] !== l && (e.colorTextures[0] = l, e.dirtyId++, e.dirtyFormat++), (e.width !== o.width || e.height !== o.height) && (e.width = o.width, e.height = o.height, e.dirtyId++, e.dirtySize++);
          }
          t || (t = q_, t.width = o.width, t.height = o.height), i || (i = t);
          var c = t.width === i.width && t.height === i.height;
          this.bind(e), a.bindFramebuffer(a.READ_FRAMEBUFFER, u.framebuffer), a.blitFramebuffer(t.left, t.top, t.right, t.bottom, i.left, i.top, i.right, i.bottom, a.COLOR_BUFFER_BIT, c ? a.NEAREST : a.LINEAR);
        }
      }
    }, r.prototype.disposeFramebuffer = function(e, t) {
      var i = e.glFramebuffers[this.CONTEXT_UID], n = this.gl;
      if (i) {
        delete e.glFramebuffers[this.CONTEXT_UID];
        var o = this.managedFramebuffers.indexOf(e);
        o >= 0 && this.managedFramebuffers.splice(o, 1), e.disposeRunner.remove(this), t || (n.deleteFramebuffer(i.framebuffer), i.msaaBuffer && n.deleteRenderbuffer(i.msaaBuffer), i.stencil && n.deleteRenderbuffer(i.stencil)), i.blitFramebuffer && i.blitFramebuffer.dispose();
      }
    }, r.prototype.disposeAll = function(e) {
      var t = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var i = 0; i < t.length; i++)
        this.disposeFramebuffer(t[i], e);
    }, r.prototype.forceStencil = function() {
      var e = this.current;
      if (e) {
        var t = e.glFramebuffers[this.CONTEXT_UID];
        if (!(!t || t.stencil)) {
          e.stencil = !0;
          var i = e.width, n = e.height, o = this.gl, s = o.createRenderbuffer();
          o.bindRenderbuffer(o.RENDERBUFFER, s), t.msaaBuffer ? o.renderbufferStorageMultisample(o.RENDERBUFFER, t.multisample, o.DEPTH24_STENCIL8, i, n) : o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, i, n), t.stencil = s, o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, s);
        }
      }
    }, r.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new it();
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), $n = { 5126: 4, 5123: 2, 5121: 1 }, Z_ = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {};
    }
    return r.prototype.contextChange = function() {
      this.disposeAll(!0);
      var e = this.gl = this.renderer.gl, t = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, t.webGLVersion !== 2) {
        var i = this.renderer.context.extensions.vertexArrayObject;
        L.PREFER_ENV === be.WEBGL_LEGACY && (i = null), i ? (e.createVertexArray = function() {
          return i.createVertexArrayOES();
        }, e.bindVertexArray = function(o) {
          return i.bindVertexArrayOES(o);
        }, e.deleteVertexArray = function(o) {
          return i.deleteVertexArrayOES(o);
        }) : (this.hasVao = !1, e.createVertexArray = function() {
          return null;
        }, e.bindVertexArray = function() {
          return null;
        }, e.deleteVertexArray = function() {
          return null;
        });
      }
      if (t.webGLVersion !== 2) {
        var n = e.getExtension("ANGLE_instanced_arrays");
        n ? (e.vertexAttribDivisor = function(o, s) {
          return n.vertexAttribDivisorANGLE(o, s);
        }, e.drawElementsInstanced = function(o, s, a, h, u) {
          return n.drawElementsInstancedANGLE(o, s, a, h, u);
        }, e.drawArraysInstanced = function(o, s, a, h) {
          return n.drawArraysInstancedANGLE(o, s, a, h);
        }) : this.hasInstance = !1;
      }
      this.canUseUInt32ElementIndex = t.webGLVersion === 2 || !!t.extensions.uint32ElementIndex;
    }, r.prototype.bind = function(e, t) {
      t = t || this.renderer.shader.shader;
      var i = this.gl, n = e.glVertexArrayObjects[this.CONTEXT_UID], o = !1;
      n || (this.managedGeometries[e.id] = e, e.disposeRunner.add(this), e.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, o = !0);
      var s = n[t.program.id] || this.initGeometryVao(e, t, o);
      this._activeGeometry = e, this._activeVao !== s && (this._activeVao = s, this.hasVao ? i.bindVertexArray(s) : this.activateVao(e, t.program)), this.updateBuffers();
    }, r.prototype.reset = function() {
      this.unbind();
    }, r.prototype.updateBuffers = function() {
      for (var e = this._activeGeometry, t = this.renderer.buffer, i = 0; i < e.buffers.length; i++) {
        var n = e.buffers[i];
        t.update(n);
      }
    }, r.prototype.checkCompatibility = function(e, t) {
      var i = e.attributes, n = t.attributeData;
      for (var o in n)
        if (!i[o])
          throw new Error('shader and geometry incompatible, geometry missing the "' + o + '" attribute');
    }, r.prototype.getSignature = function(e, t) {
      var i = e.attributes, n = t.attributeData, o = ["g", e.id];
      for (var s in i)
        n[s] && o.push(s, n[s].location);
      return o.join("-");
    }, r.prototype.initGeometryVao = function(e, t, i) {
      i === void 0 && (i = !0);
      var n = this.gl, o = this.CONTEXT_UID, s = this.renderer.buffer, a = t.program;
      a.glPrograms[o] || this.renderer.shader.generateProgram(t), this.checkCompatibility(e, a);
      var h = this.getSignature(e, a), u = e.glVertexArrayObjects[this.CONTEXT_UID], l = u[h];
      if (l)
        return u[a.id] = l, l;
      var c = e.buffers, p = e.attributes, d = {}, f = {};
      for (var y in c)
        d[y] = 0, f[y] = 0;
      for (var y in p)
        !p[y].size && a.attributeData[y] ? p[y].size = a.attributeData[y].size : p[y].size || console.warn("PIXI Geometry attribute '" + y + "' size cannot be determined (likely the bound shader does not have the attribute)"), d[p[y].buffer] += p[y].size * $n[p[y].type];
      for (var y in p) {
        var m = p[y], _ = m.size;
        m.stride === void 0 && (d[m.buffer] === _ * $n[m.type] ? m.stride = 0 : m.stride = d[m.buffer]), m.start === void 0 && (m.start = f[m.buffer], f[m.buffer] += _ * $n[m.type]);
      }
      l = n.createVertexArray(), n.bindVertexArray(l);
      for (var g = 0; g < c.length; g++) {
        var b = c[g];
        s.bind(b), i && b._glBuffers[o].refCount++;
      }
      return this.activateVao(e, a), this._activeVao = l, u[a.id] = l, u[h] = l, l;
    }, r.prototype.disposeGeometry = function(e, t) {
      var i;
      if (this.managedGeometries[e.id]) {
        delete this.managedGeometries[e.id];
        var n = e.glVertexArrayObjects[this.CONTEXT_UID], o = this.gl, s = e.buffers, a = (i = this.renderer) === null || i === void 0 ? void 0 : i.buffer;
        if (e.disposeRunner.remove(this), !!n) {
          if (a)
            for (var h = 0; h < s.length; h++) {
              var u = s[h]._glBuffers[this.CONTEXT_UID];
              u && (u.refCount--, u.refCount === 0 && !t && a.dispose(s[h], t));
            }
          if (!t) {
            for (var l in n)
              if (l[0] === "g") {
                var c = n[l];
                this._activeVao === c && this.unbind(), o.deleteVertexArray(c);
              }
          }
          delete e.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, r.prototype.disposeAll = function(e) {
      for (var t = Object.keys(this.managedGeometries), i = 0; i < t.length; i++)
        this.disposeGeometry(this.managedGeometries[t[i]], e);
    }, r.prototype.activateVao = function(e, t) {
      var i = this.gl, n = this.CONTEXT_UID, o = this.renderer.buffer, s = e.buffers, a = e.attributes;
      e.indexBuffer && o.bind(e.indexBuffer);
      var h = null;
      for (var u in a) {
        var l = a[u], c = s[l.buffer], p = c._glBuffers[n];
        if (t.attributeData[u]) {
          h !== p && (o.bind(c), h = p);
          var d = t.attributeData[u].location;
          if (i.enableVertexAttribArray(d), i.vertexAttribPointer(d, l.size, l.type || i.FLOAT, l.normalized, l.stride, l.start), l.instance)
            if (this.hasInstance)
              i.vertexAttribDivisor(d, 1);
            else
              throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }, r.prototype.draw = function(e, t, i, n) {
      var o = this.gl, s = this._activeGeometry;
      if (s.indexBuffer) {
        var a = s.indexBuffer.data.BYTES_PER_ELEMENT, h = a === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
        a === 2 || a === 4 && this.canUseUInt32ElementIndex ? s.instanced ? o.drawElementsInstanced(e, t || s.indexBuffer.data.length, h, (i || 0) * a, n || 1) : o.drawElements(e, t || s.indexBuffer.data.length, h, (i || 0) * a) : console.warn("unsupported index buffer type: uint32");
      } else
        s.instanced ? o.drawArraysInstanced(e, i, t || s.getSize(), n || 1) : o.drawArrays(e, i, t || s.getSize());
      return this;
    }, r.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), J_ = (
  /** @class */
  function() {
    function r(e) {
      e === void 0 && (e = null), this.type = Rt.NONE, this.autoDetect = !0, this.maskObject = e || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = L.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
    }
    return Object.defineProperty(r.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(e) {
        e ? this._filters ? this._filters[0] = e : this._filters = [e] : this._filters = null;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = Rt.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null;
    }, r.prototype.copyCountersOrReset = function(e) {
      e ? (this._stencilCounter = e._stencilCounter, this._scissorCounter = e._scissorCounter, this._scissorRect = e._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, r;
  }()
);
function qa(r, e, t) {
  var i = r.createShader(e);
  return r.shaderSource(i, t), r.compileShader(i), i;
}
function Ka(r, e) {
  var t = r.getShaderSource(e).split(`
`).map(function(u, l) {
    return l + ": " + u;
  }), i = r.getShaderInfoLog(e), n = i.split(`
`), o = {}, s = n.map(function(u) {
    return parseFloat(u.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(u) {
    return u && !o[u] ? (o[u] = !0, !0) : !1;
  }), a = [""];
  s.forEach(function(u) {
    t[u - 1] = "%c" + t[u - 1] + "%c", a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var h = t.join(`
`);
  a[0] = h, console.error(i), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, a), console.groupEnd();
}
function Q_(r, e, t, i) {
  r.getProgramParameter(e, r.LINK_STATUS) || (r.getShaderParameter(t, r.COMPILE_STATUS) || Ka(r, t), r.getShaderParameter(i, r.COMPILE_STATUS) || Ka(r, i), console.error("PixiJS Error: Could not initialize shader."), r.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", r.getProgramInfoLog(e)));
}
function qn(r) {
  for (var e = new Array(r), t = 0; t < e.length; t++)
    e[t] = !1;
  return e;
}
function Nu(r, e) {
  switch (r) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * e);
    case "vec3":
      return new Float32Array(3 * e);
    case "vec4":
      return new Float32Array(4 * e);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * e);
    case "ivec3":
      return new Int32Array(3 * e);
    case "ivec4":
      return new Int32Array(4 * e);
    case "uvec2":
      return new Uint32Array(2 * e);
    case "uvec3":
      return new Uint32Array(3 * e);
    case "uvec4":
      return new Uint32Array(4 * e);
    case "bool":
      return !1;
    case "bvec2":
      return qn(2 * e);
    case "bvec3":
      return qn(3 * e);
    case "bvec4":
      return qn(4 * e);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var Lu = {}, Lr = Lu;
function tg() {
  if (Lr === Lu || Lr && Lr.isContextLost()) {
    var r = L.ADAPTER.createCanvas(), e = void 0;
    L.PREFER_ENV >= be.WEBGL2 && (e = r.getContext("webgl2", {})), e || (e = r.getContext("webgl", {}) || r.getContext("experimental-webgl", {}), e ? e.getExtension("WEBGL_draw_buffers") : e = null), Lr = e;
  }
  return Lr;
}
var Ii;
function eg() {
  if (!Ii) {
    Ii = Xt.MEDIUM;
    var r = tg();
    if (r && r.getShaderPrecisionFormat) {
      var e = r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT);
      Ii = e.precision ? Xt.HIGH : Xt.MEDIUM;
    }
  }
  return Ii;
}
function Za(r, e, t) {
  if (r.substring(0, 9) !== "precision") {
    var i = e;
    return e === Xt.HIGH && t !== Xt.HIGH && (i = Xt.MEDIUM), "precision " + i + ` float;
` + r;
  } else if (t !== Xt.HIGH && r.substring(0, 15) === "precision highp")
    return r.replace("precision highp", "precision mediump");
  return r;
}
var rg = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function Bu(r) {
  return rg[r];
}
var Pi = null, Ja = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function Gu(r, e) {
  if (!Pi) {
    var t = Object.keys(Ja);
    Pi = {};
    for (var i = 0; i < t.length; ++i) {
      var n = t[i];
      Pi[r[n]] = Ja[n];
    }
  }
  return Pi[e];
}
var Ar = [
  // a float cache layer
  {
    test: function(r) {
      return r.type === "float" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
            if(uv["` + r + '"] !== ud["' + r + `"].value)
            {
                ud["` + r + '"].value = uv["' + r + `"]
                gl.uniform1f(ud["` + r + '"].location, uv["' + r + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(r, e) {
      return (r.type === "sampler2D" || r.type === "samplerCube" || r.type === "sampler2DArray") && r.size === 1 && !r.isArray && (e == null || e.castToBaseTexture !== void 0);
    },
    code: function(r) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + r + `"], t);

            if(ud["` + r + `"].value !== t)
            {
                ud["` + r + `"].value = t;
                gl.uniform1i(ud["` + r + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(r, e) {
      return r.type === "mat3" && r.size === 1 && !r.isArray && e.a !== void 0;
    },
    code: function(r) {
      return `
            gl.uniformMatrix3fv(ud["` + r + '"].location, false, uv["' + r + `"].toArray(true));
            `;
    },
    codeUbo: function(r) {
      return `
                var ` + r + "_matrix = uv." + r + `.toArray(true);

                data[offset] = ` + r + `_matrix[0];
                data[offset+1] = ` + r + `_matrix[1];
                data[offset+2] = ` + r + `_matrix[2];
        
                data[offset + 4] = ` + r + `_matrix[3];
                data[offset + 5] = ` + r + `_matrix[4];
                data[offset + 6] = ` + r + `_matrix[5];
        
                data[offset + 8] = ` + r + `_matrix[6];
                data[offset + 9] = ` + r + `_matrix[7];
                data[offset + 10] = ` + r + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(r, e) {
      return r.type === "vec2" && r.size === 1 && !r.isArray && e.x !== void 0;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + r + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(r) {
      return `
                v = uv.` + r + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(r) {
      return r.type === "vec2" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + r + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(r, e) {
      return r.type === "vec4" && r.size === 1 && !r.isArray && e.width !== void 0;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + r + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(r) {
      return `
                    v = uv.` + r + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(r) {
      return r.type === "vec4" && r.size === 1 && !r.isArray;
    },
    code: function(r) {
      return `
                cv = ud["` + r + `"].value;
                v = uv["` + r + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + r + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], ig = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, ng = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function og(r, e) {
  var t, i = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var n in r.uniforms) {
    var o = e[n];
    if (!o) {
      !((t = r.uniforms[n]) === null || t === void 0) && t.group && (r.uniforms[n].ubo ? i.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + n + ", '" + n + `');
                    `) : i.push(`
                        renderer.shader.syncUniformGroup(uv.` + n + `, syncData);
                    `));
      continue;
    }
    for (var s = r.uniforms[n], a = !1, h = 0; h < Ar.length; h++)
      if (Ar[h].test(o, s)) {
        i.push(Ar[h].code(n, s)), a = !0;
        break;
      }
    if (!a) {
      var u = o.size === 1 && !o.isArray ? ig : ng, l = u[o.type].replace("location", 'ud["' + n + '"].location');
      i.push(`
            cu = ud["` + n + `"];
            cv = cu.value;
            v = uv["` + n + `"];
            ` + l + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", i.join(`
`));
}
var sg = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function ag(r) {
  for (var e = "", t = 0; t < r; ++t)
    t > 0 && (e += `
else `), t < r - 1 && (e += "if(test == " + t + ".0){}");
  return e;
}
function hg(r, e) {
  if (r === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var t = e.createShader(e.FRAGMENT_SHADER); ; ) {
    var i = sg.replace(/%forloop%/gi, ag(r));
    if (e.shaderSource(t, i), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS))
      r = r / 2 | 0;
    else
      break;
  }
  return r;
}
var Br;
function ug() {
  if (typeof Br == "boolean")
    return Br;
  try {
    var r = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    Br = r({ a: "b" }, "a", "b") === !0;
  } catch {
    Br = !1;
  }
  return Br;
}
var lg = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, cg = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, pg = 0, Mi = {}, pi = (
  /** @class */
  function() {
    function r(e, t, i) {
      i === void 0 && (i = "pixi-shader"), this.id = pg++, this.vertexSrc = e || r.defaultVertexSrc, this.fragmentSrc = t || r.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"), Mi[i] ? (Mi[i]++, i += "-" + Mi[i]) : Mi[i] = 1, this.vertexSrc = "#define SHADER_NAME " + i + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + i + `
` + this.fragmentSrc, this.vertexSrc = Za(this.vertexSrc, L.PRECISION_VERTEX, Xt.HIGH), this.fragmentSrc = Za(this.fragmentSrc, L.PRECISION_FRAGMENT, eg())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(r, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return cg;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return lg;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(e, t, i) {
      var n = e + t, o = ja[n];
      return o || (ja[n] = o = new r(e, t, i)), o;
    }, r;
  }()
), we = (
  /** @class */
  function() {
    function r(e, t) {
      this.uniformBindCount = 0, this.program = e, t ? t instanceof Je ? this.uniformGroup = t : this.uniformGroup = new Je(t) : this.uniformGroup = new Je({}), this.disposeRunner = new Nt("disposeShader");
    }
    return r.prototype.checkUniformExists = function(e, t) {
      if (t.uniforms[e])
        return !0;
      for (var i in t.uniforms) {
        var n = t.uniforms[i];
        if (n.group && this.checkUniformExists(e, n))
          return !0;
      }
      return !1;
    }, r.prototype.destroy = function() {
      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
    }, Object.defineProperty(r.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: !1,
      configurable: !0
    }), r.from = function(e, t, i) {
      var n = pi.from(e, t);
      return new r(n, i);
    }, r;
  }()
), Kn = 0, Zn = 1, Jn = 2, Qn = 3, to = 4, eo = 5, ir = (
  /** @class */
  function() {
    function r() {
      this.data = 0, this.blendMode = k.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0;
    }
    return Object.defineProperty(r.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << Kn);
      },
      set: function(e) {
        !!(this.data & 1 << Kn) !== e && (this.data ^= 1 << Kn);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << Zn);
      },
      set: function(e) {
        !!(this.data & 1 << Zn) !== e && (this.data ^= 1 << Zn);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << Jn);
      },
      set: function(e) {
        !!(this.data & 1 << Jn) !== e && (this.data ^= 1 << Jn);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << Qn);
      },
      set: function(e) {
        !!(this.data & 1 << Qn) !== e && (this.data ^= 1 << Qn);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << eo);
      },
      set: function(e) {
        !!(this.data & 1 << eo) !== e && (this.data ^= 1 << eo);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << to);
      },
      set: function(e) {
        !!(this.data & 1 << to) !== e && (this.data ^= 1 << to);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(e) {
        this.blend = e !== k.NONE, this._blendMode = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(e) {
        this.offsets = !!e, this._polygonOffset = e;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    }, r.for2d = function() {
      var e = new r();
      return e.depthTest = !1, e.blend = !0, e;
    }, r;
  }()
), dg = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, fg = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Ne = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i, n) {
      var o = this, s = pi.from(t || e.defaultVertexSrc, i || e.defaultFragmentSrc);
      return o = r.call(this, s, n) || this, o.padding = 0, o.resolution = L.FILTER_RESOLUTION, o.multisample = L.FILTER_MULTISAMPLE, o.enabled = !0, o.autoFit = !0, o.state = new ir(), o;
    }
    return e.prototype.apply = function(t, i, n, o, s) {
      t.applyFilter(this, i, n, o);
    }, Object.defineProperty(e.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(t) {
        this.state.blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(t) {
        this._resolution = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return fg;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return dg;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(we)
), yg = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, mg = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, Qa = new It(), Is = (
  /** @class */
  function() {
    function r(e, t) {
      this._texture = e, this.mapCoord = new It(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof t > "u" ? 0.5 : t, this.isSimple = !1;
    }
    return Object.defineProperty(r.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(e) {
        this._texture = e, this._textureID = -1;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.multiplyUvs = function(e, t) {
      t === void 0 && (t = e);
      for (var i = this.mapCoord, n = 0; n < e.length; n += 2) {
        var o = e[n], s = e[n + 1];
        t[n] = o * i.a + s * i.c + i.tx, t[n + 1] = o * i.b + s * i.d + i.ty;
      }
      return t;
    }, r.prototype.update = function(e) {
      var t = this._texture;
      if (!t || !t.valid || !e && this._textureID === t._updateID)
        return !1;
      this._textureID = t._updateID, this._updateID++;
      var i = t._uvs;
      this.mapCoord.set(i.x1 - i.x0, i.y1 - i.y0, i.x3 - i.x0, i.y3 - i.y0, i.x0, i.y0);
      var n = t.orig, o = t.trim;
      o && (Qa.set(n.width / o.width, 0, 0, n.height / o.height, -o.x / o.width, -o.y / o.height), this.mapCoord.append(Qa));
      var s = t.baseTexture, a = this.uClampFrame, h = this.clampMargin / s.resolution, u = this.clampOffset;
      return a[0] = (t._frame.x + h + u) / s.width, a[1] = (t._frame.y + h + u) / s.height, a[2] = (t._frame.x + t._frame.width - h + u) / s.width, a[3] = (t._frame.y + t._frame.height - h + u) / s.height, this.uClampOffset[0] = u / s.realWidth, this.uClampOffset[1] = u / s.realHeight, this.isSimple = t._frame.width === s.width && t._frame.height === s.height && t.rotate === 0, !0;
    }, r;
  }()
), _g = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i, n) {
      var o = this, s = null;
      return typeof t != "string" && i === void 0 && n === void 0 && (s = t, t = void 0, i = void 0, n = void 0), o = r.call(this, t || yg, i || mg, n) || this, o.maskSprite = s, o.maskMatrix = new It(), o;
    }
    return Object.defineProperty(e.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(t) {
        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1);
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.apply = function(t, i, n, o) {
      var s = this._maskSprite, a = s._texture;
      a.valid && (a.uvMatrix || (a.uvMatrix = new Is(a, 0)), a.uvMatrix.update(), this.uniforms.npmAlpha = a.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = a, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, s).prepend(a.uvMatrix.mapCoord), this.uniforms.alpha = s.worldAlpha, this.uniforms.maskClamp = a.uvMatrix.uClampFrame, t.applyFilter(this, i, n, o));
    }, e;
  }(Ne)
), gg = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return r.prototype.setMaskStack = function(e) {
      this.maskStack = e, this.renderer.scissor.setMaskStack(e), this.renderer.stencil.setMaskStack(e);
    }, r.prototype.push = function(e, t) {
      var i = t;
      if (!i.isMaskData) {
        var n = this.maskDataPool.pop() || new J_();
        n.pooled = !0, n.maskObject = t, i = n;
      }
      var o = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (i.copyCountersOrReset(o), i._colorMask = o ? o._colorMask : 15, i.autoDetect && this.detect(i), i._target = e, i.type !== Rt.SPRITE && this.maskStack.push(i), i.enabled)
        switch (i.type) {
          case Rt.SCISSOR:
            this.renderer.scissor.push(i);
            break;
          case Rt.STENCIL:
            this.renderer.stencil.push(i);
            break;
          case Rt.SPRITE:
            i.copyCountersOrReset(null), this.pushSpriteMask(i);
            break;
          case Rt.COLOR:
            this.pushColorMask(i);
            break;
        }
      i.type === Rt.SPRITE && this.maskStack.push(i);
    }, r.prototype.pop = function(e) {
      var t = this.maskStack.pop();
      if (!(!t || t._target !== e)) {
        if (t.enabled)
          switch (t.type) {
            case Rt.SCISSOR:
              this.renderer.scissor.pop(t);
              break;
            case Rt.STENCIL:
              this.renderer.stencil.pop(t.maskObject);
              break;
            case Rt.SPRITE:
              this.popSpriteMask(t);
              break;
            case Rt.COLOR:
              this.popColorMask(t);
              break;
          }
        if (t.reset(), t.pooled && this.maskDataPool.push(t), this.maskStack.length !== 0) {
          var i = this.maskStack[this.maskStack.length - 1];
          i.type === Rt.SPRITE && i._filters && (i._filters[0].maskSprite = i.maskObject);
        }
      }
    }, r.prototype.detect = function(e) {
      var t = e.maskObject;
      t ? t.isSprite ? e.type = Rt.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(e) ? e.type = Rt.SCISSOR : e.type = Rt.STENCIL : e.type = Rt.COLOR;
    }, r.prototype.pushSpriteMask = function(e) {
      var t, i, n = e.maskObject, o = e._target, s = e._filters;
      s || (s = this.alphaMaskPool[this.alphaMaskIndex], s || (s = this.alphaMaskPool[this.alphaMaskIndex] = [new _g()]));
      var a = this.renderer, h = a.renderTexture, u, l;
      if (h.current) {
        var c = h.current;
        u = e.resolution || c.resolution, l = (t = e.multisample) !== null && t !== void 0 ? t : c.multisample;
      } else
        u = e.resolution || a.resolution, l = (i = e.multisample) !== null && i !== void 0 ? i : a.multisample;
      s[0].resolution = u, s[0].multisample = l, s[0].maskSprite = n;
      var p = o.filterArea;
      o.filterArea = n.getBounds(!0), a.filter.push(o, s), o.filterArea = p, e._filters || this.alphaMaskIndex++;
    }, r.prototype.popSpriteMask = function(e) {
      this.renderer.filter.pop(), e._filters ? e._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, r.prototype.pushColorMask = function(e) {
      var t = e._colorMask, i = e._colorMask = t & e.colorMask;
      i !== t && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0);
    }, r.prototype.popColorMask = function(e) {
      var t = e._colorMask, i = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      i !== t && this.renderer.gl.colorMask((i & 1) !== 0, (i & 2) !== 0, (i & 4) !== 0, (i & 8) !== 0);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), Uu = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.maskStack = [], this.glConst = 0;
    }
    return r.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, r.prototype.setMaskStack = function(e) {
      var t = this.renderer.gl, i = this.getStackLength();
      this.maskStack = e;
      var n = this.getStackLength();
      n !== i && (n === 0 ? t.disable(this.glConst) : (t.enable(this.glConst), this._useCurrent()));
    }, r.prototype._useCurrent = function() {
    }, r.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, r;
  }()
), th = new It(), eh = [], vg = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.glConst = L.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, i;
    }
    return e.prototype.getStackLength = function() {
      var t = this.maskStack[this.maskStack.length - 1];
      return t ? t._scissorCounter : 0;
    }, e.prototype.calcScissorRect = function(t) {
      var i;
      if (!t._scissorRectLocal) {
        var n = t._scissorRect, o = t.maskObject, s = this.renderer, a = s.renderTexture, h = o.getBounds(!0, (i = eh.pop()) !== null && i !== void 0 ? i : new it());
        this.roundFrameToPixels(h, a.current ? a.current.resolution : s.resolution, a.sourceFrame, a.destinationFrame, s.projection.transform), n && h.fit(n), t._scissorRectLocal = h;
      }
    }, e.isMatrixRotated = function(t) {
      if (!t)
        return !1;
      var i = t.a, n = t.b, o = t.c, s = t.d;
      return (Math.abs(n) > 1e-4 || Math.abs(o) > 1e-4) && (Math.abs(i) > 1e-4 || Math.abs(s) > 1e-4);
    }, e.prototype.testScissor = function(t) {
      var i = t.maskObject;
      if (!i.isFastRect || !i.isFastRect() || e.isMatrixRotated(i.worldTransform) || e.isMatrixRotated(this.renderer.projection.transform))
        return !1;
      this.calcScissorRect(t);
      var n = t._scissorRectLocal;
      return n.width > 0 && n.height > 0;
    }, e.prototype.roundFrameToPixels = function(t, i, n, o, s) {
      e.isMatrixRotated(s) || (s = s ? th.copyFrom(s) : th.identity(), s.translate(-n.x, -n.y).scale(o.width / n.width, o.height / n.height).translate(o.x, o.y), this.renderer.filter.transformAABB(s, t), t.fit(o), t.x = Math.round(t.x * i), t.y = Math.round(t.y * i), t.width = Math.round(t.width * i), t.height = Math.round(t.height * i));
    }, e.prototype.push = function(t) {
      t._scissorRectLocal || this.calcScissorRect(t);
      var i = this.renderer.gl;
      t._scissorRect || i.enable(i.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent();
    }, e.prototype.pop = function(t) {
      var i = this.renderer.gl;
      t && eh.push(t._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : i.disable(i.SCISSOR_TEST);
    }, e.prototype._useCurrent = function() {
      var t = this.maskStack[this.maskStack.length - 1]._scissorRect, i;
      this.renderer.renderTexture.current ? i = t.y : i = this.renderer.height - t.height - t.y, this.renderer.gl.scissor(t.x, i, t.width, t.height);
    }, e;
  }(Uu)
), bg = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.glConst = L.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, i;
    }
    return e.prototype.getStackLength = function() {
      var t = this.maskStack[this.maskStack.length - 1];
      return t ? t._stencilCounter : 0;
    }, e.prototype.push = function(t) {
      var i = t.maskObject, n = this.renderer.gl, o = t._stencilCounter;
      o === 0 && (this.renderer.framebuffer.forceStencil(), n.clearStencil(0), n.clear(n.STENCIL_BUFFER_BIT), n.enable(n.STENCIL_TEST)), t._stencilCounter++;
      var s = t._colorMask;
      s !== 0 && (t._colorMask = 0, n.colorMask(!1, !1, !1, !1)), n.stencilFunc(n.EQUAL, o, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.INCR), i.renderable = !0, i.render(this.renderer), this.renderer.batch.flush(), i.renderable = !1, s !== 0 && (t._colorMask = s, n.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent();
    }, e.prototype.pop = function(t) {
      var i = this.renderer.gl;
      if (this.getStackLength() === 0)
        i.disable(i.STENCIL_TEST);
      else {
        var n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, o = n ? n._colorMask : 15;
        o !== 0 && (n._colorMask = 0, i.colorMask(!1, !1, !1, !1)), i.stencilOp(i.KEEP, i.KEEP, i.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, o !== 0 && (n._colorMask = o, i.colorMask((o & 1) !== 0, (o & 2) !== 0, (o & 4) !== 0, (o & 8) !== 0)), this._useCurrent();
      }
    }, e.prototype._useCurrent = function() {
      var t = this.renderer.gl;
      t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
    }, e;
  }(Uu)
), xg = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new It(), this.transform = null;
    }
    return r.prototype.update = function(e, t, i, n) {
      this.destinationFrame = e || this.destinationFrame || this.defaultFrame, this.sourceFrame = t || this.sourceFrame || e, this.calculateProjection(this.destinationFrame, this.sourceFrame, i, n), this.transform && this.projectionMatrix.append(this.transform);
      var o = this.renderer;
      o.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, o.globalUniforms.update(), o.shader.shader && o.shader.syncUniformGroup(o.shader.shader.uniforms.globals);
    }, r.prototype.calculateProjection = function(e, t, i, n) {
      var o = this.projectionMatrix, s = n ? -1 : 1;
      o.identity(), o.a = 1 / t.width * 2, o.d = s * (1 / t.height * 2), o.tx = -1 - t.x * o.a, o.ty = -s - t.y * o.d;
    }, r.prototype.setTransform = function(e) {
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), Be = new it(), Gr = new it(), Tg = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.clearColor = e._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new it(), this.destinationFrame = new it(), this.viewportFrame = new it();
    }
    return r.prototype.bind = function(e, t, i) {
      e === void 0 && (e = null);
      var n = this.renderer;
      this.current = e;
      var o, s, a;
      e ? (o = e.baseTexture, a = o.resolution, t || (Be.width = e.frame.width, Be.height = e.frame.height, t = Be), i || (Gr.x = e.frame.x, Gr.y = e.frame.y, Gr.width = t.width, Gr.height = t.height, i = Gr), s = o.framebuffer) : (a = n.resolution, t || (Be.width = n.screen.width, Be.height = n.screen.height, t = Be), i || (i = Be, i.width = t.width, i.height = t.height));
      var h = this.viewportFrame;
      h.x = i.x * a, h.y = i.y * a, h.width = i.width * a, h.height = i.height * a, e || (h.y = n.view.height - (h.y + h.height)), h.ceil(), this.renderer.framebuffer.bind(s, h), this.renderer.projection.update(i, t, a, !s), e ? this.renderer.mask.setMaskStack(o.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(t), this.destinationFrame.copyFrom(i);
    }, r.prototype.clear = function(e, t) {
      this.current ? e = e || this.current.baseTexture.clearColor : e = e || this.clearColor;
      var i = this.destinationFrame, n = this.current ? this.current.baseTexture : this.renderer.screen, o = i.width !== n.width || i.height !== n.height;
      if (o) {
        var s = this.viewportFrame, a = s.x, h = s.y, u = s.width, l = s.height;
        a = Math.round(a), h = Math.round(h), u = Math.round(u), l = Math.round(l), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(a, h, u, l);
      }
      this.renderer.framebuffer.clear(e[0], e[1], e[2], e[3], t), o && this.renderer.scissor.pop();
    }, r.prototype.resize = function() {
      this.bind(null);
    }, r.prototype.reset = function() {
      this.bind(null);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
);
function Eg(r, e, t, i, n) {
  t.buffer.update(n);
}
var Ag = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, ku = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function Sg(r) {
  for (var e = r.map(function(h) {
    return {
      data: h,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), t = 0, i = 0, n = 0, o = 0; o < e.length; o++) {
    var s = e[o];
    if (t = ku[s.data.type], s.data.size > 1 && (t = Math.max(t, 16) * s.data.size), s.dataLen = t, i % t !== 0 && i < 16) {
      var a = i % t % 16;
      i += a, n += a;
    }
    i + t > 16 ? (n = Math.ceil(n / 16) * 16, s.offset = n, n += t, i = t) : (s.offset = n, i += t, n += t);
  }
  return n = Math.ceil(n / 16) * 16, { uboElements: e, size: n };
}
function Rg(r, e) {
  var t = [];
  for (var i in r)
    e[i] && t.push(e[i]);
  return t.sort(function(n, o) {
    return n.index - o.index;
  }), t;
}
function Og(r, e) {
  if (!r.autoManage)
    return { size: 0, syncFunc: Eg };
  for (var t = Rg(r.uniforms, e), i = Sg(t), n = i.uboElements, o = i.size, s = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], a = 0; a < n.length; a++) {
    for (var h = n[a], u = r.uniforms[h.data.name], l = h.data.name, c = !1, p = 0; p < Ar.length; p++) {
      var d = Ar[p];
      if (d.codeUbo && d.test(h.data, u)) {
        s.push("offset = " + h.offset / 4 + ";", Ar[p].codeUbo(h.data.name, u)), c = !0;
        break;
      }
    }
    if (!c)
      if (h.data.size > 1) {
        var f = Bu(h.data.type), y = Math.max(ku[h.data.type] / 16, 1), m = f / y, _ = (4 - m % 4) % 4;
        s.push(`
                cv = ud.` + l + `.value;
                v = uv.` + l + `;
                offset = ` + h.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + h.data.size * y + `; i++)
                {
                    for(var j = 0; j < ` + m + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + _ + `;
                }

                `);
      } else {
        var g = Ag[h.data.type];
        s.push(`
                cv = ud.` + l + `.value;
                v = uv.` + l + `;
                offset = ` + h.offset / 4 + `;
                ` + g + `;
                `);
      }
  }
  return s.push(`
       renderer.buffer.update(buffer);
    `), {
    size: o,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", s.join(`
`))
  };
}
var wg = (
  /** @class */
  function() {
    function r(e, t) {
      this.program = e, this.uniformData = t, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return r.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, r;
  }()
);
function Ig(r, e) {
  for (var t = {}, i = e.getProgramParameter(r, e.ACTIVE_ATTRIBUTES), n = 0; n < i; n++) {
    var o = e.getActiveAttrib(r, n);
    if (o.name.indexOf("gl_") !== 0) {
      var s = Gu(e, o.type), a = {
        type: s,
        name: o.name,
        size: Bu(s),
        location: e.getAttribLocation(r, o.name)
      };
      t[o.name] = a;
    }
  }
  return t;
}
function Pg(r, e) {
  for (var t = {}, i = e.getProgramParameter(r, e.ACTIVE_UNIFORMS), n = 0; n < i; n++) {
    var o = e.getActiveUniform(r, n), s = o.name.replace(/\[.*?\]$/, ""), a = !!o.name.match(/\[.*?\]$/), h = Gu(e, o.type);
    t[s] = {
      name: s,
      index: n,
      type: h,
      size: o.size,
      isArray: a,
      value: Nu(h, o.size)
    };
  }
  return t;
}
function Mg(r, e) {
  var t = qa(r, r.VERTEX_SHADER, e.vertexSrc), i = qa(r, r.FRAGMENT_SHADER, e.fragmentSrc), n = r.createProgram();
  if (r.attachShader(n, t), r.attachShader(n, i), r.linkProgram(n), r.getProgramParameter(n, r.LINK_STATUS) || Q_(r, n, t, i), e.attributeData = Ig(n, r), e.uniformData = Pg(n, r), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
    var o = Object.keys(e.attributeData);
    o.sort(function(l, c) {
      return l > c ? 1 : -1;
    });
    for (var s = 0; s < o.length; s++)
      e.attributeData[o[s]].location = s, r.bindAttribLocation(n, s, o[s]);
    r.linkProgram(n);
  }
  r.deleteShader(t), r.deleteShader(i);
  var a = {};
  for (var s in e.uniformData) {
    var h = e.uniformData[s];
    a[s] = {
      location: r.getUniformLocation(n, s),
      value: Nu(h.type, h.size)
    };
  }
  var u = new wg(n, a);
  return u;
}
var Dg = 0, Di = { textureCount: 0, uboCount: 0 }, Cg = (
  /** @class */
  function() {
    function r(e) {
      this.destroyed = !1, this.renderer = e, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = Dg++;
    }
    return r.prototype.systemCheck = function() {
      if (!ug())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, r.prototype.contextChange = function(e) {
      this.gl = e, this.reset();
    }, r.prototype.bind = function(e, t) {
      e.disposeRunner.add(this), e.uniforms.globals = this.renderer.globalUniforms;
      var i = e.program, n = i.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
      return this.shader = e, this.program !== i && (this.program = i, this.gl.useProgram(n.program)), t || (Di.textureCount = 0, Di.uboCount = 0, this.syncUniformGroup(e.uniformGroup, Di)), n;
    }, r.prototype.setUniforms = function(e) {
      var t = this.shader.program, i = t.glPrograms[this.renderer.CONTEXT_UID];
      t.syncUniforms(i.uniformData, e, this.renderer);
    }, r.prototype.syncUniformGroup = function(e, t) {
      var i = this.getGlProgram();
      (!e.static || e.dirtyId !== i.uniformDirtyGroups[e.id]) && (i.uniformDirtyGroups[e.id] = e.dirtyId, this.syncUniforms(e, i, t));
    }, r.prototype.syncUniforms = function(e, t, i) {
      var n = e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e);
      n(t.uniformData, e.uniforms, this.renderer, i);
    }, r.prototype.createSyncGroups = function(e) {
      var t = this.getSignature(e, this.shader.program.uniformData, "u");
      return this.cache[t] || (this.cache[t] = og(e, this.shader.program.uniformData)), e.syncUniforms[this.shader.program.id] = this.cache[t], e.syncUniforms[this.shader.program.id];
    }, r.prototype.syncUniformBufferGroup = function(e, t) {
      var i = this.getGlProgram();
      if (!e.static || e.dirtyId !== 0 || !i.uniformGroups[e.id]) {
        e.dirtyId = 0;
        var n = i.uniformGroups[e.id] || this.createSyncBufferGroup(e, i, t);
        e.buffer.update(), n(i.uniformData, e.uniforms, this.renderer, Di, e.buffer);
      }
      this.renderer.buffer.bindBufferBase(e.buffer, i.uniformBufferBindings[t]);
    }, r.prototype.createSyncBufferGroup = function(e, t, i) {
      var n = this.renderer.gl;
      this.renderer.buffer.bind(e.buffer);
      var o = this.gl.getUniformBlockIndex(t.program, i);
      t.uniformBufferBindings[i] = this.shader.uniformBindCount, n.uniformBlockBinding(t.program, o, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var s = this.getSignature(e, this.shader.program.uniformData, "ubo"), a = this._uboCache[s];
      if (a || (a = this._uboCache[s] = Og(e, this.shader.program.uniformData)), e.autoManage) {
        var h = new Float32Array(a.size / 4);
        e.buffer.update(h);
      }
      return t.uniformGroups[e.id] = a.syncFunc, t.uniformGroups[e.id];
    }, r.prototype.getSignature = function(e, t, i) {
      var n = e.uniforms, o = [i + "-"];
      for (var s in n)
        o.push(s), t[s] && o.push(t[s].type);
      return o.join("-");
    }, r.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, r.prototype.generateProgram = function(e) {
      var t = this.gl, i = e.program, n = Mg(t, i);
      return i.glPrograms[this.renderer.CONTEXT_UID] = n, n;
    }, r.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, r.prototype.disposeShader = function(e) {
      this.shader === e && (this.shader = null);
    }, r.prototype.destroy = function() {
      this.renderer = null, this.destroyed = !0;
    }, r;
  }()
);
function Fg(r, e) {
  return e === void 0 && (e = []), e[k.NORMAL] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.ADD] = [r.ONE, r.ONE], e[k.MULTIPLY] = [r.DST_COLOR, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.SCREEN] = [r.ONE, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.OVERLAY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.DARKEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.LIGHTEN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.COLOR_DODGE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.COLOR_BURN] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.HARD_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.SOFT_LIGHT] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.DIFFERENCE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.EXCLUSION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.HUE] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.SATURATION] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.COLOR] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.LUMINOSITY] = [r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.NONE] = [0, 0], e[k.NORMAL_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.ADD_NPM] = [r.SRC_ALPHA, r.ONE, r.ONE, r.ONE], e[k.SCREEN_NPM] = [r.SRC_ALPHA, r.ONE_MINUS_SRC_COLOR, r.ONE, r.ONE_MINUS_SRC_ALPHA], e[k.SRC_IN] = [r.DST_ALPHA, r.ZERO], e[k.SRC_OUT] = [r.ONE_MINUS_DST_ALPHA, r.ZERO], e[k.SRC_ATOP] = [r.DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], e[k.DST_OVER] = [r.ONE_MINUS_DST_ALPHA, r.ONE], e[k.DST_IN] = [r.ZERO, r.SRC_ALPHA], e[k.DST_OUT] = [r.ZERO, r.ONE_MINUS_SRC_ALPHA], e[k.DST_ATOP] = [r.ONE_MINUS_DST_ALPHA, r.SRC_ALPHA], e[k.XOR] = [r.ONE_MINUS_DST_ALPHA, r.ONE_MINUS_SRC_ALPHA], e[k.SUBTRACT] = [r.ONE, r.ONE, r.ONE, r.ONE, r.FUNC_REVERSE_SUBTRACT, r.FUNC_ADD], e;
}
var Ng = 0, Lg = 1, Bg = 2, Gg = 3, Ug = 4, kg = 5, Xg = (
  /** @class */
  function() {
    function r() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = k.NONE, this._blendEq = !1, this.map = [], this.map[Ng] = this.setBlend, this.map[Lg] = this.setOffset, this.map[Bg] = this.setCullFace, this.map[Gg] = this.setDepthTest, this.map[Ug] = this.setFrontFace, this.map[kg] = this.setDepthMask, this.checks = [], this.defaultState = new ir(), this.defaultState.blend = !0;
    }
    return r.prototype.contextChange = function(e) {
      this.gl = e, this.blendModes = Fg(e), this.set(this.defaultState), this.reset();
    }, r.prototype.set = function(e) {
      if (e = e || this.defaultState, this.stateId !== e.data) {
        for (var t = this.stateId ^ e.data, i = 0; t; )
          t & 1 && this.map[i].call(this, !!(e.data & 1 << i)), t = t >> 1, i++;
        this.stateId = e.data;
      }
      for (var i = 0; i < this.checks.length; i++)
        this.checks[i](this, e);
    }, r.prototype.forceState = function(e) {
      e = e || this.defaultState;
      for (var t = 0; t < this.map.length; t++)
        this.map[t].call(this, !!(e.data & 1 << t));
      for (var t = 0; t < this.checks.length; t++)
        this.checks[t](this, e);
      this.stateId = e.data;
    }, r.prototype.setBlend = function(e) {
      this.updateCheck(r.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND);
    }, r.prototype.setOffset = function(e) {
      this.updateCheck(r.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, r.prototype.setDepthTest = function(e) {
      this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, r.prototype.setDepthMask = function(e) {
      this.gl.depthMask(e);
    }, r.prototype.setCullFace = function(e) {
      this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE);
    }, r.prototype.setFrontFace = function(e) {
      this.gl.frontFace(this.gl[e ? "CW" : "CCW"]);
    }, r.prototype.setBlendMode = function(e) {
      if (e !== this.blendMode) {
        this.blendMode = e;
        var t = this.blendModes[e], i = this.gl;
        t.length === 2 ? i.blendFunc(t[0], t[1]) : i.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, i.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
      }
    }, r.prototype.setPolygonOffset = function(e, t) {
      this.gl.polygonOffset(e, t);
    }, r.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0);
    }, r.prototype.updateCheck = function(e, t) {
      var i = this.checks.indexOf(e);
      t && i === -1 ? this.checks.push(e) : !t && i !== -1 && this.checks.splice(i, 1);
    }, r.checkBlendMode = function(e, t) {
      e.setBlendMode(t.blendMode);
    }, r.checkPolygonOffset = function(e, t) {
      e.setPolygonOffset(1, t.polygonOffset);
    }, r.prototype.destroy = function() {
      this.gl = null;
    }, r;
  }()
), jg = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.count = 0, this.checkCount = 0, this.maxIdle = L.GC_MAX_IDLE, this.checkCountMax = L.GC_MAX_CHECK_COUNT, this.mode = L.GC_MODE;
    }
    return r.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== tn.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, r.prototype.run = function() {
      for (var e = this.renderer.texture, t = e.managedTextures, i = !1, n = 0; n < t.length; n++) {
        var o = t[n];
        !o.framebuffer && this.count - o.touched > this.maxIdle && (e.destroyTexture(o, !0), t[n] = null, i = !0);
      }
      if (i) {
        for (var s = 0, n = 0; n < t.length; n++)
          t[n] !== null && (t[s++] = t[n]);
        t.length = s;
      }
    }, r.prototype.unload = function(e) {
      var t = this.renderer.texture, i = e._texture;
      i && !i.framebuffer && t.destroyTexture(i);
      for (var n = e.children.length - 1; n >= 0; n--)
        this.unload(e.children[n]);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
);
function Hg(r) {
  var e, t, i, n, o, s, a, h, u, l, c, p, d, f, y, m, _, g, b, x, E, v, T;
  return "WebGL2RenderingContext" in globalThis && r instanceof globalThis.WebGL2RenderingContext ? T = (e = {}, e[U.UNSIGNED_BYTE] = (t = {}, t[P.RGBA] = r.RGBA8, t[P.RGB] = r.RGB8, t[P.RG] = r.RG8, t[P.RED] = r.R8, t[P.RGBA_INTEGER] = r.RGBA8UI, t[P.RGB_INTEGER] = r.RGB8UI, t[P.RG_INTEGER] = r.RG8UI, t[P.RED_INTEGER] = r.R8UI, t[P.ALPHA] = r.ALPHA, t[P.LUMINANCE] = r.LUMINANCE, t[P.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, t), e[U.BYTE] = (i = {}, i[P.RGBA] = r.RGBA8_SNORM, i[P.RGB] = r.RGB8_SNORM, i[P.RG] = r.RG8_SNORM, i[P.RED] = r.R8_SNORM, i[P.RGBA_INTEGER] = r.RGBA8I, i[P.RGB_INTEGER] = r.RGB8I, i[P.RG_INTEGER] = r.RG8I, i[P.RED_INTEGER] = r.R8I, i), e[U.UNSIGNED_SHORT] = (n = {}, n[P.RGBA_INTEGER] = r.RGBA16UI, n[P.RGB_INTEGER] = r.RGB16UI, n[P.RG_INTEGER] = r.RG16UI, n[P.RED_INTEGER] = r.R16UI, n[P.DEPTH_COMPONENT] = r.DEPTH_COMPONENT16, n), e[U.SHORT] = (o = {}, o[P.RGBA_INTEGER] = r.RGBA16I, o[P.RGB_INTEGER] = r.RGB16I, o[P.RG_INTEGER] = r.RG16I, o[P.RED_INTEGER] = r.R16I, o), e[U.UNSIGNED_INT] = (s = {}, s[P.RGBA_INTEGER] = r.RGBA32UI, s[P.RGB_INTEGER] = r.RGB32UI, s[P.RG_INTEGER] = r.RG32UI, s[P.RED_INTEGER] = r.R32UI, s[P.DEPTH_COMPONENT] = r.DEPTH_COMPONENT24, s), e[U.INT] = (a = {}, a[P.RGBA_INTEGER] = r.RGBA32I, a[P.RGB_INTEGER] = r.RGB32I, a[P.RG_INTEGER] = r.RG32I, a[P.RED_INTEGER] = r.R32I, a), e[U.FLOAT] = (h = {}, h[P.RGBA] = r.RGBA32F, h[P.RGB] = r.RGB32F, h[P.RG] = r.RG32F, h[P.RED] = r.R32F, h[P.DEPTH_COMPONENT] = r.DEPTH_COMPONENT32F, h), e[U.HALF_FLOAT] = (u = {}, u[P.RGBA] = r.RGBA16F, u[P.RGB] = r.RGB16F, u[P.RG] = r.RG16F, u[P.RED] = r.R16F, u), e[U.UNSIGNED_SHORT_5_6_5] = (l = {}, l[P.RGB] = r.RGB565, l), e[U.UNSIGNED_SHORT_4_4_4_4] = (c = {}, c[P.RGBA] = r.RGBA4, c), e[U.UNSIGNED_SHORT_5_5_5_1] = (p = {}, p[P.RGBA] = r.RGB5_A1, p), e[U.UNSIGNED_INT_2_10_10_10_REV] = (d = {}, d[P.RGBA] = r.RGB10_A2, d[P.RGBA_INTEGER] = r.RGB10_A2UI, d), e[U.UNSIGNED_INT_10F_11F_11F_REV] = (f = {}, f[P.RGB] = r.R11F_G11F_B10F, f), e[U.UNSIGNED_INT_5_9_9_9_REV] = (y = {}, y[P.RGB] = r.RGB9_E5, y), e[U.UNSIGNED_INT_24_8] = (m = {}, m[P.DEPTH_STENCIL] = r.DEPTH24_STENCIL8, m), e[U.FLOAT_32_UNSIGNED_INT_24_8_REV] = (_ = {}, _[P.DEPTH_STENCIL] = r.DEPTH32F_STENCIL8, _), e) : T = (g = {}, g[U.UNSIGNED_BYTE] = (b = {}, b[P.RGBA] = r.RGBA, b[P.RGB] = r.RGB, b[P.ALPHA] = r.ALPHA, b[P.LUMINANCE] = r.LUMINANCE, b[P.LUMINANCE_ALPHA] = r.LUMINANCE_ALPHA, b), g[U.UNSIGNED_SHORT_5_6_5] = (x = {}, x[P.RGB] = r.RGB, x), g[U.UNSIGNED_SHORT_4_4_4_4] = (E = {}, E[P.RGBA] = r.RGBA, E), g[U.UNSIGNED_SHORT_5_5_5_1] = (v = {}, v[P.RGBA] = r.RGBA, v), g), T;
}
var ro = (
  /** @class */
  function() {
    function r(e) {
      this.texture = e, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = U.UNSIGNED_BYTE, this.internalFormat = P.RGBA, this.samplerType = 0;
    }
    return r;
  }()
), Yg = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new rt(), this.hasIntegerTextures = !1;
    }
    return r.prototype.contextChange = function() {
      var e = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = Hg(e);
      var t = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = t;
      for (var i = 0; i < t; i++)
        this.boundTextures[i] = null;
      this.emptyTextures = {};
      var n = new ro(e.createTexture());
      e.bindTexture(e.TEXTURE_2D, n.texture), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[e.TEXTURE_2D] = n, this.emptyTextures[e.TEXTURE_CUBE_MAP] = new ro(e.createTexture()), e.bindTexture(e.TEXTURE_CUBE_MAP, this.emptyTextures[e.TEXTURE_CUBE_MAP].texture);
      for (var i = 0; i < 6; i++)
        e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, null);
      e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR);
      for (var i = 0; i < this.boundTextures.length; i++)
        this.bind(null, i);
    }, r.prototype.bind = function(e, t) {
      t === void 0 && (t = 0);
      var i = this.gl;
      if (e = e == null ? void 0 : e.castToBaseTexture(), e && e.valid && !e.parentTextureArray) {
        e.touched = this.renderer.textureGC.count;
        var n = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
        this.boundTextures[t] !== e && (this.currentLocation !== t && (this.currentLocation = t, i.activeTexture(i.TEXTURE0 + t)), i.bindTexture(e.target, n.texture)), n.dirtyId !== e.dirtyId ? (this.currentLocation !== t && (this.currentLocation = t, i.activeTexture(i.TEXTURE0 + t)), this.updateTexture(e)) : n.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e), this.boundTextures[t] = e;
      } else
        this.currentLocation !== t && (this.currentLocation = t, i.activeTexture(i.TEXTURE0 + t)), i.bindTexture(i.TEXTURE_2D, this.emptyTextures[i.TEXTURE_2D].texture), this.boundTextures[t] = null;
    }, r.prototype.reset = function() {
      this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
      for (var e = 0; e < this.boundTextures.length; e++)
        this.boundTextures[e] = this.unknownTexture;
    }, r.prototype.unbind = function(e) {
      var t = this, i = t.gl, n = t.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (var o = 0; o < n.length; o++)
          n[o] === this.unknownTexture && this.bind(null, o);
      }
      for (var o = 0; o < n.length; o++)
        n[o] === e && (this.currentLocation !== o && (i.activeTexture(i.TEXTURE0 + o), this.currentLocation = o), i.bindTexture(e.target, this.emptyTextures[e.target].texture), n[o] = null);
    }, r.prototype.ensureSamplerType = function(e) {
      var t = this, i = t.boundTextures, n = t.hasIntegerTextures, o = t.CONTEXT_UID;
      if (n)
        for (var s = e - 1; s >= 0; --s) {
          var a = i[s];
          if (a) {
            var h = a._glTextures[o];
            h.samplerType !== Qi.FLOAT && this.renderer.texture.unbind(a);
          }
        }
    }, r.prototype.initTexture = function(e) {
      var t = new ro(this.gl.createTexture());
      return t.dirtyId = -1, e._glTextures[this.CONTEXT_UID] = t, this.managedTextures.push(e), e.on("dispose", this.destroyTexture, this), t;
    }, r.prototype.initTextureType = function(e, t) {
      var i, n;
      t.internalFormat = (n = (i = this.internalFormats[e.type]) === null || i === void 0 ? void 0 : i[e.format]) !== null && n !== void 0 ? n : e.format, this.webGLVersion === 2 && e.type === U.HALF_FLOAT ? t.type = this.gl.HALF_FLOAT : t.type = e.type;
    }, r.prototype.updateTexture = function(e) {
      var t = e._glTextures[this.CONTEXT_UID];
      if (t) {
        var i = this.renderer;
        if (this.initTextureType(e, t), e.resource && e.resource.upload(i, e, t))
          t.samplerType !== Qi.FLOAT && (this.hasIntegerTextures = !0);
        else {
          var n = e.realWidth, o = e.realHeight, s = i.gl;
          (t.width !== n || t.height !== o || t.dirtyId < 0) && (t.width = n, t.height = o, s.texImage2D(e.target, 0, t.internalFormat, n, o, 0, e.format, t.type, null));
        }
        e.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(e), t.dirtyId = e.dirtyId;
      }
    }, r.prototype.destroyTexture = function(e, t) {
      var i = this.gl;
      if (e = e.castToBaseTexture(), e._glTextures[this.CONTEXT_UID] && (this.unbind(e), i.deleteTexture(e._glTextures[this.CONTEXT_UID].texture), e.off("dispose", this.destroyTexture, this), delete e._glTextures[this.CONTEXT_UID], !t)) {
        var n = this.managedTextures.indexOf(e);
        n !== -1 && Er(this.managedTextures, n, 1);
      }
    }, r.prototype.updateTextureStyle = function(e) {
      var t = e._glTextures[this.CONTEXT_UID];
      t && ((e.mipmap === ie.POW2 || this.webGLVersion !== 2) && !e.isPowerOfTwo ? t.mipmap = !1 : t.mipmap = e.mipmap >= 1, this.webGLVersion !== 2 && !e.isPowerOfTwo ? t.wrapMode = le.CLAMP : t.wrapMode = e.wrapMode, e.resource && e.resource.style(this.renderer, e, t) || this.setStyle(e, t), t.dirtyStyleId = e.dirtyStyleId);
    }, r.prototype.setStyle = function(e, t) {
      var i = this.gl;
      if (t.mipmap && e.mipmap !== ie.ON_MANUAL && i.generateMipmap(e.target), i.texParameteri(e.target, i.TEXTURE_WRAP_S, t.wrapMode), i.texParameteri(e.target, i.TEXTURE_WRAP_T, t.wrapMode), t.mipmap) {
        i.texParameteri(e.target, i.TEXTURE_MIN_FILTER, e.scaleMode === he.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST);
        var n = this.renderer.context.extensions.anisotropicFiltering;
        if (n && e.anisotropicLevel > 0 && e.scaleMode === he.LINEAR) {
          var o = Math.min(e.anisotropicLevel, i.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          i.texParameterf(e.target, n.TEXTURE_MAX_ANISOTROPY_EXT, o);
        }
      } else
        i.texParameteri(e.target, i.TEXTURE_MIN_FILTER, e.scaleMode === he.LINEAR ? i.LINEAR : i.NEAREST);
      i.texParameteri(e.target, i.TEXTURE_MAG_FILTER, e.scaleMode === he.LINEAR ? i.LINEAR : i.NEAREST);
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r;
  }()
), io = new It(), Vg = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t, i) {
      t === void 0 && (t = Qr.UNKNOWN);
      var n = r.call(this) || this;
      return i = Object.assign({}, L.RENDER_OPTIONS, i), n.options = i, n.type = t, n.screen = new it(0, 0, i.width, i.height), n.view = i.view || L.ADAPTER.createCanvas(), n.resolution = i.resolution || L.RESOLUTION, n.useContextAlpha = i.useContextAlpha, n.autoDensity = !!i.autoDensity, n.preserveDrawingBuffer = i.preserveDrawingBuffer, n.clearBeforeRender = i.clearBeforeRender, n._backgroundColor = 0, n._backgroundColorRgba = [0, 0, 0, 1], n._backgroundColorString = "#000000", n.backgroundColor = i.backgroundColor || n._backgroundColor, n.backgroundAlpha = i.backgroundAlpha, i.transparent !== void 0 && (re("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), n.useContextAlpha = i.transparent, n.backgroundAlpha = i.transparent ? 0 : 1), n._lastObjectRendered = null, n.plugins = {}, n;
    }
    return e.prototype.initPlugins = function(t) {
      for (var i in t)
        this.plugins[i] = new t[i](this);
    }, Object.defineProperty(e.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.resize = function(t, i) {
      this.view.width = Math.round(t * this.resolution), this.view.height = Math.round(i * this.resolution);
      var n = this.view.width / this.resolution, o = this.view.height / this.resolution;
      this.screen.width = n, this.screen.height = o, this.autoDensity && (this.view.style.width = n + "px", this.view.style.height = o + "px"), this.emit("resize", n, o);
    }, e.prototype.generateTexture = function(t, i, n, o) {
      i === void 0 && (i = {}), typeof i == "number" && (re("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), i = { scaleMode: i, resolution: n, region: o });
      var s = i.region, a = O_(i, ["region"]);
      o = s || t.getLocalBounds(null, !0), o.width === 0 && (o.width = 1), o.height === 0 && (o.height = 1);
      var h = er.create(Uo({ width: o.width, height: o.height }, a));
      return io.tx = -o.x, io.ty = -o.y, this.render(t, {
        renderTexture: h,
        clear: !1,
        transform: io,
        skipUpdateTransform: !!t.parent
      }), h;
    }, e.prototype.destroy = function(t) {
      for (var i in this.plugins)
        this.plugins[i].destroy(), this.plugins[i] = null;
      t && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      var n = this;
      n.plugins = null, n.type = Qr.UNKNOWN, n.view = null, n.screen = null, n._tempDisplayObjectParent = null, n.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(e.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(t) {
        this._backgroundColor = t, this._backgroundColorString = xu(t), wr(t, this._backgroundColorRgba);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(t) {
        this._backgroundColorRgba[3] = t;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(hi)
), zg = (
  /** @class */
  function() {
    function r(e) {
      this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }
    return r;
  }()
), Wg = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return r.prototype.destroy = function() {
      this.renderer = null;
    }, r.prototype.contextChange = function() {
      this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, r.prototype.bind = function(e) {
      var t = this, i = t.gl, n = t.CONTEXT_UID, o = e._glBuffers[n] || this.createGLBuffer(e);
      i.bindBuffer(e.type, o.buffer);
    }, r.prototype.bindBufferBase = function(e, t) {
      var i = this, n = i.gl, o = i.CONTEXT_UID;
      if (this.boundBufferBases[t] !== e) {
        var s = e._glBuffers[o] || this.createGLBuffer(e);
        this.boundBufferBases[t] = e, n.bindBufferBase(n.UNIFORM_BUFFER, t, s.buffer);
      }
    }, r.prototype.bindBufferRange = function(e, t, i) {
      var n = this, o = n.gl, s = n.CONTEXT_UID;
      i = i || 0;
      var a = e._glBuffers[s] || this.createGLBuffer(e);
      o.bindBufferRange(o.UNIFORM_BUFFER, t || 0, a.buffer, i * 256, 256);
    }, r.prototype.update = function(e) {
      var t = this, i = t.gl, n = t.CONTEXT_UID, o = e._glBuffers[n];
      if (e._updateID !== o.updateID)
        if (o.updateID = e._updateID, i.bindBuffer(e.type, o.buffer), o.byteLength >= e.data.byteLength)
          i.bufferSubData(e.type, 0, e.data);
        else {
          var s = e.static ? i.STATIC_DRAW : i.DYNAMIC_DRAW;
          o.byteLength = e.data.byteLength, i.bufferData(e.type, e.data, s);
        }
    }, r.prototype.dispose = function(e, t) {
      if (this.managedBuffers[e.id]) {
        delete this.managedBuffers[e.id];
        var i = e._glBuffers[this.CONTEXT_UID], n = this.gl;
        e.disposeRunner.remove(this), i && (t || n.deleteBuffer(i.buffer), delete e._glBuffers[this.CONTEXT_UID]);
      }
    }, r.prototype.disposeAll = function(e) {
      for (var t = Object.keys(this.managedBuffers), i = 0; i < t.length; i++)
        this.dispose(this.managedBuffers[t[i]], e);
    }, r.prototype.createGLBuffer = function(e) {
      var t = this, i = t.CONTEXT_UID, n = t.gl;
      return e._glBuffers[i] = new zg(n.createBuffer()), this.managedBuffers[e.id] = e, e.disposeRunner.add(this), e._glBuffers[i];
    }, r;
  }()
), Xu = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      var i = r.call(this, Qr.WEBGL, t) || this;
      return t = i.options, i.gl = null, i.CONTEXT_UID = 0, i.runners = {
        destroy: new Nt("destroy"),
        contextChange: new Nt("contextChange"),
        reset: new Nt("reset"),
        update: new Nt("update"),
        postrender: new Nt("postrender"),
        prerender: new Nt("prerender"),
        resize: new Nt("resize")
      }, i.runners.contextChange.add(i), i.globalUniforms = new Je({
        projectionMatrix: new It()
      }, !0), i.addSystem(gg, "mask").addSystem(W_, "context").addSystem(Xg, "state").addSystem(Cg, "shader").addSystem(Yg, "texture").addSystem(Wg, "buffer").addSystem(Z_, "geometry").addSystem(K_, "framebuffer").addSystem(vg, "scissor").addSystem(bg, "stencil").addSystem(xg, "projection").addSystem(jg, "textureGC").addSystem(V_, "filter").addSystem(Tg, "renderTexture").addSystem(z_, "batch"), i.initPlugins(e.__plugins), i.multisample = void 0, t.context ? i.context.initFromContext(t.context) : i.context.initFromOptions({
        alpha: !!i.useContextAlpha,
        antialias: t.antialias,
        premultipliedAlpha: i.useContextAlpha && i.useContextAlpha !== "notMultiplied",
        stencil: !0,
        preserveDrawingBuffer: t.preserveDrawingBuffer,
        powerPreference: i.options.powerPreference
      }), i.renderingToScreen = !0, Af(i.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), i.resize(i.options.width, i.options.height), i;
    }
    return e.create = function(t) {
      if (Sf())
        return new e(t);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, e.prototype.contextChange = function() {
      var t = this.gl, i;
      if (this.context.webGLVersion === 1) {
        var n = t.getParameter(t.FRAMEBUFFER_BINDING);
        t.bindFramebuffer(t.FRAMEBUFFER, null), i = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.FRAMEBUFFER, n);
      } else {
        var n = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
        t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), i = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, n);
      }
      i >= gt.HIGH ? this.multisample = gt.HIGH : i >= gt.MEDIUM ? this.multisample = gt.MEDIUM : i >= gt.LOW ? this.multisample = gt.LOW : this.multisample = gt.NONE;
    }, e.prototype.addSystem = function(t, i) {
      var n = new t(this);
      if (this[i])
        throw new Error('Whoops! The name "' + i + '" is already in use');
      this[i] = n;
      for (var o in this.runners)
        this.runners[o].add(n);
      return this;
    }, e.prototype.render = function(t, i) {
      var n, o, s, a;
      if (i && (i instanceof er ? (re("6.0.0", "Renderer#render arguments changed, use options instead."), n = i, o = arguments[2], s = arguments[3], a = arguments[4]) : (n = i.renderTexture, o = i.clear, s = i.transform, a = i.skipUpdateTransform)), this.renderingToScreen = !n, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = s, !this.context.isLost) {
        if (n || (this._lastObjectRendered = t), !a) {
          var h = t.enableTempParent();
          t.updateTransform(), t.disableTempParent(h);
        }
        this.renderTexture.bind(n), this.batch.currentRenderer.start(), (o !== void 0 ? o : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), n && n.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, e.prototype.generateTexture = function(t, i, n, o) {
      i === void 0 && (i = {});
      var s = r.prototype.generateTexture.call(this, t, i, n, o);
      return this.framebuffer.blit(), s;
    }, e.prototype.resize = function(t, i) {
      r.prototype.resize.call(this, t, i), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, e.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, e.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, e.prototype.destroy = function(t) {
      this.runners.destroy.emit();
      for (var i in this.runners)
        this.runners[i].destroy();
      r.prototype.destroy.call(this, t), this.gl = null;
    }, Object.defineProperty(e.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        return re("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      },
      enumerable: !1,
      configurable: !0
    }), e.registerPlugin = function(t, i) {
      re("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), Te.add({
        name: t,
        type: dt.RendererPlugin,
        ref: i
      });
    }, e.__plugins = {}, e;
  }(Vg)
);
Te.handleByMap(dt.RendererPlugin, Xu.__plugins);
function ju(r) {
  return Xu.create(r);
}
var $g = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`, qg = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Kg = $g, Hu = qg, Xo = (
  /** @class */
  function() {
    function r() {
      this.texArray = null, this.blend = 0, this.type = te.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }
    return r;
  }()
), jo = (
  /** @class */
  function() {
    function r() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return r.prototype.clear = function() {
      for (var e = 0; e < this.count; e++)
        this.elements[e] = null;
      this.count = 0;
    }, r;
  }()
), Ho = (
  /** @class */
  function() {
    function r(e) {
      typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(r.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.view = function(e) {
      return this[e + "View"];
    }, r.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, r.sizeOf = function(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(e + " isn't a valid view type");
      }
    }, r;
  }()
), Zg = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.shaderGenerator = null, i.geometryClass = null, i.vertexSize = null, i.state = ir.for2d(), i.size = L.SPRITE_BATCH_SIZE * 4, i._vertexCount = 0, i._indexCount = 0, i._bufferedElements = [], i._bufferedTextures = [], i._bufferSize = 0, i._shader = null, i._packedGeometries = [], i._packedGeometryPoolSize = 2, i._flushId = 0, i._aBuffers = {}, i._iBuffers = {}, i.MAX_TEXTURES = 1, i.renderer.on("prerender", i.onPrerender, i), t.runners.contextChange.add(i), i._dcIndex = 0, i._aIndex = 0, i._iIndex = 0, i._attributeBuffer = null, i._indexBuffer = null, i._tempBoundTextures = [], i;
    }
    return e.prototype.contextChange = function() {
      var t = this.renderer.gl;
      L.PREFER_ENV === be.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), L.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = hg(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var i = 0; i < this._packedGeometryPoolSize; i++)
        this._packedGeometries[i] = new this.geometryClass();
      this.initFlushBuffers();
    }, e.prototype.initFlushBuffers = function() {
      for (var t = e._drawCallPool, i = e._textureArrayPool, n = this.size / 4, o = Math.floor(n / this.MAX_TEXTURES) + 1; t.length < n; )
        t.push(new Xo());
      for (; i.length < o; )
        i.push(new jo());
      for (var s = 0; s < this.MAX_TEXTURES; s++)
        this._tempBoundTextures[s] = null;
    }, e.prototype.onPrerender = function() {
      this._flushId = 0;
    }, e.prototype.render = function(t) {
      t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t);
    }, e.prototype.buildTexturesAndDrawCalls = function() {
      var t = this, i = t._bufferedTextures, n = t.MAX_TEXTURES, o = e._textureArrayPool, s = this.renderer.batch, a = this._tempBoundTextures, h = this.renderer.textureGC.count, u = ++rt._globalBatch, l = 0, c = o[0], p = 0;
      s.copyBoundTextures(a, n);
      for (var d = 0; d < this._bufferSize; ++d) {
        var f = i[d];
        i[d] = null, f._batchEnabled !== u && (c.count >= n && (s.boundArray(c, a, u, n), this.buildDrawCalls(c, p, d), p = d, c = o[++l], ++u), f._batchEnabled = u, f.touched = h, c.elements[c.count++] = f);
      }
      c.count > 0 && (s.boundArray(c, a, u, n), this.buildDrawCalls(c, p, this._bufferSize), ++l, ++u);
      for (var d = 0; d < a.length; d++)
        a[d] = null;
      rt._globalBatch = u;
    }, e.prototype.buildDrawCalls = function(t, i, n) {
      var o = this, s = o._bufferedElements, a = o._attributeBuffer, h = o._indexBuffer, u = o.vertexSize, l = e._drawCallPool, c = this._dcIndex, p = this._aIndex, d = this._iIndex, f = l[c];
      f.start = this._iIndex, f.texArray = t;
      for (var y = i; y < n; ++y) {
        var m = s[y], _ = m._texture.baseTexture, g = Tu[_.alphaMode ? 1 : 0][m.blendMode];
        s[y] = null, i < y && f.blend !== g && (f.size = d - f.start, i = y, f = l[++c], f.texArray = t, f.start = d), this.packInterleavedGeometry(m, a, h, p, d), p += m.vertexData.length / 2 * u, d += m.indices.length, f.blend = g;
      }
      i < n && (f.size = d - f.start, ++c), this._dcIndex = c, this._aIndex = p, this._iIndex = d;
    }, e.prototype.bindAndClearTexArray = function(t) {
      for (var i = this.renderer.texture, n = 0; n < t.count; n++)
        i.bind(t.elements[n], t.ids[n]), t.elements[n] = null;
      t.count = 0;
    }, e.prototype.updateGeometry = function() {
      var t = this, i = t._packedGeometries, n = t._attributeBuffer, o = t._indexBuffer;
      L.CAN_UPLOAD_SAME_BUFFER ? (i[this._flushId]._buffer.update(n.rawBinaryData), i[this._flushId]._indexBuffer.update(o), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, i[this._flushId] = new this.geometryClass()), i[this._flushId]._buffer.update(n.rawBinaryData), i[this._flushId]._indexBuffer.update(o), this.renderer.geometry.bind(i[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, e.prototype.drawBatches = function() {
      for (var t = this._dcIndex, i = this.renderer, n = i.gl, o = i.state, s = e._drawCallPool, a = null, h = 0; h < t; h++) {
        var u = s[h], l = u.texArray, c = u.type, p = u.size, d = u.start, f = u.blend;
        a !== l && (a = l, this.bindAndClearTexArray(l)), this.state.blendMode = f, o.set(this.state), n.drawElements(c, p, n.UNSIGNED_SHORT, d * 2);
      }
    }, e.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, e.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), L.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, e.prototype.stop = function() {
      this.flush();
    }, e.prototype.destroy = function() {
      for (var t = 0; t < this._packedGeometryPoolSize; t++)
        this._packedGeometries[t] && this._packedGeometries[t].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), r.prototype.destroy.call(this);
    }, e.prototype.getAttributeBuffer = function(t) {
      var i = an(Math.ceil(t / 8)), n = ka(i), o = i * 8;
      this._aBuffers.length <= n && (this._iBuffers.length = n + 1);
      var s = this._aBuffers[o];
      return s || (this._aBuffers[o] = s = new Ho(o * this.vertexSize * 4)), s;
    }, e.prototype.getIndexBuffer = function(t) {
      var i = an(Math.ceil(t / 12)), n = ka(i), o = i * 12;
      this._iBuffers.length <= n && (this._iBuffers.length = n + 1);
      var s = this._iBuffers[n];
      return s || (this._iBuffers[n] = s = new Uint16Array(o)), s;
    }, e.prototype.packInterleavedGeometry = function(t, i, n, o, s) {
      for (var a = i.uint32View, h = i.float32View, u = o / this.vertexSize, l = t.uvs, c = t.indices, p = t.vertexData, d = t._texture.baseTexture._batchLocation, f = Math.min(t.worldAlpha, 1), y = f < 1 && t._texture.baseTexture.alphaMode ? Os(t._tintRGB, f) : t._tintRGB + (f * 255 << 24), m = 0; m < p.length; m += 2)
        h[o++] = p[m], h[o++] = p[m + 1], h[o++] = l[m], h[o++] = l[m + 1], a[o++] = y, h[o++] = d;
      for (var m = 0; m < c.length; m++)
        n[s++] = u + c[m];
    }, e._drawCallPool = [], e._textureArrayPool = [], e;
  }(xn)
), Jg = (
  /** @class */
  function() {
    function r(e, t) {
      if (this.vertexSrc = e, this.fragTemplate = t, this.programCache = {}, this.defaultGroupCache = {}, t.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (t.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return r.prototype.generateShader = function(e) {
      if (!this.programCache[e]) {
        for (var t = new Int32Array(e), i = 0; i < e; i++)
          t[i] = i;
        this.defaultGroupCache[e] = Je.from({ uSamplers: t }, !0);
        var n = this.fragTemplate;
        n = n.replace(/%count%/gi, "" + e), n = n.replace(/%forloop%/gi, this.generateSampleSrc(e)), this.programCache[e] = new pi(this.vertexSrc, n);
      }
      var o = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new It(),
        default: this.defaultGroupCache[e]
      };
      return new we(this.programCache[e], o);
    }, r.prototype.generateSampleSrc = function(e) {
      var t = "";
      t += `
`, t += `
`;
      for (var i = 0; i < e; i++)
        i > 0 && (t += `
else `), i < e - 1 && (t += "if(vTextureId < " + i + ".5)"), t += `
{`, t += `
	color = texture2D(uSamplers[` + i + "], vTextureCoord);", t += `
}`;
      return t += `
`, t += `
`, t;
    }, r;
  }()
), Yu = (
  /** @class */
  function(r) {
    yt(e, r);
    function e(t) {
      t === void 0 && (t = !1);
      var i = r.call(this) || this;
      return i._buffer = new wt(null, t, !1), i._indexBuffer = new wt(null, t, !0), i.addAttribute("aVertexPosition", i._buffer, 2, !1, U.FLOAT).addAttribute("aTextureCoord", i._buffer, 2, !1, U.FLOAT).addAttribute("aColor", i._buffer, 4, !0, U.UNSIGNED_BYTE).addAttribute("aTextureId", i._buffer, 1, !0, U.FLOAT).addIndex(i._indexBuffer), i;
    }
    return e;
  }(ci)
), rh = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, ih = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, Qg = (
  /** @class */
  function() {
    function r() {
    }
    return r.create = function(e) {
      var t = Object.assign({
        vertex: rh,
        fragment: ih,
        geometryClass: Yu,
        vertexSize: 6
      }, e), i = t.vertex, n = t.fragment, o = t.vertexSize, s = t.geometryClass;
      return (
        /** @class */
        function(a) {
          yt(h, a);
          function h(u) {
            var l = a.call(this, u) || this;
            return l.shaderGenerator = new Jg(i, n), l.geometryClass = s, l.vertexSize = o, l;
          }
          return h;
        }(Zg)
      );
    }, Object.defineProperty(r, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return rh;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return ih;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
), Vu = Qg.create();
Object.assign(Vu, {
  extension: {
    name: "batch",
    type: dt.RendererPlugin
  }
});
/*!
 * @pixi/accessibility - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/accessibility is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var tv = {
  /**
   *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
   *   shadow div with attributes set
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  accessible: !1,
  /**
   * Sets the title attribute of the shadow div
   * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
   * @member {?string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleTitle: null,
  /**
   * Sets the aria-label attribute of the shadow div
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  accessibleHint: null,
  /**
   * @member {number}
   * @memberof PIXI.DisplayObject#
   * @private
   * @todo Needs docs.
   */
  tabIndex: 0,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleActive: !1,
  /**
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @todo Needs docs.
   */
  _accessibleDiv: null,
  /**
   * Specify the type of div the accessible layer is. Screen readers treat the element differently
   * depending on this type. Defaults to button.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'button'
   */
  accessibleType: "button",
  /**
   * Specify the pointer-events the accessible div will use
   * Defaults to auto.
   * @member {string}
   * @memberof PIXI.DisplayObject#
   * @default 'auto'
   */
  accessiblePointerEvents: "auto",
  /**
   * Setting to false will prevent any children inside this container to
   * be accessible. Defaults to true.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   * @default true
   */
  accessibleChildren: !0,
  renderId: -1
};
St.mixin(tv);
var ev = 9, Ci = 100, rv = 0, iv = 0, nh = 2, oh = 1, nv = -1e3, ov = -1e3, sv = 2, av = (
  /** @class */
  function() {
    function r(e) {
      this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (ue.tablet || ue.phone) && this.createTouchHook();
      var t = document.createElement("div");
      t.style.width = Ci + "px", t.style.height = Ci + "px", t.style.position = "absolute", t.style.top = rv + "px", t.style.left = iv + "px", t.style.zIndex = nh.toString(), this.div = t, this.renderer = e, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1);
    }
    return Object.defineProperty(r.prototype, "isActive", {
      /**
       * Value of `true` if accessibility is currently active and accessibility layers are showing.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isActive;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isMobileAccessibility", {
      /**
       * Value of `true` if accessibility is enabled for touch devices.
       * @member {boolean}
       * @readonly
       */
      get: function() {
        return this._isMobileAccessibility;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.createTouchHook = function() {
      var e = this, t = document.createElement("button");
      t.style.width = oh + "px", t.style.height = oh + "px", t.style.position = "absolute", t.style.top = nv + "px", t.style.left = ov + "px", t.style.zIndex = sv.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", function() {
        e._isMobileAccessibility = !0, e.activate(), e.destroyTouchHook();
      }), document.body.appendChild(t), this._hookDiv = t;
    }, r.prototype.destroyTouchHook = function() {
      this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null);
    }, r.prototype.activate = function() {
      var e;
      this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), (e = this.renderer.view.parentNode) === null || e === void 0 || e.appendChild(this.div));
    }, r.prototype.deactivate = function() {
      var e;
      !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), (e = this.div.parentNode) === null || e === void 0 || e.removeChild(this.div));
    }, r.prototype.updateAccessibleObjects = function(e) {
      if (!(!e.visible || !e.accessibleChildren)) {
        e.accessible && e.interactive && (e._accessibleActive || this.addChild(e), e.renderId = this.renderId);
        var t = e.children;
        if (t)
          for (var i = 0; i < t.length; i++)
            this.updateAccessibleObjects(t[i]);
      }
    }, r.prototype.update = function() {
      var e = performance.now();
      if (!(ue.android.device && e < this.androidUpdateCount) && (this.androidUpdateCount = e + this.androidUpdateFrequency, !!this.renderer.renderingToScreen)) {
        this.renderer._lastObjectRendered && this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var t = this.renderer.view.getBoundingClientRect(), i = t.left, n = t.top, o = t.width, s = t.height, a = this.renderer, h = a.width, u = a.height, l = a.resolution, c = o / h * l, p = s / u * l, d = this.div;
        d.style.left = i + "px", d.style.top = n + "px", d.style.width = h + "px", d.style.height = u + "px";
        for (var f = 0; f < this.children.length; f++) {
          var y = this.children[f];
          if (y.renderId !== this.renderId)
            y._accessibleActive = !1, Er(this.children, f, 1), this.div.removeChild(y._accessibleDiv), this.pool.push(y._accessibleDiv), y._accessibleDiv = null, f--;
          else {
            d = y._accessibleDiv;
            var m = y.hitArea, _ = y.worldTransform;
            y.hitArea ? (d.style.left = (_.tx + m.x * _.a) * c + "px", d.style.top = (_.ty + m.y * _.d) * p + "px", d.style.width = m.width * _.a * c + "px", d.style.height = m.height * _.d * p + "px") : (m = y.getBounds(), this.capHitArea(m), d.style.left = m.x * c + "px", d.style.top = m.y * p + "px", d.style.width = m.width * c + "px", d.style.height = m.height * p + "px", d.title !== y.accessibleTitle && y.accessibleTitle !== null && (d.title = y.accessibleTitle), d.getAttribute("aria-label") !== y.accessibleHint && y.accessibleHint !== null && d.setAttribute("aria-label", y.accessibleHint)), (y.accessibleTitle !== d.title || y.tabIndex !== d.tabIndex) && (d.title = y.accessibleTitle, d.tabIndex = y.tabIndex, this.debug && this.updateDebugHTML(d));
          }
        }
        this.renderId++;
      }
    }, r.prototype.updateDebugHTML = function(e) {
      e.innerHTML = "type: " + e.type + "</br> title : " + e.title + "</br> tabIndex: " + e.tabIndex;
    }, r.prototype.capHitArea = function(e) {
      e.x < 0 && (e.width += e.x, e.x = 0), e.y < 0 && (e.height += e.y, e.y = 0);
      var t = this.renderer, i = t.width, n = t.height;
      e.x + e.width > i && (e.width = i - e.x), e.y + e.height > n && (e.height = n - e.y);
    }, r.prototype.addChild = function(e) {
      var t = this.pool.pop();
      t || (t = document.createElement("button"), t.style.width = Ci + "px", t.style.height = Ci + "px", t.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", t.style.position = "absolute", t.style.zIndex = nh.toString(), t.style.borderStyle = "none", navigator.userAgent.toLowerCase().indexOf("chrome") > -1 ? t.setAttribute("aria-live", "off") : t.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? t.setAttribute("aria-relevant", "additions") : t.setAttribute("aria-relevant", "text"), t.addEventListener("click", this._onClick.bind(this)), t.addEventListener("focus", this._onFocus.bind(this)), t.addEventListener("focusout", this._onFocusOut.bind(this))), t.style.pointerEvents = e.accessiblePointerEvents, t.type = e.accessibleType, e.accessibleTitle && e.accessibleTitle !== null ? t.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (t.title = "displayObject " + e.tabIndex), e.accessibleHint && e.accessibleHint !== null && t.setAttribute("aria-label", e.accessibleHint), this.debug && this.updateDebugHTML(t), e._accessibleActive = !0, e._accessibleDiv = t, t.displayObject = e, this.children.push(e), this.div.appendChild(e._accessibleDiv), e._accessibleDiv.tabIndex = e.tabIndex;
    }, r.prototype._onClick = function(e) {
      var t = this.renderer.plugins.interaction, i = e.target.displayObject, n = t.eventData;
      t.dispatchEvent(i, "click", n), t.dispatchEvent(i, "pointertap", n), t.dispatchEvent(i, "tap", n);
    }, r.prototype._onFocus = function(e) {
      e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive");
      var t = this.renderer.plugins.interaction, i = e.target.displayObject, n = t.eventData;
      t.dispatchEvent(i, "mouseover", n);
    }, r.prototype._onFocusOut = function(e) {
      e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite");
      var t = this.renderer.plugins.interaction, i = e.target.displayObject, n = t.eventData;
      t.dispatchEvent(i, "mouseout", n);
    }, r.prototype._onKeyDown = function(e) {
      e.keyCode === ev && this.activate();
    }, r.prototype._onMouseMove = function(e) {
      e.movementX === 0 && e.movementY === 0 || this.deactivate();
    }, r.prototype.destroy = function() {
      this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null;
    }, r.extension = {
      name: "accessibility",
      type: [
        dt.RendererPlugin,
        dt.CanvasRendererPlugin
      ]
    }, r;
  }()
);
/*!
 * @pixi/interaction - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var sh = (
  /** @class */
  function() {
    function r() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new _t(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = !1, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(r.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.getLocalPosition = function(e, t, i) {
      return e.worldTransform.applyInverse(i || this.global, t);
    }, r.prototype.copyEvent = function(e) {
      "isPrimary" in e && e.isPrimary && (this.isPrimary = !0), this.button = "button" in e && e.button;
      var t = "buttons" in e && e.buttons;
      this.buttons = Number.isInteger(t) ? t : "which" in e && e.which, this.width = "width" in e && e.width, this.height = "height" in e && e.height, this.tiltX = "tiltX" in e && e.tiltX, this.tiltY = "tiltY" in e && e.tiltY, this.pointerType = "pointerType" in e && e.pointerType, this.pressure = "pressure" in e && e.pressure, this.rotationAngle = "rotationAngle" in e && e.rotationAngle, this.twist = "twist" in e && e.twist || 0, this.tangentialPressure = "tangentialPressure" in e && e.tangentialPressure || 0;
    }, r.prototype.reset = function() {
      this.isPrimary = !1;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Yo = function(r, e) {
  return Yo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Yo(r, e);
};
function hv(r, e) {
  Yo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var uv = (
  /** @class */
  function() {
    function r() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return r.prototype.stopPropagation = function() {
      this.stopped = !0, this.stopPropagationHint = !0, this.stopsPropagatingAt = this.currentTarget;
    }, r.prototype.reset = function() {
      this.stopped = !1, this.stopsPropagatingAt = null, this.stopPropagationHint = !1, this.currentTarget = null, this.target = null;
    }, r;
  }()
), no = (
  /** @class */
  function() {
    function r(e) {
      this._pointerId = e, this._flags = r.FLAGS.NONE;
    }
    return r.prototype._doSet = function(e, t) {
      t ? this._flags = this._flags | e : this._flags = this._flags & ~e;
    }, Object.defineProperty(r.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(e) {
        this._flags = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === r.FLAGS.NONE;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.OVER) !== 0;
      },
      set: function(e) {
        this._doSet(r.FLAGS.OVER, e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(e) {
        this._doSet(r.FLAGS.RIGHT_DOWN, e);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & r.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(e) {
        this._doSet(r.FLAGS.LEFT_DOWN, e);
      },
      enumerable: !1,
      configurable: !0
    }), r.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1,
      LEFT_DOWN: 2,
      RIGHT_DOWN: 4
    }), r;
  }()
), lv = (
  /** @class */
  function() {
    function r() {
      this._tempPoint = new _t();
    }
    return r.prototype.recursiveFindHit = function(e, t, i, n, o) {
      var s;
      if (!t || !t.visible)
        return !1;
      var a = e.data.global;
      o = t.interactive || o;
      var h = !1, u = o, l = !0;
      if (t.hitArea)
        n && (t.worldTransform.applyInverse(a, this._tempPoint), t.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? h = !0 : (n = !1, l = !1)), u = !1;
      else if (t._mask && n) {
        var c = t._mask.isMaskData ? t._mask.maskObject : t._mask;
        c && !(!((s = c.containsPoint) === null || s === void 0) && s.call(c, a)) && (n = !1);
      }
      if (l && t.interactiveChildren && t.children)
        for (var p = t.children, d = p.length - 1; d >= 0; d--) {
          var f = p[d], y = this.recursiveFindHit(e, f, i, n, u);
          if (y) {
            if (!f.parent)
              continue;
            u = !1, y && (e.target && (n = !1), h = !0);
          }
        }
      return o && (n && !e.target && !t.hitArea && t.containsPoint && t.containsPoint(a) && (h = !0), t.interactive && (h && !e.target && (e.target = t), i && i(e, t, !!h))), h;
    }, r.prototype.findHit = function(e, t, i, n) {
      this.recursiveFindHit(e, t, i, n, !1);
    }, r;
  }()
), cv = {
  interactive: !1,
  interactiveChildren: !0,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(r) {
    r ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
St.mixin(cv);
var Fi = 1, Ni = {
  target: null,
  data: {
    global: null
  }
}, pv = (
  /** @class */
  function(r) {
    hv(e, r);
    function e(t, i) {
      var n = r.call(this) || this;
      return i = i || {}, n.renderer = t, n.autoPreventDefault = i.autoPreventDefault !== void 0 ? i.autoPreventDefault : !0, n.interactionFrequency = i.interactionFrequency || 10, n.mouse = new sh(), n.mouse.identifier = Fi, n.mouse.global.set(-999999), n.activeInteractionData = {}, n.activeInteractionData[Fi] = n.mouse, n.interactionDataPool = [], n.eventData = new uv(), n.interactionDOMElement = null, n.moveWhenInside = !1, n.eventsAdded = !1, n.tickerAdded = !1, n.mouseOverRenderer = !("PointerEvent" in globalThis), n.supportsTouchEvents = "ontouchstart" in globalThis, n.supportsPointerEvents = !!globalThis.PointerEvent, n.onPointerUp = n.onPointerUp.bind(n), n.processPointerUp = n.processPointerUp.bind(n), n.onPointerCancel = n.onPointerCancel.bind(n), n.processPointerCancel = n.processPointerCancel.bind(n), n.onPointerDown = n.onPointerDown.bind(n), n.processPointerDown = n.processPointerDown.bind(n), n.onPointerMove = n.onPointerMove.bind(n), n.processPointerMove = n.processPointerMove.bind(n), n.onPointerOut = n.onPointerOut.bind(n), n.processPointerOverOut = n.processPointerOverOut.bind(n), n.onPointerOver = n.onPointerOver.bind(n), n.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, n.currentCursorMode = null, n.cursor = null, n.resolution = 1, n.delayedEvents = [], n.search = new lv(), n._tempDisplayObject = new wu(), n._eventListenerOptions = { capture: !0, passive: !1 }, n._useSystemTicker = i.useSystemTicker !== void 0 ? i.useSystemTicker : !0, n.setTargetElement(n.renderer.view, n.renderer.resolution), n;
    }
    return Object.defineProperty(e.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(t) {
        this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener();
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hitTest = function(t, i) {
      return Ni.target = null, Ni.data.global = t, i || (i = this.lastObjectRendered), this.processInteractive(Ni, i, null, !0), Ni.target;
    }, e.prototype.setTargetElement = function(t, i) {
      i === void 0 && (i = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = i, this.addEvents(), this.addTickerListener();
    }, e.prototype.addTickerListener = function() {
      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Lt.system.add(this.tickerUpdate, this, xe.INTERACTION), this.tickerAdded = !0);
    }, e.prototype.removeTickerListener = function() {
      this.tickerAdded && (Lt.system.remove(this.tickerUpdate, this), this.tickerAdded = !1);
    }, e.prototype.addEvents = function() {
      if (!(this.eventsAdded || !this.interactionDOMElement)) {
        var t = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = !0;
      }
    }, e.prototype.removeEvents = function() {
      if (!(!this.eventsAdded || !this.interactionDOMElement)) {
        var t = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = !1;
      }
    }, e.prototype.tickerUpdate = function(t) {
      this._deltaTime += t, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
    }, e.prototype.update = function() {
      if (this.interactionDOMElement) {
        if (this._didMove) {
          this._didMove = !1;
          return;
        }
        this.cursor = null;
        for (var t in this.activeInteractionData)
          if (this.activeInteractionData.hasOwnProperty(t)) {
            var i = this.activeInteractionData[t];
            if (i.originalEvent && i.pointerType !== "touch") {
              var n = this.configureInteractionEventForDOMEvent(this.eventData, i.originalEvent, i);
              this.processInteractive(n, this.lastObjectRendered, this.processPointerOverOut, !0);
            }
          }
        this.setCursorMode(this.cursor);
      }
    }, e.prototype.setCursorMode = function(t) {
      t = t || "default";
      var i = !0;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (i = !1), this.currentCursorMode !== t) {
        this.currentCursorMode = t;
        var n = this.cursorStyles[t];
        if (n)
          switch (typeof n) {
            case "string":
              i && (this.interactionDOMElement.style.cursor = n);
              break;
            case "function":
              n(t);
              break;
            case "object":
              i && Object.assign(this.interactionDOMElement.style, n);
              break;
          }
        else
          i && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.interactionDOMElement.style.cursor = t);
      }
    }, e.prototype.dispatchEvent = function(t, i, n) {
      (!n.stopPropagationHint || t === n.stopsPropagatingAt) && (n.currentTarget = t, n.type = i, t.emit(i, n), t[i] && t[i](n));
    }, e.prototype.delayDispatchEvent = function(t, i, n) {
      this.delayedEvents.push({ displayObject: t, eventString: i, eventData: n });
    }, e.prototype.mapPositionToPoint = function(t, i, n) {
      var o;
      this.interactionDOMElement.parentElement ? o = this.interactionDOMElement.getBoundingClientRect() : o = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
      var s = 1 / this.resolution;
      t.x = (i - o.left) * (this.interactionDOMElement.width / o.width) * s, t.y = (n - o.top) * (this.interactionDOMElement.height / o.height) * s;
    }, e.prototype.processInteractive = function(t, i, n, o) {
      var s = this.search.findHit(t, i, n, o), a = this.delayedEvents;
      if (!a.length)
        return s;
      t.stopPropagationHint = !1;
      var h = a.length;
      this.delayedEvents = [];
      for (var u = 0; u < h; u++) {
        var l = a[u], c = l.displayObject, p = l.eventString, d = l.eventData;
        d.stopsPropagatingAt === c && (d.stopPropagationHint = !0), this.dispatchEvent(c, p, d);
      }
      return s;
    }, e.prototype.onPointerDown = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var i = this.normalizeToPointerData(t);
        if (this.autoPreventDefault && i[0].isNormalized) {
          var n = t.cancelable || !("cancelable" in t);
          n && t.preventDefault();
        }
        for (var o = i.length, s = 0; s < o; s++) {
          var a = i[s], h = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, h);
          if (u.data.originalEvent = t, this.processInteractive(u, this.lastObjectRendered, this.processPointerDown, !0), this.emit("pointerdown", u), a.pointerType === "touch")
            this.emit("touchstart", u);
          else if (a.pointerType === "mouse" || a.pointerType === "pen") {
            var l = a.button === 2;
            this.emit(l ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, e.prototype.processPointerDown = function(t, i, n) {
      var o = t.data, s = t.data.identifier;
      if (n) {
        if (i.trackedPointers[s] || (i.trackedPointers[s] = new no(s)), this.dispatchEvent(i, "pointerdown", t), o.pointerType === "touch")
          this.dispatchEvent(i, "touchstart", t);
        else if (o.pointerType === "mouse" || o.pointerType === "pen") {
          var a = o.button === 2;
          a ? i.trackedPointers[s].rightDown = !0 : i.trackedPointers[s].leftDown = !0, this.dispatchEvent(i, a ? "rightdown" : "mousedown", t);
        }
      }
    }, e.prototype.onPointerComplete = function(t, i, n) {
      var o = this.normalizeToPointerData(t), s = o.length, a = t.target;
      t.composedPath && t.composedPath().length > 0 && (a = t.composedPath()[0]);
      for (var h = a !== this.interactionDOMElement ? "outside" : "", u = 0; u < s; u++) {
        var l = o[u], c = this.getInteractionDataForPointerId(l), p = this.configureInteractionEventForDOMEvent(this.eventData, l, c);
        if (p.data.originalEvent = t, this.processInteractive(p, this.lastObjectRendered, n, i || !h), this.emit(i ? "pointercancel" : "pointerup" + h, p), l.pointerType === "mouse" || l.pointerType === "pen") {
          var d = l.button === 2;
          this.emit(d ? "rightup" + h : "mouseup" + h, p);
        } else
          l.pointerType === "touch" && (this.emit(i ? "touchcancel" : "touchend" + h, p), this.releaseInteractionDataForPointerId(l.pointerId));
      }
    }, e.prototype.onPointerCancel = function(t) {
      this.supportsTouchEvents && t.pointerType === "touch" || this.onPointerComplete(t, !0, this.processPointerCancel);
    }, e.prototype.processPointerCancel = function(t, i) {
      var n = t.data, o = t.data.identifier;
      i.trackedPointers[o] !== void 0 && (delete i.trackedPointers[o], this.dispatchEvent(i, "pointercancel", t), n.pointerType === "touch" && this.dispatchEvent(i, "touchcancel", t));
    }, e.prototype.onPointerUp = function(t) {
      this.supportsTouchEvents && t.pointerType === "touch" || this.onPointerComplete(t, !1, this.processPointerUp);
    }, e.prototype.processPointerUp = function(t, i, n) {
      var o = t.data, s = t.data.identifier, a = i.trackedPointers[s], h = o.pointerType === "touch", u = o.pointerType === "mouse" || o.pointerType === "pen", l = !1;
      if (u) {
        var c = o.button === 2, p = no.FLAGS, d = c ? p.RIGHT_DOWN : p.LEFT_DOWN, f = a !== void 0 && a.flags & d;
        n ? (this.dispatchEvent(i, c ? "rightup" : "mouseup", t), f && (this.dispatchEvent(i, c ? "rightclick" : "click", t), l = !0)) : f && this.dispatchEvent(i, c ? "rightupoutside" : "mouseupoutside", t), a && (c ? a.rightDown = !1 : a.leftDown = !1);
      }
      n ? (this.dispatchEvent(i, "pointerup", t), h && this.dispatchEvent(i, "touchend", t), a && ((!u || l) && this.dispatchEvent(i, "pointertap", t), h && (this.dispatchEvent(i, "tap", t), a.over = !1))) : a && (this.dispatchEvent(i, "pointerupoutside", t), h && this.dispatchEvent(i, "touchendoutside", t)), a && a.none && delete i.trackedPointers[s];
    }, e.prototype.onPointerMove = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var i = this.normalizeToPointerData(t);
        (i[0].pointerType === "mouse" || i[0].pointerType === "pen") && (this._didMove = !0, this.cursor = null);
        for (var n = i.length, o = 0; o < n; o++) {
          var s = i[o], a = this.getInteractionDataForPointerId(s), h = this.configureInteractionEventForDOMEvent(this.eventData, s, a);
          h.data.originalEvent = t, this.processInteractive(h, this.lastObjectRendered, this.processPointerMove, !0), this.emit("pointermove", h), s.pointerType === "touch" && this.emit("touchmove", h), (s.pointerType === "mouse" || s.pointerType === "pen") && this.emit("mousemove", h);
        }
        i[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, e.prototype.processPointerMove = function(t, i, n) {
      var o = t.data, s = o.pointerType === "touch", a = o.pointerType === "mouse" || o.pointerType === "pen";
      a && this.processPointerOverOut(t, i, n), (!this.moveWhenInside || n) && (this.dispatchEvent(i, "pointermove", t), s && this.dispatchEvent(i, "touchmove", t), a && this.dispatchEvent(i, "mousemove", t));
    }, e.prototype.onPointerOut = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var i = this.normalizeToPointerData(t), n = i[0];
        n.pointerType === "mouse" && (this.mouseOverRenderer = !1, this.setCursorMode(null));
        var o = this.getInteractionDataForPointerId(n), s = this.configureInteractionEventForDOMEvent(this.eventData, n, o);
        s.data.originalEvent = n, this.processInteractive(s, this.lastObjectRendered, this.processPointerOverOut, !1), this.emit("pointerout", s), n.pointerType === "mouse" || n.pointerType === "pen" ? this.emit("mouseout", s) : this.releaseInteractionDataForPointerId(o.identifier);
      }
    }, e.prototype.processPointerOverOut = function(t, i, n) {
      var o = t.data, s = t.data.identifier, a = o.pointerType === "mouse" || o.pointerType === "pen", h = i.trackedPointers[s];
      n && !h && (h = i.trackedPointers[s] = new no(s)), h !== void 0 && (n && this.mouseOverRenderer ? (h.over || (h.over = !0, this.delayDispatchEvent(i, "pointerover", t), a && this.delayDispatchEvent(i, "mouseover", t)), a && this.cursor === null && (this.cursor = i.cursor)) : h.over && (h.over = !1, this.dispatchEvent(i, "pointerout", this.eventData), a && this.dispatchEvent(i, "mouseout", t), h.none && delete i.trackedPointers[s]));
    }, e.prototype.onPointerOver = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var i = this.normalizeToPointerData(t), n = i[0], o = this.getInteractionDataForPointerId(n), s = this.configureInteractionEventForDOMEvent(this.eventData, n, o);
        s.data.originalEvent = n, n.pointerType === "mouse" && (this.mouseOverRenderer = !0), this.emit("pointerover", s), (n.pointerType === "mouse" || n.pointerType === "pen") && this.emit("mouseover", s);
      }
    }, e.prototype.getInteractionDataForPointerId = function(t) {
      var i = t.pointerId, n;
      return i === Fi || t.pointerType === "mouse" ? n = this.mouse : this.activeInteractionData[i] ? n = this.activeInteractionData[i] : (n = this.interactionDataPool.pop() || new sh(), n.identifier = i, this.activeInteractionData[i] = n), n.copyEvent(t), n;
    }, e.prototype.releaseInteractionDataForPointerId = function(t) {
      var i = this.activeInteractionData[t];
      i && (delete this.activeInteractionData[t], i.reset(), this.interactionDataPool.push(i));
    }, e.prototype.configureInteractionEventForDOMEvent = function(t, i, n) {
      return t.data = n, this.mapPositionToPoint(n.global, i.clientX, i.clientY), i.pointerType === "touch" && (i.globalX = n.global.x, i.globalY = n.global.y), n.originalEvent = i, t.reset(), t;
    }, e.prototype.normalizeToPointerData = function(t) {
      var i = [];
      if (this.supportsTouchEvents && t instanceof TouchEvent)
        for (var n = 0, o = t.changedTouches.length; n < o; n++) {
          var s = t.changedTouches[n];
          typeof s.button > "u" && (s.button = t.touches.length ? 1 : 0), typeof s.buttons > "u" && (s.buttons = t.touches.length ? 1 : 0), typeof s.isPrimary > "u" && (s.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof s.width > "u" && (s.width = s.radiusX || 1), typeof s.height > "u" && (s.height = s.radiusY || 1), typeof s.tiltX > "u" && (s.tiltX = 0), typeof s.tiltY > "u" && (s.tiltY = 0), typeof s.pointerType > "u" && (s.pointerType = "touch"), typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0), typeof s.pressure > "u" && (s.pressure = s.force || 0.5), typeof s.twist > "u" && (s.twist = 0), typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0), typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX), typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY), s.isNormalized = !0, i.push(s);
        }
      else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
        var a = t;
        typeof a.isPrimary > "u" && (a.isPrimary = !0), typeof a.width > "u" && (a.width = 1), typeof a.height > "u" && (a.height = 1), typeof a.tiltX > "u" && (a.tiltX = 0), typeof a.tiltY > "u" && (a.tiltY = 0), typeof a.pointerType > "u" && (a.pointerType = "mouse"), typeof a.pointerId > "u" && (a.pointerId = Fi), typeof a.pressure > "u" && (a.pressure = 0.5), typeof a.twist > "u" && (a.twist = 0), typeof a.tangentialPressure > "u" && (a.tangentialPressure = 0), a.isNormalized = !0, i.push(a);
      } else
        i.push(t);
      return i;
    }, e.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, e.extension = {
      name: "interaction",
      type: [
        dt.RendererPlugin,
        dt.CanvasRendererPlugin
      ]
    }, e;
  }(hi)
);
/*!
 * @pixi/extract - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extract is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var dv = new it(), fv = 4, yv = (
  /** @class */
  function() {
    function r(e) {
      this.renderer = e;
    }
    return r.prototype.image = function(e, t, i) {
      var n = new Image();
      return n.src = this.base64(e, t, i), n;
    }, r.prototype.base64 = function(e, t, i) {
      return this.canvas(e).toDataURL(t, i);
    }, r.prototype.canvas = function(e, t) {
      var i = this._rawPixels(e, t), n = i.pixels, o = i.width, s = i.height, a = i.flipY, h = new Ha(o, s, 1), u = h.context.getImageData(0, 0, o, s);
      if (r.arrayPostDivide(n, u.data), h.context.putImageData(u, 0, 0), a) {
        var l = new Ha(h.width, h.height, 1);
        l.context.scale(1, -1), l.context.drawImage(h.canvas, 0, -s), h.destroy(), h = l;
      }
      return h.canvas;
    }, r.prototype.pixels = function(e, t) {
      var i = this._rawPixels(e, t).pixels;
      return r.arrayPostDivide(i, i), i;
    }, r.prototype._rawPixels = function(e, t) {
      var i = this.renderer, n, o = !1, s, a = !1;
      if (e)
        if (e instanceof er)
          s = e;
        else {
          var h = i.context.webGLVersion >= 2 ? i.multisample : gt.NONE;
          if (s = this.renderer.generateTexture(e, { multisample: h }), h !== gt.NONE) {
            var u = er.create({
              width: s.width,
              height: s.height
            });
            i.framebuffer.bind(s.framebuffer), i.framebuffer.blit(u.framebuffer), i.framebuffer.bind(null), s.destroy(!0), s = u;
          }
          a = !0;
        }
      s ? (n = s.baseTexture.resolution, t = t ?? s.frame, o = !1, i.renderTexture.bind(s)) : (n = i.resolution, t || (t = dv, t.width = i.width, t.height = i.height), o = !0, i.renderTexture.bind(null));
      var l = Math.round(t.width * n), c = Math.round(t.height * n), p = new Uint8Array(fv * l * c), d = i.gl;
      return d.readPixels(Math.round(t.x * n), Math.round(t.y * n), l, c, d.RGBA, d.UNSIGNED_BYTE, p), a && s.destroy(!0), { pixels: p, width: l, height: c, flipY: o };
    }, r.prototype.destroy = function() {
      this.renderer = null;
    }, r.arrayPostDivide = function(e, t) {
      for (var i = 0; i < e.length; i += 4) {
        var n = t[i + 3] = e[i + 3];
        n !== 0 ? (t[i] = Math.round(Math.min(e[i] * 255 / n, 255)), t[i + 1] = Math.round(Math.min(e[i + 1] * 255 / n, 255)), t[i + 2] = Math.round(Math.min(e[i + 2] * 255 / n, 255))) : (t[i] = e[i], t[i + 1] = e[i + 1], t[i + 2] = e[i + 2]);
      }
    }, r.extension = {
      name: "extract",
      type: dt.RendererPlugin
    }, r;
  }()
);
/*!
 * @pixi/loaders - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/loaders is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Li = (
  /** @class */
  function() {
    function r(e, t, i) {
      t === void 0 && (t = !1), this._fn = e, this._once = t, this._thisArg = i, this._next = this._prev = this._owner = null;
    }
    return r.prototype.detach = function() {
      return this._owner === null ? !1 : (this._owner.detach(this), !0);
    }, r;
  }()
);
function ah(r, e) {
  return r._head ? (r._tail._next = e, e._prev = r._tail, r._tail = e) : (r._head = e, r._tail = e), e._owner = r, e;
}
var ge = (
  /** @class */
  function() {
    function r() {
      this._head = this._tail = void 0;
    }
    return r.prototype.handlers = function(e) {
      e === void 0 && (e = !1);
      var t = this._head;
      if (e)
        return !!t;
      for (var i = []; t; )
        i.push(t), t = t._next;
      return i;
    }, r.prototype.has = function(e) {
      if (!(e instanceof Li))
        throw new Error("MiniSignal#has(): First arg must be a SignalBinding object.");
      return e._owner === this;
    }, r.prototype.dispatch = function() {
      for (var e = arguments, t = [], i = 0; i < arguments.length; i++)
        t[i] = e[i];
      var n = this._head;
      if (!n)
        return !1;
      for (; n; )
        n._once && this.detach(n), n._fn.apply(n._thisArg, t), n = n._next;
      return !0;
    }, r.prototype.add = function(e, t) {
      if (t === void 0 && (t = null), typeof e != "function")
        throw new Error("MiniSignal#add(): First arg must be a Function.");
      return ah(this, new Li(e, !1, t));
    }, r.prototype.once = function(e, t) {
      if (t === void 0 && (t = null), typeof e != "function")
        throw new Error("MiniSignal#once(): First arg must be a Function.");
      return ah(this, new Li(e, !0, t));
    }, r.prototype.detach = function(e) {
      if (!(e instanceof Li))
        throw new Error("MiniSignal#detach(): First arg must be a SignalBinding object.");
      return e._owner !== this ? this : (e._prev && (e._prev._next = e._next), e._next && (e._next._prev = e._prev), e === this._head ? (this._head = e._next, e._next === null && (this._tail = null)) : e === this._tail && (this._tail = e._prev, this._tail._next = null), e._owner = null, this);
    }, r.prototype.detachAll = function() {
      var e = this._head;
      if (!e)
        return this;
      for (this._head = this._tail = null; e; )
        e._owner = null, e = e._next;
      return this;
    }, r;
  }()
);
function zu(r, e) {
  e = e || {};
  for (var t = {
    // eslint-disable-next-line max-len
    key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
    q: {
      name: "queryKey",
      parser: /(?:^|&)([^&=]*)=?([^&]*)/g
    },
    parser: {
      // eslint-disable-next-line max-len
      strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
      // eslint-disable-next-line max-len
      loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
    }
  }, i = t.parser[e.strictMode ? "strict" : "loose"].exec(r), n = {}, o = 14; o--; )
    n[t.key[o]] = i[o] || "";
  return n[t.q.name] = {}, n[t.key[12]].replace(t.q.parser, function(s, a, h) {
    a && (n[t.q.name][a] = h);
  }), n;
}
var oo, Bi = null, mv = 0, hh = 200, _v = 204, gv = 1223, vv = 2;
function uh() {
}
function lh(r, e, t) {
  e && e.indexOf(".") === 0 && (e = e.substring(1)), e && (r[e] = t);
}
function so(r) {
  return r.toString().replace("object ", "");
}
var Et = (
  /** @class */
  function() {
    function r(e, t, i) {
      if (this._dequeue = uh, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = null, this._boundOnError = null, this._boundOnProgress = null, this._boundOnTimeout = null, this._boundXhrOnError = null, this._boundXhrOnTimeout = null, this._boundXhrOnAbort = null, this._boundXhrOnLoad = null, typeof e != "string" || typeof t != "string")
        throw new Error("Both name and url are required for constructing a resource.");
      i = i || {}, this._flags = 0, this._setFlag(r.STATUS_FLAGS.DATA_URL, t.indexOf("data:") === 0), this.name = e, this.url = t, this.extension = this._getExtension(), this.data = null, this.crossOrigin = i.crossOrigin === !0 ? "anonymous" : i.crossOrigin, this.timeout = i.timeout || 0, this.loadType = i.loadType || this._determineLoadType(), this.xhrType = i.xhrType, this.metadata = i.metadata || {}, this.error = null, this.xhr = null, this.children = [], this.type = r.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = uh, this._onLoadBinding = null, this._elementTimer = 0, this._boundComplete = this.complete.bind(this), this._boundOnError = this._onError.bind(this), this._boundOnProgress = this._onProgress.bind(this), this._boundOnTimeout = this._onTimeout.bind(this), this._boundXhrOnError = this._xhrOnError.bind(this), this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this), this._boundXhrOnAbort = this._xhrOnAbort.bind(this), this._boundXhrOnLoad = this._xhrOnLoad.bind(this), this.onStart = new ge(), this.onProgress = new ge(), this.onComplete = new ge(), this.onAfterMiddleware = new ge();
    }
    return r.setExtensionLoadType = function(e, t) {
      lh(r._loadTypeMap, e, t);
    }, r.setExtensionXhrType = function(e, t) {
      lh(r._xhrTypeMap, e, t);
    }, Object.defineProperty(r.prototype, "isDataUrl", {
      /**
       * When the resource starts to load.
       * @memberof PIXI.LoaderResource
       * @callback OnStartSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * When the resource reports loading progress.
       * @memberof PIXI.LoaderResource
       * @callback OnProgressSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       * @param {number} percentage - The progress of the load in the range [0, 1].
       */
      /**
       * When the resource finishes loading.
       * @memberof PIXI.LoaderResource
       * @callback OnCompleteSignal
       * @param {PIXI.Resource} resource - The resource that the event happened on.
       */
      /**
       * @memberof PIXI.LoaderResource
       * @typedef {object} IMetadata
       * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The
       *      element to use for loading, instead of creating one.
       * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This
       *      is useful if you want to pass in a `loadElement` that you already added load sources to.
       * @property {string|string[]} [mimeType] - The mime type to use for the source element
       *      of a video/audio elment. If the urls are an array, you can pass this as an array as well
       *      where each index is the mime type to use for the corresponding url index.
       */
      /**
       * Stores whether or not this url is a data url.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.DATA_URL);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isComplete", {
      /**
       * Describes if this resource has finished loading. Is true when the resource has completely
       * loaded.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.COMPLETE);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "isLoading", {
      /**
       * Describes if this resource is currently loading. Is true when the resource starts loading,
       * and is false again when complete.
       * @readonly
       * @member {boolean}
       */
      get: function() {
        return this._hasFlag(r.STATUS_FLAGS.LOADING);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.complete = function() {
      this._clearEvents(), this._finish();
    }, r.prototype.abort = function(e) {
      if (!this.error) {
        if (this.error = new Error(e), this._clearEvents(), this.xhr)
          this.xhr.abort();
        else if (this.xdr)
          this.xdr.abort();
        else if (this.data)
          if (this.data.src)
            this.data.src = r.EMPTY_GIF;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }, r.prototype.load = function(e) {
      var t = this;
      if (!this.isLoading) {
        if (this.isComplete) {
          e && setTimeout(function() {
            return e(t);
          }, 1);
          return;
        } else
          e && this.onComplete.once(e);
        switch (this._setFlag(r.STATUS_FLAGS.LOADING, !0), this.onStart.dispatch(this), (this.crossOrigin === !1 || typeof this.crossOrigin != "string") && (this.crossOrigin = this._determineCrossOrigin(this.url)), this.loadType) {
          case r.LOAD_TYPE.IMAGE:
            this.type = r.TYPE.IMAGE, this._loadElement("image");
            break;
          case r.LOAD_TYPE.AUDIO:
            this.type = r.TYPE.AUDIO, this._loadSourceElement("audio");
            break;
          case r.LOAD_TYPE.VIDEO:
            this.type = r.TYPE.VIDEO, this._loadSourceElement("video");
            break;
          case r.LOAD_TYPE.XHR:
          default:
            typeof oo > "u" && (oo = !!(globalThis.XDomainRequest && !("withCredentials" in new XMLHttpRequest()))), oo && this.crossOrigin ? this._loadXdr() : this._loadXhr();
            break;
        }
      }
    }, r.prototype._hasFlag = function(e) {
      return (this._flags & e) !== 0;
    }, r.prototype._setFlag = function(e, t) {
      this._flags = t ? this._flags | e : this._flags & ~e;
    }, r.prototype._clearEvents = function() {
      clearTimeout(this._elementTimer), this.data && this.data.removeEventListener && (this.data.removeEventListener("error", this._boundOnError, !1), this.data.removeEventListener("load", this._boundComplete, !1), this.data.removeEventListener("progress", this._boundOnProgress, !1), this.data.removeEventListener("canplaythrough", this._boundComplete, !1)), this.xhr && (this.xhr.removeEventListener ? (this.xhr.removeEventListener("error", this._boundXhrOnError, !1), this.xhr.removeEventListener("timeout", this._boundXhrOnTimeout, !1), this.xhr.removeEventListener("abort", this._boundXhrOnAbort, !1), this.xhr.removeEventListener("progress", this._boundOnProgress, !1), this.xhr.removeEventListener("load", this._boundXhrOnLoad, !1)) : (this.xhr.onerror = null, this.xhr.ontimeout = null, this.xhr.onprogress = null, this.xhr.onload = null));
    }, r.prototype._finish = function() {
      if (this.isComplete)
        throw new Error("Complete called again for an already completed resource.");
      this._setFlag(r.STATUS_FLAGS.COMPLETE, !0), this._setFlag(r.STATUS_FLAGS.LOADING, !1), this.onComplete.dispatch(this);
    }, r.prototype._loadElement = function(e) {
      this.metadata.loadElement ? this.data = this.metadata.loadElement : e === "image" && typeof globalThis.Image < "u" ? this.data = new Image() : this.data = document.createElement(e), this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.metadata.skipSource || (this.data.src = this.url), this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, r.prototype._loadSourceElement = function(e) {
      if (this.metadata.loadElement ? this.data = this.metadata.loadElement : e === "audio" && typeof globalThis.Audio < "u" ? this.data = new Audio() : this.data = document.createElement(e), this.data === null) {
        this.abort("Unsupported element: " + e);
        return;
      }
      if (this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), !this.metadata.skipSource)
        if (navigator.isCocoonJS)
          this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;
        else if (Array.isArray(this.url))
          for (var t = this.metadata.mimeType, i = 0; i < this.url.length; ++i)
            this.data.appendChild(this._createSource(e, this.url[i], Array.isArray(t) ? t[i] : t));
        else {
          var t = this.metadata.mimeType;
          this.data.appendChild(this._createSource(e, this.url, Array.isArray(t) ? t[0] : t));
        }
      this.data.addEventListener("error", this._boundOnError, !1), this.data.addEventListener("load", this._boundComplete, !1), this.data.addEventListener("progress", this._boundOnProgress, !1), this.data.addEventListener("canplaythrough", this._boundComplete, !1), this.data.load(), this.timeout && (this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout));
    }, r.prototype._loadXhr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var e = this.xhr = new XMLHttpRequest();
      this.crossOrigin === "use-credentials" && (e.withCredentials = !0), e.open("GET", this.url, !0), e.timeout = this.timeout, this.xhrType === r.XHR_RESPONSE_TYPE.JSON || this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT ? e.responseType = r.XHR_RESPONSE_TYPE.TEXT : e.responseType = this.xhrType, e.addEventListener("error", this._boundXhrOnError, !1), e.addEventListener("timeout", this._boundXhrOnTimeout, !1), e.addEventListener("abort", this._boundXhrOnAbort, !1), e.addEventListener("progress", this._boundOnProgress, !1), e.addEventListener("load", this._boundXhrOnLoad, !1), e.send();
    }, r.prototype._loadXdr = function() {
      typeof this.xhrType != "string" && (this.xhrType = this._determineXhrType());
      var e = this.xhr = new globalThis.XDomainRequest();
      e.timeout = this.timeout || 5e3, e.onerror = this._boundXhrOnError, e.ontimeout = this._boundXhrOnTimeout, e.onprogress = this._boundOnProgress, e.onload = this._boundXhrOnLoad, e.open("GET", this.url, !0), setTimeout(function() {
        return e.send();
      }, 1);
    }, r.prototype._createSource = function(e, t, i) {
      i || (i = e + "/" + this._getExtension(t));
      var n = document.createElement("source");
      return n.src = t, n.type = i, n;
    }, r.prototype._onError = function(e) {
      this.abort("Failed to load element using: " + e.target.nodeName);
    }, r.prototype._onProgress = function(e) {
      e && e.lengthComputable && this.onProgress.dispatch(this, e.loaded / e.total);
    }, r.prototype._onTimeout = function() {
      this.abort("Load timed out.");
    }, r.prototype._xhrOnError = function() {
      var e = this.xhr;
      this.abort(so(e) + " Request failed. Status: " + e.status + ', text: "' + e.statusText + '"');
    }, r.prototype._xhrOnTimeout = function() {
      var e = this.xhr;
      this.abort(so(e) + " Request timed out.");
    }, r.prototype._xhrOnAbort = function() {
      var e = this.xhr;
      this.abort(so(e) + " Request was aborted by the user.");
    }, r.prototype._xhrOnLoad = function() {
      var e = this.xhr, t = "", i = typeof e.status > "u" ? hh : e.status;
      (e.responseType === "" || e.responseType === "text" || typeof e.responseType > "u") && (t = e.responseText), i === mv && (t.length > 0 || e.responseType === r.XHR_RESPONSE_TYPE.BUFFER) ? i = hh : i === gv && (i = _v);
      var n = i / 100 | 0;
      if (n === vv)
        if (this.xhrType === r.XHR_RESPONSE_TYPE.TEXT)
          this.data = t, this.type = r.TYPE.TEXT;
        else if (this.xhrType === r.XHR_RESPONSE_TYPE.JSON)
          try {
            this.data = JSON.parse(t), this.type = r.TYPE.JSON;
          } catch (a) {
            this.abort("Error trying to parse loaded json: " + a);
            return;
          }
        else if (this.xhrType === r.XHR_RESPONSE_TYPE.DOCUMENT)
          try {
            if (globalThis.DOMParser) {
              var o = new DOMParser();
              this.data = o.parseFromString(t, "text/xml");
            } else {
              var s = document.createElement("div");
              s.innerHTML = t, this.data = s;
            }
            this.type = r.TYPE.XML;
          } catch (a) {
            this.abort("Error trying to parse loaded xml: " + a);
            return;
          }
        else
          this.data = e.response || t;
      else {
        this.abort("[" + e.status + "] " + e.statusText + ": " + e.responseURL);
        return;
      }
      this.complete();
    }, r.prototype._determineCrossOrigin = function(e, t) {
      if (e.indexOf("data:") === 0)
        return "";
      if (globalThis.origin !== globalThis.location.origin)
        return "anonymous";
      t = t || globalThis.location, Bi || (Bi = document.createElement("a")), Bi.href = e;
      var i = zu(Bi.href, { strictMode: !0 }), n = !i.port && t.port === "" || i.port === t.port, o = i.protocol ? i.protocol + ":" : "";
      return i.host !== t.hostname || !n || o !== t.protocol ? "anonymous" : "";
    }, r.prototype._determineXhrType = function() {
      return r._xhrTypeMap[this.extension] || r.XHR_RESPONSE_TYPE.TEXT;
    }, r.prototype._determineLoadType = function() {
      return r._loadTypeMap[this.extension] || r.LOAD_TYPE.XHR;
    }, r.prototype._getExtension = function(e) {
      e === void 0 && (e = this.url);
      var t = "";
      if (this.isDataUrl) {
        var i = e.indexOf("/");
        t = e.substring(i + 1, e.indexOf(";", i));
      } else {
        var n = e.indexOf("?"), o = e.indexOf("#"), s = Math.min(n > -1 ? n : e.length, o > -1 ? o : e.length);
        e = e.substring(0, s), t = e.substring(e.lastIndexOf(".") + 1);
      }
      return t.toLowerCase();
    }, r.prototype._getMimeFromXhrType = function(e) {
      switch (e) {
        case r.XHR_RESPONSE_TYPE.BUFFER:
          return "application/octet-binary";
        case r.XHR_RESPONSE_TYPE.BLOB:
          return "application/blob";
        case r.XHR_RESPONSE_TYPE.DOCUMENT:
          return "application/xml";
        case r.XHR_RESPONSE_TYPE.JSON:
          return "application/json";
        case r.XHR_RESPONSE_TYPE.DEFAULT:
        case r.XHR_RESPONSE_TYPE.TEXT:
        default:
          return "text/plain";
      }
    }, r;
  }()
);
(function(r) {
  (function(e) {
    e[e.NONE = 0] = "NONE", e[e.DATA_URL = 1] = "DATA_URL", e[e.COMPLETE = 2] = "COMPLETE", e[e.LOADING = 4] = "LOADING";
  })(r.STATUS_FLAGS || (r.STATUS_FLAGS = {})), function(e) {
    e[e.UNKNOWN = 0] = "UNKNOWN", e[e.JSON = 1] = "JSON", e[e.XML = 2] = "XML", e[e.IMAGE = 3] = "IMAGE", e[e.AUDIO = 4] = "AUDIO", e[e.VIDEO = 5] = "VIDEO", e[e.TEXT = 6] = "TEXT";
  }(r.TYPE || (r.TYPE = {})), function(e) {
    e[e.XHR = 1] = "XHR", e[e.IMAGE = 2] = "IMAGE", e[e.AUDIO = 3] = "AUDIO", e[e.VIDEO = 4] = "VIDEO";
  }(r.LOAD_TYPE || (r.LOAD_TYPE = {})), function(e) {
    e.DEFAULT = "text", e.BUFFER = "arraybuffer", e.BLOB = "blob", e.DOCUMENT = "document", e.JSON = "json", e.TEXT = "text";
  }(r.XHR_RESPONSE_TYPE || (r.XHR_RESPONSE_TYPE = {})), r._loadTypeMap = {
    // images
    gif: r.LOAD_TYPE.IMAGE,
    png: r.LOAD_TYPE.IMAGE,
    bmp: r.LOAD_TYPE.IMAGE,
    jpg: r.LOAD_TYPE.IMAGE,
    jpeg: r.LOAD_TYPE.IMAGE,
    tif: r.LOAD_TYPE.IMAGE,
    tiff: r.LOAD_TYPE.IMAGE,
    webp: r.LOAD_TYPE.IMAGE,
    tga: r.LOAD_TYPE.IMAGE,
    avif: r.LOAD_TYPE.IMAGE,
    svg: r.LOAD_TYPE.IMAGE,
    "svg+xml": r.LOAD_TYPE.IMAGE,
    // audio
    mp3: r.LOAD_TYPE.AUDIO,
    ogg: r.LOAD_TYPE.AUDIO,
    wav: r.LOAD_TYPE.AUDIO,
    // videos
    mp4: r.LOAD_TYPE.VIDEO,
    webm: r.LOAD_TYPE.VIDEO
  }, r._xhrTypeMap = {
    // xml
    xhtml: r.XHR_RESPONSE_TYPE.DOCUMENT,
    html: r.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: r.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: r.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: r.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: r.XHR_RESPONSE_TYPE.DOCUMENT,
    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.
    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,
    // this should probably be fine.
    tsx: r.XHR_RESPONSE_TYPE.DOCUMENT,
    // images
    gif: r.XHR_RESPONSE_TYPE.BLOB,
    png: r.XHR_RESPONSE_TYPE.BLOB,
    bmp: r.XHR_RESPONSE_TYPE.BLOB,
    jpg: r.XHR_RESPONSE_TYPE.BLOB,
    jpeg: r.XHR_RESPONSE_TYPE.BLOB,
    tif: r.XHR_RESPONSE_TYPE.BLOB,
    tiff: r.XHR_RESPONSE_TYPE.BLOB,
    webp: r.XHR_RESPONSE_TYPE.BLOB,
    tga: r.XHR_RESPONSE_TYPE.BLOB,
    avif: r.XHR_RESPONSE_TYPE.BLOB,
    // json
    json: r.XHR_RESPONSE_TYPE.JSON,
    // text
    text: r.XHR_RESPONSE_TYPE.TEXT,
    txt: r.XHR_RESPONSE_TYPE.TEXT,
    // fonts
    ttf: r.XHR_RESPONSE_TYPE.BUFFER,
    otf: r.XHR_RESPONSE_TYPE.BUFFER
  }, r.EMPTY_GIF = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
})(Et || (Et = {}));
function Ge() {
}
function bv(r) {
  return function() {
    for (var e = arguments, t = [], i = 0; i < arguments.length; i++)
      t[i] = e[i];
    if (r === null)
      throw new Error("Callback was already called.");
    var n = r;
    r = null, n.apply(this, t);
  };
}
var xv = (
  /** @class */
  function() {
    function r(e, t) {
      this.data = e, this.callback = t;
    }
    return r;
  }()
), ao = (
  /** @class */
  function() {
    function r(e, t) {
      var i = this;
      if (t === void 0 && (t = 1), this.workers = 0, this.saturated = Ge, this.unsaturated = Ge, this.empty = Ge, this.drain = Ge, this.error = Ge, this.started = !1, this.paused = !1, this._tasks = [], this._insert = function(n, o, s) {
        if (s && typeof s != "function")
          throw new Error("task callback must be a function");
        if (i.started = !0, n == null && i.idle()) {
          setTimeout(function() {
            return i.drain();
          }, 1);
          return;
        }
        var a = new xv(n, typeof s == "function" ? s : Ge);
        o ? i._tasks.unshift(a) : i._tasks.push(a), setTimeout(i.process, 1);
      }, this.process = function() {
        for (; !i.paused && i.workers < i.concurrency && i._tasks.length; ) {
          var n = i._tasks.shift();
          i._tasks.length === 0 && i.empty(), i.workers += 1, i.workers === i.concurrency && i.saturated(), i._worker(n.data, bv(i._next(n)));
        }
      }, this._worker = e, t === 0)
        throw new Error("Concurrency must not be zero");
      this.concurrency = t, this.buffer = t / 4;
    }
    return r.prototype._next = function(e) {
      var t = this;
      return function() {
        for (var i = arguments, n = [], o = 0; o < arguments.length; o++)
          n[o] = i[o];
        t.workers -= 1, e.callback.apply(e, n), n[0] != null && t.error(n[0], e.data), t.workers <= t.concurrency - t.buffer && t.unsaturated(), t.idle() && t.drain(), t.process();
      };
    }, r.prototype.push = function(e, t) {
      this._insert(e, !1, t);
    }, r.prototype.kill = function() {
      this.workers = 0, this.drain = Ge, this.started = !1, this._tasks = [];
    }, r.prototype.unshift = function(e, t) {
      this._insert(e, !0, t);
    }, r.prototype.length = function() {
      return this._tasks.length;
    }, r.prototype.running = function() {
      return this.workers;
    }, r.prototype.idle = function() {
      return this._tasks.length + this.workers === 0;
    }, r.prototype.pause = function() {
      this.paused !== !0 && (this.paused = !0);
    }, r.prototype.resume = function() {
      if (this.paused !== !1) {
        this.paused = !1;
        for (var e = 1; e <= this.concurrency; e++)
          this.process();
      }
    }, r.eachSeries = function(e, t, i, n) {
      var o = 0, s = e.length;
      function a(h) {
        if (h || o === s) {
          i && i(h);
          return;
        }
        n ? setTimeout(function() {
          t(e[o++], a);
        }, 1) : t(e[o++], a);
      }
      a();
    }, r.queue = function(e, t) {
      return new r(e, t);
    }, r;
  }()
), ho = 100, Tv = /(#[\w-]+)?$/, cn = (
  /** @class */
  function() {
    function r(e, t) {
      var i = this;
      e === void 0 && (e = ""), t === void 0 && (t = 10), this.progress = 0, this.loading = !1, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(h, u) {
        return i._loadResource(h, u);
      }, this.resources = {}, this.baseUrl = e, this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = function(h, u) {
        return i._loadResource(h, u);
      }, this._queue = ao.queue(this._boundLoadResource, t), this._queue.pause(), this.resources = {}, this.onProgress = new ge(), this.onError = new ge(), this.onLoad = new ge(), this.onStart = new ge(), this.onComplete = new ge();
      for (var n = 0; n < r._plugins.length; ++n) {
        var o = r._plugins[n], s = o.pre, a = o.use;
        s && this.pre(s), a && this.use(a);
      }
      this._protected = !1;
    }
    return r.prototype._add = function(e, t, i, n) {
      if (this.loading && (!i || !i.parentResource))
        throw new Error("Cannot add resources while the loader is running.");
      if (this.resources[e])
        throw new Error('Resource named "' + e + '" already exists.');
      if (t = this._prepareUrl(t), this.resources[e] = new Et(e, t, i), typeof n == "function" && this.resources[e].onAfterMiddleware.once(n), this.loading) {
        for (var o = i.parentResource, s = [], a = 0; a < o.children.length; ++a)
          o.children[a].isComplete || s.push(o.children[a]);
        var h = o.progressChunk * (s.length + 1), u = h / (s.length + 2);
        o.children.push(this.resources[e]), o.progressChunk = u;
        for (var a = 0; a < s.length; ++a)
          s[a].progressChunk = u;
        this.resources[e].progressChunk = u;
      }
      return this._queue.push(this.resources[e]), this;
    }, r.prototype.pre = function(e) {
      return this._beforeMiddleware.push(e), this;
    }, r.prototype.use = function(e) {
      return this._afterMiddleware.push(e), this;
    }, r.prototype.reset = function() {
      this.progress = 0, this.loading = !1, this._queue.kill(), this._queue.pause();
      for (var e in this.resources) {
        var t = this.resources[e];
        t._onLoadBinding && t._onLoadBinding.detach(), t.isLoading && t.abort("loader reset");
      }
      return this.resources = {}, this;
    }, r.prototype.load = function(e) {
      if (re("6.5.0", "@pixi/loaders is being replaced with @pixi/assets in the next major release."), typeof e == "function" && this.onComplete.once(e), this.loading)
        return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var t = this._queue._tasks.length, i = ho / t, n = 0; n < this._queue._tasks.length; ++n)
          this._queue._tasks[n].data.progressChunk = i;
        this._onStart(), this._queue.resume();
      }
      return this;
    }, Object.defineProperty(r.prototype, "concurrency", {
      /**
       * The number of resources to load concurrently.
       * @default 10
       */
      get: function() {
        return this._queue.concurrency;
      },
      set: function(e) {
        this._queue.concurrency = e;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype._prepareUrl = function(e) {
      var t = zu(e, { strictMode: !0 }), i;
      if (t.protocol || !t.path || e.indexOf("//") === 0 ? i = e : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && e.charAt(0) !== "/" ? i = this.baseUrl + "/" + e : i = this.baseUrl + e, this.defaultQueryString) {
        var n = Tv.exec(i)[0];
        i = i.slice(0, i.length - n.length), i.indexOf("?") !== -1 ? i += "&" + this.defaultQueryString : i += "?" + this.defaultQueryString, i += n;
      }
      return i;
    }, r.prototype._loadResource = function(e, t) {
      var i = this;
      e._dequeue = t, ao.eachSeries(this._beforeMiddleware, function(n, o) {
        n.call(i, e, function() {
          o(e.isComplete ? {} : null);
        });
      }, function() {
        e.isComplete ? i._onLoad(e) : (e._onLoadBinding = e.onComplete.once(i._onLoad, i), e.load());
      }, !0);
    }, r.prototype._onStart = function() {
      this.progress = 0, this.loading = !0, this.onStart.dispatch(this);
    }, r.prototype._onComplete = function() {
      this.progress = ho, this.loading = !1, this.onComplete.dispatch(this, this.resources);
    }, r.prototype._onLoad = function(e) {
      var t = this;
      e._onLoadBinding = null, this._resourcesParsing.push(e), e._dequeue(), ao.eachSeries(this._afterMiddleware, function(i, n) {
        i.call(t, e, n);
      }, function() {
        e.onAfterMiddleware.dispatch(e), t.progress = Math.min(ho, t.progress + e.progressChunk), t.onProgress.dispatch(t, e), e.error ? t.onError.dispatch(e.error, t, e) : t.onLoad.dispatch(t, e), t._resourcesParsing.splice(t._resourcesParsing.indexOf(e), 1), t._queue.idle() && t._resourcesParsing.length === 0 && t._onComplete();
      }, !0);
    }, r.prototype.destroy = function() {
      this._protected || this.reset();
    }, Object.defineProperty(r, "shared", {
      /** A premade instance of the loader that can be used to load resources. */
      get: function() {
        var e = r._shared;
        return e || (e = new r(), e._protected = !0, r._shared = e), e;
      },
      enumerable: !1,
      configurable: !0
    }), r.registerPlugin = function(e) {
      return re("6.5.0", "Loader.registerPlugin() is deprecated, use extensions.add() instead."), Te.add({
        type: dt.Loader,
        ref: e
      }), r;
    }, r._plugins = [], r;
  }()
);
Te.handleByList(dt.Loader, cn._plugins);
cn.prototype.add = function(r, e, t, i) {
  if (Array.isArray(r)) {
    for (var n = 0; n < r.length; ++n)
      this.add(r[n]);
    return this;
  }
  if (typeof r == "object" && (t = r, i = e || t.callback || t.onComplete, e = t.url, r = t.name || t.key || t.url), typeof e != "string" && (i = t, t = e, e = r), typeof e != "string")
    throw new Error("No url passed to add resource to loader.");
  return typeof t == "function" && (i = t, t = null), this._add(r, e, t, i);
};
var Ev = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(e) {
      e = Object.assign({
        sharedLoader: !1
      }, e), this.loader = e.sharedLoader ? cn.shared : new cn();
    }, r.destroy = function() {
      this.loader && (this.loader.destroy(), this.loader = null);
    }, r.extension = dt.Application, r;
  }()
), Av = (
  /** @class */
  function() {
    function r() {
    }
    return r.add = function() {
      Et.setExtensionLoadType("svg", Et.LOAD_TYPE.XHR), Et.setExtensionXhrType("svg", Et.XHR_RESPONSE_TYPE.TEXT);
    }, r.use = function(e, t) {
      if (e.data && (e.type === Et.TYPE.IMAGE || e.extension === "svg")) {
        var i = e.data, n = e.url, o = e.name, s = e.metadata;
        W.fromLoader(i, n, o, s).then(function(a) {
          e.texture = a, t();
        }).catch(t);
      } else
        t();
    }, r.extension = dt.Loader, r;
  }()
), Sv = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Rv(r) {
  for (var e = "", t = 0; t < r.length; ) {
    for (var i = [0, 0, 0], n = [0, 0, 0, 0], o = 0; o < i.length; ++o)
      t < r.length ? i[o] = r.charCodeAt(t++) & 255 : i[o] = 0;
    n[0] = i[0] >> 2, n[1] = (i[0] & 3) << 4 | i[1] >> 4, n[2] = (i[1] & 15) << 2 | i[2] >> 6, n[3] = i[2] & 63;
    var s = t - (r.length - 1);
    switch (s) {
      case 2:
        n[3] = 64, n[2] = 64;
        break;
      case 1:
        n[3] = 64;
        break;
    }
    for (var o = 0; o < n.length; ++o)
      e += Sv.charAt(n[o]);
  }
  return e;
}
function Ov(r, e) {
  if (!r.data) {
    e();
    return;
  }
  if (r.xhr && r.xhrType === Et.XHR_RESPONSE_TYPE.BLOB) {
    if (!self.Blob || typeof r.data == "string") {
      var t = r.xhr.getResponseHeader("content-type");
      if (t && t.indexOf("image") === 0) {
        r.data = new Image(), r.data.src = "data:" + t + ";base64," + Rv(r.xhr.responseText), r.type = Et.TYPE.IMAGE, r.data.onload = function() {
          r.data.onload = null, e();
        };
        return;
      }
    } else if (r.data.type.indexOf("image") === 0) {
      var i = globalThis.URL || globalThis.webkitURL, n = i.createObjectURL(r.data);
      r.blob = r.data, r.data = new Image(), r.data.src = n, r.type = Et.TYPE.IMAGE, r.data.onload = function() {
        i.revokeObjectURL(n), r.data.onload = null, e();
      };
      return;
    }
  }
  e();
}
var wv = (
  /** @class */
  function() {
    function r() {
    }
    return r.extension = dt.Loader, r.use = Ov, r;
  }()
);
Te.add(Av, wv);
/*!
 * @pixi/compressed-textures - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/compressed-textures is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ct, $;
(function(r) {
  r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
})($ || ($ = {}));
var pn = (ct = {}, // WEBGL_compressed_texture_s3tc
ct[$.COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5, ct[$.COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5, ct[$.COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1, ct[$.COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_s3tc
ct[$.COMPRESSED_SRGB_S3TC_DXT1_EXT] = 0.5, ct[$.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT] = 0.5, ct[$.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT] = 1, ct[$.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT] = 1, // WEBGL_compressed_texture_etc
ct[$.COMPRESSED_R11_EAC] = 0.5, ct[$.COMPRESSED_SIGNED_R11_EAC] = 0.5, ct[$.COMPRESSED_RG11_EAC] = 1, ct[$.COMPRESSED_SIGNED_RG11_EAC] = 1, ct[$.COMPRESSED_RGB8_ETC2] = 0.5, ct[$.COMPRESSED_RGBA8_ETC2_EAC] = 1, ct[$.COMPRESSED_SRGB8_ETC2] = 0.5, ct[$.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC] = 1, ct[$.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, ct[$.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2] = 0.5, // WEBGL_compressed_texture_pvrtc
ct[$.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5, ct[$.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5, ct[$.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25, ct[$.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25, // WEBGL_compressed_texture_etc1
ct[$.COMPRESSED_RGB_ETC1_WEBGL] = 0.5, // @see https://www.khronos.org/registry/OpenGL/extensions/AMD/AMD_compressed_ATC_texture.txt
// WEBGL_compressed_texture_atc
ct[$.COMPRESSED_RGB_ATC_WEBGL] = 0.5, ct[$.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1, ct[$.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1, // @see https://registry.khronos.org/OpenGL/extensions/KHR/KHR_texture_compression_astc_hdr.txt
// WEBGL_compressed_texture_astc
/* eslint-disable-next-line camelcase */
ct[$.COMPRESSED_RGBA_ASTC_4x4_KHR] = 1, ct);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Vo = function(r, e) {
  return Vo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Vo(r, e);
};
function Wu(r, e) {
  Vo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Iv(r, e, t, i) {
  function n(o) {
    return o instanceof t ? o : new t(function(s) {
      s(o);
    });
  }
  return new (t || (t = Promise))(function(o, s) {
    function a(l) {
      try {
        u(i.next(l));
      } catch (c) {
        s(c);
      }
    }
    function h(l) {
      try {
        u(i.throw(l));
      } catch (c) {
        s(c);
      }
    }
    function u(l) {
      l.done ? o(l.value) : n(l.value).then(a, h);
    }
    u((i = i.apply(r, e || [])).next());
  });
}
function Pv(r, e) {
  var t = { label: 0, sent: function() {
    if (o[0] & 1)
      throw o[1];
    return o[1];
  }, trys: [], ops: [] }, i, n, o, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(l) {
      return h([u, l]);
    };
  }
  function h(u) {
    if (i)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (i = 1, n && (o = u[0] & 2 ? n.return : u[0] ? n.throw || ((o = n.return) && o.call(n), 0) : n.next) && !(o = o.call(n, u[1])).done)
          return o;
        switch (n = 0, o && (u = [u[0] & 2, o.value]), u[0]) {
          case 0:
          case 1:
            o = u;
            break;
          case 4:
            return t.label++, { value: u[1], done: !1 };
          case 5:
            t.label++, n = u[1], u = [0];
            continue;
          case 7:
            u = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (o = t.trys, !(o = o.length > 0 && o[o.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              t = 0;
              continue;
            }
            if (u[0] === 3 && (!o || u[1] > o[0] && u[1] < o[3])) {
              t.label = u[1];
              break;
            }
            if (u[0] === 6 && t.label < o[1]) {
              t.label = o[1], o = u;
              break;
            }
            if (o && t.label < o[2]) {
              t.label = o[2], t.ops.push(u);
              break;
            }
            o[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        u = e.call(r, t);
      } catch (l) {
        u = [6, l], n = 0;
      } finally {
        i = o = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
var Mv = (
  /** @class */
  function(r) {
    Wu(e, r);
    function e(t, i) {
      i === void 0 && (i = { width: 1, height: 1, autoLoad: !0 });
      var n = this, o, s;
      return typeof t == "string" ? (o = t, s = new Uint8Array()) : (o = null, s = t), n = r.call(this, s, i) || this, n.origin = o, n.buffer = s ? new Ho(s) : null, n.origin && i.autoLoad !== !1 && n.load(), s && s.length && (n.loaded = !0, n.onBlobLoaded(n.buffer.rawBinaryData)), n;
    }
    return e.prototype.onBlobLoaded = function(t) {
    }, e.prototype.load = function() {
      return Iv(this, void 0, Promise, function() {
        var t, i, n;
        return Pv(this, function(o) {
          switch (o.label) {
            case 0:
              return [4, fetch(this.origin)];
            case 1:
              return t = o.sent(), [4, t.blob()];
            case 2:
              return i = o.sent(), [4, i.arrayBuffer()];
            case 3:
              return n = o.sent(), this.data = new Uint32Array(n), this.buffer = new Ho(n), this.loaded = !0, this.onBlobLoaded(n), this.update(), [2, this];
          }
        });
      });
    }, e;
  }(li)
), zo = (
  /** @class */
  function(r) {
    Wu(e, r);
    function e(t, i) {
      var n = r.call(this, t, i) || this;
      return n.format = i.format, n.levels = i.levels || 1, n._width = i.width, n._height = i.height, n._extension = e._formatToExtension(n.format), (i.levelBuffers || n.buffer) && (n._levelBuffers = i.levelBuffers || e._createLevelBuffers(
        t instanceof Uint8Array ? t : n.buffer.uint8View,
        n.format,
        n.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        n.width,
        n.height
      )), n;
    }
    return e.prototype.upload = function(t, i, n) {
      var o = t.gl, s = t.context.extensions[this._extension];
      if (!s)
        throw new Error(this._extension + " textures are not supported on the current machine");
      if (!this._levelBuffers)
        return !1;
      for (var a = 0, h = this.levels; a < h; a++) {
        var u = this._levelBuffers[a], l = u.levelID, c = u.levelWidth, p = u.levelHeight, d = u.levelBuffer;
        o.compressedTexImage2D(o.TEXTURE_2D, l, this.format, c, p, 0, d);
      }
      return !0;
    }, e.prototype.onBlobLoaded = function() {
      this._levelBuffers = e._createLevelBuffers(
        this.buffer.uint8View,
        this.format,
        this.levels,
        4,
        4,
        // PVRTC has 8x4 blocks in 2bpp mode
        this.width,
        this.height
      );
    }, e._formatToExtension = function(t) {
      if (t >= 33776 && t <= 33779)
        return "s3tc";
      if (t >= 37488 && t <= 37497)
        return "etc";
      if (t >= 35840 && t <= 35843)
        return "pvrtc";
      if (t >= 36196)
        return "etc1";
      if (t >= 35986 && t <= 34798)
        return "atc";
      throw new Error("Invalid (compressed) texture format given!");
    }, e._createLevelBuffers = function(t, i, n, o, s, a, h) {
      for (var u = new Array(n), l = t.byteOffset, c = a, p = h, d = c + o - 1 & ~(o - 1), f = p + s - 1 & ~(s - 1), y = d * f * pn[i], m = 0; m < n; m++)
        u[m] = {
          levelID: m,
          levelWidth: n > 1 ? c : d,
          levelHeight: n > 1 ? p : f,
          levelBuffer: new Uint8Array(t.buffer, l, y)
        }, l += y, c = c >> 1 || 1, p = p >> 1 || 1, d = c + o - 1 & ~(o - 1), f = p + s - 1 & ~(s - 1), y = d * f * pn[i];
      return u;
    }, e;
  }(Mv)
), Dv = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(e, t) {
      var i = e.data, n = this;
      if (e.type === Et.TYPE.JSON && i && i.cacheID && i.textures) {
        for (var o = i.textures, s = void 0, a = void 0, h = 0, u = o.length; h < u; h++) {
          var l = o[h], c = l.src, p = l.format;
          if (p || (a = c), r.textureFormats[p]) {
            s = c;
            break;
          }
        }
        if (s = s || a, !s) {
          t(new Error("Cannot load compressed-textures in " + e.url + ", make sure you provide a fallback"));
          return;
        }
        if (s === e.url) {
          t(new Error("URL of compressed texture cannot be the same as the manifest's URL"));
          return;
        }
        var d = {
          crossOrigin: e.crossOrigin,
          metadata: e.metadata.imageMetadata,
          parentResource: e
        }, f = mr.resolve(e.url.replace(n.baseUrl, ""), s), y = i.cacheID;
        n.add(y, f, d, function(m) {
          if (m.error) {
            t(m.error);
            return;
          }
          var _ = m.texture, g = _ === void 0 ? null : _, b = m.textures, x = b === void 0 ? {} : b;
          Object.assign(e, { texture: g, textures: x }), t();
        });
      } else
        t();
    }, Object.defineProperty(r, "textureExtensions", {
      /**  Map of available texture extensions. */
      get: function() {
        if (!r._textureExtensions) {
          var e = L.ADAPTER.createCanvas(), t = e.getContext("webgl");
          if (!t)
            return console.warn("WebGL not available for compressed textures. Silently failing."), {};
          var i = {
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
          };
          r._textureExtensions = i;
        }
        return r._textureExtensions;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "textureFormats", {
      /** Map of available texture formats. */
      get: function() {
        if (!r._textureFormats) {
          var e = r.textureExtensions;
          r._textureFormats = {};
          for (var t in e) {
            var i = e[t];
            i && Object.assign(r._textureFormats, Object.getPrototypeOf(i));
          }
        }
        return r._textureFormats;
      },
      enumerable: !1,
      configurable: !0
    }), r.extension = dt.Loader, r;
  }()
);
function $u(r, e, t) {
  var i = {
    textures: {},
    texture: null
  };
  if (!e)
    return i;
  var n = e.map(function(o) {
    return new W(new rt(o, Object.assign({
      mipmap: ie.OFF,
      alphaMode: ne.NO_PREMULTIPLIED_ALPHA
    }, t)));
  });
  return n.forEach(function(o, s) {
    var a = o.baseTexture, h = r + "-" + (s + 1);
    rt.addToCache(a, h), W.addToCache(o, h), s === 0 && (rt.addToCache(a, r), W.addToCache(o, r), i.texture = o), i.textures[h] = o;
  }), i;
}
var Ur, qt, uo = 4, Gi = 124, Cv = 32, ch = 20, Fv = 542327876, Ui = {
  SIZE: 1,
  FLAGS: 2,
  HEIGHT: 3,
  WIDTH: 4,
  MIPMAP_COUNT: 7,
  PIXEL_FORMAT: 19
}, Nv = {
  SIZE: 0,
  FLAGS: 1,
  FOURCC: 2,
  RGB_BITCOUNT: 3,
  R_BIT_MASK: 4,
  G_BIT_MASK: 5,
  B_BIT_MASK: 6,
  A_BIT_MASK: 7
}, ki = {
  DXGI_FORMAT: 0,
  RESOURCE_DIMENSION: 1,
  MISC_FLAG: 2,
  ARRAY_SIZE: 3,
  MISC_FLAGS2: 4
}, Jt;
(function(r) {
  r[r.DXGI_FORMAT_UNKNOWN = 0] = "DXGI_FORMAT_UNKNOWN", r[r.DXGI_FORMAT_R32G32B32A32_TYPELESS = 1] = "DXGI_FORMAT_R32G32B32A32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32A32_FLOAT = 2] = "DXGI_FORMAT_R32G32B32A32_FLOAT", r[r.DXGI_FORMAT_R32G32B32A32_UINT = 3] = "DXGI_FORMAT_R32G32B32A32_UINT", r[r.DXGI_FORMAT_R32G32B32A32_SINT = 4] = "DXGI_FORMAT_R32G32B32A32_SINT", r[r.DXGI_FORMAT_R32G32B32_TYPELESS = 5] = "DXGI_FORMAT_R32G32B32_TYPELESS", r[r.DXGI_FORMAT_R32G32B32_FLOAT = 6] = "DXGI_FORMAT_R32G32B32_FLOAT", r[r.DXGI_FORMAT_R32G32B32_UINT = 7] = "DXGI_FORMAT_R32G32B32_UINT", r[r.DXGI_FORMAT_R32G32B32_SINT = 8] = "DXGI_FORMAT_R32G32B32_SINT", r[r.DXGI_FORMAT_R16G16B16A16_TYPELESS = 9] = "DXGI_FORMAT_R16G16B16A16_TYPELESS", r[r.DXGI_FORMAT_R16G16B16A16_FLOAT = 10] = "DXGI_FORMAT_R16G16B16A16_FLOAT", r[r.DXGI_FORMAT_R16G16B16A16_UNORM = 11] = "DXGI_FORMAT_R16G16B16A16_UNORM", r[r.DXGI_FORMAT_R16G16B16A16_UINT = 12] = "DXGI_FORMAT_R16G16B16A16_UINT", r[r.DXGI_FORMAT_R16G16B16A16_SNORM = 13] = "DXGI_FORMAT_R16G16B16A16_SNORM", r[r.DXGI_FORMAT_R16G16B16A16_SINT = 14] = "DXGI_FORMAT_R16G16B16A16_SINT", r[r.DXGI_FORMAT_R32G32_TYPELESS = 15] = "DXGI_FORMAT_R32G32_TYPELESS", r[r.DXGI_FORMAT_R32G32_FLOAT = 16] = "DXGI_FORMAT_R32G32_FLOAT", r[r.DXGI_FORMAT_R32G32_UINT = 17] = "DXGI_FORMAT_R32G32_UINT", r[r.DXGI_FORMAT_R32G32_SINT = 18] = "DXGI_FORMAT_R32G32_SINT", r[r.DXGI_FORMAT_R32G8X24_TYPELESS = 19] = "DXGI_FORMAT_R32G8X24_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT_S8X24_UINT = 20] = "DXGI_FORMAT_D32_FLOAT_S8X24_UINT", r[r.DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS = 21] = "DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS", r[r.DXGI_FORMAT_X32_TYPELESS_G8X24_UINT = 22] = "DXGI_FORMAT_X32_TYPELESS_G8X24_UINT", r[r.DXGI_FORMAT_R10G10B10A2_TYPELESS = 23] = "DXGI_FORMAT_R10G10B10A2_TYPELESS", r[r.DXGI_FORMAT_R10G10B10A2_UNORM = 24] = "DXGI_FORMAT_R10G10B10A2_UNORM", r[r.DXGI_FORMAT_R10G10B10A2_UINT = 25] = "DXGI_FORMAT_R10G10B10A2_UINT", r[r.DXGI_FORMAT_R11G11B10_FLOAT = 26] = "DXGI_FORMAT_R11G11B10_FLOAT", r[r.DXGI_FORMAT_R8G8B8A8_TYPELESS = 27] = "DXGI_FORMAT_R8G8B8A8_TYPELESS", r[r.DXGI_FORMAT_R8G8B8A8_UNORM = 28] = "DXGI_FORMAT_R8G8B8A8_UNORM", r[r.DXGI_FORMAT_R8G8B8A8_UNORM_SRGB = 29] = "DXGI_FORMAT_R8G8B8A8_UNORM_SRGB", r[r.DXGI_FORMAT_R8G8B8A8_UINT = 30] = "DXGI_FORMAT_R8G8B8A8_UINT", r[r.DXGI_FORMAT_R8G8B8A8_SNORM = 31] = "DXGI_FORMAT_R8G8B8A8_SNORM", r[r.DXGI_FORMAT_R8G8B8A8_SINT = 32] = "DXGI_FORMAT_R8G8B8A8_SINT", r[r.DXGI_FORMAT_R16G16_TYPELESS = 33] = "DXGI_FORMAT_R16G16_TYPELESS", r[r.DXGI_FORMAT_R16G16_FLOAT = 34] = "DXGI_FORMAT_R16G16_FLOAT", r[r.DXGI_FORMAT_R16G16_UNORM = 35] = "DXGI_FORMAT_R16G16_UNORM", r[r.DXGI_FORMAT_R16G16_UINT = 36] = "DXGI_FORMAT_R16G16_UINT", r[r.DXGI_FORMAT_R16G16_SNORM = 37] = "DXGI_FORMAT_R16G16_SNORM", r[r.DXGI_FORMAT_R16G16_SINT = 38] = "DXGI_FORMAT_R16G16_SINT", r[r.DXGI_FORMAT_R32_TYPELESS = 39] = "DXGI_FORMAT_R32_TYPELESS", r[r.DXGI_FORMAT_D32_FLOAT = 40] = "DXGI_FORMAT_D32_FLOAT", r[r.DXGI_FORMAT_R32_FLOAT = 41] = "DXGI_FORMAT_R32_FLOAT", r[r.DXGI_FORMAT_R32_UINT = 42] = "DXGI_FORMAT_R32_UINT", r[r.DXGI_FORMAT_R32_SINT = 43] = "DXGI_FORMAT_R32_SINT", r[r.DXGI_FORMAT_R24G8_TYPELESS = 44] = "DXGI_FORMAT_R24G8_TYPELESS", r[r.DXGI_FORMAT_D24_UNORM_S8_UINT = 45] = "DXGI_FORMAT_D24_UNORM_S8_UINT", r[r.DXGI_FORMAT_R24_UNORM_X8_TYPELESS = 46] = "DXGI_FORMAT_R24_UNORM_X8_TYPELESS", r[r.DXGI_FORMAT_X24_TYPELESS_G8_UINT = 47] = "DXGI_FORMAT_X24_TYPELESS_G8_UINT", r[r.DXGI_FORMAT_R8G8_TYPELESS = 48] = "DXGI_FORMAT_R8G8_TYPELESS", r[r.DXGI_FORMAT_R8G8_UNORM = 49] = "DXGI_FORMAT_R8G8_UNORM", r[r.DXGI_FORMAT_R8G8_UINT = 50] = "DXGI_FORMAT_R8G8_UINT", r[r.DXGI_FORMAT_R8G8_SNORM = 51] = "DXGI_FORMAT_R8G8_SNORM", r[r.DXGI_FORMAT_R8G8_SINT = 52] = "DXGI_FORMAT_R8G8_SINT", r[r.DXGI_FORMAT_R16_TYPELESS = 53] = "DXGI_FORMAT_R16_TYPELESS", r[r.DXGI_FORMAT_R16_FLOAT = 54] = "DXGI_FORMAT_R16_FLOAT", r[r.DXGI_FORMAT_D16_UNORM = 55] = "DXGI_FORMAT_D16_UNORM", r[r.DXGI_FORMAT_R16_UNORM = 56] = "DXGI_FORMAT_R16_UNORM", r[r.DXGI_FORMAT_R16_UINT = 57] = "DXGI_FORMAT_R16_UINT", r[r.DXGI_FORMAT_R16_SNORM = 58] = "DXGI_FORMAT_R16_SNORM", r[r.DXGI_FORMAT_R16_SINT = 59] = "DXGI_FORMAT_R16_SINT", r[r.DXGI_FORMAT_R8_TYPELESS = 60] = "DXGI_FORMAT_R8_TYPELESS", r[r.DXGI_FORMAT_R8_UNORM = 61] = "DXGI_FORMAT_R8_UNORM", r[r.DXGI_FORMAT_R8_UINT = 62] = "DXGI_FORMAT_R8_UINT", r[r.DXGI_FORMAT_R8_SNORM = 63] = "DXGI_FORMAT_R8_SNORM", r[r.DXGI_FORMAT_R8_SINT = 64] = "DXGI_FORMAT_R8_SINT", r[r.DXGI_FORMAT_A8_UNORM = 65] = "DXGI_FORMAT_A8_UNORM", r[r.DXGI_FORMAT_R1_UNORM = 66] = "DXGI_FORMAT_R1_UNORM", r[r.DXGI_FORMAT_R9G9B9E5_SHAREDEXP = 67] = "DXGI_FORMAT_R9G9B9E5_SHAREDEXP", r[r.DXGI_FORMAT_R8G8_B8G8_UNORM = 68] = "DXGI_FORMAT_R8G8_B8G8_UNORM", r[r.DXGI_FORMAT_G8R8_G8B8_UNORM = 69] = "DXGI_FORMAT_G8R8_G8B8_UNORM", r[r.DXGI_FORMAT_BC1_TYPELESS = 70] = "DXGI_FORMAT_BC1_TYPELESS", r[r.DXGI_FORMAT_BC1_UNORM = 71] = "DXGI_FORMAT_BC1_UNORM", r[r.DXGI_FORMAT_BC1_UNORM_SRGB = 72] = "DXGI_FORMAT_BC1_UNORM_SRGB", r[r.DXGI_FORMAT_BC2_TYPELESS = 73] = "DXGI_FORMAT_BC2_TYPELESS", r[r.DXGI_FORMAT_BC2_UNORM = 74] = "DXGI_FORMAT_BC2_UNORM", r[r.DXGI_FORMAT_BC2_UNORM_SRGB = 75] = "DXGI_FORMAT_BC2_UNORM_SRGB", r[r.DXGI_FORMAT_BC3_TYPELESS = 76] = "DXGI_FORMAT_BC3_TYPELESS", r[r.DXGI_FORMAT_BC3_UNORM = 77] = "DXGI_FORMAT_BC3_UNORM", r[r.DXGI_FORMAT_BC3_UNORM_SRGB = 78] = "DXGI_FORMAT_BC3_UNORM_SRGB", r[r.DXGI_FORMAT_BC4_TYPELESS = 79] = "DXGI_FORMAT_BC4_TYPELESS", r[r.DXGI_FORMAT_BC4_UNORM = 80] = "DXGI_FORMAT_BC4_UNORM", r[r.DXGI_FORMAT_BC4_SNORM = 81] = "DXGI_FORMAT_BC4_SNORM", r[r.DXGI_FORMAT_BC5_TYPELESS = 82] = "DXGI_FORMAT_BC5_TYPELESS", r[r.DXGI_FORMAT_BC5_UNORM = 83] = "DXGI_FORMAT_BC5_UNORM", r[r.DXGI_FORMAT_BC5_SNORM = 84] = "DXGI_FORMAT_BC5_SNORM", r[r.DXGI_FORMAT_B5G6R5_UNORM = 85] = "DXGI_FORMAT_B5G6R5_UNORM", r[r.DXGI_FORMAT_B5G5R5A1_UNORM = 86] = "DXGI_FORMAT_B5G5R5A1_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_UNORM = 87] = "DXGI_FORMAT_B8G8R8A8_UNORM", r[r.DXGI_FORMAT_B8G8R8X8_UNORM = 88] = "DXGI_FORMAT_B8G8R8X8_UNORM", r[r.DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM = 89] = "DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM", r[r.DXGI_FORMAT_B8G8R8A8_TYPELESS = 90] = "DXGI_FORMAT_B8G8R8A8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8A8_UNORM_SRGB = 91] = "DXGI_FORMAT_B8G8R8A8_UNORM_SRGB", r[r.DXGI_FORMAT_B8G8R8X8_TYPELESS = 92] = "DXGI_FORMAT_B8G8R8X8_TYPELESS", r[r.DXGI_FORMAT_B8G8R8X8_UNORM_SRGB = 93] = "DXGI_FORMAT_B8G8R8X8_UNORM_SRGB", r[r.DXGI_FORMAT_BC6H_TYPELESS = 94] = "DXGI_FORMAT_BC6H_TYPELESS", r[r.DXGI_FORMAT_BC6H_UF16 = 95] = "DXGI_FORMAT_BC6H_UF16", r[r.DXGI_FORMAT_BC6H_SF16 = 96] = "DXGI_FORMAT_BC6H_SF16", r[r.DXGI_FORMAT_BC7_TYPELESS = 97] = "DXGI_FORMAT_BC7_TYPELESS", r[r.DXGI_FORMAT_BC7_UNORM = 98] = "DXGI_FORMAT_BC7_UNORM", r[r.DXGI_FORMAT_BC7_UNORM_SRGB = 99] = "DXGI_FORMAT_BC7_UNORM_SRGB", r[r.DXGI_FORMAT_AYUV = 100] = "DXGI_FORMAT_AYUV", r[r.DXGI_FORMAT_Y410 = 101] = "DXGI_FORMAT_Y410", r[r.DXGI_FORMAT_Y416 = 102] = "DXGI_FORMAT_Y416", r[r.DXGI_FORMAT_NV12 = 103] = "DXGI_FORMAT_NV12", r[r.DXGI_FORMAT_P010 = 104] = "DXGI_FORMAT_P010", r[r.DXGI_FORMAT_P016 = 105] = "DXGI_FORMAT_P016", r[r.DXGI_FORMAT_420_OPAQUE = 106] = "DXGI_FORMAT_420_OPAQUE", r[r.DXGI_FORMAT_YUY2 = 107] = "DXGI_FORMAT_YUY2", r[r.DXGI_FORMAT_Y210 = 108] = "DXGI_FORMAT_Y210", r[r.DXGI_FORMAT_Y216 = 109] = "DXGI_FORMAT_Y216", r[r.DXGI_FORMAT_NV11 = 110] = "DXGI_FORMAT_NV11", r[r.DXGI_FORMAT_AI44 = 111] = "DXGI_FORMAT_AI44", r[r.DXGI_FORMAT_IA44 = 112] = "DXGI_FORMAT_IA44", r[r.DXGI_FORMAT_P8 = 113] = "DXGI_FORMAT_P8", r[r.DXGI_FORMAT_A8P8 = 114] = "DXGI_FORMAT_A8P8", r[r.DXGI_FORMAT_B4G4R4A4_UNORM = 115] = "DXGI_FORMAT_B4G4R4A4_UNORM", r[r.DXGI_FORMAT_P208 = 116] = "DXGI_FORMAT_P208", r[r.DXGI_FORMAT_V208 = 117] = "DXGI_FORMAT_V208", r[r.DXGI_FORMAT_V408 = 118] = "DXGI_FORMAT_V408", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 119] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE", r[r.DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 120] = "DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE", r[r.DXGI_FORMAT_FORCE_UINT = 121] = "DXGI_FORMAT_FORCE_UINT";
})(Jt || (Jt = {}));
var Wo;
(function(r) {
  r[r.DDS_DIMENSION_TEXTURE1D = 2] = "DDS_DIMENSION_TEXTURE1D", r[r.DDS_DIMENSION_TEXTURE2D = 3] = "DDS_DIMENSION_TEXTURE2D", r[r.DDS_DIMENSION_TEXTURE3D = 6] = "DDS_DIMENSION_TEXTURE3D";
})(Wo || (Wo = {}));
var Lv = 1, Bv = 2, Gv = 4, Uv = 64, kv = 512, Xv = 131072, jv = 827611204, Hv = 861165636, Yv = 894720068, Vv = 808540228, zv = 4, Wv = (Ur = {}, Ur[jv] = $.COMPRESSED_RGBA_S3TC_DXT1_EXT, Ur[Hv] = $.COMPRESSED_RGBA_S3TC_DXT3_EXT, Ur[Yv] = $.COMPRESSED_RGBA_S3TC_DXT5_EXT, Ur), $v = (qt = {}, // WEBGL_compressed_texture_s3tc
qt[Jt.DXGI_FORMAT_BC1_TYPELESS] = $.COMPRESSED_RGBA_S3TC_DXT1_EXT, qt[Jt.DXGI_FORMAT_BC1_UNORM] = $.COMPRESSED_RGBA_S3TC_DXT1_EXT, qt[Jt.DXGI_FORMAT_BC2_TYPELESS] = $.COMPRESSED_RGBA_S3TC_DXT3_EXT, qt[Jt.DXGI_FORMAT_BC2_UNORM] = $.COMPRESSED_RGBA_S3TC_DXT3_EXT, qt[Jt.DXGI_FORMAT_BC3_TYPELESS] = $.COMPRESSED_RGBA_S3TC_DXT5_EXT, qt[Jt.DXGI_FORMAT_BC3_UNORM] = $.COMPRESSED_RGBA_S3TC_DXT5_EXT, // WEBGL_compressed_texture_s3tc_srgb
qt[Jt.DXGI_FORMAT_BC1_UNORM_SRGB] = $.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, qt[Jt.DXGI_FORMAT_BC2_UNORM_SRGB] = $.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT, qt[Jt.DXGI_FORMAT_BC3_UNORM_SRGB] = $.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT, qt);
function qv(r) {
  var e = new Uint32Array(r), t = e[0];
  if (t !== Fv)
    throw new Error("Invalid DDS file magic word");
  var i = new Uint32Array(r, 0, Gi / Uint32Array.BYTES_PER_ELEMENT), n = i[Ui.HEIGHT], o = i[Ui.WIDTH], s = i[Ui.MIPMAP_COUNT], a = new Uint32Array(r, Ui.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, Cv / Uint32Array.BYTES_PER_ELEMENT), h = a[Lv];
  if (h & Gv) {
    var u = a[Nv.FOURCC];
    if (u !== Vv) {
      var l = Wv[u], c = uo + Gi, p = new Uint8Array(r, c), d = new zo(p, {
        format: l,
        width: o,
        height: n,
        levels: s
        // CompressedTextureResource will separate the levelBuffers for us!
      });
      return [d];
    }
    var f = uo + Gi, y = new Uint32Array(e.buffer, f, ch / Uint32Array.BYTES_PER_ELEMENT), m = y[ki.DXGI_FORMAT], _ = y[ki.RESOURCE_DIMENSION], g = y[ki.MISC_FLAG], b = y[ki.ARRAY_SIZE], x = $v[m];
    if (x === void 0)
      throw new Error("DDSParser cannot parse texture data with DXGI format " + m);
    if (g === zv)
      throw new Error("DDSParser does not support cubemap textures");
    if (_ === Wo.DDS_DIMENSION_TEXTURE3D)
      throw new Error("DDSParser does not supported 3D texture data");
    var E = new Array(), v = uo + Gi + ch;
    if (b === 1)
      E.push(new Uint8Array(r, v));
    else {
      for (var T = pn[x], S = 0, R = o, O = n, w = 0; w < s; w++) {
        var C = Math.max(1, R + 3 & -4), B = Math.max(1, O + 3 & -4), V = C * B * T;
        S += V, R = R >>> 1, O = O >>> 1;
      }
      for (var F = v, w = 0; w < b; w++)
        E.push(new Uint8Array(r, F, S)), F += S;
    }
    return E.map(function(D) {
      return new zo(D, {
        format: x,
        width: o,
        height: n,
        levels: s
      });
    });
  }
  throw h & Uv ? new Error("DDSParser does not support uncompressed texture data.") : h & kv ? new Error("DDSParser does not supported YUV uncompressed texture data.") : h & Xv ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : h & Bv ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!");
}
var Ee, ye, kr, ph = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], Kv = 67305985, Kt = {
  FILE_IDENTIFIER: 0,
  ENDIANNESS: 12,
  GL_TYPE: 16,
  GL_TYPE_SIZE: 20,
  GL_FORMAT: 24,
  GL_INTERNAL_FORMAT: 28,
  GL_BASE_INTERNAL_FORMAT: 32,
  PIXEL_WIDTH: 36,
  PIXEL_HEIGHT: 40,
  PIXEL_DEPTH: 44,
  NUMBER_OF_ARRAY_ELEMENTS: 48,
  NUMBER_OF_FACES: 52,
  NUMBER_OF_MIPMAP_LEVELS: 56,
  BYTES_OF_KEY_VALUE_DATA: 60
}, $o = 64, dh = (Ee = {}, Ee[U.UNSIGNED_BYTE] = 1, Ee[U.UNSIGNED_SHORT] = 2, Ee[U.INT] = 4, Ee[U.UNSIGNED_INT] = 4, Ee[U.FLOAT] = 4, Ee[U.HALF_FLOAT] = 8, Ee), Zv = (ye = {}, ye[P.RGBA] = 4, ye[P.RGB] = 3, ye[P.RG] = 2, ye[P.RED] = 1, ye[P.LUMINANCE] = 1, ye[P.LUMINANCE_ALPHA] = 2, ye[P.ALPHA] = 1, ye), Jv = (kr = {}, kr[U.UNSIGNED_SHORT_4_4_4_4] = 2, kr[U.UNSIGNED_SHORT_5_5_5_1] = 2, kr[U.UNSIGNED_SHORT_5_6_5] = 2, kr);
function Qv(r, e, t) {
  t === void 0 && (t = !1);
  var i = new DataView(e);
  if (!t0(r, i))
    return null;
  var n = i.getUint32(Kt.ENDIANNESS, !0) === Kv, o = i.getUint32(Kt.GL_TYPE, n), s = i.getUint32(Kt.GL_FORMAT, n), a = i.getUint32(Kt.GL_INTERNAL_FORMAT, n), h = i.getUint32(Kt.PIXEL_WIDTH, n), u = i.getUint32(Kt.PIXEL_HEIGHT, n) || 1, l = i.getUint32(Kt.PIXEL_DEPTH, n) || 1, c = i.getUint32(Kt.NUMBER_OF_ARRAY_ELEMENTS, n) || 1, p = i.getUint32(Kt.NUMBER_OF_FACES, n), d = i.getUint32(Kt.NUMBER_OF_MIPMAP_LEVELS, n), f = i.getUint32(Kt.BYTES_OF_KEY_VALUE_DATA, n);
  if (u === 0 || l !== 1)
    throw new Error("Only 2D textures are supported");
  if (p !== 1)
    throw new Error("CubeTextures are not supported by KTXLoader yet!");
  if (c !== 1)
    throw new Error("WebGL does not support array textures");
  var y = 4, m = 4, _ = h + 3 & -4, g = u + 3 & -4, b = new Array(c), x = h * u;
  o === 0 && (x = _ * g);
  var E;
  if (o !== 0 ? dh[o] ? E = dh[o] * Zv[s] : E = Jv[o] : E = pn[a], E === void 0)
    throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
  for (var v = t ? r0(i, f, n) : null, T = x * E, S = T, R = h, O = u, w = _, C = g, B = $o + f, V = 0; V < d; V++) {
    for (var F = i.getUint32(B, n), D = B + 4, z = 0; z < c; z++) {
      var ot = b[z];
      ot || (ot = b[z] = new Array(d)), ot[V] = {
        levelID: V,
        // don't align mipWidth when texture not compressed! (glType not zero)
        levelWidth: d > 1 || o !== 0 ? R : w,
        levelHeight: d > 1 || o !== 0 ? O : C,
        levelBuffer: new Uint8Array(e, D, S)
      }, D += S;
    }
    B += F + 4, B = B % 4 !== 0 ? B + 4 - B % 4 : B, R = R >> 1 || 1, O = O >> 1 || 1, w = R + y - 1 & ~(y - 1), C = O + m - 1 & ~(m - 1), S = w * C * E;
  }
  return o !== 0 ? {
    uncompressed: b.map(function(K) {
      var M = K[0].levelBuffer, I = !1;
      return o === U.FLOAT ? M = new Float32Array(K[0].levelBuffer.buffer, K[0].levelBuffer.byteOffset, K[0].levelBuffer.byteLength / 4) : o === U.UNSIGNED_INT ? (I = !0, M = new Uint32Array(K[0].levelBuffer.buffer, K[0].levelBuffer.byteOffset, K[0].levelBuffer.byteLength / 4)) : o === U.INT && (I = !0, M = new Int32Array(K[0].levelBuffer.buffer, K[0].levelBuffer.byteOffset, K[0].levelBuffer.byteLength / 4)), {
        resource: new li(M, {
          width: K[0].levelWidth,
          height: K[0].levelHeight
        }),
        type: o,
        format: I ? e0(s) : s
      };
    }),
    kvData: v
  } : {
    compressed: b.map(function(K) {
      return new zo(null, {
        format: a,
        width: h,
        height: u,
        levels: d,
        levelBuffers: K
      });
    }),
    kvData: v
  };
}
function t0(r, e) {
  for (var t = 0; t < ph.length; t++)
    if (e.getUint8(t) !== ph[t])
      return console.error(r + " is not a valid *.ktx file!"), !1;
  return !0;
}
function e0(r) {
  switch (r) {
    case P.RGBA:
      return P.RGBA_INTEGER;
    case P.RGB:
      return P.RGB_INTEGER;
    case P.RG:
      return P.RG_INTEGER;
    case P.RED:
      return P.RED_INTEGER;
    default:
      return r;
  }
}
function r0(r, e, t) {
  for (var i = /* @__PURE__ */ new Map(), n = 0; n < e; ) {
    var o = r.getUint32($o + n, t), s = $o + n + 4, a = 3 - (o + 3) % 4;
    if (o === 0 || o > e - n) {
      console.error("KTXLoader: keyAndValueByteSize out of bounds");
      break;
    }
    for (var h = 0; h < o && r.getUint8(s + h) !== 0; h++)
      ;
    if (h === -1) {
      console.error("KTXLoader: Failed to find null byte terminating kvData key");
      break;
    }
    var u = new TextDecoder().decode(new Uint8Array(r.buffer, s, h)), l = new DataView(r.buffer, s + h + 1, o - h - 1);
    i.set(u, l), n += 4 + o + a;
  }
  return i;
}
Et.setExtensionXhrType("dds", Et.XHR_RESPONSE_TYPE.BUFFER);
var i0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(e, t) {
      if (e.extension === "dds" && e.data)
        try {
          Object.assign(e, $u(e.name || e.url, qv(e.data), e.metadata));
        } catch (i) {
          t(i);
          return;
        }
      t();
    }, r.extension = dt.Loader, r;
  }()
);
Et.setExtensionXhrType("ktx", Et.XHR_RESPONSE_TYPE.BUFFER);
var n0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(e, t) {
      if (e.extension === "ktx" && e.data)
        try {
          var i = e.name || e.url, n = Qv(i, e.data, this.loadKeyValueData), o = n.compressed, s = n.uncompressed, a = n.kvData;
          if (o) {
            var h = $u(i, o, e.metadata);
            if (a && h.textures)
              for (var u in h.textures)
                h.textures[u].baseTexture.ktxKeyValueData = a;
            Object.assign(e, h);
          } else if (s) {
            var l = {};
            s.forEach(function(c, p) {
              var d = new W(new rt(c.resource, {
                mipmap: ie.OFF,
                alphaMode: ne.NO_PREMULTIPLIED_ALPHA,
                type: c.type,
                format: c.format
              })), f = i + "-" + (p + 1);
              a && (d.baseTexture.ktxKeyValueData = a), rt.addToCache(d.baseTexture, f), W.addToCache(d, f), p === 0 && (l[i] = d, rt.addToCache(d.baseTexture, i), W.addToCache(d, i)), l[f] = d;
            }), Object.assign(e, { textures: l });
          }
        } catch (c) {
          t(c);
          return;
        }
      t();
    }, r.extension = dt.Loader, r.loadKeyValueData = !1, r;
  }()
);
/*!
 * @pixi/particle-container - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/particle-container is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var qo = function(r, e) {
  return qo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, qo(r, e);
};
function qu(r, e) {
  qo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
(function(r) {
  qu(e, r);
  function e(t, i, n, o) {
    t === void 0 && (t = 1500), n === void 0 && (n = 16384), o === void 0 && (o = !1);
    var s = r.call(this) || this, a = 16384;
    return n > a && (n = a), s._properties = [!1, !0, !1, !1, !1], s._maxSize = t, s._batchSize = n, s._buffers = null, s._bufferUpdateIDs = [], s._updateID = 0, s.interactiveChildren = !1, s.blendMode = k.NORMAL, s.autoResize = o, s.roundPixels = !0, s.baseTexture = null, s.setProperties(i), s._tint = 0, s.tintRgb = new Float32Array(4), s.tint = 16777215, s;
  }
  return e.prototype.setProperties = function(t) {
    t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4]);
  }, e.prototype.updateTransform = function() {
    this.displayObjectUpdateTransform();
  }, Object.defineProperty(e.prototype, "tint", {
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
     * @default 0xFFFFFF
     */
    get: function() {
      return this._tint;
    },
    set: function(t) {
      this._tint = t, wr(t, this.tintRgb);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.render = function(t) {
    var i = this;
    !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", function() {
      return i.onChildrenChange(0);
    })), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this));
  }, e.prototype.onChildrenChange = function(t) {
    for (var i = Math.floor(t / this._batchSize); this._bufferUpdateIDs.length < i; )
      this._bufferUpdateIDs.push(0);
    this._bufferUpdateIDs[i] = ++this._updateID;
  }, e.prototype.dispose = function() {
    if (this._buffers) {
      for (var t = 0; t < this._buffers.length; ++t)
        this._buffers[t].destroy();
      this._buffers = null;
    }
  }, e.prototype.destroy = function(t) {
    r.prototype.destroy.call(this, t), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null;
  }, e;
})(pe);
var fh = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.geometry = new ci(), this.indexBuffer = null, this.size = i, this.dynamicProperties = [], this.staticProperties = [];
      for (var n = 0; n < e.length; ++n) {
        var o = e[n];
        o = {
          attributeName: o.attributeName,
          size: o.size,
          uploadFunction: o.uploadFunction,
          type: o.type || U.FLOAT,
          offset: o.offset
        }, t[n] ? this.dynamicProperties.push(o) : this.staticProperties.push(o);
      }
      this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers();
    }
    return r.prototype.initBuffers = function() {
      var e = this.geometry, t = 0;
      this.indexBuffer = new wt(y_(this.size), !0, !0), e.addIndex(this.indexBuffer), this.dynamicStride = 0;
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var n = this.dynamicProperties[i];
        n.offset = t, t += n.size, this.dynamicStride += n.size;
      }
      var o = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
      this.dynamicData = new Float32Array(o), this.dynamicDataUint32 = new Uint32Array(o), this.dynamicBuffer = new wt(this.dynamicData, !1, !1);
      var s = 0;
      this.staticStride = 0;
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var n = this.staticProperties[i];
        n.offset = s, s += n.size, this.staticStride += n.size;
      }
      var a = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
      this.staticData = new Float32Array(a), this.staticDataUint32 = new Uint32Array(a), this.staticBuffer = new wt(this.staticData, !0, !1);
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var n = this.dynamicProperties[i];
        e.addAttribute(n.attributeName, this.dynamicBuffer, 0, n.type === U.UNSIGNED_BYTE, n.type, this.dynamicStride * 4, n.offset * 4);
      }
      for (var i = 0; i < this.staticProperties.length; ++i) {
        var n = this.staticProperties[i];
        e.addAttribute(n.attributeName, this.staticBuffer, 0, n.type === U.UNSIGNED_BYTE, n.type, this.staticStride * 4, n.offset * 4);
      }
    }, r.prototype.uploadDynamic = function(e, t, i) {
      for (var n = 0; n < this.dynamicProperties.length; n++) {
        var o = this.dynamicProperties[n];
        o.uploadFunction(e, t, i, o.type === U.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, o.offset);
      }
      this.dynamicBuffer._updateID++;
    }, r.prototype.uploadStatic = function(e, t, i) {
      for (var n = 0; n < this.staticProperties.length; n++) {
        var o = this.staticProperties[n];
        o.uploadFunction(e, t, i, o.type === U.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, o.offset);
      }
      this.staticBuffer._updateID++;
    }, r.prototype.destroy = function() {
      this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy();
    }, r;
  }()
), o0 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`, s0 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`, a0 = (
  /** @class */
  function(r) {
    qu(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.shader = null, i.properties = null, i.tempMatrix = new It(), i.properties = [
        // verticesData
        {
          attributeName: "aVertexPosition",
          size: 2,
          uploadFunction: i.uploadVertices,
          offset: 0
        },
        // positionData
        {
          attributeName: "aPositionCoord",
          size: 2,
          uploadFunction: i.uploadPosition,
          offset: 0
        },
        // rotationData
        {
          attributeName: "aRotation",
          size: 1,
          uploadFunction: i.uploadRotation,
          offset: 0
        },
        // uvsData
        {
          attributeName: "aTextureCoord",
          size: 2,
          uploadFunction: i.uploadUvs,
          offset: 0
        },
        // tintData
        {
          attributeName: "aColor",
          size: 1,
          type: U.UNSIGNED_BYTE,
          uploadFunction: i.uploadTint,
          offset: 0
        }
      ], i.shader = we.from(s0, o0, {}), i.state = ir.for2d(), i;
    }
    return e.prototype.render = function(t) {
      var i = t.children, n = t._maxSize, o = t._batchSize, s = this.renderer, a = i.length;
      if (a !== 0) {
        a > n && !t.autoResize && (a = n);
        var h = t._buffers;
        h || (h = t._buffers = this.generateBuffers(t));
        var u = i[0]._texture.baseTexture, l = u.alphaMode > 0;
        this.state.blendMode = Eu(t.blendMode, l), s.state.set(this.state);
        var c = s.gl, p = t.worldTransform.copyTo(this.tempMatrix);
        p.prepend(s.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = p.toArray(!0), this.shader.uniforms.uColor = f_(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, l), this.shader.uniforms.uSampler = u, this.renderer.shader.bind(this.shader);
        for (var d = !1, f = 0, y = 0; f < a; f += o, y += 1) {
          var m = a - f;
          m > o && (m = o), y >= h.length && h.push(this._generateOneMoreBuffer(t));
          var _ = h[y];
          _.uploadDynamic(i, f, m);
          var g = t._bufferUpdateIDs[y] || 0;
          d = d || _._updateID < g, d && (_._updateID = t._updateID, _.uploadStatic(i, f, m)), s.geometry.bind(_.geometry), c.drawElements(c.TRIANGLES, m * 6, c.UNSIGNED_SHORT, 0);
        }
      }
    }, e.prototype.generateBuffers = function(t) {
      for (var i = [], n = t._maxSize, o = t._batchSize, s = t._properties, a = 0; a < n; a += o)
        i.push(new fh(this.properties, s, o));
      return i;
    }, e.prototype._generateOneMoreBuffer = function(t) {
      var i = t._batchSize, n = t._properties;
      return new fh(this.properties, n, i);
    }, e.prototype.uploadVertices = function(t, i, n, o, s, a) {
      for (var h = 0, u = 0, l = 0, c = 0, p = 0; p < n; ++p) {
        var d = t[i + p], f = d._texture, y = d.scale.x, m = d.scale.y, _ = f.trim, g = f.orig;
        _ ? (u = _.x - d.anchor.x * g.width, h = u + _.width, c = _.y - d.anchor.y * g.height, l = c + _.height) : (h = g.width * (1 - d.anchor.x), u = g.width * -d.anchor.x, l = g.height * (1 - d.anchor.y), c = g.height * -d.anchor.y), o[a] = u * y, o[a + 1] = c * m, o[a + s] = h * y, o[a + s + 1] = c * m, o[a + s * 2] = h * y, o[a + s * 2 + 1] = l * m, o[a + s * 3] = u * y, o[a + s * 3 + 1] = l * m, a += s * 4;
      }
    }, e.prototype.uploadPosition = function(t, i, n, o, s, a) {
      for (var h = 0; h < n; h++) {
        var u = t[i + h].position;
        o[a] = u.x, o[a + 1] = u.y, o[a + s] = u.x, o[a + s + 1] = u.y, o[a + s * 2] = u.x, o[a + s * 2 + 1] = u.y, o[a + s * 3] = u.x, o[a + s * 3 + 1] = u.y, a += s * 4;
      }
    }, e.prototype.uploadRotation = function(t, i, n, o, s, a) {
      for (var h = 0; h < n; h++) {
        var u = t[i + h].rotation;
        o[a] = u, o[a + s] = u, o[a + s * 2] = u, o[a + s * 3] = u, a += s * 4;
      }
    }, e.prototype.uploadUvs = function(t, i, n, o, s, a) {
      for (var h = 0; h < n; ++h) {
        var u = t[i + h]._texture._uvs;
        u ? (o[a] = u.x0, o[a + 1] = u.y0, o[a + s] = u.x1, o[a + s + 1] = u.y1, o[a + s * 2] = u.x2, o[a + s * 2 + 1] = u.y2, o[a + s * 3] = u.x3, o[a + s * 3 + 1] = u.y3, a += s * 4) : (o[a] = 0, o[a + 1] = 0, o[a + s] = 0, o[a + s + 1] = 0, o[a + s * 2] = 0, o[a + s * 2 + 1] = 0, o[a + s * 3] = 0, o[a + s * 3 + 1] = 0, a += s * 4);
      }
    }, e.prototype.uploadTint = function(t, i, n, o, s, a) {
      for (var h = 0; h < n; ++h) {
        var u = t[i + h], l = u._texture.baseTexture.alphaMode > 0, c = u.alpha, p = c < 1 && l ? Os(u._tintRGB, c) : u._tintRGB + (c * 255 << 24);
        o[a] = p, o[a + s] = p, o[a + s * 2] = p, o[a + s * 3] = p, a += s * 4;
      }
    }, e.prototype.destroy = function() {
      r.prototype.destroy.call(this), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null;
    }, e.extension = {
      name: "particle",
      type: dt.RendererPlugin
    }, e;
  }(xn)
);
/*!
 * @pixi/graphics - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/graphics is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ve;
(function(r) {
  r.MITER = "miter", r.BEVEL = "bevel", r.ROUND = "round";
})(ve || (ve = {}));
var Oe;
(function(r) {
  r.BUTT = "butt", r.ROUND = "round", r.SQUARE = "square";
})(Oe || (Oe = {}));
var ni = {
  adaptive: !0,
  maxLength: 10,
  minSegments: 8,
  maxSegments: 2048,
  epsilon: 1e-4,
  _segmentsCount: function(r, e) {
    if (e === void 0 && (e = 20), !this.adaptive || !r || isNaN(r))
      return e;
    var t = Math.ceil(r / this.maxLength);
    return t < this.minSegments ? t = this.minSegments : t > this.maxSegments && (t = this.maxSegments), t;
  }
}, Ku = (
  /** @class */
  function() {
    function r() {
      this.color = 16777215, this.alpha = 1, this.texture = W.WHITE, this.matrix = null, this.visible = !1, this.reset();
    }
    return r.prototype.clone = function() {
      var e = new r();
      return e.color = this.color, e.alpha = this.alpha, e.texture = this.texture, e.matrix = this.matrix, e.visible = this.visible, e;
    }, r.prototype.reset = function() {
      this.color = 16777215, this.alpha = 1, this.texture = W.WHITE, this.matrix = null, this.visible = !1;
    }, r.prototype.destroy = function() {
      this.texture = null, this.matrix = null;
    }, r;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ko = function(r, e) {
  return Ko = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Ko(r, e);
};
function Ps(r, e) {
  Ko(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function yh(r, e) {
  var t, i;
  e === void 0 && (e = !1);
  var n = r.length;
  if (!(n < 6)) {
    for (var o = 0, s = 0, a = r[n - 2], h = r[n - 1]; s < n; s += 2) {
      var u = r[s], l = r[s + 1];
      o += (u - a) * (l + h), a = u, h = l;
    }
    if (!e && o > 0 || e && o <= 0)
      for (var c = n / 2, s = c + c % 2; s < n; s += 2) {
        var p = n - s - 2, d = n - s - 1, f = s, y = s + 1;
        t = [r[f], r[p]], r[p] = t[0], r[f] = t[1], i = [r[y], r[d]], r[d] = i[0], r[y] = i[1];
      }
  }
}
var Zu = {
  build: function(r) {
    r.points = r.shape.points.slice();
  },
  triangulate: function(r, e) {
    var t = r.points, i = r.holes, n = e.points, o = e.indices;
    if (t.length >= 6) {
      yh(t, !1);
      for (var s = [], a = 0; a < i.length; a++) {
        var h = i[a];
        yh(h.points, !0), s.push(t.length / 2), t = t.concat(h.points);
      }
      var u = nu(t, s, 2);
      if (!u)
        return;
      for (var l = n.length / 2, a = 0; a < u.length; a += 3)
        o.push(u[a] + l), o.push(u[a + 1] + l), o.push(u[a + 2] + l);
      for (var a = 0; a < t.length; a++)
        n.push(t[a]);
    }
  }
}, dn = {
  build: function(r) {
    var e = r.points, t, i, n, o, s, a;
    if (r.type === Dt.CIRC) {
      var h = r.shape;
      t = h.x, i = h.y, s = a = h.radius, n = o = 0;
    } else if (r.type === Dt.ELIP) {
      var u = r.shape;
      t = u.x, i = u.y, s = u.width, a = u.height, n = o = 0;
    } else {
      var l = r.shape, c = l.width / 2, p = l.height / 2;
      t = l.x + c, i = l.y + p, s = a = Math.max(0, Math.min(l.radius, Math.min(c, p))), n = c - s, o = p - a;
    }
    if (!(s >= 0 && a >= 0 && n >= 0 && o >= 0)) {
      e.length = 0;
      return;
    }
    var d = Math.ceil(2.3 * Math.sqrt(s + a)), f = d * 8 + (n ? 4 : 0) + (o ? 4 : 0);
    if (e.length = f, f !== 0) {
      if (d === 0) {
        e.length = 8, e[0] = e[6] = t + n, e[1] = e[3] = i + o, e[2] = e[4] = t - n, e[5] = e[7] = i - o;
        return;
      }
      var y = 0, m = d * 4 + (n ? 2 : 0) + 2, _ = m, g = f;
      {
        var b = n + s, x = o, E = t + b, v = t - b, T = i + x;
        if (e[y++] = E, e[y++] = T, e[--m] = T, e[--m] = v, o) {
          var S = i - x;
          e[_++] = v, e[_++] = S, e[--g] = S, e[--g] = E;
        }
      }
      for (var R = 1; R < d; R++) {
        var O = Math.PI / 2 * (R / d), b = n + Math.cos(O) * s, x = o + Math.sin(O) * a, E = t + b, v = t - b, T = i + x, S = i - x;
        e[y++] = E, e[y++] = T, e[--m] = T, e[--m] = v, e[_++] = v, e[_++] = S, e[--g] = S, e[--g] = E;
      }
      {
        var b = n, x = o + a, E = t + b, v = t - b, T = i + x, S = i - x;
        e[y++] = E, e[y++] = T, e[--g] = S, e[--g] = E, n && (e[y++] = v, e[y++] = T, e[--g] = S, e[--g] = v);
      }
    }
  },
  triangulate: function(r, e) {
    var t = r.points, i = e.points, n = e.indices;
    if (t.length !== 0) {
      var o = i.length / 2, s = o, a, h;
      if (r.type !== Dt.RREC) {
        var u = r.shape;
        a = u.x, h = u.y;
      } else {
        var l = r.shape;
        a = l.x + l.width / 2, h = l.y + l.height / 2;
      }
      var c = r.matrix;
      i.push(r.matrix ? c.a * a + c.c * h + c.tx : a, r.matrix ? c.b * a + c.d * h + c.ty : h), o++, i.push(t[0], t[1]);
      for (var p = 2; p < t.length; p += 2)
        i.push(t[p], t[p + 1]), n.push(o++, s, o);
      n.push(s + 1, s, o);
    }
  }
}, h0 = {
  build: function(r) {
    var e = r.shape, t = e.x, i = e.y, n = e.width, o = e.height, s = r.points;
    s.length = 0, s.push(t, i, t + n, i, t + n, i + o, t, i + o);
  },
  triangulate: function(r, e) {
    var t = r.points, i = e.points, n = i.length / 2;
    i.push(t[0], t[1], t[2], t[3], t[6], t[7], t[4], t[5]), e.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3);
  }
};
function lr(r, e, t) {
  var i = e - r;
  return r + i * t;
}
function Xi(r, e, t, i, n, o, s) {
  s === void 0 && (s = []);
  for (var a = 20, h = s, u = 0, l = 0, c = 0, p = 0, d = 0, f = 0, y = 0, m = 0; y <= a; ++y)
    m = y / a, u = lr(r, t, m), l = lr(e, i, m), c = lr(t, n, m), p = lr(i, o, m), d = lr(u, c, m), f = lr(l, p, m), !(y === 0 && h[h.length - 2] === d && h[h.length - 1] === f) && h.push(d, f);
  return h;
}
var u0 = {
  build: function(r) {
    if (rr.nextRoundedRectBehavior) {
      dn.build(r);
      return;
    }
    var e = r.shape, t = r.points, i = e.x, n = e.y, o = e.width, s = e.height, a = Math.max(0, Math.min(e.radius, Math.min(o, s) / 2));
    t.length = 0, a ? (Xi(i, n + a, i, n, i + a, n, t), Xi(i + o - a, n, i + o, n, i + o, n + a, t), Xi(i + o, n + s - a, i + o, n + s, i + o - a, n + s, t), Xi(i + a, n + s, i, n + s, i, n + s - a, t)) : t.push(i, n, i + o, n, i + o, n + s, i, n + s);
  },
  triangulate: function(r, e) {
    if (rr.nextRoundedRectBehavior) {
      dn.triangulate(r, e);
      return;
    }
    for (var t = r.points, i = e.points, n = e.indices, o = i.length / 2, s = nu(t, null, 2), a = 0, h = s.length; a < h; a += 3)
      n.push(s[a] + o), n.push(s[a + 1] + o), n.push(s[a + 2] + o);
    for (var a = 0, h = t.length; a < h; a++)
      i.push(t[a], t[++a]);
  }
};
function mh(r, e, t, i, n, o, s, a) {
  var h = r - t * n, u = e - i * n, l = r + t * o, c = e + i * o, p, d;
  s ? (p = i, d = -t) : (p = -i, d = t);
  var f = h + p, y = u + d, m = l + p, _ = c + d;
  return a.push(f, y), a.push(m, _), 2;
}
function Ue(r, e, t, i, n, o, s, a) {
  var h = t - r, u = i - e, l = Math.atan2(h, u), c = Math.atan2(n - r, o - e);
  a && l < c ? l += Math.PI * 2 : !a && l > c && (c += Math.PI * 2);
  var p = l, d = c - l, f = Math.abs(d), y = Math.sqrt(h * h + u * u), m = (15 * f * Math.sqrt(y) / Math.PI >> 0) + 1, _ = d / m;
  if (p += _, a) {
    s.push(r, e), s.push(t, i);
    for (var g = 1, b = p; g < m; g++, b += _)
      s.push(r, e), s.push(r + Math.sin(b) * y, e + Math.cos(b) * y);
    s.push(r, e), s.push(n, o);
  } else {
    s.push(t, i), s.push(r, e);
    for (var g = 1, b = p; g < m; g++, b += _)
      s.push(r + Math.sin(b) * y, e + Math.cos(b) * y), s.push(r, e);
    s.push(n, o), s.push(r, e);
  }
  return m * 2;
}
function l0(r, e) {
  var t = r.shape, i = r.points || t.points.slice(), n = e.closePointEps;
  if (i.length !== 0) {
    var o = r.lineStyle, s = new _t(i[0], i[1]), a = new _t(i[i.length - 2], i[i.length - 1]), h = t.type !== Dt.POLY || t.closeStroke, u = Math.abs(s.x - a.x) < n && Math.abs(s.y - a.y) < n;
    if (h) {
      i = i.slice(), u && (i.pop(), i.pop(), a.set(i[i.length - 2], i[i.length - 1]));
      var l = (s.x + a.x) * 0.5, c = (a.y + s.y) * 0.5;
      i.unshift(l, c), i.push(l, c);
    }
    var p = e.points, d = i.length / 2, f = i.length, y = p.length / 2, m = o.width / 2, _ = m * m, g = o.miterLimit * o.miterLimit, b = i[0], x = i[1], E = i[2], v = i[3], T = 0, S = 0, R = -(x - v), O = b - E, w = 0, C = 0, B = Math.sqrt(R * R + O * O);
    R /= B, O /= B, R *= m, O *= m;
    var V = o.alignment, F = (1 - V) * 2, D = V * 2;
    h || (o.cap === Oe.ROUND ? f += Ue(b - R * (F - D) * 0.5, x - O * (F - D) * 0.5, b - R * F, x - O * F, b + R * D, x + O * D, p, !0) + 2 : o.cap === Oe.SQUARE && (f += mh(b, x, R, O, F, D, !0, p))), p.push(b - R * F, x - O * F), p.push(b + R * D, x + O * D);
    for (var z = 1; z < d - 1; ++z) {
      b = i[(z - 1) * 2], x = i[(z - 1) * 2 + 1], E = i[z * 2], v = i[z * 2 + 1], T = i[(z + 1) * 2], S = i[(z + 1) * 2 + 1], R = -(x - v), O = b - E, B = Math.sqrt(R * R + O * O), R /= B, O /= B, R *= m, O *= m, w = -(v - S), C = E - T, B = Math.sqrt(w * w + C * C), w /= B, C /= B, w *= m, C *= m;
      var ot = E - b, K = x - v, M = E - T, I = S - v, X = ot * M + K * I, Z = K * M - I * ot, Q = Z < 0;
      if (Math.abs(Z) < 1e-3 * Math.abs(X)) {
        p.push(E - R * F, v - O * F), p.push(E + R * D, v + O * D), X >= 0 && (o.join === ve.ROUND ? f += Ue(E, v, E - R * F, v - O * F, E - w * F, v - C * F, p, !1) + 4 : f += 2, p.push(E - w * D, v - C * D), p.push(E + w * F, v + C * F));
        continue;
      }
      var mt = (-R + b) * (-O + v) - (-R + E) * (-O + x), q = (-w + T) * (-C + v) - (-w + E) * (-C + S), lt = (ot * q - M * mt) / Z, vt = (I * mt - K * q) / Z, At = (lt - E) * (lt - E) + (vt - v) * (vt - v), tt = E + (lt - E) * F, nt = v + (vt - v) * F, ht = E - (lt - E) * D, pt = v - (vt - v) * D, J = Math.min(ot * ot + K * K, M * M + I * I), G = Q ? F : D, N = J + G * G * _, ut = At <= N;
      ut ? o.join === ve.BEVEL || At / _ > g ? (Q ? (p.push(tt, nt), p.push(E + R * D, v + O * D), p.push(tt, nt), p.push(E + w * D, v + C * D)) : (p.push(E - R * F, v - O * F), p.push(ht, pt), p.push(E - w * F, v - C * F), p.push(ht, pt)), f += 2) : o.join === ve.ROUND ? Q ? (p.push(tt, nt), p.push(E + R * D, v + O * D), f += Ue(E, v, E + R * D, v + O * D, E + w * D, v + C * D, p, !0) + 4, p.push(tt, nt), p.push(E + w * D, v + C * D)) : (p.push(E - R * F, v - O * F), p.push(ht, pt), f += Ue(E, v, E - R * F, v - O * F, E - w * F, v - C * F, p, !1) + 4, p.push(E - w * F, v - C * F), p.push(ht, pt)) : (p.push(tt, nt), p.push(ht, pt)) : (p.push(E - R * F, v - O * F), p.push(E + R * D, v + O * D), o.join === ve.ROUND ? Q ? f += Ue(E, v, E + R * D, v + O * D, E + w * D, v + C * D, p, !0) + 2 : f += Ue(E, v, E - R * F, v - O * F, E - w * F, v - C * F, p, !1) + 2 : o.join === ve.MITER && At / _ <= g && (Q ? (p.push(ht, pt), p.push(ht, pt)) : (p.push(tt, nt), p.push(tt, nt)), f += 2), p.push(E - w * F, v - C * F), p.push(E + w * D, v + C * D), f += 2);
    }
    b = i[(d - 2) * 2], x = i[(d - 2) * 2 + 1], E = i[(d - 1) * 2], v = i[(d - 1) * 2 + 1], R = -(x - v), O = b - E, B = Math.sqrt(R * R + O * O), R /= B, O /= B, R *= m, O *= m, p.push(E - R * F, v - O * F), p.push(E + R * D, v + O * D), h || (o.cap === Oe.ROUND ? f += Ue(E - R * (F - D) * 0.5, v - O * (F - D) * 0.5, E - R * F, v - O * F, E + R * D, v + O * D, p, !1) + 2 : o.cap === Oe.SQUARE && (f += mh(E, v, R, O, F, D, !1, p)));
    for (var oe = e.indices, nr = ni.epsilon * ni.epsilon, z = y; z < f + y - 2; ++z)
      b = p[z * 2], x = p[z * 2 + 1], E = p[(z + 1) * 2], v = p[(z + 1) * 2 + 1], T = p[(z + 2) * 2], S = p[(z + 2) * 2 + 1], !(Math.abs(b * (v - S) + E * (S - x) + T * (x - v)) < nr) && oe.push(z, z + 1, z + 2);
  }
}
function c0(r, e) {
  var t = 0, i = r.shape, n = r.points || i.points, o = i.type !== Dt.POLY || i.closeStroke;
  if (n.length !== 0) {
    var s = e.points, a = e.indices, h = n.length / 2, u = s.length / 2, l = u;
    for (s.push(n[0], n[1]), t = 1; t < h; t++)
      s.push(n[t * 2], n[t * 2 + 1]), a.push(l, l + 1), l++;
    o && a.push(l, u);
  }
}
function _h(r, e) {
  r.lineStyle.native ? c0(r, e) : l0(r, e);
}
var gh = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveTo = function(e, t, i, n, o, s) {
      var a = s[s.length - 2], h = s[s.length - 1], u = h - t, l = a - e, c = n - t, p = i - e, d = Math.abs(u * p - l * c);
      if (d < 1e-8 || o === 0)
        return (s[s.length - 2] !== e || s[s.length - 1] !== t) && s.push(e, t), null;
      var f = u * u + l * l, y = c * c + p * p, m = u * c + l * p, _ = o * Math.sqrt(f) / d, g = o * Math.sqrt(y) / d, b = _ * m / f, x = g * m / y, E = _ * p + g * l, v = _ * c + g * u, T = l * (g + b), S = u * (g + b), R = p * (_ + x), O = c * (_ + x), w = Math.atan2(S - v, T - E), C = Math.atan2(O - v, R - E);
      return {
        cx: E + e,
        cy: v + t,
        radius: o,
        startAngle: w,
        endAngle: C,
        anticlockwise: l * c > p * u
      };
    }, r.arc = function(e, t, i, n, o, s, a, h, u) {
      for (var l = a - s, c = ni._segmentsCount(Math.abs(l) * o, Math.ceil(Math.abs(l) / un) * 40), p = l / (c * 2), d = p * 2, f = Math.cos(p), y = Math.sin(p), m = c - 1, _ = m % 1 / m, g = 0; g <= m; ++g) {
        var b = g + _ * g, x = p + s + d * b, E = Math.cos(x), v = -Math.sin(x);
        u.push((f * E + y * v) * o + i, (f * -v + y * E) * o + n);
      }
    }, r;
  }()
), p0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveLength = function(e, t, i, n, o, s, a, h) {
      for (var u = 10, l = 0, c = 0, p = 0, d = 0, f = 0, y = 0, m = 0, _ = 0, g = 0, b = 0, x = 0, E = e, v = t, T = 1; T <= u; ++T)
        c = T / u, p = c * c, d = p * c, f = 1 - c, y = f * f, m = y * f, _ = m * e + 3 * y * c * i + 3 * f * p * o + d * a, g = m * t + 3 * y * c * n + 3 * f * p * s + d * h, b = E - _, x = v - g, E = _, v = g, l += Math.sqrt(b * b + x * x);
      return l;
    }, r.curveTo = function(e, t, i, n, o, s, a) {
      var h = a[a.length - 2], u = a[a.length - 1];
      a.length -= 2;
      var l = ni._segmentsCount(r.curveLength(h, u, e, t, i, n, o, s)), c = 0, p = 0, d = 0, f = 0, y = 0;
      a.push(h, u);
      for (var m = 1, _ = 0; m <= l; ++m)
        _ = m / l, c = 1 - _, p = c * c, d = p * c, f = _ * _, y = f * _, a.push(d * h + 3 * p * _ * e + 3 * c * f * i + y * o, d * u + 3 * p * _ * t + 3 * c * f * n + y * s);
    }, r;
  }()
), d0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.curveLength = function(e, t, i, n, o, s) {
      var a = e - 2 * i + o, h = t - 2 * n + s, u = 2 * i - 2 * e, l = 2 * n - 2 * t, c = 4 * (a * a + h * h), p = 4 * (a * u + h * l), d = u * u + l * l, f = 2 * Math.sqrt(c + p + d), y = Math.sqrt(c), m = 2 * c * y, _ = 2 * Math.sqrt(d), g = p / y;
      return (m * f + y * p * (f - _) + (4 * d * c - p * p) * Math.log((2 * y + g + f) / (g + _))) / (4 * m);
    }, r.curveTo = function(e, t, i, n, o) {
      for (var s = o[o.length - 2], a = o[o.length - 1], h = ni._segmentsCount(r.curveLength(s, a, e, t, i, n)), u = 0, l = 0, c = 1; c <= h; ++c) {
        var p = c / h;
        u = s + (e - s) * p, l = a + (t - a) * p, o.push(u + (e + (i - e) * p - u) * p, l + (t + (n - t) * p - l) * p);
      }
    }, r;
  }()
), f0 = (
  /** @class */
  function() {
    function r() {
      this.reset();
    }
    return r.prototype.begin = function(e, t, i) {
      this.reset(), this.style = e, this.start = t, this.attribStart = i;
    }, r.prototype.end = function(e, t) {
      this.attribSize = t - this.attribStart, this.size = e - this.start;
    }, r.prototype.reset = function() {
      this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0;
    }, r;
  }()
), ke, lo = (ke = {}, ke[Dt.POLY] = Zu, ke[Dt.CIRC] = dn, ke[Dt.ELIP] = dn, ke[Dt.RECT] = h0, ke[Dt.RREC] = u0, ke), vh = [], ji = [], bh = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      t === void 0 && (t = null), i === void 0 && (i = null), n === void 0 && (n = null), this.points = [], this.holes = [], this.shape = e, this.lineStyle = i, this.fillStyle = t, this.matrix = n, this.type = e.type;
    }
    return r.prototype.clone = function() {
      return new r(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }, r.prototype.destroy = function() {
      this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null;
    }, r;
  }()
), cr = new _t(), y0 = (
  /** @class */
  function(r) {
    Ps(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.closePointEps = 1e-4, t.boundsPadding = 0, t.uvsFloat32 = null, t.indicesUint16 = null, t.batchable = !1, t.points = [], t.colors = [], t.uvs = [], t.indices = [], t.textureIds = [], t.graphicsData = [], t.drawCalls = [], t.batchDirty = -1, t.batches = [], t.dirty = 0, t.cacheDirty = -1, t.clearDirty = 0, t.shapeIndex = 0, t._bounds = new ln(), t.boundsDirty = -1, t;
    }
    return Object.defineProperty(e.prototype, "bounds", {
      /**
       * Get the current bounds of the graphic geometry.
       * @readonly
       */
      get: function() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.invalidate = function() {
      this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
      for (var t = 0; t < this.drawCalls.length; t++)
        this.drawCalls[t].texArray.clear(), ji.push(this.drawCalls[t]);
      this.drawCalls.length = 0;
      for (var t = 0; t < this.batches.length; t++) {
        var i = this.batches[t];
        i.reset(), vh.push(i);
      }
      this.batches.length = 0;
    }, e.prototype.clear = function() {
      return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
    }, e.prototype.drawShape = function(t, i, n, o) {
      i === void 0 && (i = null), n === void 0 && (n = null), o === void 0 && (o = null);
      var s = new bh(t, i, n, o);
      return this.graphicsData.push(s), this.dirty++, this;
    }, e.prototype.drawHole = function(t, i) {
      if (i === void 0 && (i = null), !this.graphicsData.length)
        return null;
      var n = new bh(t, null, null, i), o = this.graphicsData[this.graphicsData.length - 1];
      return n.lineStyle = o.lineStyle, o.holes.push(n), this.dirty++, this;
    }, e.prototype.destroy = function() {
      r.prototype.destroy.call(this);
      for (var t = 0; t < this.graphicsData.length; ++t)
        this.graphicsData[t].destroy();
      this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null;
    }, e.prototype.containsPoint = function(t) {
      for (var i = this.graphicsData, n = 0; n < i.length; ++n) {
        var o = i[n];
        if (o.fillStyle.visible && o.shape && (o.matrix ? o.matrix.applyInverse(t, cr) : cr.copyFrom(t), o.shape.contains(cr.x, cr.y))) {
          var s = !1;
          if (o.holes)
            for (var a = 0; a < o.holes.length; a++) {
              var h = o.holes[a];
              if (h.shape.contains(cr.x, cr.y)) {
                s = !0;
                break;
              }
            }
          if (!s)
            return !0;
        }
      }
      return !1;
    }, e.prototype.updateBatches = function() {
      if (!this.graphicsData.length) {
        this.batchable = !0;
        return;
      }
      if (this.validateBatching()) {
        this.cacheDirty = this.dirty;
        var t = this.uvs, i = this.graphicsData, n = null, o = null;
        this.batches.length > 0 && (n = this.batches[this.batches.length - 1], o = n.style);
        for (var s = this.shapeIndex; s < i.length; s++) {
          this.shapeIndex++;
          var a = i[s], h = a.fillStyle, u = a.lineStyle, l = lo[a.type];
          l.build(a), a.matrix && this.transformPoints(a.points, a.matrix), (h.visible || u.visible) && this.processHoles(a.holes);
          for (var c = 0; c < 2; c++) {
            var p = c === 0 ? h : u;
            if (p.visible) {
              var d = p.texture.baseTexture, f = this.indices.length, y = this.points.length / 2;
              d.wrapMode = le.REPEAT, c === 0 ? this.processFill(a) : this.processLine(a);
              var m = this.points.length / 2 - y;
              m !== 0 && (n && !this._compareStyles(o, p) && (n.end(f, y), n = null), n || (n = vh.pop() || new f0(), n.begin(p, f, y), this.batches.push(n), o = p), this.addUvs(this.points, t, p.texture, y, m, p.matrix));
            }
          }
        }
        var _ = this.indices.length, g = this.points.length / 2;
        if (n && n.end(_, g), this.batches.length === 0) {
          this.batchable = !0;
          return;
        }
        var b = g > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && b === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = b ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls();
      }
    }, e.prototype._compareStyles = function(t, i) {
      return !(!t || !i || t.texture.baseTexture !== i.texture.baseTexture || t.color + t.alpha !== i.color + i.alpha || !!t.native != !!i.native);
    }, e.prototype.validateBatching = function() {
      if (this.dirty === this.cacheDirty || !this.graphicsData.length)
        return !1;
      for (var t = 0, i = this.graphicsData.length; t < i; t++) {
        var n = this.graphicsData[t], o = n.fillStyle, s = n.lineStyle;
        if (o && !o.texture.baseTexture.valid || s && !s.texture.baseTexture.valid)
          return !1;
      }
      return !0;
    }, e.prototype.packBatches = function() {
      this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
      for (var t = this.batches, i = 0, n = t.length; i < n; i++)
        for (var o = t[i], s = 0; s < o.size; s++) {
          var a = o.start + s;
          this.indicesUint16[a] = this.indicesUint16[a] - o.attribStart;
        }
    }, e.prototype.isBatchable = function() {
      if (this.points.length > 65535 * 2)
        return !1;
      for (var t = this.batches, i = 0; i < t.length; i++)
        if (t[i].style.native)
          return !1;
      return this.points.length < e.BATCHABLE_SIZE * 2;
    }, e.prototype.buildDrawCalls = function() {
      for (var t = ++rt._globalBatch, i = 0; i < this.drawCalls.length; i++)
        this.drawCalls[i].texArray.clear(), ji.push(this.drawCalls[i]);
      this.drawCalls.length = 0;
      var n = this.colors, o = this.textureIds, s = ji.pop();
      s || (s = new Xo(), s.texArray = new jo()), s.texArray.count = 0, s.start = 0, s.size = 0, s.type = te.TRIANGLES;
      var a = 0, h = null, u = 0, l = !1, c = te.TRIANGLES, p = 0;
      this.drawCalls.push(s);
      for (var i = 0; i < this.batches.length; i++) {
        var d = this.batches[i], f = 8, y = d.style, m = y.texture.baseTexture;
        l !== !!y.native && (l = !!y.native, c = l ? te.LINES : te.TRIANGLES, h = null, a = f, t++), h !== m && (h = m, m._batchEnabled !== t && (a === f && (t++, a = 0, s.size > 0 && (s = ji.pop(), s || (s = new Xo(), s.texArray = new jo()), this.drawCalls.push(s)), s.start = p, s.size = 0, s.texArray.count = 0, s.type = c), m.touched = 1, m._batchEnabled = t, m._batchLocation = a, m.wrapMode = le.REPEAT, s.texArray.elements[s.texArray.count++] = m, a++)), s.size += d.size, p += d.size, u = m._batchLocation, this.addColors(n, y.color, y.alpha, d.attribSize, d.attribStart), this.addTextureIds(o, u, d.attribSize, d.attribStart);
      }
      rt._globalBatch = t, this.packAttributes();
    }, e.prototype.packAttributes = function() {
      for (var t = this.points, i = this.uvs, n = this.colors, o = this.textureIds, s = new ArrayBuffer(t.length * 3 * 4), a = new Float32Array(s), h = new Uint32Array(s), u = 0, l = 0; l < t.length / 2; l++)
        a[u++] = t[l * 2], a[u++] = t[l * 2 + 1], a[u++] = i[l * 2], a[u++] = i[l * 2 + 1], h[u++] = n[l], a[u++] = o[l];
      this._buffer.update(s), this._indexBuffer.update(this.indicesUint16);
    }, e.prototype.processFill = function(t) {
      if (t.holes.length)
        Zu.triangulate(t, this);
      else {
        var i = lo[t.type];
        i.triangulate(t, this);
      }
    }, e.prototype.processLine = function(t) {
      _h(t, this);
      for (var i = 0; i < t.holes.length; i++)
        _h(t.holes[i], this);
    }, e.prototype.processHoles = function(t) {
      for (var i = 0; i < t.length; i++) {
        var n = t[i], o = lo[n.type];
        o.build(n), n.matrix && this.transformPoints(n.points, n.matrix);
      }
    }, e.prototype.calculateBounds = function() {
      var t = this._bounds;
      t.clear(), t.addVertexData(this.points, 0, this.points.length), t.pad(this.boundsPadding, this.boundsPadding);
    }, e.prototype.transformPoints = function(t, i) {
      for (var n = 0; n < t.length / 2; n++) {
        var o = t[n * 2], s = t[n * 2 + 1];
        t[n * 2] = i.a * o + i.c * s + i.tx, t[n * 2 + 1] = i.b * o + i.d * s + i.ty;
      }
    }, e.prototype.addColors = function(t, i, n, o, s) {
      s === void 0 && (s = 0);
      var a = (i >> 16) + (i & 65280) + ((i & 255) << 16), h = Os(a, n);
      t.length = Math.max(t.length, s + o);
      for (var u = 0; u < o; u++)
        t[s + u] = h;
    }, e.prototype.addTextureIds = function(t, i, n, o) {
      o === void 0 && (o = 0), t.length = Math.max(t.length, o + n);
      for (var s = 0; s < n; s++)
        t[o + s] = i;
    }, e.prototype.addUvs = function(t, i, n, o, s, a) {
      a === void 0 && (a = null);
      for (var h = 0, u = i.length, l = n.frame; h < s; ) {
        var c = t[(o + h) * 2], p = t[(o + h) * 2 + 1];
        if (a) {
          var d = a.a * c + a.c * p + a.tx;
          p = a.b * c + a.d * p + a.ty, c = d;
        }
        h++, i.push(c / l.width, p / l.height);
      }
      var f = n.baseTexture;
      (l.width < f.width || l.height < f.height) && this.adjustUvs(i, n, u, s);
    }, e.prototype.adjustUvs = function(t, i, n, o) {
      for (var s = i.baseTexture, a = 1e-6, h = n + o * 2, u = i.frame, l = u.width / s.width, c = u.height / s.height, p = u.x / u.width, d = u.y / u.height, f = Math.floor(t[n] + a), y = Math.floor(t[n + 1] + a), m = n + 2; m < h; m += 2)
        f = Math.min(f, Math.floor(t[m] + a)), y = Math.min(y, Math.floor(t[m + 1] + a));
      p -= f, d -= y;
      for (var m = n; m < h; m += 2)
        t[m] = (t[m] + p) * l, t[m + 1] = (t[m + 1] + d) * c;
    }, e.BATCHABLE_SIZE = 100, e;
  }(Yu)
), m0 = (
  /** @class */
  function(r) {
    Ps(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.width = 0, t.alignment = 0.5, t.native = !1, t.cap = Oe.BUTT, t.join = ve.MITER, t.miterLimit = 10, t;
    }
    return e.prototype.clone = function() {
      var t = new e();
      return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t;
    }, e.prototype.reset = function() {
      r.prototype.reset.call(this), this.color = 0, this.alignment = 0.5, this.width = 0, this.native = !1;
    }, e;
  }(Ku)
), _0 = new Float32Array(3), co = {}, rr = (
  /** @class */
  function(r) {
    Ps(e, r);
    function e(t) {
      t === void 0 && (t = null);
      var i = r.call(this) || this;
      return i.shader = null, i.pluginName = "batch", i.currentPath = null, i.batches = [], i.batchTint = -1, i.batchDirty = -1, i.vertexData = null, i._fillStyle = new Ku(), i._lineStyle = new m0(), i._matrix = null, i._holeMode = !1, i.state = ir.for2d(), i._geometry = t || new y0(), i._geometry.refCount++, i._transformID = -1, i.tint = 16777215, i.blendMode = k.NORMAL, i;
    }
    return Object.defineProperty(e.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
       * @readonly
       */
      get: function() {
        return this._geometry;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.clone = function() {
      return this.finishPoly(), new e(this._geometry);
    }, Object.defineProperty(e.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the graphic shape. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each
       * primitive in the GraphicsGeometry list is rendered sequentially, modes
       * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will
       * be applied per-primitive.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      set: function(t) {
        this.state.blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tint", {
      /**
       * The tint applied to each graphic shape. This is a hex value. A value of
       * 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(t) {
        this._tint = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "fill", {
      /**
       * The current fill style.
       * @readonly
       */
      get: function() {
        return this._fillStyle;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "line", {
      /**
       * The current line style.
       * @readonly
       */
      get: function() {
        return this._lineStyle;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.lineStyle = function(t, i, n, o, s) {
      return t === void 0 && (t = null), i === void 0 && (i = 0), n === void 0 && (n = 1), o === void 0 && (o = 0.5), s === void 0 && (s = !1), typeof t == "number" && (t = { width: t, color: i, alpha: n, alignment: o, native: s }), this.lineTextureStyle(t);
    }, e.prototype.lineTextureStyle = function(t) {
      t = Object.assign({
        width: 0,
        texture: W.WHITE,
        color: t && t.texture ? 16777215 : 0,
        alpha: 1,
        matrix: null,
        alignment: 0.5,
        native: !1,
        cap: Oe.BUTT,
        join: ve.MITER,
        miterLimit: 10
      }, t), this.currentPath && this.startPoly();
      var i = t.width > 0 && t.alpha > 0;
      return i ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._lineStyle, { visible: i }, t)) : this._lineStyle.reset(), this;
    }, e.prototype.startPoly = function() {
      if (this.currentPath) {
        var t = this.currentPath.points, i = this.currentPath.points.length;
        i > 2 && (this.drawShape(this.currentPath), this.currentPath = new $i(), this.currentPath.closeStroke = !1, this.currentPath.points.push(t[i - 2], t[i - 1]));
      } else
        this.currentPath = new $i(), this.currentPath.closeStroke = !1;
    }, e.prototype.finishPoly = function() {
      this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
    }, e.prototype.moveTo = function(t, i) {
      return this.startPoly(), this.currentPath.points[0] = t, this.currentPath.points[1] = i, this;
    }, e.prototype.lineTo = function(t, i) {
      this.currentPath || this.moveTo(0, 0);
      var n = this.currentPath.points, o = n[n.length - 2], s = n[n.length - 1];
      return (o !== t || s !== i) && n.push(t, i), this;
    }, e.prototype._initCurve = function(t, i) {
      t === void 0 && (t = 0), i === void 0 && (i = 0), this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [t, i]) : this.moveTo(t, i);
    }, e.prototype.quadraticCurveTo = function(t, i, n, o) {
      this._initCurve();
      var s = this.currentPath.points;
      return s.length === 0 && this.moveTo(0, 0), d0.curveTo(t, i, n, o, s), this;
    }, e.prototype.bezierCurveTo = function(t, i, n, o, s, a) {
      return this._initCurve(), p0.curveTo(t, i, n, o, s, a, this.currentPath.points), this;
    }, e.prototype.arcTo = function(t, i, n, o, s) {
      this._initCurve(t, i);
      var a = this.currentPath.points, h = gh.curveTo(t, i, n, o, s, a);
      if (h) {
        var u = h.cx, l = h.cy, c = h.radius, p = h.startAngle, d = h.endAngle, f = h.anticlockwise;
        this.arc(u, l, c, p, d, f);
      }
      return this;
    }, e.prototype.arc = function(t, i, n, o, s, a) {
      if (a === void 0 && (a = !1), o === s)
        return this;
      !a && s <= o ? s += un : a && o <= s && (o += un);
      var h = s - o;
      if (h === 0)
        return this;
      var u = t + Math.cos(o) * n, l = i + Math.sin(o) * n, c = this._geometry.closePointEps, p = this.currentPath ? this.currentPath.points : null;
      if (p) {
        var d = Math.abs(p[p.length - 2] - u), f = Math.abs(p[p.length - 1] - l);
        d < c && f < c || p.push(u, l);
      } else
        this.moveTo(u, l), p = this.currentPath.points;
      return gh.arc(u, l, t, i, n, o, s, a, p), this;
    }, e.prototype.beginFill = function(t, i) {
      return t === void 0 && (t = 0), i === void 0 && (i = 1), this.beginTextureFill({ texture: W.WHITE, color: t, alpha: i });
    }, e.prototype.beginTextureFill = function(t) {
      t = Object.assign({
        texture: W.WHITE,
        color: 16777215,
        alpha: 1,
        matrix: null
      }, t), this.currentPath && this.startPoly();
      var i = t.alpha > 0;
      return i ? (t.matrix && (t.matrix = t.matrix.clone(), t.matrix.invert()), Object.assign(this._fillStyle, { visible: i }, t)) : this._fillStyle.reset(), this;
    }, e.prototype.endFill = function() {
      return this.finishPoly(), this._fillStyle.reset(), this;
    }, e.prototype.drawRect = function(t, i, n, o) {
      return this.drawShape(new it(t, i, n, o));
    }, e.prototype.drawRoundedRect = function(t, i, n, o, s) {
      return this.drawShape(new E_(t, i, n, o, s));
    }, e.prototype.drawCircle = function(t, i, n) {
      return this.drawShape(new x_(t, i, n));
    }, e.prototype.drawEllipse = function(t, i, n, o) {
      return this.drawShape(new T_(t, i, n, o));
    }, e.prototype.drawPolygon = function() {
      for (var t = arguments, i = [], n = 0; n < arguments.length; n++)
        i[n] = t[n];
      var o, s = !0, a = i[0];
      a.points ? (s = a.closeStroke, o = a.points) : Array.isArray(i[0]) ? o = i[0] : o = i;
      var h = new $i(o);
      return h.closeStroke = s, this.drawShape(h), this;
    }, e.prototype.drawShape = function(t) {
      return this._holeMode ? this._geometry.drawHole(t, this._matrix) : this._geometry.drawShape(t, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
    }, e.prototype.clear = function() {
      return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
    }, e.prototype.isFastRect = function() {
      var t = this._geometry.graphicsData;
      return t.length === 1 && t[0].shape.type === Dt.RECT && !t[0].matrix && !t[0].holes.length && !(t[0].lineStyle.visible && t[0].lineStyle.width);
    }, e.prototype._render = function(t) {
      this.finishPoly();
      var i = this._geometry;
      i.updateBatches(), i.batchable ? (this.batchDirty !== i.batchDirty && this._populateBatches(), this._renderBatched(t)) : (t.batch.flush(), this._renderDirect(t));
    }, e.prototype._populateBatches = function() {
      var t = this._geometry, i = this.blendMode, n = t.batches.length;
      this.batchTint = -1, this._transformID = -1, this.batchDirty = t.batchDirty, this.batches.length = n, this.vertexData = new Float32Array(t.points);
      for (var o = 0; o < n; o++) {
        var s = t.batches[o], a = s.style.color, h = new Float32Array(this.vertexData.buffer, s.attribStart * 4 * 2, s.attribSize * 2), u = new Float32Array(t.uvsFloat32.buffer, s.attribStart * 4 * 2, s.attribSize * 2), l = new Uint16Array(t.indicesUint16.buffer, s.start * 2, s.size), c = {
          vertexData: h,
          blendMode: i,
          indices: l,
          uvs: u,
          _batchRGB: wr(a),
          _tintRGB: a,
          _texture: s.style.texture,
          alpha: s.style.alpha,
          worldAlpha: 1
        };
        this.batches[o] = c;
      }
    }, e.prototype._renderBatched = function(t) {
      if (this.batches.length) {
        t.batch.setObjectRenderer(t.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
        for (var i = 0, n = this.batches.length; i < n; i++) {
          var o = this.batches[i];
          o.worldAlpha = this.worldAlpha * o.alpha, t.plugins[this.pluginName].render(o);
        }
      }
    }, e.prototype._renderDirect = function(t) {
      var i = this._resolveDirectShader(t), n = this._geometry, o = this.tint, s = this.worldAlpha, a = i.uniforms, h = n.drawCalls;
      a.translationMatrix = this.transform.worldTransform, a.tint[0] = (o >> 16 & 255) / 255 * s, a.tint[1] = (o >> 8 & 255) / 255 * s, a.tint[2] = (o & 255) / 255 * s, a.tint[3] = s, t.shader.bind(i), t.geometry.bind(n, i), t.state.set(this.state);
      for (var u = 0, l = h.length; u < l; u++)
        this._renderDrawCallDirect(t, n.drawCalls[u]);
    }, e.prototype._renderDrawCallDirect = function(t, i) {
      for (var n = i.texArray, o = i.type, s = i.size, a = i.start, h = n.count, u = 0; u < h; u++)
        t.texture.bind(n.elements[u], u);
      t.geometry.draw(o, s, a);
    }, e.prototype._resolveDirectShader = function(t) {
      var i = this.shader, n = this.pluginName;
      if (!i) {
        if (!co[n]) {
          for (var o = t.plugins[n].MAX_TEXTURES, s = new Int32Array(o), a = 0; a < o; a++)
            s[a] = a;
          var h = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new It(),
            default: Je.from({ uSamplers: s }, !0)
          }, u = t.plugins[n]._shader.program;
          co[n] = new we(u, h);
        }
        i = co[n];
      }
      return i;
    }, e.prototype._calculateBounds = function() {
      this.finishPoly();
      var t = this._geometry;
      if (t.graphicsData.length) {
        var i = t.bounds, n = i.minX, o = i.minY, s = i.maxX, a = i.maxY;
        this._bounds.addFrame(this.transform, n, o, s, a);
      }
    }, e.prototype.containsPoint = function(t) {
      return this.worldTransform.applyInverse(t, e._TEMP_POINT), this._geometry.containsPoint(e._TEMP_POINT);
    }, e.prototype.calculateTints = function() {
      if (this.batchTint !== this.tint) {
        this.batchTint = this.tint;
        for (var t = wr(this.tint, _0), i = 0; i < this.batches.length; i++) {
          var n = this.batches[i], o = n._batchRGB, s = t[0] * o[0] * 255, a = t[1] * o[1] * 255, h = t[2] * o[2] * 255, u = (s << 16) + (a << 8) + (h | 0);
          n._tintRGB = (u >> 16) + (u & 65280) + ((u & 255) << 16);
        }
      }
    }, e.prototype.calculateVertices = function() {
      var t = this.transform._worldID;
      if (this._transformID !== t) {
        this._transformID = t;
        for (var i = this.transform.worldTransform, n = i.a, o = i.b, s = i.c, a = i.d, h = i.tx, u = i.ty, l = this._geometry.points, c = this.vertexData, p = 0, d = 0; d < l.length; d += 2) {
          var f = l[d], y = l[d + 1];
          c[p++] = n * f + s * y + h, c[p++] = a * y + o * f + u;
        }
      }
    }, e.prototype.closePath = function() {
      var t = this.currentPath;
      return t && (t.closeStroke = !0, this.finishPoly()), this;
    }, e.prototype.setMatrix = function(t) {
      return this._matrix = t, this;
    }, e.prototype.beginHole = function() {
      return this.finishPoly(), this._holeMode = !0, this;
    }, e.prototype.endHole = function() {
      return this.finishPoly(), this._holeMode = !1, this;
    }, e.prototype.destroy = function(t) {
      this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, r.prototype.destroy.call(this, t);
    }, e.nextRoundedRectBehavior = !1, e._TEMP_POINT = new _t(), e;
  }(pe)
);
/*!
 * @pixi/sprite - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Zo = function(r, e) {
  return Zo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Zo(r, e);
};
function g0(r, e) {
  Zo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Xr = new _t(), v0 = new Uint16Array([0, 1, 2, 0, 2, 3]), di = (
  /** @class */
  function(r) {
    g0(e, r);
    function e(t) {
      var i = r.call(this) || this;
      return i._anchor = new gr(i._onAnchorUpdate, i, t ? t.defaultAnchor.x : 0, t ? t.defaultAnchor.y : 0), i._texture = null, i._width = 0, i._height = 0, i._tint = null, i._tintRGB = null, i.tint = 16777215, i.blendMode = k.NORMAL, i._cachedTint = 16777215, i.uvs = null, i.texture = t || W.EMPTY, i.vertexData = new Float32Array(8), i.vertexTrimmedData = null, i._transformID = -1, i._textureID = -1, i._transformTrimmedID = -1, i._textureTrimmedID = -1, i.indices = v0, i.pluginName = "batch", i.isSprite = !0, i._roundPixels = L.ROUND_PIXELS, i;
    }
    return e.prototype._onTextureUpdate = function() {
      this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = _r(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = _r(this.scale.y) * this._height / this._texture.orig.height);
    }, e.prototype._onAnchorUpdate = function() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }, e.prototype.calculateVertices = function() {
      var t = this._texture;
      if (!(this._transformID === this.transform._worldID && this._textureID === t._updateID)) {
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
        var i = this.transform.worldTransform, n = i.a, o = i.b, s = i.c, a = i.d, h = i.tx, u = i.ty, l = this.vertexData, c = t.trim, p = t.orig, d = this._anchor, f = 0, y = 0, m = 0, _ = 0;
        if (c ? (y = c.x - d._x * p.width, f = y + c.width, _ = c.y - d._y * p.height, m = _ + c.height) : (y = -d._x * p.width, f = y + p.width, _ = -d._y * p.height, m = _ + p.height), l[0] = n * y + s * _ + h, l[1] = a * _ + o * y + u, l[2] = n * f + s * _ + h, l[3] = a * _ + o * f + u, l[4] = n * f + s * m + h, l[5] = a * m + o * f + u, l[6] = n * y + s * m + h, l[7] = a * m + o * y + u, this._roundPixels)
          for (var g = L.RESOLUTION, b = 0; b < l.length; ++b)
            l[b] = Math.round((l[b] * g | 0) / g);
      }
    }, e.prototype.calculateTrimmedVertices = function() {
      if (!this.vertexTrimmedData)
        this.vertexTrimmedData = new Float32Array(8);
      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
        return;
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var t = this._texture, i = this.vertexTrimmedData, n = t.orig, o = this._anchor, s = this.transform.worldTransform, a = s.a, h = s.b, u = s.c, l = s.d, c = s.tx, p = s.ty, d = -o._x * n.width, f = d + n.width, y = -o._y * n.height, m = y + n.height;
      i[0] = a * d + u * y + c, i[1] = l * y + h * d + p, i[2] = a * f + u * y + c, i[3] = l * y + h * f + p, i[4] = a * f + u * m + c, i[5] = l * m + h * f + p, i[6] = a * d + u * m + c, i[7] = l * m + h * d + p;
    }, e.prototype._render = function(t) {
      this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this);
    }, e.prototype._calculateBounds = function() {
      var t = this._texture.trim, i = this._texture.orig;
      !t || t.width === i.width && t.height === i.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }, e.prototype.getLocalBounds = function(t) {
      return this.children.length === 0 ? (this._localBounds || (this._localBounds = new ln()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new it()), t = this._localBoundsRect), this._localBounds.getRectangle(t)) : r.prototype.getLocalBounds.call(this, t);
    }, e.prototype.containsPoint = function(t) {
      this.worldTransform.applyInverse(t, Xr);
      var i = this._texture.orig.width, n = this._texture.orig.height, o = -i * this.anchor.x, s = 0;
      return Xr.x >= o && Xr.x < o + i && (s = -n * this.anchor.y, Xr.y >= s && Xr.y < s + n);
    }, e.prototype.destroy = function(t) {
      r.prototype.destroy.call(this, t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
      var i = typeof t == "boolean" ? t : t && t.texture;
      if (i) {
        var n = typeof t == "boolean" ? t : t && t.baseTexture;
        this._texture.destroy(!!n);
      }
      this._texture = null;
    }, e.from = function(t, i) {
      var n = t instanceof W ? t : W.from(t, i);
      return new e(n);
    }, Object.defineProperty(e.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       *
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       *
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}.
       * @default false
       */
      set: function(t) {
        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "width", {
      /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(t) {
        var i = _r(this.scale.x) || 1;
        this.scale.x = i * t / this._texture.orig.width, this._width = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(t) {
        var i = _r(this.scale.y) || 1;
        this.scale.y = i * t / this._texture.orig.height, this._height = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "anchor", {
      /**
       * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}
       * and passed to the constructor.
       *
       * The default is `(0,0)`, this means the sprite's origin is the top left.
       *
       * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.
       *
       * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.
       *
       * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
       * @example
       * const sprite = new PIXI.Sprite(texture);
       * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
       */
      get: function() {
        return this._anchor;
      },
      set: function(t) {
        this._anchor.copyFrom(t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tint", {
      /**
       * The tint applied to the sprite. This is a hex value.
       *
       * A value of 0xFFFFFF will remove any tint effect.
       * @default 0xFFFFFF
       */
      get: function() {
        return this._tint;
      },
      set: function(t) {
        this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "texture", {
      /** The texture that the sprite is using. */
      get: function() {
        return this._texture;
      },
      set: function(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || W.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)));
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(pe)
);
/*!
 * @pixi/text - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Jo = function(r, e) {
  return Jo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Jo(r, e);
};
function b0(r, e) {
  Jo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var oi;
(function(r) {
  r[r.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", r[r.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL";
})(oi || (oi = {}));
var po = {
  align: "left",
  breakWords: !1,
  dropShadow: !1,
  dropShadowAlpha: 1,
  dropShadowAngle: Math.PI / 6,
  dropShadowBlur: 0,
  dropShadowColor: "black",
  dropShadowDistance: 5,
  fill: "black",
  fillGradientType: oi.LINEAR_VERTICAL,
  fillGradientStops: [],
  fontFamily: "Arial",
  fontSize: 26,
  fontStyle: "normal",
  fontVariant: "normal",
  fontWeight: "normal",
  letterSpacing: 0,
  lineHeight: 0,
  lineJoin: "miter",
  miterLimit: 10,
  padding: 0,
  stroke: "black",
  strokeThickness: 0,
  textBaseline: "alphabetic",
  trim: !1,
  whiteSpace: "pre",
  wordWrap: !1,
  wordWrapWidth: 100,
  leading: 0
}, x0 = [
  "serif",
  "sans-serif",
  "monospace",
  "cursive",
  "fantasy",
  "system-ui"
], Pr = (
  /** @class */
  function() {
    function r(e) {
      this.styleID = 0, this.reset(), yo(this, e, e);
    }
    return r.prototype.clone = function() {
      var e = {};
      return yo(e, this, po), new r(e);
    }, r.prototype.reset = function() {
      yo(this, po, po);
    }, Object.defineProperty(r.prototype, "align", {
      /**
       * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
       *
       * @member {string}
       */
      get: function() {
        return this._align;
      },
      set: function(e) {
        this._align !== e && (this._align = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "breakWords", {
      /** Indicates if lines can be wrapped within words, it needs wordWrap to be set to true. */
      get: function() {
        return this._breakWords;
      },
      set: function(e) {
        this._breakWords !== e && (this._breakWords = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadow", {
      /** Set a drop shadow for the text. */
      get: function() {
        return this._dropShadow;
      },
      set: function(e) {
        this._dropShadow !== e && (this._dropShadow = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowAlpha", {
      /** Set alpha for the drop shadow. */
      get: function() {
        return this._dropShadowAlpha;
      },
      set: function(e) {
        this._dropShadowAlpha !== e && (this._dropShadowAlpha = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowAngle", {
      /** Set a angle of the drop shadow. */
      get: function() {
        return this._dropShadowAngle;
      },
      set: function(e) {
        this._dropShadowAngle !== e && (this._dropShadowAngle = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowBlur", {
      /** Set a shadow blur radius. */
      get: function() {
        return this._dropShadowBlur;
      },
      set: function(e) {
        this._dropShadowBlur !== e && (this._dropShadowBlur = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowColor", {
      /** A fill style to be used on the dropshadow e.g 'red', '#00FF00'. */
      get: function() {
        return this._dropShadowColor;
      },
      set: function(e) {
        var t = fo(e);
        this._dropShadowColor !== t && (this._dropShadowColor = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "dropShadowDistance", {
      /** Set a distance of the drop shadow. */
      get: function() {
        return this._dropShadowDistance;
      },
      set: function(e) {
        this._dropShadowDistance !== e && (this._dropShadowDistance = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fill", {
      /**
       * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
       *
       * Can be an array to create a gradient eg ['#000000','#FFFFFF']
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
       *
       * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
       */
      get: function() {
        return this._fill;
      },
      set: function(e) {
        var t = fo(e);
        this._fill !== t && (this._fill = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fillGradientType", {
      /**
       * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
       *
       * @see PIXI.TEXT_GRADIENT
       */
      get: function() {
        return this._fillGradientType;
      },
      set: function(e) {
        this._fillGradientType !== e && (this._fillGradientType = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fillGradientStops", {
      /**
       * If fill is an array of colours to create a gradient, this array can set the stop points
       * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
       */
      get: function() {
        return this._fillGradientStops;
      },
      set: function(e) {
        T0(this._fillGradientStops, e) || (this._fillGradientStops = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontFamily", {
      /** The font family. */
      get: function() {
        return this._fontFamily;
      },
      set: function(e) {
        this.fontFamily !== e && (this._fontFamily = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontSize", {
      /**
       * The font size
       * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
       */
      get: function() {
        return this._fontSize;
      },
      set: function(e) {
        this._fontSize !== e && (this._fontSize = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontStyle", {
      /**
       * The font style
       * ('normal', 'italic' or 'oblique')
       *
       * @member {string}
       */
      get: function() {
        return this._fontStyle;
      },
      set: function(e) {
        this._fontStyle !== e && (this._fontStyle = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontVariant", {
      /**
       * The font variant
       * ('normal' or 'small-caps')
       *
       * @member {string}
       */
      get: function() {
        return this._fontVariant;
      },
      set: function(e) {
        this._fontVariant !== e && (this._fontVariant = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "fontWeight", {
      /**
       * The font weight
       * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
       *
       * @member {string}
       */
      get: function() {
        return this._fontWeight;
      },
      set: function(e) {
        this._fontWeight !== e && (this._fontWeight = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "letterSpacing", {
      /** The amount of spacing between letters, default is 0. */
      get: function() {
        return this._letterSpacing;
      },
      set: function(e) {
        this._letterSpacing !== e && (this._letterSpacing = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lineHeight", {
      /** The line height, a number that represents the vertical space that a letter uses. */
      get: function() {
        return this._lineHeight;
      },
      set: function(e) {
        this._lineHeight !== e && (this._lineHeight = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "leading", {
      /** The space between lines. */
      get: function() {
        return this._leading;
      },
      set: function(e) {
        this._leading !== e && (this._leading = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lineJoin", {
      /**
       * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
       * Default is 'miter' (creates a sharp corner).
       *
       * @member {string}
       */
      get: function() {
        return this._lineJoin;
      },
      set: function(e) {
        this._lineJoin !== e && (this._lineJoin = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "miterLimit", {
      /**
       * The miter limit to use when using the 'miter' lineJoin mode.
       *
       * This can reduce or increase the spikiness of rendered text.
       */
      get: function() {
        return this._miterLimit;
      },
      set: function(e) {
        this._miterLimit !== e && (this._miterLimit = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "padding", {
      /**
       * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
       * by adding padding to all sides of the text.
       */
      get: function() {
        return this._padding;
      },
      set: function(e) {
        this._padding !== e && (this._padding = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "stroke", {
      /**
       * A canvas fillstyle that will be used on the text stroke
       * e.g 'blue', '#FCFF00'
       */
      get: function() {
        return this._stroke;
      },
      set: function(e) {
        var t = fo(e);
        this._stroke !== t && (this._stroke = t, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "strokeThickness", {
      /**
       * A number that represents the thickness of the stroke.
       *
       * @default 0
       */
      get: function() {
        return this._strokeThickness;
      },
      set: function(e) {
        this._strokeThickness !== e && (this._strokeThickness = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "textBaseline", {
      /**
       * The baseline of the text that is rendered.
       *
       * @member {string}
       */
      get: function() {
        return this._textBaseline;
      },
      set: function(e) {
        this._textBaseline !== e && (this._textBaseline = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "trim", {
      /** Trim transparent borders. */
      get: function() {
        return this._trim;
      },
      set: function(e) {
        this._trim !== e && (this._trim = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "whiteSpace", {
      /**
       * How newlines and spaces should be handled.
       * Default is 'pre' (preserve, preserve).
       *
       *  value       | New lines     |   Spaces
       *  ---         | ---           |   ---
       * 'normal'     | Collapse      |   Collapse
       * 'pre'        | Preserve      |   Preserve
       * 'pre-line'   | Preserve      |   Collapse
       *
       * @member {string}
       */
      get: function() {
        return this._whiteSpace;
      },
      set: function(e) {
        this._whiteSpace !== e && (this._whiteSpace = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wordWrap", {
      /** Indicates if word wrap should be used. */
      get: function() {
        return this._wordWrap;
      },
      set: function(e) {
        this._wordWrap !== e && (this._wordWrap = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wordWrapWidth", {
      /** The width at which text will wrap, it needs wordWrap to be set to true. */
      get: function() {
        return this._wordWrapWidth;
      },
      set: function(e) {
        this._wordWrapWidth !== e && (this._wordWrapWidth = e, this.styleID++);
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toFontString = function() {
      var e = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, t = this.fontFamily;
      Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
      for (var i = t.length - 1; i >= 0; i--) {
        var n = t[i].trim();
        !/([\"\'])[^\'\"]+\1/.test(n) && x0.indexOf(n) < 0 && (n = '"' + n + '"'), t[i] = n;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + e + " " + t.join(",");
    }, r;
  }()
);
function xh(r) {
  return typeof r == "number" ? xu(r) : (typeof r == "string" && r.indexOf("0x") === 0 && (r = r.replace("0x", "#")), r);
}
function fo(r) {
  if (Array.isArray(r)) {
    for (var e = 0; e < r.length; ++e)
      r[e] = xh(r[e]);
    return r;
  } else
    return xh(r);
}
function T0(r, e) {
  if (!Array.isArray(r) || !Array.isArray(e) || r.length !== e.length)
    return !1;
  for (var t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
function yo(r, e, t) {
  for (var i in t)
    Array.isArray(e[i]) ? r[i] = e[i].slice() : r[i] = e[i];
}
var Hi = {
  // TextMetrics requires getImageData readback for measuring fonts.
  willReadFrequently: !0
}, de = (
  /** @class */
  function() {
    function r(e, t, i, n, o, s, a, h, u) {
      this.text = e, this.style = t, this.width = i, this.height = n, this.lines = o, this.lineWidths = s, this.lineHeight = a, this.maxLineWidth = h, this.fontProperties = u;
    }
    return r.measureText = function(e, t, i, n) {
      n === void 0 && (n = r._canvas), i = i ?? t.wordWrap;
      var o = t.toFontString(), s = r.measureFont(o);
      s.fontSize === 0 && (s.fontSize = t.fontSize, s.ascent = t.fontSize);
      var a = n.getContext("2d", Hi);
      a.font = o;
      for (var h = i ? r.wordWrap(e, t, n) : e, u = h.split(/(?:\r\n|\r|\n)/), l = new Array(u.length), c = 0, p = 0; p < u.length; p++) {
        var d = a.measureText(u[p]).width + (u[p].length - 1) * t.letterSpacing;
        l[p] = d, c = Math.max(c, d);
      }
      var f = c + t.strokeThickness;
      t.dropShadow && (f += t.dropShadowDistance);
      var y = t.lineHeight || s.fontSize + t.strokeThickness, m = Math.max(y, s.fontSize + t.strokeThickness) + (u.length - 1) * (y + t.leading);
      return t.dropShadow && (m += t.dropShadowDistance), new r(e, t, f, m, u, l, y + t.leading, c, s);
    }, r.wordWrap = function(e, t, i) {
      i === void 0 && (i = r._canvas);
      for (var n = i.getContext("2d", Hi), o = 0, s = "", a = "", h = /* @__PURE__ */ Object.create(null), u = t.letterSpacing, l = t.whiteSpace, c = r.collapseSpaces(l), p = r.collapseNewlines(l), d = !c, f = t.wordWrapWidth + u, y = r.tokenize(e), m = 0; m < y.length; m++) {
        var _ = y[m];
        if (r.isNewline(_)) {
          if (!p) {
            a += r.addLine(s), d = !c, s = "", o = 0;
            continue;
          }
          _ = " ";
        }
        if (c) {
          var g = r.isBreakingSpace(_), b = r.isBreakingSpace(s[s.length - 1]);
          if (g && b)
            continue;
        }
        var x = r.getFromCache(_, u, h, n);
        if (x > f)
          if (s !== "" && (a += r.addLine(s), s = "", o = 0), r.canBreakWords(_, t.breakWords))
            for (var E = r.wordWrapSplit(_), v = 0; v < E.length; v++) {
              for (var T = E[v], S = 1; E[v + S]; ) {
                var R = E[v + S], O = T[T.length - 1];
                if (!r.canBreakChars(O, R, _, v, t.breakWords))
                  T += R;
                else
                  break;
                S++;
              }
              v += T.length - 1;
              var w = r.getFromCache(T, u, h, n);
              w + o > f && (a += r.addLine(s), d = !1, s = "", o = 0), s += T, o += w;
            }
          else {
            s.length > 0 && (a += r.addLine(s), s = "", o = 0);
            var C = m === y.length - 1;
            a += r.addLine(_, !C), d = !1, s = "", o = 0;
          }
        else
          x + o > f && (d = !1, a += r.addLine(s), s = "", o = 0), (s.length > 0 || !r.isBreakingSpace(_) || d) && (s += _, o += x);
      }
      return a += r.addLine(s, !1), a;
    }, r.addLine = function(e, t) {
      return t === void 0 && (t = !0), e = r.trimRight(e), e = t ? e + `
` : e, e;
    }, r.getFromCache = function(e, t, i, n) {
      var o = i[e];
      if (typeof o != "number") {
        var s = e.length * t;
        o = n.measureText(e).width + s, i[e] = o;
      }
      return o;
    }, r.collapseSpaces = function(e) {
      return e === "normal" || e === "pre-line";
    }, r.collapseNewlines = function(e) {
      return e === "normal";
    }, r.trimRight = function(e) {
      if (typeof e != "string")
        return "";
      for (var t = e.length - 1; t >= 0; t--) {
        var i = e[t];
        if (!r.isBreakingSpace(i))
          break;
        e = e.slice(0, -1);
      }
      return e;
    }, r.isNewline = function(e) {
      return typeof e != "string" ? !1 : r._newlines.indexOf(e.charCodeAt(0)) >= 0;
    }, r.isBreakingSpace = function(e, t) {
      return typeof e != "string" ? !1 : r._breakingSpaces.indexOf(e.charCodeAt(0)) >= 0;
    }, r.tokenize = function(e) {
      var t = [], i = "";
      if (typeof e != "string")
        return t;
      for (var n = 0; n < e.length; n++) {
        var o = e[n], s = e[n + 1];
        if (r.isBreakingSpace(o, s) || r.isNewline(o)) {
          i !== "" && (t.push(i), i = ""), t.push(o);
          continue;
        }
        i += o;
      }
      return i !== "" && t.push(i), t;
    }, r.canBreakWords = function(e, t) {
      return t;
    }, r.canBreakChars = function(e, t, i, n, o) {
      return !0;
    }, r.wordWrapSplit = function(e) {
      return e.split("");
    }, r.measureFont = function(e) {
      if (r._fonts[e])
        return r._fonts[e];
      var t = {
        ascent: 0,
        descent: 0,
        fontSize: 0
      }, i = r._canvas, n = r._context;
      n.font = e;
      var o = r.METRICS_STRING + r.BASELINE_SYMBOL, s = Math.ceil(n.measureText(o).width), a = Math.ceil(n.measureText(r.BASELINE_SYMBOL).width), h = Math.ceil(r.HEIGHT_MULTIPLIER * a);
      a = a * r.BASELINE_MULTIPLIER | 0, i.width = s, i.height = h, n.fillStyle = "#f00", n.fillRect(0, 0, s, h), n.font = e, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText(o, 0, a);
      var u = n.getImageData(0, 0, s, h).data, l = u.length, c = s * 4, p = 0, d = 0, f = !1;
      for (p = 0; p < a; ++p) {
        for (var y = 0; y < c; y += 4)
          if (u[d + y] !== 255) {
            f = !0;
            break;
          }
        if (!f)
          d += c;
        else
          break;
      }
      for (t.ascent = a - p, d = l - c, f = !1, p = h; p > a; --p) {
        for (var y = 0; y < c; y += 4)
          if (u[d + y] !== 255) {
            f = !0;
            break;
          }
        if (!f)
          d -= c;
        else
          break;
      }
      return t.descent = p - a, t.fontSize = t.ascent + t.descent, r._fonts[e] = t, t;
    }, r.clearMetrics = function(e) {
      e === void 0 && (e = ""), e ? delete r._fonts[e] : r._fonts = {};
    }, Object.defineProperty(r, "_canvas", {
      /**
       * Cached canvas element for measuring text
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        if (!r.__canvas) {
          var e = void 0;
          try {
            var t = new OffscreenCanvas(0, 0), i = t.getContext("2d", Hi);
            if (i && i.measureText)
              return r.__canvas = t, t;
            e = L.ADAPTER.createCanvas();
          } catch {
            e = L.ADAPTER.createCanvas();
          }
          e.width = e.height = 10, r.__canvas = e;
        }
        return r.__canvas;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r, "_context", {
      /**
       * TODO: this should be private, but isn't because of backward compat, will fix later.
       * @ignore
       */
      get: function() {
        return r.__context || (r.__context = r._canvas.getContext("2d", Hi)), r.__context;
      },
      enumerable: !1,
      configurable: !0
    }), r;
  }()
);
de._fonts = {};
de.METRICS_STRING = "|ÉqÅ";
de.BASELINE_SYMBOL = "M";
de.BASELINE_MULTIPLIER = 1.4;
de.HEIGHT_MULTIPLIER = 2;
de._newlines = [
  10,
  13
];
de._breakingSpaces = [
  9,
  32,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8200,
  8201,
  8202,
  8287,
  12288
];
var E0 = {
  texture: !0,
  children: !1,
  baseTexture: !0
}, Ju = (
  /** @class */
  function(r) {
    b0(e, r);
    function e(t, i, n) {
      var o = this, s = !1;
      n || (n = L.ADAPTER.createCanvas(), s = !0), n.width = 3, n.height = 3;
      var a = W.from(n);
      return a.orig = new it(), a.trim = new it(), o = r.call(this, a) || this, o._ownCanvas = s, o.canvas = n, o.context = n.getContext("2d", {
        // required for trimming to work without warnings
        willReadFrequently: !0
      }), o._resolution = L.RESOLUTION, o._autoResolution = !0, o._text = null, o._style = null, o._styleListener = null, o._font = "", o.text = t, o.style = i, o.localStyleID = -1, o;
    }
    return e.prototype.updateText = function(t) {
      var i = this._style;
      if (this.localStyleID !== i.styleID && (this.dirty = !0, this.localStyleID = i.styleID), !(!this.dirty && t)) {
        this._font = this._style.toFontString();
        var n = this.context, o = de.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), s = o.width, a = o.height, h = o.lines, u = o.lineHeight, l = o.lineWidths, c = o.maxLineWidth, p = o.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, s) + i.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, a) + i.padding * 2) * this._resolution), n.scale(this._resolution, this._resolution), n.clearRect(0, 0, this.canvas.width, this.canvas.height), n.font = this._font, n.lineWidth = i.strokeThickness, n.textBaseline = i.textBaseline, n.lineJoin = i.lineJoin, n.miterLimit = i.miterLimit;
        for (var d, f, y = i.dropShadow ? 2 : 1, m = 0; m < y; ++m) {
          var _ = i.dropShadow && m === 0, g = _ ? Math.ceil(Math.max(1, a) + i.padding * 2) : 0, b = g * this._resolution;
          if (_) {
            n.fillStyle = "black", n.strokeStyle = "black";
            var x = i.dropShadowColor, E = wr(typeof x == "number" ? x : Ir(x)), v = i.dropShadowBlur * this._resolution, T = i.dropShadowDistance * this._resolution;
            n.shadowColor = "rgba(" + E[0] * 255 + "," + E[1] * 255 + "," + E[2] * 255 + "," + i.dropShadowAlpha + ")", n.shadowBlur = v, n.shadowOffsetX = Math.cos(i.dropShadowAngle) * T, n.shadowOffsetY = Math.sin(i.dropShadowAngle) * T + b;
          } else
            n.fillStyle = this._generateFillStyle(i, h, o), n.strokeStyle = i.stroke, n.shadowColor = "black", n.shadowBlur = 0, n.shadowOffsetX = 0, n.shadowOffsetY = 0;
          var S = (u - p.fontSize) / 2;
          (!e.nextLineHeightBehavior || u - p.fontSize < 0) && (S = 0);
          for (var R = 0; R < h.length; R++)
            d = i.strokeThickness / 2, f = i.strokeThickness / 2 + R * u + p.ascent + S, i.align === "right" ? d += c - l[R] : i.align === "center" && (d += (c - l[R]) / 2), i.stroke && i.strokeThickness && this.drawLetterSpacing(h[R], d + i.padding, f + i.padding - g, !0), i.fill && this.drawLetterSpacing(h[R], d + i.padding, f + i.padding - g);
        }
        this.updateTexture();
      }
    }, e.prototype.drawLetterSpacing = function(t, i, n, o) {
      o === void 0 && (o = !1);
      var s = this._style, a = s.letterSpacing, h = e.experimentalLetterSpacing && ("letterSpacing" in CanvasRenderingContext2D.prototype || "textLetterSpacing" in CanvasRenderingContext2D.prototype);
      if (a === 0 || h) {
        h && (this.context.letterSpacing = a, this.context.textLetterSpacing = a), o ? this.context.strokeText(t, i, n) : this.context.fillText(t, i, n);
        return;
      }
      for (var u = i, l = Array.from ? Array.from(t) : t.split(""), c = this.context.measureText(t).width, p = 0, d = 0; d < l.length; ++d) {
        var f = l[d];
        o ? this.context.strokeText(f, u, n) : this.context.fillText(f, u, n);
        for (var y = "", m = d + 1; m < l.length; ++m)
          y += l[m];
        p = this.context.measureText(y).width, u += c - p + a, c = p;
      }
    }, e.prototype.updateTexture = function() {
      var t = this.canvas;
      if (this._style.trim) {
        var i = __(t);
        i.data && (t.width = i.width, t.height = i.height, this.context.putImageData(i.data, 0, 0));
      }
      var n = this._texture, o = this._style, s = o.trim ? 0 : o.padding, a = n.baseTexture;
      n.trim.width = n._frame.width = t.width / this._resolution, n.trim.height = n._frame.height = t.height / this._resolution, n.trim.x = -s, n.trim.y = -s, n.orig.width = n._frame.width - s * 2, n.orig.height = n._frame.height - s * 2, this._onTextureUpdate(), a.setRealSize(t.width, t.height, this._resolution), n.updateUvs(), this.dirty = !1;
    }, e.prototype._render = function(t) {
      this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), r.prototype._render.call(this, t);
    }, e.prototype.updateTransform = function() {
      this.updateText(!0), r.prototype.updateTransform.call(this);
    }, e.prototype.getBounds = function(t, i) {
      return this.updateText(!0), this._textureID === -1 && (t = !1), r.prototype.getBounds.call(this, t, i);
    }, e.prototype.getLocalBounds = function(t) {
      return this.updateText(!0), r.prototype.getLocalBounds.call(this, t);
    }, e.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }, e.prototype._generateFillStyle = function(t, i, n) {
      var o = t.fill;
      if (Array.isArray(o)) {
        if (o.length === 1)
          return o[0];
      } else
        return o;
      var s, a = t.dropShadow ? t.dropShadowDistance : 0, h = t.padding || 0, u = this.canvas.width / this._resolution - a - h * 2, l = this.canvas.height / this._resolution - a - h * 2, c = o.slice(), p = t.fillGradientStops.slice();
      if (!p.length)
        for (var d = c.length + 1, f = 1; f < d; ++f)
          p.push(f / d);
      if (c.unshift(o[0]), p.unshift(0), c.push(o[o.length - 1]), p.push(1), t.fillGradientType === oi.LINEAR_VERTICAL) {
        s = this.context.createLinearGradient(u / 2, h, u / 2, l + h);
        for (var y = n.fontProperties.fontSize + t.strokeThickness, f = 0; f < i.length; f++) {
          var m = n.lineHeight * (f - 1) + y, _ = n.lineHeight * f, g = _;
          f > 0 && m > _ && (g = (_ + m) / 2);
          var b = _ + y, x = n.lineHeight * (f + 1), E = b;
          f + 1 < i.length && x < b && (E = (b + x) / 2);
          for (var v = (E - g) / l, T = 0; T < c.length; T++) {
            var S = 0;
            typeof p[T] == "number" ? S = p[T] : S = T / c.length;
            var R = Math.min(1, Math.max(0, g / l + S * v));
            R = Number(R.toFixed(5)), s.addColorStop(R, c[T]);
          }
        }
      } else {
        s = this.context.createLinearGradient(h, l / 2, u + h, l / 2);
        for (var O = c.length + 1, w = 1, f = 0; f < c.length; f++) {
          var C = void 0;
          typeof p[f] == "number" ? C = p[f] : C = w / O, s.addColorStop(C, c[f]), w++;
        }
      }
      return s;
    }, e.prototype.destroy = function(t) {
      typeof t == "boolean" && (t = { children: t }), t = Object.assign({}, E0, t), r.prototype.destroy.call(this, t), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null;
    }, Object.defineProperty(e.prototype, "width", {
      /** The width of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
      },
      set: function(t) {
        this.updateText(!0);
        var i = _r(this.scale.x) || 1;
        this.scale.x = i * t / this._texture.orig.width, this._width = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "height", {
      /** The height of the Text, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
      },
      set: function(t) {
        this.updateText(!0);
        var i = _r(this.scale.y) || 1;
        this.scale.y = i * t / this._texture.orig.height, this._height = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "style", {
      /**
       * Set the style of the text.
       *
       * Set up an event listener to listen for changes on the style object and mark the text as dirty.
       */
      get: function() {
        return this._style;
      },
      set: function(t) {
        t = t || {}, t instanceof Pr ? this._style = t : this._style = new Pr(t), this.localStyleID = -1, this.dirty = !0;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "text", {
      /** Set the copy for the text object. To split a line you can use '\n'. */
      get: function() {
        return this._text;
      },
      set: function(t) {
        t = String(t ?? ""), this._text !== t && (this._text = t, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "resolution", {
      /**
       * The resolution / device pixel ratio of the canvas.
       *
       * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
       * @default 1
       */
      get: function() {
        return this._resolution;
      },
      set: function(t) {
        this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), e.nextLineHeightBehavior = !1, e.experimentalLetterSpacing = !1, e;
  }(di)
);
/*!
 * @pixi/prepare - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/prepare is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
L.UPLOADS_PER_FRAME = 4;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Qo = function(r, e) {
  return Qo = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, Qo(r, e);
};
function A0(r, e) {
  Qo(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var S0 = (
  /** @class */
  function() {
    function r(e) {
      this.maxItemsPerFrame = e, this.itemsLeft = 0;
    }
    return r.prototype.beginFrame = function() {
      this.itemsLeft = this.maxItemsPerFrame;
    }, r.prototype.allowedToUpload = function() {
      return this.itemsLeft-- > 0;
    }, r;
  }()
);
function R0(r, e) {
  var t = !1;
  if (r && r._textures && r._textures.length) {
    for (var i = 0; i < r._textures.length; i++)
      if (r._textures[i] instanceof W) {
        var n = r._textures[i].baseTexture;
        e.indexOf(n) === -1 && (e.push(n), t = !0);
      }
  }
  return t;
}
function O0(r, e) {
  if (r.baseTexture instanceof rt) {
    var t = r.baseTexture;
    return e.indexOf(t) === -1 && e.push(t), !0;
  }
  return !1;
}
function w0(r, e) {
  if (r._texture && r._texture instanceof W) {
    var t = r._texture.baseTexture;
    return e.indexOf(t) === -1 && e.push(t), !0;
  }
  return !1;
}
function I0(r, e) {
  return e instanceof Ju ? (e.updateText(!0), !0) : !1;
}
function P0(r, e) {
  if (e instanceof Pr) {
    var t = e.toFontString();
    return de.measureFont(t), !0;
  }
  return !1;
}
function M0(r, e) {
  if (r instanceof Ju) {
    e.indexOf(r.style) === -1 && e.push(r.style), e.indexOf(r) === -1 && e.push(r);
    var t = r._texture.baseTexture;
    return e.indexOf(t) === -1 && e.push(t), !0;
  }
  return !1;
}
function D0(r, e) {
  return r instanceof Pr ? (e.indexOf(r) === -1 && e.push(r), !0) : !1;
}
var C0 = (
  /** @class */
  function() {
    function r(e) {
      var t = this;
      this.limiter = new S0(L.UPLOADS_PER_FRAME), this.renderer = e, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = function() {
        t.queue && t.prepareItems();
      }, this.registerFindHook(M0), this.registerFindHook(D0), this.registerFindHook(R0), this.registerFindHook(O0), this.registerFindHook(w0), this.registerUploadHook(I0), this.registerUploadHook(P0);
    }
    return r.prototype.upload = function(e, t) {
      var i = this;
      return typeof e == "function" && (t = e, e = null), t && re("6.5.0", "BasePrepare.upload callback is deprecated, use the return Promise instead."), new Promise(function(n) {
        e && i.add(e);
        var o = function() {
          t == null || t(), n();
        };
        i.queue.length ? (i.completes.push(o), i.ticking || (i.ticking = !0, Lt.system.addOnce(i.tick, i, xe.UTILITY))) : o();
      });
    }, r.prototype.tick = function() {
      setTimeout(this.delayedTick, 0);
    }, r.prototype.prepareItems = function() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
        var e = this.queue[0], t = !1;
        if (e && !e._destroyed) {
          for (var i = 0, n = this.uploadHooks.length; i < n; i++)
            if (this.uploadHooks[i](this.uploadHookHelper, e)) {
              this.queue.shift(), t = !0;
              break;
            }
        }
        t || this.queue.shift();
      }
      if (this.queue.length)
        Lt.system.addOnce(this.tick, this, xe.UTILITY);
      else {
        this.ticking = !1;
        var o = this.completes.slice(0);
        this.completes.length = 0;
        for (var i = 0, n = o.length; i < n; i++)
          o[i]();
      }
    }, r.prototype.registerFindHook = function(e) {
      return e && this.addHooks.push(e), this;
    }, r.prototype.registerUploadHook = function(e) {
      return e && this.uploadHooks.push(e), this;
    }, r.prototype.add = function(e) {
      for (var t = 0, i = this.addHooks.length; t < i && !this.addHooks[t](e, this.queue); t++)
        ;
      if (e instanceof pe)
        for (var t = e.children.length - 1; t >= 0; t--)
          this.add(e.children[t]);
      return this;
    }, r.prototype.destroy = function() {
      this.ticking && Lt.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null;
    }, r;
  }()
);
function Qu(r, e) {
  return e instanceof rt ? (e._glTextures[r.CONTEXT_UID] || r.texture.bind(e), !0) : !1;
}
function F0(r, e) {
  if (!(e instanceof rr))
    return !1;
  var t = e.geometry;
  e.finishPoly(), t.updateBatches();
  for (var i = t.batches, n = 0; n < i.length; n++) {
    var o = i[n].style.texture;
    o && Qu(r, o.baseTexture);
  }
  return t.batchable || r.geometry.bind(t, e._resolveDirectShader(r)), !0;
}
function N0(r, e) {
  return r instanceof rr ? (e.push(r), !0) : !1;
}
var L0 = (
  /** @class */
  function(r) {
    A0(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.uploadHookHelper = i.renderer, i.registerFindHook(N0), i.registerUploadHook(Qu), i.registerUploadHook(F0), i;
    }
    return e.extension = {
      name: "prepare",
      type: dt.RendererPlugin
    }, e;
  }(C0)
);
/*!
 * @pixi/spritesheet - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/spritesheet is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var B0 = (
  /** @class */
  function() {
    function r(e, t, i) {
      i === void 0 && (i = null), this.linkedSheets = [], this._texture = e instanceof W ? e : null, this.baseTexture = e instanceof rt ? e : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = t;
      var n = this.baseTexture.resource;
      this.resolution = this._updateResolution(i || (n ? n.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    return r.prototype._updateResolution = function(e) {
      e === void 0 && (e = null);
      var t = this.data.meta.scale, i = hn(e, null);
      return i === null && (i = t !== void 0 ? parseFloat(t) : 1), i !== 1 && this.baseTexture.setResolution(i), i;
    }, r.prototype.parse = function(e) {
      var t = this;
      return e && re("6.5.0", "Spritesheet.parse callback is deprecated, use the return Promise instead."), new Promise(function(i) {
        t._callback = function(n) {
          e == null || e(n), i(n);
        }, t._batchIndex = 0, t._frameKeys.length <= r.BATCH_SIZE ? (t._processFrames(0), t._processAnimations(), t._parseComplete()) : t._nextBatch();
      });
    }, r.prototype._processFrames = function(e) {
      for (var t = e, i = r.BATCH_SIZE; t - e < i && t < this._frameKeys.length; ) {
        var n = this._frameKeys[t], o = this._frames[n], s = o.frame;
        if (s) {
          var a = null, h = null, u = o.trimmed !== !1 && o.sourceSize ? o.sourceSize : o.frame, l = new it(0, 0, Math.floor(u.w) / this.resolution, Math.floor(u.h) / this.resolution);
          o.rotated ? a = new it(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.h) / this.resolution, Math.floor(s.w) / this.resolution) : a = new it(Math.floor(s.x) / this.resolution, Math.floor(s.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution), o.trimmed !== !1 && o.spriteSourceSize && (h = new it(Math.floor(o.spriteSourceSize.x) / this.resolution, Math.floor(o.spriteSourceSize.y) / this.resolution, Math.floor(s.w) / this.resolution, Math.floor(s.h) / this.resolution)), this.textures[n] = new W(this.baseTexture, a, l, h, o.rotated ? 2 : 0, o.anchor), W.addToCache(this.textures[n], n);
        }
        t++;
      }
    }, r.prototype._processAnimations = function() {
      var e = this.data.animations || {};
      for (var t in e) {
        this.animations[t] = [];
        for (var i = 0; i < e[t].length; i++) {
          var n = e[t][i];
          this.animations[t].push(this.textures[n]);
        }
      }
    }, r.prototype._parseComplete = function() {
      var e = this._callback;
      this._callback = null, this._batchIndex = 0, e.call(this, this.textures);
    }, r.prototype._nextBatch = function() {
      var e = this;
      this._processFrames(this._batchIndex * r.BATCH_SIZE), this._batchIndex++, setTimeout(function() {
        e._batchIndex * r.BATCH_SIZE < e._frameKeys.length ? e._nextBatch() : (e._processAnimations(), e._parseComplete());
      }, 0);
    }, r.prototype.destroy = function(e) {
      var t;
      e === void 0 && (e = !1);
      for (var i in this.textures)
        this.textures[i].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((t = this._texture) === null || t === void 0 || t.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = [];
    }, r.BATCH_SIZE = 1e3, r;
  }()
), G0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.use = function(e, t) {
      var i, n, o = this, s = e.name + "_image";
      if (!e.data || e.type !== Et.TYPE.JSON || !e.data.frames || o.resources[s]) {
        t();
        return;
      }
      var a = (n = (i = e.data) === null || i === void 0 ? void 0 : i.meta) === null || n === void 0 ? void 0 : n.related_multi_packs;
      if (Array.isArray(a))
        for (var h = function(f) {
          if (typeof f != "string")
            return "continue";
          var y = f.replace(".json", ""), m = mr.resolve(e.url.replace(o.baseUrl, ""), f);
          if (o.resources[y] || Object.values(o.resources).some(function(g) {
            return mr.format(mr.parse(g.url)) === m;
          }))
            return "continue";
          var _ = {
            crossOrigin: e.crossOrigin,
            loadType: Et.LOAD_TYPE.XHR,
            xhrType: Et.XHR_RESPONSE_TYPE.JSON,
            parentResource: e,
            metadata: e.metadata
          };
          o.add(y, m, _);
        }, u = 0, l = a; u < l.length; u++) {
          var c = l[u];
          h(c);
        }
      var p = {
        crossOrigin: e.crossOrigin,
        metadata: e.metadata.imageMetadata,
        parentResource: e
      }, d = r.getResourcePath(e, o.baseUrl);
      o.add(s, d, p, function(f) {
        if (f.error) {
          t(f.error);
          return;
        }
        var y = new B0(f.texture, e.data, e.url);
        y.parse().then(function() {
          e.spritesheet = y, e.textures = y.textures, t();
        });
      });
    }, r.getResourcePath = function(e, t) {
      return e.isDataUrl ? e.data.meta.image : mr.resolve(e.url.replace(t, ""), e.data.meta.image);
    }, r.extension = dt.Loader, r;
  }()
);
/*!
 * @pixi/sprite-tiling - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-tiling is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ts = function(r, e) {
  return ts = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, ts(r, e);
};
function tl(r, e) {
  ts(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var jr = new _t();
(function(r) {
  tl(e, r);
  function e(t, i, n) {
    i === void 0 && (i = 100), n === void 0 && (n = 100);
    var o = r.call(this, t) || this;
    return o.tileTransform = new Ou(), o._width = i, o._height = n, o.uvMatrix = o.texture.uvMatrix || new Is(t), o.pluginName = "tilingSprite", o.uvRespectAnchor = !1, o;
  }
  return Object.defineProperty(e.prototype, "clampMargin", {
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     * @default 0.5
     * @member {number}
     */
    get: function() {
      return this.uvMatrix.clampMargin;
    },
    set: function(t) {
      this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "tileScale", {
    /** The scaling of the image that is being tiled. */
    get: function() {
      return this.tileTransform.scale;
    },
    set: function(t) {
      this.tileTransform.scale.copyFrom(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "tilePosition", {
    /** The offset of the image that is being tiled. */
    get: function() {
      return this.tileTransform.position;
    },
    set: function(t) {
      this.tileTransform.position.copyFrom(t);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._onTextureUpdate = function() {
    this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215;
  }, e.prototype._render = function(t) {
    var i = this._texture;
    !i || !i.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this));
  }, e.prototype._calculateBounds = function() {
    var t = this._width * -this._anchor._x, i = this._height * -this._anchor._y, n = this._width * (1 - this._anchor._x), o = this._height * (1 - this._anchor._y);
    this._bounds.addFrame(this.transform, t, i, n, o);
  }, e.prototype.getLocalBounds = function(t) {
    return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new it()), t = this._localBoundsRect), this._bounds.getRectangle(t)) : r.prototype.getLocalBounds.call(this, t);
  }, e.prototype.containsPoint = function(t) {
    this.worldTransform.applyInverse(t, jr);
    var i = this._width, n = this._height, o = -i * this.anchor._x;
    if (jr.x >= o && jr.x < o + i) {
      var s = -n * this.anchor._y;
      if (jr.y >= s && jr.y < s + n)
        return !0;
    }
    return !1;
  }, e.prototype.destroy = function(t) {
    r.prototype.destroy.call(this, t), this.tileTransform = null, this.uvMatrix = null;
  }, e.from = function(t, i) {
    var n = t instanceof W ? t : W.from(t, i);
    return new e(n, i.width, i.height);
  }, Object.defineProperty(e.prototype, "width", {
    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._width;
    },
    set: function(t) {
      this._width = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "height", {
    /** The height of the TilingSprite, setting this will actually modify the scale to achieve the value set. */
    get: function() {
      return this._height;
    },
    set: function(t) {
      this._height = t;
    },
    enumerable: !1,
    configurable: !0
  }), e;
})(di);
var U0 = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`, Th = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, k0 = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`, X0 = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`, j0 = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`, Yi = new It(), H0 = (
  /** @class */
  function(r) {
    tl(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return t.runners.contextChange.add(i), i.quad = new Fu(), i.state = ir.for2d(), i;
    }
    return e.prototype.contextChange = function() {
      var t = this.renderer, i = { globals: t.globalUniforms };
      this.simpleShader = we.from(Th, U0, i), this.shader = t.context.webGLVersion > 1 ? we.from(X0, j0, i) : we.from(Th, k0, i);
    }, e.prototype.render = function(t) {
      var i = this.renderer, n = this.quad, o = n.vertices;
      o[0] = o[6] = t._width * -t.anchor.x, o[1] = o[3] = t._height * -t.anchor.y, o[2] = o[4] = t._width * (1 - t.anchor.x), o[5] = o[7] = t._height * (1 - t.anchor.y);
      var s = t.uvRespectAnchor ? t.anchor.x : 0, a = t.uvRespectAnchor ? t.anchor.y : 0;
      o = n.uvs, o[0] = o[6] = -s, o[1] = o[3] = -a, o[2] = o[4] = 1 - s, o[5] = o[7] = 1 - a, n.invalidate();
      var h = t._texture, u = h.baseTexture, l = u.alphaMode > 0, c = t.tileTransform.localTransform, p = t.uvMatrix, d = u.isPowerOfTwo && h.frame.width === u.width && h.frame.height === u.height;
      d && (u._glTextures[i.CONTEXT_UID] ? d = u.wrapMode !== le.CLAMP : u.wrapMode === le.CLAMP && (u.wrapMode = le.REPEAT));
      var f = d ? this.simpleShader : this.shader, y = h.width, m = h.height, _ = t._width, g = t._height;
      Yi.set(c.a * y / _, c.b * y / g, c.c * m / _, c.d * m / g, c.tx / _, c.ty / g), Yi.invert(), d ? Yi.prepend(p.mapCoord) : (f.uniforms.uMapCoord = p.mapCoord.toArray(!0), f.uniforms.uClampFrame = p.uClampFrame, f.uniforms.uClampOffset = p.uClampOffset), f.uniforms.uTransform = Yi.toArray(!0), f.uniforms.uColor = Au(t.tint, t.worldAlpha, f.uniforms.uColor, l), f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), f.uniforms.uSampler = h, i.shader.bind(f), i.geometry.bind(n), this.state.blendMode = Eu(t.blendMode, l), i.state.set(this.state), i.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }, e.extension = {
      name: "tilingSprite",
      type: dt.RendererPlugin
    }, e;
  }(xn)
);
/*!
 * @pixi/mesh - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var es = function(r, e) {
  return es = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, es(r, e);
};
function Ms(r, e) {
  es(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Y0 = (
  /** @class */
  function() {
    function r(e, t) {
      this.uvBuffer = e, this.uvMatrix = t, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0;
    }
    return r.prototype.update = function(e) {
      if (!(!e && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)) {
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        var t = this.uvBuffer.data;
        (!this.data || this.data.length !== t.length) && (this.data = new Float32Array(t.length)), this.uvMatrix.multiplyUvs(t, this.data), this._updateID++;
      }
    }, r;
  }()
), mo = new _t(), Eh = new $i(), si = (
  /** @class */
  function(r) {
    Ms(e, r);
    function e(t, i, n, o) {
      o === void 0 && (o = te.TRIANGLES);
      var s = r.call(this) || this;
      return s.geometry = t, s.shader = i, s.state = n || ir.for2d(), s.drawMode = o, s.start = 0, s.size = 0, s.uvs = null, s.indices = null, s.vertexData = new Float32Array(1), s.vertexDirty = -1, s._transformID = -1, s._roundPixels = L.ROUND_PIXELS, s.batchUvs = null, s;
    }
    return Object.defineProperty(e.prototype, "geometry", {
      /**
       * Includes vertex positions, face indices, normals, colors, UVs, and
       * custom attributes within buffers, reducing the cost of passing all
       * this data to the GPU. Can be shared between multiple Mesh objects.
       */
      get: function() {
        return this._geometry;
      },
      set: function(t) {
        this._geometry !== t && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = t, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "uvBuffer", {
      /**
       * To change mesh uv's, change its uvBuffer data and increment its _updateID.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[1];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "verticesBuffer", {
      /**
       * To change mesh vertices, change its uvBuffer data and increment its _updateID.
       * Incrementing _updateID is optional because most of Mesh objects do it anyway.
       * @readonly
       */
      get: function() {
        return this.geometry.buffers[0];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "material", {
      get: function() {
        return this.shader;
      },
      /** Alias for {@link PIXI.Mesh#shader}. */
      set: function(t) {
        this.shader = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "blendMode", {
      get: function() {
        return this.state.blendMode;
      },
      /**
       * The blend mode to be applied to the Mesh. Apply a value of
       * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * @default PIXI.BLEND_MODES.NORMAL;
       */
      set: function(t) {
        this.state.blendMode = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "roundPixels", {
      get: function() {
        return this._roundPixels;
      },
      /**
       * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
       * Advantages can include sharper image quality (like text) and faster rendering on canvas.
       * The main disadvantage is movement of objects may appear less smooth.
       * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
       * @default false
       */
      set: function(t) {
        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tint", {
      /**
       * The multiply tint applied to the Mesh. This is a hex value. A value of
       * `0xFFFFFF` will remove any tint effect.
       *
       * Null for non-MeshMaterial shaders
       * @default 0xFFFFFF
       */
      get: function() {
        return "tint" in this.shader ? this.shader.tint : null;
      },
      set: function(t) {
        this.shader.tint = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "texture", {
      /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */
      get: function() {
        return "texture" in this.shader ? this.shader.texture : null;
      },
      set: function(t) {
        this.shader.texture = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype._render = function(t) {
      var i = this.geometry.buffers[0].data, n = this.shader;
      n.batchable && this.drawMode === te.TRIANGLES && i.length < e.BATCHABLE_SIZE * 2 ? this._renderToBatch(t) : this._renderDefault(t);
    }, e.prototype._renderDefault = function(t) {
      var i = this.shader;
      i.alpha = this.worldAlpha, i.update && i.update(), t.batch.flush(), i.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), t.shader.bind(i), t.state.set(this.state), t.geometry.bind(this.geometry, i), t.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }, e.prototype._renderToBatch = function(t) {
      var i = this.geometry, n = this.shader;
      n.uvMatrix && (n.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = i.indexBuffer.data, this._tintRGB = n._tintRGB, this._texture = n.texture;
      var o = this.material.pluginName;
      t.batch.setObjectRenderer(t.plugins[o]), t.plugins[o].render(this);
    }, e.prototype.calculateVertices = function() {
      var t = this.geometry, i = t.buffers[0], n = i.data, o = i._updateID;
      if (!(o === this.vertexDirty && this._transformID === this.transform._worldID)) {
        this._transformID = this.transform._worldID, this.vertexData.length !== n.length && (this.vertexData = new Float32Array(n.length));
        for (var s = this.transform.worldTransform, a = s.a, h = s.b, u = s.c, l = s.d, c = s.tx, p = s.ty, d = this.vertexData, f = 0; f < d.length / 2; f++) {
          var y = n[f * 2], m = n[f * 2 + 1];
          d[f * 2] = a * y + u * m + c, d[f * 2 + 1] = h * y + l * m + p;
        }
        if (this._roundPixels)
          for (var _ = L.RESOLUTION, f = 0; f < d.length; ++f)
            d[f] = Math.round((d[f] * _ | 0) / _);
        this.vertexDirty = o;
      }
    }, e.prototype.calculateUvs = function() {
      var t = this.geometry.buffers[1], i = this.shader;
      i.uvMatrix.isSimple ? this.uvs = t.data : (this.batchUvs || (this.batchUvs = new Y0(t, i.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
    }, e.prototype._calculateBounds = function() {
      this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }, e.prototype.containsPoint = function(t) {
      if (!this.getBounds().contains(t.x, t.y))
        return !1;
      this.worldTransform.applyInverse(t, mo);
      for (var i = this.geometry.getBuffer("aVertexPosition").data, n = Eh.points, o = this.geometry.getIndex().data, s = o.length, a = this.drawMode === 4 ? 3 : 1, h = 0; h + 2 < s; h += a) {
        var u = o[h] * 2, l = o[h + 1] * 2, c = o[h + 2] * 2;
        if (n[0] = i[u], n[1] = i[u + 1], n[2] = i[l], n[3] = i[l + 1], n[4] = i[c], n[5] = i[c + 1], Eh.contains(mo.x, mo.y))
          return !0;
      }
      return !1;
    }, e.prototype.destroy = function(t) {
      r.prototype.destroy.call(this, t), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null;
    }, e.BATCHABLE_SIZE = 100, e;
  }(pe)
), V0 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`, z0 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`, ai = (
  /** @class */
  function(r) {
    Ms(e, r);
    function e(t, i) {
      var n = this, o = {
        uSampler: t,
        alpha: 1,
        uTextureMatrix: It.IDENTITY,
        uColor: new Float32Array([1, 1, 1, 1])
      };
      return i = Object.assign({
        tint: 16777215,
        alpha: 1,
        pluginName: "batch"
      }, i), i.uniforms && Object.assign(o, i.uniforms), n = r.call(this, i.program || pi.from(z0, V0), o) || this, n._colorDirty = !1, n.uvMatrix = new Is(t), n.batchable = i.program === void 0, n.pluginName = i.pluginName, n.tint = i.tint, n.alpha = i.alpha, n;
    }
    return Object.defineProperty(e.prototype, "texture", {
      /** Reference to the texture being rendered. */
      get: function() {
        return this.uniforms.uSampler;
      },
      set: function(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = t, this.uvMatrix.texture = t);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "alpha", {
      get: function() {
        return this._alpha;
      },
      /**
       * This gets automatically set by the object using this.
       * @default 1
       */
      set: function(t) {
        t !== this._alpha && (this._alpha = t, this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tint", {
      get: function() {
        return this._tint;
      },
      /**
       * Multiply tint for the material.
       * @default 0xFFFFFF
       */
      set: function(t) {
        t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16), this._colorDirty = !0);
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.update = function() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        var t = this.texture.baseTexture;
        Au(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }, e;
  }(we)
), Tn = (
  /** @class */
  function(r) {
    Ms(e, r);
    function e(t, i, n) {
      var o = r.call(this) || this, s = new wt(t), a = new wt(i, !0), h = new wt(n, !0, !0);
      return o.addAttribute("aVertexPosition", s, 2, !1, U.FLOAT).addAttribute("aTextureCoord", a, 2, !1, U.FLOAT).addIndex(h), o._updateId = -1, o;
    }
    return Object.defineProperty(e.prototype, "vertexDirtyId", {
      /**
       * If the vertex position is updated.
       * @readonly
       * @private
       */
      get: function() {
        return this.buffers[0]._updateID;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ci)
);
/*!
 * @pixi/text-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/text-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var rs = function(r, e) {
  return rs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, rs(r, e);
};
function W0(r, e) {
  rs(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var fn = (
  /** @class */
  function() {
    function r() {
      this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = [];
    }
    return r;
  }()
), $0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(e) {
      return typeof e == "string" && e.indexOf("info face=") === 0;
    }, r.parse = function(e) {
      var t = e.match(/^[a-z]+\s+.+$/gm), i = {
        info: [],
        common: [],
        page: [],
        char: [],
        chars: [],
        kerning: [],
        kernings: [],
        distanceField: []
      };
      for (var n in t) {
        var o = t[n].match(/^[a-z]+/gm)[0], s = t[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), a = {};
        for (var h in s) {
          var u = s[h].split("="), l = u[0], c = u[1].replace(/"/gm, ""), p = parseFloat(c), d = isNaN(p) ? c : p;
          a[l] = d;
        }
        i[o].push(a);
      }
      var f = new fn();
      return i.info.forEach(function(y) {
        return f.info.push({
          face: y.face,
          size: parseInt(y.size, 10)
        });
      }), i.common.forEach(function(y) {
        return f.common.push({
          lineHeight: parseInt(y.lineHeight, 10)
        });
      }), i.page.forEach(function(y) {
        return f.page.push({
          id: parseInt(y.id, 10),
          file: y.file
        });
      }), i.char.forEach(function(y) {
        return f.char.push({
          id: parseInt(y.id, 10),
          page: parseInt(y.page, 10),
          x: parseInt(y.x, 10),
          y: parseInt(y.y, 10),
          width: parseInt(y.width, 10),
          height: parseInt(y.height, 10),
          xoffset: parseInt(y.xoffset, 10),
          yoffset: parseInt(y.yoffset, 10),
          xadvance: parseInt(y.xadvance, 10)
        });
      }), i.kerning.forEach(function(y) {
        return f.kerning.push({
          first: parseInt(y.first, 10),
          second: parseInt(y.second, 10),
          amount: parseInt(y.amount, 10)
        });
      }), i.distanceField.forEach(function(y) {
        return f.distanceField.push({
          distanceRange: parseInt(y.distanceRange, 10),
          fieldType: y.fieldType
        });
      }), f;
    }, r;
  }()
), is = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(e) {
      return e instanceof XMLDocument && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null;
    }, r.parse = function(e) {
      for (var t = new fn(), i = e.getElementsByTagName("info"), n = e.getElementsByTagName("common"), o = e.getElementsByTagName("page"), s = e.getElementsByTagName("char"), a = e.getElementsByTagName("kerning"), h = e.getElementsByTagName("distanceField"), u = 0; u < i.length; u++)
        t.info.push({
          face: i[u].getAttribute("face"),
          size: parseInt(i[u].getAttribute("size"), 10)
        });
      for (var u = 0; u < n.length; u++)
        t.common.push({
          lineHeight: parseInt(n[u].getAttribute("lineHeight"), 10)
        });
      for (var u = 0; u < o.length; u++)
        t.page.push({
          id: parseInt(o[u].getAttribute("id"), 10) || 0,
          file: o[u].getAttribute("file")
        });
      for (var u = 0; u < s.length; u++) {
        var l = s[u];
        t.char.push({
          id: parseInt(l.getAttribute("id"), 10),
          page: parseInt(l.getAttribute("page"), 10) || 0,
          x: parseInt(l.getAttribute("x"), 10),
          y: parseInt(l.getAttribute("y"), 10),
          width: parseInt(l.getAttribute("width"), 10),
          height: parseInt(l.getAttribute("height"), 10),
          xoffset: parseInt(l.getAttribute("xoffset"), 10),
          yoffset: parseInt(l.getAttribute("yoffset"), 10),
          xadvance: parseInt(l.getAttribute("xadvance"), 10)
        });
      }
      for (var u = 0; u < a.length; u++)
        t.kerning.push({
          first: parseInt(a[u].getAttribute("first"), 10),
          second: parseInt(a[u].getAttribute("second"), 10),
          amount: parseInt(a[u].getAttribute("amount"), 10)
        });
      for (var u = 0; u < h.length; u++)
        t.distanceField.push({
          fieldType: h[u].getAttribute("fieldType"),
          distanceRange: parseInt(h[u].getAttribute("distanceRange"), 10)
        });
      return t;
    }, r;
  }()
), q0 = (
  /** @class */
  function() {
    function r() {
    }
    return r.test = function(e) {
      if (typeof e == "string" && e.indexOf("<font>") > -1) {
        var t = new globalThis.DOMParser().parseFromString(e, "text/xml");
        return is.test(t);
      }
      return !1;
    }, r.parse = function(e) {
      var t = new globalThis.DOMParser().parseFromString(e, "text/xml");
      return is.parse(t);
    }, r;
  }()
), _o = [
  $0,
  is,
  q0
];
function el(r) {
  for (var e = 0; e < _o.length; e++)
    if (_o[e].test(r))
      return _o[e];
  return null;
}
function K0(r, e, t, i, n, o) {
  var s = t.fill;
  if (Array.isArray(s)) {
    if (s.length === 1)
      return s[0];
  } else
    return s;
  var a, h = t.dropShadow ? t.dropShadowDistance : 0, u = t.padding || 0, l = r.width / i - h - u * 2, c = r.height / i - h - u * 2, p = s.slice(), d = t.fillGradientStops.slice();
  if (!d.length)
    for (var f = p.length + 1, y = 1; y < f; ++y)
      d.push(y / f);
  if (p.unshift(s[0]), d.unshift(0), p.push(s[s.length - 1]), d.push(1), t.fillGradientType === oi.LINEAR_VERTICAL) {
    a = e.createLinearGradient(l / 2, u, l / 2, c + u);
    for (var m = 0, _ = o.fontProperties.fontSize + t.strokeThickness, g = _ / c, y = 0; y < n.length; y++)
      for (var b = o.lineHeight * y, x = 0; x < p.length; x++) {
        var E = 0;
        typeof d[x] == "number" ? E = d[x] : E = x / p.length;
        var v = b / c + E * g, T = Math.max(m, v);
        T = Math.min(T, 1), a.addColorStop(T, p[x]), m = T;
      }
  } else {
    a = e.createLinearGradient(u, c / 2, l + u, c / 2);
    for (var S = p.length + 1, R = 1, y = 0; y < p.length; y++) {
      var O = void 0;
      typeof d[y] == "number" ? O = d[y] : O = R / S, a.addColorStop(O, p[y]), R++;
    }
  }
  return a;
}
function Z0(r, e, t, i, n, o, s) {
  var a = t.text, h = t.fontProperties;
  e.translate(i, n), e.scale(o, o);
  var u = s.strokeThickness / 2, l = -(s.strokeThickness / 2);
  if (e.font = s.toFontString(), e.lineWidth = s.strokeThickness, e.textBaseline = s.textBaseline, e.lineJoin = s.lineJoin, e.miterLimit = s.miterLimit, e.fillStyle = K0(r, e, s, o, [a], t), e.strokeStyle = s.stroke, s.dropShadow) {
    var c = s.dropShadowColor, p = wr(typeof c == "number" ? c : Ir(c)), d = s.dropShadowBlur * o, f = s.dropShadowDistance * o;
    e.shadowColor = "rgba(" + p[0] * 255 + "," + p[1] * 255 + "," + p[2] * 255 + "," + s.dropShadowAlpha + ")", e.shadowBlur = d, e.shadowOffsetX = Math.cos(s.dropShadowAngle) * f, e.shadowOffsetY = Math.sin(s.dropShadowAngle) * f;
  } else
    e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0;
  s.stroke && s.strokeThickness && e.strokeText(a, u, l + t.lineHeight - h.descent), s.fill && e.fillText(a, u, l + t.lineHeight - h.descent), e.setTransform(1, 0, 0, 1, 0, 0), e.fillStyle = "rgba(0, 0, 0, 0)";
}
function rl(r) {
  return Array.from ? Array.from(r) : r.split("");
}
function J0(r) {
  typeof r == "string" && (r = [r]);
  for (var e = [], t = 0, i = r.length; t < i; t++) {
    var n = r[t];
    if (Array.isArray(n)) {
      if (n.length !== 2)
        throw new Error("[BitmapFont]: Invalid character range length, expecting 2 got " + n.length + ".");
      var o = n[0].charCodeAt(0), s = n[1].charCodeAt(0);
      if (s < o)
        throw new Error("[BitmapFont]: Invalid character range.");
      for (var a = o, h = s; a <= h; a++)
        e.push(String.fromCharCode(a));
    } else
      e.push.apply(e, rl(n));
  }
  if (e.length === 0)
    throw new Error("[BitmapFont]: Empty set when resolving characters.");
  return e;
}
function qi(r) {
  return r.codePointAt ? r.codePointAt(0) : r.charCodeAt(0);
}
var Ae = (
  /** @class */
  function() {
    function r(e, t, i) {
      var n, o, s = e.info[0], a = e.common[0], h = e.page[0], u = e.distanceField[0], l = hn(h.file), c = {};
      this._ownsTextures = i, this.font = s.face, this.size = s.size, this.lineHeight = a.lineHeight / l, this.chars = {}, this.pageTextures = c;
      for (var p = 0; p < e.page.length; p++) {
        var d = e.page[p], f = d.id, y = d.file;
        c[f] = t instanceof Array ? t[p] : t[y], u != null && u.fieldType && u.fieldType !== "none" && (c[f].baseTexture.alphaMode = ne.NO_PREMULTIPLIED_ALPHA, c[f].baseTexture.mipmap = ie.OFF);
      }
      for (var p = 0; p < e.char.length; p++) {
        var m = e.char[p], f = m.id, _ = m.page, g = e.char[p], b = g.x, x = g.y, E = g.width, v = g.height, T = g.xoffset, S = g.yoffset, R = g.xadvance;
        b /= l, x /= l, E /= l, v /= l, T /= l, S /= l, R /= l;
        var O = new it(b + c[_].frame.x / l, x + c[_].frame.y / l, E, v);
        this.chars[f] = {
          xOffset: T,
          yOffset: S,
          xAdvance: R,
          kerning: {},
          texture: new W(c[_].baseTexture, O),
          page: _
        };
      }
      for (var p = 0; p < e.kerning.length; p++) {
        var w = e.kerning[p], C = w.first, B = w.second, V = w.amount;
        C /= l, B /= l, V /= l, this.chars[B] && (this.chars[B].kerning[C] = V);
      }
      this.distanceFieldRange = u == null ? void 0 : u.distanceRange, this.distanceFieldType = (o = (n = u == null ? void 0 : u.fieldType) === null || n === void 0 ? void 0 : n.toLowerCase()) !== null && o !== void 0 ? o : "none";
    }
    return r.prototype.destroy = function() {
      for (var e in this.chars)
        this.chars[e].texture.destroy(), this.chars[e].texture = null;
      for (var e in this.pageTextures)
        this._ownsTextures && this.pageTextures[e].destroy(!0), this.pageTextures[e] = null;
      this.chars = null, this.pageTextures = null;
    }, r.install = function(e, t, i) {
      var n;
      if (e instanceof fn)
        n = e;
      else {
        var o = el(e);
        if (!o)
          throw new Error("Unrecognized data format for font.");
        n = o.parse(e);
      }
      t instanceof W && (t = [t]);
      var s = new r(n, t, i);
      return r.available[s.font] = s, s;
    }, r.uninstall = function(e) {
      var t = r.available[e];
      if (!t)
        throw new Error("No font found named '" + e + "'");
      t.destroy(), delete r.available[e];
    }, r.from = function(e, t, i) {
      if (!e)
        throw new Error("[BitmapFont] Property `name` is required.");
      var n = Object.assign({}, r.defaultOptions, i), o = n.chars, s = n.padding, a = n.resolution, h = n.textureWidth, u = n.textureHeight, l = J0(o), c = t instanceof Pr ? t : new Pr(t), p = h, d = new fn();
      d.info[0] = {
        face: c.fontFamily,
        size: c.fontSize
      }, d.common[0] = {
        lineHeight: c.fontSize
      };
      for (var f = 0, y = 0, m, _, g, b = 0, x = [], E = 0; E < l.length; E++) {
        m || (m = L.ADAPTER.createCanvas(), m.width = h, m.height = u, _ = m.getContext("2d"), g = new rt(m, { resolution: a }), x.push(new W(g)), d.page.push({
          id: x.length - 1,
          file: ""
        }));
        var v = l[E], T = de.measureText(v, c, !1, m), S = T.width, R = Math.ceil(T.height), O = Math.ceil((c.fontStyle === "italic" ? 2 : 1) * S);
        if (y >= u - R * a) {
          if (y === 0)
            throw new Error("[BitmapFont] textureHeight " + u + "px is too small " + ("(fontFamily: '" + c.fontFamily + "', fontSize: " + c.fontSize + "px, char: '" + v + "')"));
          --E, m = null, _ = null, g = null, y = 0, f = 0, b = 0;
          continue;
        }
        if (b = Math.max(R + T.fontProperties.descent, b), O * a + f >= p) {
          if (f === 0)
            throw new Error("[BitmapFont] textureWidth " + h + "px is too small " + ("(fontFamily: '" + c.fontFamily + "', fontSize: " + c.fontSize + "px, char: '" + v + "')"));
          --E, y += b * a, y = Math.ceil(y), f = 0, b = 0;
          continue;
        }
        Z0(m, _, T, f, y, a, c);
        var w = qi(T.text);
        d.char.push({
          id: w,
          page: x.length - 1,
          x: f / a,
          y: y / a,
          width: O,
          height: R,
          xoffset: 0,
          yoffset: 0,
          xadvance: Math.ceil(S - (c.dropShadow ? c.dropShadowDistance : 0) - (c.stroke ? c.strokeThickness : 0))
        }), f += (O + 2 * s) * a, f = Math.ceil(f);
      }
      if (!(i != null && i.skipKerning))
        for (var E = 0, C = l.length; E < C; E++)
          for (var B = l[E], V = 0; V < C; V++) {
            var F = l[V], D = _.measureText(B).width, z = _.measureText(F).width, ot = _.measureText(B + F).width, K = ot - (D + z);
            K && d.kerning.push({
              first: qi(B),
              second: qi(F),
              amount: K
            });
          }
      var M = new r(d, x, !0);
      return r.available[e] !== void 0 && r.uninstall(e), r.available[e] = M, M;
    }, r.ALPHA = [["a", "z"], ["A", "Z"], " "], r.NUMERIC = [["0", "9"]], r.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "], r.ASCII = [[" ", "~"]], r.defaultOptions = {
      resolution: 1,
      textureWidth: 512,
      textureHeight: 512,
      padding: 4,
      chars: r.ALPHANUMERIC
    }, r.available = {}, r;
  }()
), Q0 = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`, tb = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`, Ah = [], Sh = [], Rh = [];
(function(r) {
  W0(e, r);
  function e(t, i) {
    i === void 0 && (i = {});
    var n = r.call(this) || this;
    n._tint = 16777215;
    var o = Object.assign({}, e.styleDefaults, i), s = o.align, a = o.tint, h = o.maxWidth, u = o.letterSpacing, l = o.fontName, c = o.fontSize;
    if (!Ae.available[l])
      throw new Error('Missing BitmapFont "' + l + '"');
    return n._activePagesMeshData = [], n._textWidth = 0, n._textHeight = 0, n._align = s, n._tint = a, n._font = void 0, n._fontName = l, n._fontSize = c, n.text = t, n._maxWidth = h, n._maxLineHeight = 0, n._letterSpacing = u, n._anchor = new gr(function() {
      n.dirty = !0;
    }, n, 0, 0), n._roundPixels = L.ROUND_PIXELS, n.dirty = !0, n._resolution = L.RESOLUTION, n._autoResolution = !0, n._textureCache = {}, n;
  }
  return e.prototype.updateText = function() {
    for (var t, i = Ae.available[this._fontName], n = this.fontSize, o = n / i.size, s = new _t(), a = [], h = [], u = [], l = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ", c = rl(l), p = this._maxWidth * i.size / n, d = i.distanceFieldType === "none" ? Ah : Sh, f = null, y = 0, m = 0, _ = 0, g = -1, b = 0, x = 0, E = 0, v = 0, T = 0; T < c.length; T++) {
      var S = c[T], R = qi(S);
      if (/(?:\s)/.test(S) && (g = T, b = y, v++), S === "\r" || S === `
`) {
        h.push(y), u.push(-1), m = Math.max(m, y), ++_, ++x, s.x = 0, s.y += i.lineHeight, f = null, v = 0;
        continue;
      }
      var O = i.chars[R];
      if (O) {
        f && O.kerning[f] && (s.x += O.kerning[f]);
        var w = Rh.pop() || {
          texture: W.EMPTY,
          line: 0,
          charCode: 0,
          prevSpaces: 0,
          position: new _t()
        };
        w.texture = O.texture, w.line = _, w.charCode = R, w.position.x = s.x + O.xOffset + this._letterSpacing / 2, w.position.y = s.y + O.yOffset, w.prevSpaces = v, a.push(w), y = w.position.x + Math.max(O.xAdvance - O.xOffset, O.texture.orig.width), s.x += O.xAdvance + this._letterSpacing, E = Math.max(E, O.yOffset + O.texture.height), f = R, g !== -1 && p > 0 && s.x > p && (++x, Er(a, 1 + g - x, 1 + T - g), T = g, g = -1, h.push(b), u.push(a.length > 0 ? a[a.length - 1].prevSpaces : 0), m = Math.max(m, b), _++, s.x = 0, s.y += i.lineHeight, f = null, v = 0);
      }
    }
    var C = c[c.length - 1];
    C !== "\r" && C !== `
` && (/(?:\s)/.test(C) && (y = b), h.push(y), m = Math.max(m, y), u.push(-1));
    for (var B = [], T = 0; T <= _; T++) {
      var V = 0;
      this._align === "right" ? V = m - h[T] : this._align === "center" ? V = (m - h[T]) / 2 : this._align === "justify" && (V = u[T] < 0 ? 0 : (m - h[T]) / u[T]), B.push(V);
    }
    var F = a.length, D = {}, z = [], ot = this._activePagesMeshData;
    d.push.apply(d, ot);
    for (var T = 0; T < F; T++) {
      var K = a[T].texture, M = K.baseTexture.uid;
      if (!D[M]) {
        var I = d.pop();
        if (!I) {
          var X = new Tn(), Z = void 0, Q = void 0;
          i.distanceFieldType === "none" ? (Z = new ai(W.EMPTY), Q = k.NORMAL) : (Z = new ai(W.EMPTY, { program: pi.from(tb, Q0), uniforms: { uFWidth: 0 } }), Q = k.NORMAL_NPM);
          var mt = new si(X, Z);
          mt.blendMode = Q, I = {
            index: 0,
            indexCount: 0,
            vertexCount: 0,
            uvsCount: 0,
            total: 0,
            mesh: mt,
            vertices: null,
            uvs: null,
            indices: null
          };
        }
        I.index = 0, I.indexCount = 0, I.vertexCount = 0, I.uvsCount = 0, I.total = 0;
        var q = this._textureCache;
        q[M] = q[M] || new W(K.baseTexture), I.mesh.texture = q[M], I.mesh.tint = this._tint, z.push(I), D[M] = I;
      }
      D[M].total++;
    }
    for (var T = 0; T < ot.length; T++)
      z.indexOf(ot[T]) === -1 && this.removeChild(ot[T].mesh);
    for (var T = 0; T < z.length; T++)
      z[T].mesh.parent !== this && this.addChild(z[T].mesh);
    this._activePagesMeshData = z;
    for (var T in D) {
      var I = D[T], lt = I.total;
      if (!(((t = I.indices) === null || t === void 0 ? void 0 : t.length) > 6 * lt) || I.vertices.length < si.BATCHABLE_SIZE * 2)
        I.vertices = new Float32Array(4 * 2 * lt), I.uvs = new Float32Array(4 * 2 * lt), I.indices = new Uint16Array(6 * lt);
      else
        for (var vt = I.total, At = I.vertices, tt = vt * 4 * 2; tt < At.length; tt++)
          At[tt] = 0;
      I.mesh.size = 6 * lt;
    }
    for (var T = 0; T < F; T++) {
      var S = a[T], nt = S.position.x + B[S.line] * (this._align === "justify" ? S.prevSpaces : 1);
      this._roundPixels && (nt = Math.round(nt));
      var ht = nt * o, pt = S.position.y * o, K = S.texture, J = D[K.baseTexture.uid], G = K.frame, N = K._uvs, ut = J.index++;
      J.indices[ut * 6 + 0] = 0 + ut * 4, J.indices[ut * 6 + 1] = 1 + ut * 4, J.indices[ut * 6 + 2] = 2 + ut * 4, J.indices[ut * 6 + 3] = 0 + ut * 4, J.indices[ut * 6 + 4] = 2 + ut * 4, J.indices[ut * 6 + 5] = 3 + ut * 4, J.vertices[ut * 8 + 0] = ht, J.vertices[ut * 8 + 1] = pt, J.vertices[ut * 8 + 2] = ht + G.width * o, J.vertices[ut * 8 + 3] = pt, J.vertices[ut * 8 + 4] = ht + G.width * o, J.vertices[ut * 8 + 5] = pt + G.height * o, J.vertices[ut * 8 + 6] = ht, J.vertices[ut * 8 + 7] = pt + G.height * o, J.uvs[ut * 8 + 0] = N.x0, J.uvs[ut * 8 + 1] = N.y0, J.uvs[ut * 8 + 2] = N.x1, J.uvs[ut * 8 + 3] = N.y1, J.uvs[ut * 8 + 4] = N.x2, J.uvs[ut * 8 + 5] = N.y2, J.uvs[ut * 8 + 6] = N.x3, J.uvs[ut * 8 + 7] = N.y3;
    }
    this._textWidth = m * o, this._textHeight = (s.y + i.lineHeight) * o;
    for (var T in D) {
      var I = D[T];
      if (this.anchor.x !== 0 || this.anchor.y !== 0)
        for (var oe = 0, nr = this._textWidth * this.anchor.x, fi = this._textHeight * this.anchor.y, Cs = 0; Cs < I.total; Cs++)
          I.vertices[oe++] -= nr, I.vertices[oe++] -= fi, I.vertices[oe++] -= nr, I.vertices[oe++] -= fi, I.vertices[oe++] -= nr, I.vertices[oe++] -= fi, I.vertices[oe++] -= nr, I.vertices[oe++] -= fi;
      this._maxLineHeight = E * o;
      var Fs = I.mesh.geometry.getBuffer("aVertexPosition"), Ns = I.mesh.geometry.getBuffer("aTextureCoord"), Ls = I.mesh.geometry.getIndex();
      Fs.data = I.vertices, Ns.data = I.uvs, Ls.data = I.indices, Fs.update(), Ns.update(), Ls.update();
    }
    for (var T = 0; T < a.length; T++)
      Rh.push(a[T]);
    this._font = i, this.dirty = !1;
  }, e.prototype.updateTransform = function() {
    this.validate(), this.containerUpdateTransform();
  }, e.prototype._render = function(t) {
    this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0);
    var i = Ae.available[this._fontName], n = i.distanceFieldRange, o = i.distanceFieldType, s = i.size;
    if (o !== "none")
      for (var a = this.worldTransform, h = a.a, u = a.b, l = a.c, c = a.d, p = Math.sqrt(h * h + u * u), d = Math.sqrt(l * l + c * c), f = (Math.abs(p) + Math.abs(d)) / 2, y = this.fontSize / s, m = 0, _ = this._activePagesMeshData; m < _.length; m++) {
        var g = _[m];
        g.mesh.shader.uniforms.uFWidth = f * n * y * this._resolution;
      }
    r.prototype._render.call(this, t);
  }, e.prototype.getLocalBounds = function() {
    return this.validate(), r.prototype.getLocalBounds.call(this);
  }, e.prototype.validate = function() {
    var t = Ae.available[this._fontName];
    if (!t)
      throw new Error('Missing BitmapFont "' + this._fontName + '"');
    this._font !== t && (this.dirty = !0), this.dirty && this.updateText();
  }, Object.defineProperty(e.prototype, "tint", {
    /**
     * The tint of the BitmapText object.
     * @default 0xffffff
     */
    get: function() {
      return this._tint;
    },
    set: function(t) {
      if (this._tint !== t) {
        this._tint = t;
        for (var i = 0; i < this._activePagesMeshData.length; i++)
          this._activePagesMeshData[i].mesh.tint = t;
      }
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "align", {
    /**
     * The alignment of the BitmapText object.
     * @member {string}
     * @default 'left'
     */
    get: function() {
      return this._align;
    },
    set: function(t) {
      this._align !== t && (this._align = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "fontName", {
    /** The name of the BitmapFont. */
    get: function() {
      return this._fontName;
    },
    set: function(t) {
      if (!Ae.available[t])
        throw new Error('Missing BitmapFont "' + t + '"');
      this._fontName !== t && (this._fontName = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "fontSize", {
    /** The size of the font to display. */
    get: function() {
      var t;
      return (t = this._fontSize) !== null && t !== void 0 ? t : Ae.available[this._fontName].size;
    },
    set: function(t) {
      this._fontSize !== t && (this._fontSize = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "anchor", {
    /**
     * The anchor sets the origin point of the text.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     */
    get: function() {
      return this._anchor;
    },
    set: function(t) {
      typeof t == "number" ? this._anchor.set(t) : this._anchor.copyFrom(t);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "text", {
    /** The text of the BitmapText object. */
    get: function() {
      return this._text;
    },
    set: function(t) {
      t = String(t ?? ""), this._text !== t && (this._text = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "maxWidth", {
    /**
     * The max width of this bitmap text in pixels. If the text provided is longer than the
     * value provided, line breaks will be automatically inserted in the last whitespace.
     * Disable by setting the value to 0.
     */
    get: function() {
      return this._maxWidth;
    },
    set: function(t) {
      this._maxWidth !== t && (this._maxWidth = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "maxLineHeight", {
    /**
     * The max line height. This is useful when trying to use the total height of the Text,
     * i.e. when trying to vertically align.
     * @readonly
     */
    get: function() {
      return this.validate(), this._maxLineHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "textWidth", {
    /**
     * The width of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textWidth;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "letterSpacing", {
    /** Additional space between characters. */
    get: function() {
      return this._letterSpacing;
    },
    set: function(t) {
      this._letterSpacing !== t && (this._letterSpacing = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "roundPixels", {
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     * @default PIXI.settings.ROUND_PIXELS
     */
    get: function() {
      return this._roundPixels;
    },
    set: function(t) {
      t !== this._roundPixels && (this._roundPixels = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "textHeight", {
    /**
     * The height of the overall text, different from fontSize,
     * which is defined in the style object.
     * @readonly
     */
    get: function() {
      return this.validate(), this._textHeight;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "resolution", {
    /**
     * The resolution / device pixel ratio of the canvas.
     *
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @default 1
     */
    get: function() {
      return this._resolution;
    },
    set: function(t) {
      this._autoResolution = !1, this._resolution !== t && (this._resolution = t, this.dirty = !0);
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.destroy = function(t) {
    var i = this._textureCache, n = Ae.available[this._fontName], o = n.distanceFieldType === "none" ? Ah : Sh;
    o.push.apply(o, this._activePagesMeshData);
    for (var s = 0, a = this._activePagesMeshData; s < a.length; s++) {
      var h = a[s];
      this.removeChild(h.mesh);
    }
    this._activePagesMeshData = [], o.filter(function(c) {
      return i[c.mesh.texture.baseTexture.uid];
    }).forEach(function(c) {
      c.mesh.texture = W.EMPTY;
    });
    for (var u in i) {
      var l = i[u];
      l.destroy(), delete i[u];
    }
    this._font = null, this._textureCache = null, r.prototype.destroy.call(this, t);
  }, e.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
  }, e;
})(pe);
var eb = (
  /** @class */
  function() {
    function r() {
    }
    return r.add = function() {
      Et.setExtensionXhrType("fnt", Et.XHR_RESPONSE_TYPE.TEXT);
    }, r.use = function(e, t) {
      var i = el(e.data);
      if (!i) {
        t();
        return;
      }
      for (var n = r.getBaseUrl(this, e), o = i.parse(e.data), s = {}, a = function(y) {
        s[y.metadata.pageFile] = y.texture, Object.keys(s).length === o.page.length && (e.bitmapFont = Ae.install(o, s, !0), t());
      }, h = 0; h < o.page.length; ++h) {
        var u = o.page[h].file, l = n + u, c = !1;
        for (var p in this.resources) {
          var d = this.resources[p];
          if (d.url === l) {
            d.metadata.pageFile = u, d.texture ? a(d) : d.onAfterMiddleware.add(a), c = !0;
            break;
          }
        }
        if (!c) {
          var f = {
            crossOrigin: e.crossOrigin,
            loadType: Et.LOAD_TYPE.IMAGE,
            metadata: Object.assign({ pageFile: u }, e.metadata.imageMetadata),
            parentResource: e
          };
          this.add(l, f, a);
        }
      }
    }, r.getBaseUrl = function(e, t) {
      var i = t.isDataUrl ? "" : r.dirname(t.url);
      return t.isDataUrl && (i === "." && (i = ""), e.baseUrl && i && e.baseUrl.charAt(e.baseUrl.length - 1) === "/" && (i += "/")), i = i.replace(e.baseUrl, ""), i && i.charAt(i.length - 1) !== "/" && (i += "/"), i;
    }, r.dirname = function(e) {
      var t = e.replace(/\\/g, "/").replace(/\/$/, "").replace(/\/[^\/]*$/, "");
      return t === e ? "." : t === "" ? "/" : t;
    }, r.extension = dt.Loader, r;
  }()
);
/*!
 * @pixi/filter-alpha - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-alpha is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ns = function(r, e) {
  return ns = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, ns(r, e);
};
function rb(r, e) {
  ns(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var ib = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
(function(r) {
  rb(e, r);
  function e(t) {
    t === void 0 && (t = 1);
    var i = r.call(this, Kg, ib, { uAlpha: 1 }) || this;
    return i.alpha = t, i;
  }
  return Object.defineProperty(e.prototype, "alpha", {
    /**
     * Coefficient for alpha multiplication
     * @default 1
     */
    get: function() {
      return this.uniforms.uAlpha;
    },
    set: function(t) {
      this.uniforms.uAlpha = t;
    },
    enumerable: !1,
    configurable: !0
  }), e;
})(Ne);
/*!
 * @pixi/filter-blur - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-blur is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var os = function(r, e) {
  return os = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, os(r, e);
};
function il(r, e) {
  os(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var nb = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function ob(r, e) {
  var t = Math.ceil(r / 2), i = nb, n = "", o;
  e ? o = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : o = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
  for (var s = 0; s < r; s++) {
    var a = o.replace("%index%", s.toString());
    a = a.replace("%sampleIndex%", s - (t - 1) + ".0"), n += a, n += `
`;
  }
  return i = i.replace("%blur%", n), i = i.replace("%size%", r.toString()), i;
}
var sb = {
  5: [0.153388, 0.221461, 0.250301],
  7: [0.071303, 0.131514, 0.189879, 0.214607],
  9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
  11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
  13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
  15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
}, ab = [
  "varying vec2 vBlurTexCoords[%size%];",
  "uniform sampler2D uSampler;",
  "void main(void)",
  "{",
  "    gl_FragColor = vec4(0.0);",
  "    %blur%",
  "}"
].join(`
`);
function hb(r) {
  for (var e = sb[r], t = e.length, i = ab, n = "", o = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", s, a = 0; a < r; a++) {
    var h = o.replace("%index%", a.toString());
    s = a, a >= t && (s = r - a - 1), h = h.replace("%value%", e[s].toString()), n += h, n += `
`;
  }
  return i = i.replace("%blur%", n), i = i.replace("%size%", r.toString()), i;
}
var Oh = (
  /** @class */
  function(r) {
    il(e, r);
    function e(t, i, n, o, s) {
      i === void 0 && (i = 8), n === void 0 && (n = 4), o === void 0 && (o = L.FILTER_RESOLUTION), s === void 0 && (s = 5);
      var a = this, h = ob(s, t), u = hb(s);
      return a = r.call(
        this,
        // vertex shader
        h,
        // fragment shader
        u
      ) || this, a.horizontal = t, a.resolution = o, a._quality = 0, a.quality = n, a.blur = i, a;
    }
    return e.prototype.apply = function(t, i, n, o) {
      if (n ? this.horizontal ? this.uniforms.strength = 1 / n.width * (n.width / i.width) : this.uniforms.strength = 1 / n.height * (n.height / i.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / i.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / i.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        t.applyFilter(this, i, n, o);
      else {
        var s = t.getFilterTexture(), a = t.renderer, h = i, u = s;
        this.state.blend = !1, t.applyFilter(this, h, u, Qt.CLEAR);
        for (var l = 1; l < this.passes - 1; l++) {
          t.bindAndClear(h, Qt.BLIT), this.uniforms.uSampler = u;
          var c = u;
          u = h, h = c, a.shader.bind(this), a.geometry.draw(5);
        }
        this.state.blend = !0, t.applyFilter(this, u, n, o), t.returnFilterTexture(s);
      }
    }, Object.defineProperty(e.prototype, "blur", {
      /**
       * Sets the strength of both the blur.
       * @default 16
       */
      get: function() {
        return this.strength;
      },
      set: function(t) {
        this.padding = 1 + Math.abs(t) * 2, this.strength = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "quality", {
      /**
       * Sets the quality of the blur by modifying the number of passes. More passes means higher
       * quality bluring but the lower the performance.
       * @default 4
       */
      get: function() {
        return this._quality;
      },
      set: function(t) {
        this._quality = t, this.passes = t;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Ne)
);
(function(r) {
  il(e, r);
  function e(t, i, n, o) {
    t === void 0 && (t = 8), i === void 0 && (i = 4), n === void 0 && (n = L.FILTER_RESOLUTION), o === void 0 && (o = 5);
    var s = r.call(this) || this;
    return s.blurXFilter = new Oh(!0, t, i, n, o), s.blurYFilter = new Oh(!1, t, i, n, o), s.resolution = n, s.quality = i, s.blur = t, s.repeatEdgePixels = !1, s;
  }
  return e.prototype.apply = function(t, i, n, o) {
    var s = Math.abs(this.blurXFilter.strength), a = Math.abs(this.blurYFilter.strength);
    if (s && a) {
      var h = t.getFilterTexture();
      this.blurXFilter.apply(t, i, h, Qt.CLEAR), this.blurYFilter.apply(t, h, n, o), t.returnFilterTexture(h);
    } else
      a ? this.blurYFilter.apply(t, i, n, o) : this.blurXFilter.apply(t, i, n, o);
  }, e.prototype.updatePadding = function() {
    this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
  }, Object.defineProperty(e.prototype, "blur", {
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(t) {
      this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "quality", {
    /**
     * Sets the number of passes for blur. More passes means higher quality bluring.
     * @default 1
     */
    get: function() {
      return this.blurXFilter.quality;
    },
    set: function(t) {
      this.blurXFilter.quality = this.blurYFilter.quality = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "blurX", {
    /**
     * Sets the strength of the blurX property
     * @default 2
     */
    get: function() {
      return this.blurXFilter.blur;
    },
    set: function(t) {
      this.blurXFilter.blur = t, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "blurY", {
    /**
     * Sets the strength of the blurY property
     * @default 2
     */
    get: function() {
      return this.blurYFilter.blur;
    },
    set: function(t) {
      this.blurYFilter.blur = t, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "blendMode", {
    /**
     * Sets the blendmode of the filter
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get: function() {
      return this.blurYFilter.blendMode;
    },
    set: function(t) {
      this.blurYFilter.blendMode = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "repeatEdgePixels", {
    /**
     * If set to true the edge of the target will be clamped
     * @default false
     */
    get: function() {
      return this._repeatEdgePixels;
    },
    set: function(t) {
      this._repeatEdgePixels = t, this.updatePadding();
    },
    enumerable: !1,
    configurable: !0
  }), e;
})(Ne);
/*!
 * @pixi/filter-color-matrix - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-color-matrix is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ss = function(r, e) {
  return ss = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, ss(r, e);
};
function ub(r, e) {
  ss(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var lb = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`, wh = (
  /** @class */
  function(r) {
    ub(e, r);
    function e() {
      var t = this, i = {
        m: new Float32Array([
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1,
          0
        ]),
        uAlpha: 1
      };
      return t = r.call(this, Hu, lb, i) || this, t.alpha = 1, t;
    }
    return e.prototype._loadMatrix = function(t, i) {
      i === void 0 && (i = !1);
      var n = t;
      i && (this._multiply(n, this.uniforms.m, t), n = this._colorMatrix(n)), this.uniforms.m = n;
    }, e.prototype._multiply = function(t, i, n) {
      return t[0] = i[0] * n[0] + i[1] * n[5] + i[2] * n[10] + i[3] * n[15], t[1] = i[0] * n[1] + i[1] * n[6] + i[2] * n[11] + i[3] * n[16], t[2] = i[0] * n[2] + i[1] * n[7] + i[2] * n[12] + i[3] * n[17], t[3] = i[0] * n[3] + i[1] * n[8] + i[2] * n[13] + i[3] * n[18], t[4] = i[0] * n[4] + i[1] * n[9] + i[2] * n[14] + i[3] * n[19] + i[4], t[5] = i[5] * n[0] + i[6] * n[5] + i[7] * n[10] + i[8] * n[15], t[6] = i[5] * n[1] + i[6] * n[6] + i[7] * n[11] + i[8] * n[16], t[7] = i[5] * n[2] + i[6] * n[7] + i[7] * n[12] + i[8] * n[17], t[8] = i[5] * n[3] + i[6] * n[8] + i[7] * n[13] + i[8] * n[18], t[9] = i[5] * n[4] + i[6] * n[9] + i[7] * n[14] + i[8] * n[19] + i[9], t[10] = i[10] * n[0] + i[11] * n[5] + i[12] * n[10] + i[13] * n[15], t[11] = i[10] * n[1] + i[11] * n[6] + i[12] * n[11] + i[13] * n[16], t[12] = i[10] * n[2] + i[11] * n[7] + i[12] * n[12] + i[13] * n[17], t[13] = i[10] * n[3] + i[11] * n[8] + i[12] * n[13] + i[13] * n[18], t[14] = i[10] * n[4] + i[11] * n[9] + i[12] * n[14] + i[13] * n[19] + i[14], t[15] = i[15] * n[0] + i[16] * n[5] + i[17] * n[10] + i[18] * n[15], t[16] = i[15] * n[1] + i[16] * n[6] + i[17] * n[11] + i[18] * n[16], t[17] = i[15] * n[2] + i[16] * n[7] + i[17] * n[12] + i[18] * n[17], t[18] = i[15] * n[3] + i[16] * n[8] + i[17] * n[13] + i[18] * n[18], t[19] = i[15] * n[4] + i[16] * n[9] + i[17] * n[14] + i[18] * n[19] + i[19], t;
    }, e.prototype._colorMatrix = function(t) {
      var i = new Float32Array(t);
      return i[4] /= 255, i[9] /= 255, i[14] /= 255, i[19] /= 255, i;
    }, e.prototype.brightness = function(t, i) {
      var n = [
        t,
        0,
        0,
        0,
        0,
        0,
        t,
        0,
        0,
        0,
        0,
        0,
        t,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, e.prototype.tint = function(t, i) {
      var n = t >> 16 & 255, o = t >> 8 & 255, s = t & 255, a = [
        n / 255,
        0,
        0,
        0,
        0,
        0,
        o / 255,
        0,
        0,
        0,
        0,
        0,
        s / 255,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(a, i);
    }, e.prototype.greyscale = function(t, i) {
      var n = [
        t,
        t,
        t,
        0,
        0,
        t,
        t,
        t,
        0,
        0,
        t,
        t,
        t,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, e.prototype.blackAndWhite = function(t) {
      var i = [
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0.3,
        0.6,
        0.1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.hue = function(t, i) {
      t = (t || 0) / 180 * Math.PI;
      var n = Math.cos(t), o = Math.sin(t), s = Math.sqrt, a = 1 / 3, h = s(a), u = n + (1 - n) * a, l = a * (1 - n) - h * o, c = a * (1 - n) + h * o, p = a * (1 - n) + h * o, d = n + a * (1 - n), f = a * (1 - n) - h * o, y = a * (1 - n) - h * o, m = a * (1 - n) + h * o, _ = n + a * (1 - n), g = [
        u,
        l,
        c,
        0,
        0,
        p,
        d,
        f,
        0,
        0,
        y,
        m,
        _,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(g, i);
    }, e.prototype.contrast = function(t, i) {
      var n = (t || 0) + 1, o = -0.5 * (n - 1), s = [
        n,
        0,
        0,
        0,
        o,
        0,
        n,
        0,
        0,
        o,
        0,
        0,
        n,
        0,
        o,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(s, i);
    }, e.prototype.saturate = function(t, i) {
      t === void 0 && (t = 0);
      var n = t * 2 / 3 + 1, o = (n - 1) * -0.5, s = [
        n,
        o,
        o,
        0,
        0,
        o,
        n,
        o,
        0,
        0,
        o,
        o,
        n,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(s, i);
    }, e.prototype.desaturate = function() {
      this.saturate(-1);
    }, e.prototype.negative = function(t) {
      var i = [
        -1,
        0,
        0,
        1,
        0,
        0,
        -1,
        0,
        1,
        0,
        0,
        0,
        -1,
        1,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.sepia = function(t) {
      var i = [
        0.393,
        0.7689999,
        0.18899999,
        0,
        0,
        0.349,
        0.6859999,
        0.16799999,
        0,
        0,
        0.272,
        0.5339999,
        0.13099999,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.technicolor = function(t) {
      var i = [
        1.9125277891456083,
        -0.8545344976951645,
        -0.09155508482755585,
        0,
        11.793603434377337,
        -0.3087833385928097,
        1.7658908555458428,
        -0.10601743074722245,
        0,
        -70.35205161461398,
        -0.231103377548616,
        -0.7501899197440212,
        1.847597816108189,
        0,
        30.950940869491138,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.polaroid = function(t) {
      var i = [
        1.438,
        -0.062,
        -0.062,
        0,
        0,
        -0.122,
        1.378,
        -0.122,
        0,
        0,
        -0.016,
        -0.016,
        1.483,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.toBGR = function(t) {
      var i = [
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.kodachrome = function(t) {
      var i = [
        1.1285582396593525,
        -0.3967382283601348,
        -0.03992559172921793,
        0,
        63.72958762196502,
        -0.16404339962244616,
        1.0835251566291304,
        -0.05498805115633132,
        0,
        24.732407896706203,
        -0.16786010706155763,
        -0.5603416277695248,
        1.6014850761964943,
        0,
        35.62982807460946,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.browni = function(t) {
      var i = [
        0.5997023498159715,
        0.34553243048391263,
        -0.2708298674538042,
        0,
        47.43192855600873,
        -0.037703249837783157,
        0.8609577587992641,
        0.15059552388459913,
        0,
        -36.96841498319127,
        0.24113635128153335,
        -0.07441037908422492,
        0.44972182064877153,
        0,
        -7.562075277591283,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.vintage = function(t) {
      var i = [
        0.6279345635605994,
        0.3202183420819367,
        -0.03965408211312453,
        0,
        9.651285835294123,
        0.02578397704808868,
        0.6441188644374771,
        0.03259127616149294,
        0,
        7.462829176470591,
        0.0466055556782719,
        -0.0851232987247891,
        0.5241648018700465,
        0,
        5.159190588235296,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.colorTone = function(t, i, n, o, s) {
      t = t || 0.2, i = i || 0.15, n = n || 16770432, o = o || 3375104;
      var a = (n >> 16 & 255) / 255, h = (n >> 8 & 255) / 255, u = (n & 255) / 255, l = (o >> 16 & 255) / 255, c = (o >> 8 & 255) / 255, p = (o & 255) / 255, d = [
        0.3,
        0.59,
        0.11,
        0,
        0,
        a,
        h,
        u,
        t,
        0,
        l,
        c,
        p,
        i,
        0,
        a - l,
        h - c,
        u - p,
        0,
        0
      ];
      this._loadMatrix(d, s);
    }, e.prototype.night = function(t, i) {
      t = t || 0.1;
      var n = [
        t * -2,
        -t,
        0,
        0,
        0,
        -t,
        0,
        t,
        0,
        0,
        0,
        t,
        t * 2,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, e.prototype.predator = function(t, i) {
      var n = [
        // row 1
        11.224130630493164 * t,
        -4.794486999511719 * t,
        -2.8746118545532227 * t,
        0 * t,
        0.40342438220977783 * t,
        // row 2
        -3.6330697536468506 * t,
        9.193157196044922 * t,
        -2.951810836791992 * t,
        0 * t,
        -1.316135048866272 * t,
        // row 3
        -3.2184197902679443 * t,
        -4.2375030517578125 * t,
        7.476448059082031 * t,
        0 * t,
        0.8044459223747253 * t,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(n, i);
    }, e.prototype.lsd = function(t) {
      var i = [
        2,
        -0.4,
        0.5,
        0,
        0,
        -0.5,
        2,
        -0.4,
        0,
        0,
        -0.4,
        -0.5,
        3,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(i, t);
    }, e.prototype.reset = function() {
      var t = [
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(t, !1);
    }, Object.defineProperty(e.prototype, "matrix", {
      /**
       * The matrix of the color matrix filter
       * @member {number[]}
       * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
       */
      get: function() {
        return this.uniforms.m;
      },
      set: function(t) {
        this.uniforms.m = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "alpha", {
      /**
       * The opacity value to use when mixing the original and resultant colors.
       *
       * When the value is 0, the original color is used without modification.
       * When the value is 1, the result color is used.
       * When in the range (0, 1) the color is interpolated between the original and result by this amount.
       * @default 1
       */
      get: function() {
        return this.uniforms.uAlpha;
      },
      set: function(t) {
        this.uniforms.uAlpha = t;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Ne)
);
wh.prototype.grayscale = wh.prototype.greyscale;
/*!
 * @pixi/filter-displacement - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-displacement is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var as = function(r, e) {
  return as = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, as(r, e);
};
function cb(r, e) {
  as(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var pb = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`, db = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
(function(r) {
  cb(e, r);
  function e(t, i) {
    var n = this, o = new It();
    return t.renderable = !1, n = r.call(this, db, pb, {
      mapSampler: t._texture,
      filterMatrix: o,
      scale: { x: 1, y: 1 },
      rotation: new Float32Array([1, 0, 0, 1])
    }) || this, n.maskSprite = t, n.maskMatrix = o, i == null && (i = 20), n.scale = new _t(i, i), n;
  }
  return e.prototype.apply = function(t, i, n, o) {
    this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
    var s = this.maskSprite.worldTransform, a = Math.sqrt(s.a * s.a + s.b * s.b), h = Math.sqrt(s.c * s.c + s.d * s.d);
    a !== 0 && h !== 0 && (this.uniforms.rotation[0] = s.a / a, this.uniforms.rotation[1] = s.b / a, this.uniforms.rotation[2] = s.c / h, this.uniforms.rotation[3] = s.d / h), t.applyFilter(this, i, n, o);
  }, Object.defineProperty(e.prototype, "map", {
    /** The texture used for the displacement map. Must be power of 2 sized texture. */
    get: function() {
      return this.uniforms.mapSampler;
    },
    set: function(t) {
      this.uniforms.mapSampler = t;
    },
    enumerable: !1,
    configurable: !0
  }), e;
})(Ne);
/*!
 * @pixi/filter-fxaa - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-fxaa is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var hs = function(r, e) {
  return hs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, hs(r, e);
};
function fb(r, e) {
  hs(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var yb = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`, mb = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`;
(function(r) {
  fb(e, r);
  function e() {
    return r.call(this, yb, mb) || this;
  }
  return e;
})(Ne);
/*!
 * @pixi/filter-noise - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/filter-noise is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var us = function(r, e) {
  return us = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, us(r, e);
};
function _b(r, e) {
  us(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var gb = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
(function(r) {
  _b(e, r);
  function e(t, i) {
    t === void 0 && (t = 0.5), i === void 0 && (i = Math.random());
    var n = r.call(this, Hu, gb, {
      uNoise: 0,
      uSeed: 0
    }) || this;
    return n.noise = t, n.seed = i, n;
  }
  return Object.defineProperty(e.prototype, "noise", {
    /**
     * The amount of noise to apply, this value should be in the range (0, 1].
     * @default 0.5
     */
    get: function() {
      return this.uniforms.uNoise;
    },
    set: function(t) {
      this.uniforms.uNoise = t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "seed", {
    /** A seed value to apply to the random noise generation. `Math.random()` is a good value to use. */
    get: function() {
      return this.uniforms.uSeed;
    },
    set: function(t) {
      this.uniforms.uSeed = t;
    },
    enumerable: !1,
    configurable: !0
  }), e;
})(Ne);
/*!
 * @pixi/mixin-cache-as-bitmap - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-cache-as-bitmap is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var nl = new It();
St.prototype._cacheAsBitmap = !1;
St.prototype._cacheData = null;
St.prototype._cacheAsBitmapResolution = null;
St.prototype._cacheAsBitmapMultisample = gt.NONE;
var vb = (
  /** @class */
  function() {
    function r() {
      this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null;
    }
    return r;
  }()
);
Object.defineProperties(St.prototype, {
  /**
   * The resolution to use for cacheAsBitmap. By default this will use the renderer's resolution
   * but can be overriden for performance. Lower values will reduce memory usage at the expense
   * of render quality. A falsey value of `null` or `0` will default to the renderer's resolution.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new resolution.
   * @member {number} cacheAsBitmapResolution
   * @memberof PIXI.DisplayObject#
   * @default null
   */
  cacheAsBitmapResolution: {
    get: function() {
      return this._cacheAsBitmapResolution;
    },
    set: function(r) {
      r !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * The number of samples to use for cacheAsBitmap. If set to `null`, the renderer's
   * sample count is used.
   * If `cacheAsBitmap` is set to `true`, this will re-render with the new number of samples.
   * @member {number} cacheAsBitmapMultisample
   * @memberof PIXI.DisplayObject#
   * @default PIXI.MSAA_QUALITY.NONE
   */
  cacheAsBitmapMultisample: {
    get: function() {
      return this._cacheAsBitmapMultisample;
    },
    set: function(r) {
      r !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = r, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
    }
  },
  /**
   * Set this to true if you want this display object to be cached as a bitmap.
   * This basically takes a snap shot of the display object as it is at that moment. It can
   * provide a performance benefit for complex static displayObjects.
   * To remove simply set this property to `false`
   *
   * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
   * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  cacheAsBitmap: {
    get: function() {
      return this._cacheAsBitmap;
    },
    set: function(r) {
      if (this._cacheAsBitmap !== r) {
        this._cacheAsBitmap = r;
        var e;
        r ? (this._cacheData || (this._cacheData = new vb()), e = this._cacheData, e.originalRender = this.render, e.originalRenderCanvas = this.renderCanvas, e.originalUpdateTransform = this.updateTransform, e.originalCalculateBounds = this.calculateBounds, e.originalGetLocalBounds = this.getLocalBounds, e.originalDestroy = this.destroy, e.originalContainsPoint = this.containsPoint, e.originalMask = this._mask, e.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (e = this._cacheData, e.sprite && this._destroyCachedDisplayObject(), this.render = e.originalRender, this.renderCanvas = e.originalRenderCanvas, this.calculateBounds = e.originalCalculateBounds, this.getLocalBounds = e.originalGetLocalBounds, this.destroy = e.originalDestroy, this.updateTransform = e.originalUpdateTransform, this.containsPoint = e.originalContainsPoint, this._mask = e.originalMask, this.filterArea = e.originalFilterArea);
      }
    }
  }
});
St.prototype._renderCached = function(r) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(r), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(r));
};
St.prototype._initCachedDisplayObject = function(r) {
  var e;
  if (!(this._cacheData && this._cacheData.sprite)) {
    var t = this.alpha;
    this.alpha = 1, r.batch.flush();
    var i = this.getLocalBounds(null, !0).clone();
    if (this.filters && this.filters.length) {
      var n = this.filters[0].padding;
      i.pad(n);
    }
    i.ceil(L.RESOLUTION);
    var o = r.renderTexture.current, s = r.renderTexture.sourceFrame.clone(), a = r.renderTexture.destinationFrame.clone(), h = r.projection.transform, u = er.create({
      width: i.width,
      height: i.height,
      resolution: this.cacheAsBitmapResolution || r.resolution,
      multisample: (e = this.cacheAsBitmapMultisample) !== null && e !== void 0 ? e : r.multisample
    }), l = "cacheAsBitmap_" + tr();
    this._cacheData.textureCacheId = l, rt.addToCache(u.baseTexture, l), W.addToCache(u, l);
    var c = this.transform.localTransform.copyTo(nl).invert().translate(-i.x, -i.y);
    this.render = this._cacheData.originalRender, r.render(this, { renderTexture: u, clear: !0, transform: c, skipUpdateTransform: !1 }), r.framebuffer.blit(), r.projection.transform = h, r.renderTexture.bind(o, s, a), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = t;
    var p = new di(u);
    p.transform.worldTransform = this.transform.worldTransform, p.anchor.x = -(i.x / i.width), p.anchor.y = -(i.y / i.height), p.alpha = t, p._bounds = this._bounds, this._cacheData.sprite = p, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = p.containsPoint.bind(p);
  }
};
St.prototype._renderCachedCanvas = function(r) {
  !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(r), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(r));
};
St.prototype._initCachedDisplayObjectCanvas = function(r) {
  if (!(this._cacheData && this._cacheData.sprite)) {
    var e = this.getLocalBounds(null, !0), t = this.alpha;
    this.alpha = 1;
    var i = r.context, n = r._projTransform;
    e.ceil(L.RESOLUTION);
    var o = er.create({ width: e.width, height: e.height }), s = "cacheAsBitmap_" + tr();
    this._cacheData.textureCacheId = s, rt.addToCache(o.baseTexture, s), W.addToCache(o, s);
    var a = nl;
    this.transform.localTransform.copyTo(a), a.invert(), a.tx -= e.x, a.ty -= e.y, this.renderCanvas = this._cacheData.originalRenderCanvas, r.render(this, { renderTexture: o, clear: !0, transform: a, skipUpdateTransform: !1 }), r.context = i, r._projTransform = n, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = t;
    var h = new di(o);
    h.transform.worldTransform = this.transform.worldTransform, h.anchor.x = -(e.x / e.width), h.anchor.y = -(e.y / e.height), h.alpha = t, h._bounds = this._bounds, this._cacheData.sprite = h, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = r._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = h.containsPoint.bind(h);
  }
};
St.prototype._calculateCachedBounds = function() {
  this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID;
};
St.prototype._getCachedLocalBounds = function() {
  return this._cacheData.sprite.getLocalBounds(null);
};
St.prototype._destroyCachedDisplayObject = function() {
  this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, rt.removeFromCache(this._cacheData.textureCacheId), W.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null;
};
St.prototype._cacheAsBitmapDestroy = function(r) {
  this.cacheAsBitmap = !1, this.destroy(r);
};
/*!
 * @pixi/mixin-get-child-by-name - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
St.prototype.name = null;
pe.prototype.getChildByName = function(r, e) {
  for (var t = 0, i = this.children.length; t < i; t++)
    if (this.children[t].name === r)
      return this.children[t];
  if (e)
    for (var t = 0, i = this.children.length; t < i; t++) {
      var n = this.children[t];
      if (n.getChildByName) {
        var o = n.getChildByName(r, !0);
        if (o)
          return o;
      }
    }
  return null;
};
/*!
 * @pixi/mixin-get-global-position - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
St.prototype.getGlobalPosition = function(r, e) {
  return r === void 0 && (r = new _t()), e === void 0 && (e = !1), this.parent ? this.parent.toGlobal(this.position, r, e) : (r.x = this.position.x, r.y = this.position.y), r;
};
/*!
 * @pixi/app - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/app is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var bb = (
  /** @class */
  function() {
    function r() {
    }
    return r.init = function(e) {
      var t = this;
      Object.defineProperty(
        this,
        "resizeTo",
        /**
         * The HTML element or window to automatically resize the
         * renderer's view element to match width and height.
         * @member {Window|HTMLElement}
         * @name resizeTo
         * @memberof PIXI.Application#
         */
        {
          set: function(i) {
            globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = i, i && (globalThis.addEventListener("resize", this.queueResize), this.resize());
          },
          get: function() {
            return this._resizeTo;
          }
        }
      ), this.queueResize = function() {
        t._resizeTo && (t.cancelResize(), t._resizeId = requestAnimationFrame(function() {
          return t.resize();
        }));
      }, this.cancelResize = function() {
        t._resizeId && (cancelAnimationFrame(t._resizeId), t._resizeId = null);
      }, this.resize = function() {
        if (t._resizeTo) {
          t.cancelResize();
          var i, n;
          if (t._resizeTo === globalThis.window)
            i = globalThis.innerWidth, n = globalThis.innerHeight;
          else {
            var o = t._resizeTo, s = o.clientWidth, a = o.clientHeight;
            i = s, n = a;
          }
          t.renderer.resize(i, n);
        }
      }, this._resizeId = null, this._resizeTo = null, this.resizeTo = e.resizeTo || null;
    }, r.destroy = function() {
      globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null;
    }, r.extension = dt.Application, r;
  }()
), xb = (
  /** @class */
  function() {
    function r(e) {
      var t = this;
      this.stage = new pe(), e = Object.assign({
        forceCanvas: !1
      }, e), this.renderer = ju(e), r._plugins.forEach(function(i) {
        i.init.call(t, e);
      });
    }
    return r.registerPlugin = function(e) {
      re("6.5.0", "Application.registerPlugin() is deprecated, use extensions.add()"), Te.add({
        type: dt.Application,
        ref: e
      });
    }, r.prototype.render = function() {
      this.renderer.render(this.stage);
    }, Object.defineProperty(r.prototype, "view", {
      /**
       * Reference to the renderer's canvas element.
       * @member {HTMLCanvasElement}
       * @readonly
       */
      get: function() {
        return this.renderer.view;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "screen", {
      /**
       * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.
       * @member {PIXI.Rectangle}
       * @readonly
       */
      get: function() {
        return this.renderer.screen;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.destroy = function(e, t) {
      var i = this, n = r._plugins.slice(0);
      n.reverse(), n.forEach(function(o) {
        o.destroy.call(i);
      }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null;
    }, r._plugins = [], r;
  }()
);
Te.handleByList(dt.Application, xb._plugins);
Te.add(bb);
/*!
 * @pixi/mesh-extras - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/mesh-extras is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ls = function(r, e) {
  return ls = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, ls(r, e);
};
function Cr(r, e) {
  ls(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Tb = (
  /** @class */
  function(r) {
    Cr(e, r);
    function e(t, i, n, o) {
      t === void 0 && (t = 100), i === void 0 && (i = 100), n === void 0 && (n = 10), o === void 0 && (o = 10);
      var s = r.call(this) || this;
      return s.segWidth = n, s.segHeight = o, s.width = t, s.height = i, s.build(), s;
    }
    return e.prototype.build = function() {
      for (var t = this.segWidth * this.segHeight, i = [], n = [], o = [], s = this.segWidth - 1, a = this.segHeight - 1, h = this.width / s, u = this.height / a, l = 0; l < t; l++) {
        var c = l % this.segWidth, p = l / this.segWidth | 0;
        i.push(c * h, p * u), n.push(c / s, p / a);
      }
      for (var d = s * a, l = 0; l < d; l++) {
        var f = l % s, y = l / s | 0, m = y * this.segWidth + f, _ = y * this.segWidth + f + 1, g = (y + 1) * this.segWidth + f, b = (y + 1) * this.segWidth + f + 1;
        o.push(m, _, g, _, b, g);
      }
      this.buffers[0].data = new Float32Array(i), this.buffers[1].data = new Float32Array(n), this.indexBuffer.data = new Uint16Array(o), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update();
    }, e;
  }(Tn)
), Eb = (
  /** @class */
  function(r) {
    Cr(e, r);
    function e(t, i, n) {
      t === void 0 && (t = 200), n === void 0 && (n = 0);
      var o = r.call(this, new Float32Array(i.length * 4), new Float32Array(i.length * 4), new Uint16Array((i.length - 1) * 6)) || this;
      return o.points = i, o._width = t, o.textureScale = n, o.build(), o;
    }
    return Object.defineProperty(e.prototype, "width", {
      /**
       * The width (i.e., thickness) of the rope.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.build = function() {
      var t = this.points;
      if (t) {
        var i = this.getBuffer("aVertexPosition"), n = this.getBuffer("aTextureCoord"), o = this.getIndex();
        if (!(t.length < 1)) {
          i.data.length / 4 !== t.length && (i.data = new Float32Array(t.length * 4), n.data = new Float32Array(t.length * 4), o.data = new Uint16Array((t.length - 1) * 6));
          var s = n.data, a = o.data;
          s[0] = 0, s[1] = 0, s[2] = 0, s[3] = 1;
          for (var h = 0, u = t[0], l = this._width * this.textureScale, c = t.length, p = 0; p < c; p++) {
            var d = p * 4;
            if (this.textureScale > 0) {
              var f = u.x - t[p].x, y = u.y - t[p].y, m = Math.sqrt(f * f + y * y);
              u = t[p], h += m / l;
            } else
              h = p / (c - 1);
            s[d] = h, s[d + 1] = 0, s[d + 2] = h, s[d + 3] = 1;
          }
          for (var _ = 0, p = 0; p < c - 1; p++) {
            var d = p * 2;
            a[_++] = d, a[_++] = d + 1, a[_++] = d + 2, a[_++] = d + 2, a[_++] = d + 1, a[_++] = d + 3;
          }
          n.update(), o.update(), this.updateVertices();
        }
      }
    }, e.prototype.updateVertices = function() {
      var t = this.points;
      if (!(t.length < 1)) {
        for (var i = t[0], n, o = 0, s = 0, a = this.buffers[0].data, h = t.length, u = 0; u < h; u++) {
          var l = t[u], c = u * 4;
          u < t.length - 1 ? n = t[u + 1] : n = l, s = -(n.x - i.x), o = n.y - i.y;
          var p = Math.sqrt(o * o + s * s), d = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
          o /= p, s /= p, o *= d, s *= d, a[c] = l.x + o, a[c + 1] = l.y + s, a[c + 2] = l.x - o, a[c + 3] = l.y - s, i = l;
        }
        this.buffers[0].update();
      }
    }, e.prototype.update = function() {
      this.textureScale > 0 ? this.build() : this.updateVertices();
    }, e;
  }(Tn)
);
(function(r) {
  Cr(e, r);
  function e(t, i, n) {
    n === void 0 && (n = 0);
    var o = this, s = new Eb(t.height, i, n), a = new ai(t);
    return n > 0 && (t.baseTexture.wrapMode = le.REPEAT), o = r.call(this, s, a) || this, o.autoUpdate = !0, o;
  }
  return e.prototype._render = function(t) {
    var i = this.geometry;
    (this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height, i.update()), r.prototype._render.call(this, t);
  }, e;
})(si);
var Ab = (
  /** @class */
  function(r) {
    Cr(e, r);
    function e(t, i, n) {
      var o = this, s = new Tb(t.width, t.height, i, n), a = new ai(W.WHITE);
      return o = r.call(this, s, a) || this, o.texture = t, o.autoResize = !0, o;
    }
    return e.prototype.textureUpdated = function() {
      this._textureID = this.shader.texture._updateID;
      var t = this.geometry, i = this.shader.texture, n = i.width, o = i.height;
      this.autoResize && (t.width !== n || t.height !== o) && (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build());
    }, Object.defineProperty(e.prototype, "texture", {
      get: function() {
        return this.shader.texture;
      },
      set: function(t) {
        this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this));
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype._render = function(t) {
      this._textureID !== this.shader.texture._updateID && this.textureUpdated(), r.prototype._render.call(this, t);
    }, e.prototype.destroy = function(t) {
      this.shader.texture.off("update", this.textureUpdated, this), r.prototype.destroy.call(this, t);
    }, e;
  }(si)
);
(function(r) {
  Cr(e, r);
  function e(t, i, n, o, s) {
    t === void 0 && (t = W.EMPTY);
    var a = this, h = new Tn(i, n, o);
    h.getBuffer("aVertexPosition").static = !1;
    var u = new ai(t);
    return a = r.call(this, h, u, null, s) || this, a.autoUpdate = !0, a;
  }
  return Object.defineProperty(e.prototype, "vertices", {
    /**
     * Collection of vertices data.
     * @type {Float32Array}
     */
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(t) {
      this.geometry.getBuffer("aVertexPosition").data = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._render = function(t) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), r.prototype._render.call(this, t);
  }, e;
})(si);
var Vi = 10;
(function(r) {
  Cr(e, r);
  function e(t, i, n, o, s) {
    i === void 0 && (i = Vi), n === void 0 && (n = Vi), o === void 0 && (o = Vi), s === void 0 && (s = Vi);
    var a = r.call(this, W.WHITE, 4, 4) || this;
    return a._origWidth = t.orig.width, a._origHeight = t.orig.height, a._width = a._origWidth, a._height = a._origHeight, a._leftWidth = i, a._rightWidth = o, a._topHeight = n, a._bottomHeight = s, a.texture = t, a;
  }
  return e.prototype.textureUpdated = function() {
    this._textureID = this.shader.texture._updateID, this._refresh();
  }, Object.defineProperty(e.prototype, "vertices", {
    get: function() {
      return this.geometry.getBuffer("aVertexPosition").data;
    },
    set: function(t) {
      this.geometry.getBuffer("aVertexPosition").data = t;
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype.updateHorizontalVertices = function() {
    var t = this.vertices, i = this._getMinScale();
    t[9] = t[11] = t[13] = t[15] = this._topHeight * i, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * i, t[25] = t[27] = t[29] = t[31] = this._height;
  }, e.prototype.updateVerticalVertices = function() {
    var t = this.vertices, i = this._getMinScale();
    t[2] = t[10] = t[18] = t[26] = this._leftWidth * i, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * i, t[6] = t[14] = t[22] = t[30] = this._width;
  }, e.prototype._getMinScale = function() {
    var t = this._leftWidth + this._rightWidth, i = this._width > t ? 1 : this._width / t, n = this._topHeight + this._bottomHeight, o = this._height > n ? 1 : this._height / n, s = Math.min(i, o);
    return s;
  }, Object.defineProperty(e.prototype, "width", {
    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._width;
    },
    set: function(t) {
      this._width = t, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "height", {
    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */
    get: function() {
      return this._height;
    },
    set: function(t) {
      this._height = t, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "leftWidth", {
    /** The width of the left column. */
    get: function() {
      return this._leftWidth;
    },
    set: function(t) {
      this._leftWidth = t, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "rightWidth", {
    /** The width of the right column. */
    get: function() {
      return this._rightWidth;
    },
    set: function(t) {
      this._rightWidth = t, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "topHeight", {
    /** The height of the top row. */
    get: function() {
      return this._topHeight;
    },
    set: function(t) {
      this._topHeight = t, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "bottomHeight", {
    /** The height of the bottom row. */
    get: function() {
      return this._bottomHeight;
    },
    set: function(t) {
      this._bottomHeight = t, this._refresh();
    },
    enumerable: !1,
    configurable: !0
  }), e.prototype._refresh = function() {
    var t = this.texture, i = this.geometry.buffers[1].data;
    this._origWidth = t.orig.width, this._origHeight = t.orig.height;
    var n = 1 / this._origWidth, o = 1 / this._origHeight;
    i[0] = i[8] = i[16] = i[24] = 0, i[1] = i[3] = i[5] = i[7] = 0, i[6] = i[14] = i[22] = i[30] = 1, i[25] = i[27] = i[29] = i[31] = 1, i[2] = i[10] = i[18] = i[26] = n * this._leftWidth, i[4] = i[12] = i[20] = i[28] = 1 - n * this._rightWidth, i[9] = i[11] = i[13] = i[15] = o * this._topHeight, i[17] = i[19] = i[21] = i[23] = 1 - o * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update();
  }, e;
})(Ab);
/*!
 * @pixi/sprite-animated - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/sprite-animated is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var cs = function(r, e) {
  return cs = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      i.hasOwnProperty(n) && (t[n] = i[n]);
  }, cs(r, e);
};
function Sb(r, e) {
  cs(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
(function(r) {
  Sb(e, r);
  function e(t, i) {
    i === void 0 && (i = !0);
    var n = r.call(this, t[0] instanceof W ? t[0] : t[0].texture) || this;
    return n._textures = null, n._durations = null, n._autoUpdate = i, n._isConnectedToTicker = !1, n.animationSpeed = 1, n.loop = !0, n.updateAnchor = !1, n.onComplete = null, n.onFrameChange = null, n.onLoop = null, n._currentTime = 0, n._playing = !1, n._previousFrame = null, n.textures = t, n;
  }
  return e.prototype.stop = function() {
    this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1));
  }, e.prototype.play = function() {
    this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Lt.shared.add(this.update, this, xe.HIGH), this._isConnectedToTicker = !0));
  }, e.prototype.gotoAndStop = function(t) {
    this.stop();
    var i = this.currentFrame;
    this._currentTime = t, i !== this.currentFrame && this.updateTexture();
  }, e.prototype.gotoAndPlay = function(t) {
    var i = this.currentFrame;
    this._currentTime = t, i !== this.currentFrame && this.updateTexture(), this.play();
  }, e.prototype.update = function(t) {
    if (this._playing) {
      var i = this.animationSpeed * t, n = this.currentFrame;
      if (this._durations !== null) {
        var o = this._currentTime % 1 * this._durations[this.currentFrame];
        for (o += i / 60 * 1e3; o < 0; )
          this._currentTime--, o += this._durations[this.currentFrame];
        var s = Math.sign(this.animationSpeed * t);
        for (this._currentTime = Math.floor(this._currentTime); o >= this._durations[this.currentFrame]; )
          o -= this._durations[this.currentFrame] * s, this._currentTime += s;
        this._currentTime += o / this._durations[this.currentFrame];
      } else
        this._currentTime += i;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : n !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < n ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > n && this.onLoop()), this.updateTexture());
    }
  }, e.prototype.updateTexture = function() {
    var t = this.currentFrame;
    this._previousFrame !== t && (this._previousFrame = t, this._texture = this._textures[t], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
  }, e.prototype.destroy = function(t) {
    this.stop(), r.prototype.destroy.call(this, t), this.onComplete = null, this.onFrameChange = null, this.onLoop = null;
  }, e.fromFrames = function(t) {
    for (var i = [], n = 0; n < t.length; ++n)
      i.push(W.from(t[n]));
    return new e(i);
  }, e.fromImages = function(t) {
    for (var i = [], n = 0; n < t.length; ++n)
      i.push(W.from(t[n]));
    return new e(i);
  }, Object.defineProperty(e.prototype, "totalFrames", {
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     * @readonly
     * @default 0
     */
    get: function() {
      return this._textures.length;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "textures", {
    /** The array of textures used for this AnimatedSprite. */
    get: function() {
      return this._textures;
    },
    set: function(t) {
      if (t[0] instanceof W)
        this._textures = t, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var i = 0; i < t.length; i++)
          this._textures.push(t[i].texture), this._durations.push(t[i].time);
      }
      this._previousFrame = null, this.gotoAndStop(0), this.updateTexture();
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "currentFrame", {
    /**
     * The AnimatedSprites current frame index.
     * @readonly
     */
    get: function() {
      var t = Math.floor(this._currentTime) % this._textures.length;
      return t < 0 && (t += this._textures.length), t;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "playing", {
    /**
     * Indicates if the AnimatedSprite is currently playing.
     * @readonly
     */
    get: function() {
      return this._playing;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(e.prototype, "autoUpdate", {
    /** Whether to use PIXI.Ticker.shared to auto update animation time. */
    get: function() {
      return this._autoUpdate;
    },
    set: function(t) {
      t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Lt.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Lt.shared.add(this.update, this), this._isConnectedToTicker = !0));
    },
    enumerable: !1,
    configurable: !0
  }), e;
})(di);
/*!
 * pixi.js - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * pixi.js is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
Te.add(
  // Install renderer plugins
  av,
  yv,
  pv,
  a0,
  L0,
  Vu,
  H0,
  // Install loader plugins
  eb,
  Dv,
  i0,
  n0,
  G0,
  // Install application plugins
  R_,
  Ev
);
const yn = 1733608, ol = 0.25, Rb = (r, e) => {
  const { x: t, y: i, w: n, h: o } = r.geometry, s = e != null && e.fill ? Ir(e.fill) : yn, a = (e == null ? void 0 : e.fillOpacity) === void 0 ? ol : e.fillOpacity, h = new rr();
  return h.beginFill(16777215, a), h.drawRect(t, i, n, o), h.endFill(), h.tint = s, h;
}, Ob = (r, e) => {
  const t = r.geometry.points.reduce((s, a) => [...s, ...a], []), i = e != null && e.fill ? Ir(e.fill) : yn, n = (e == null ? void 0 : e.fillOpacity) === void 0 ? ol : e.fillOpacity, o = new rr();
  return o.beginFill(i, n), o.drawPolygon(t), o.endFill(), o;
}, wb = (r, e, t) => () => {
  const i = r.viewport.viewportToImageRectangle(r.viewport.getBounds(!0)), n = r.viewport.getContainerSize().x, o = r.viewport.getZoom(!0) * n / r.world.getContentFactor(), s = Math.PI * r.viewport.getRotation() / 180, a = -i.x * o, h = -i.y * o;
  let u, l;
  s > 0 && s <= Math.PI / 2 ? (u = i.height * o, l = 0) : s > Math.PI / 2 && s <= Math.PI ? (u = i.width * o, l = i.height * o) : s > Math.PI && s <= Math.PI * 1.5 ? (u = 0, l = i.width * o) : (u = 0, l = 0), e.position.x = u + a * Math.cos(s) - h * Math.sin(s), e.position.y = l + a * Math.sin(s) + h * Math.cos(s), e.scale.set(o, o), e.rotation = s, t.render(e);
}, Ib = (r, e) => {
  const t = new rr(), i = ju({
    width: e.width,
    height: e.height,
    backgroundAlpha: 0,
    view: e
  }), n = /* @__PURE__ */ new Map();
  let o;
  const s = (c) => {
    const { selector: p } = c.target, d = typeof o == "function" ? o(c) : o;
    let f;
    p.type === kt.RECTANGLE ? f = Rb(p, d) : p.type === kt.POLYGON ? f = Ob(p, d) : console.warn(`Unsupported shape type: ${p.type}`), f && (t.addChild(f), n.set(c.id, { g: f, annotation: c }));
  }, a = (c) => {
    const p = n.get(c.id);
    p && (n.delete(c.id), p.g.destroy());
  }, h = (c, p) => {
    const d = n.get(c.id);
    d && (n.delete(c.id), d.g.destroy(), s(p));
  }, u = (c, p) => {
    i.resize(c, p), i.render(t);
  }, l = (c) => {
    if (typeof c == "function")
      n.forEach(({ g: p, annotation: d }, f) => {
        const { fill: y } = c(d);
        p.tint = y ? Ir(y) : yn;
      });
    else {
      const p = c != null && c.fill ? Ir(c.fill) : yn;
      n.forEach(({ g: d }, f) => d.tint = p);
    }
    o = c, i.render(t);
  };
  return {
    addAnnotation: s,
    redraw: wb(r, t, i),
    removeAnnotation: a,
    resize: u,
    setStyle: l,
    updateAnnotation: h
  };
};
function Pb(r, e, t) {
  let i, { state: n } = e, { viewer: o } = e, { style: s = void 0 } = e;
  const { store: a, hover: h, viewport: u } = n;
  Gh(r, h, (g) => t(7, i = g));
  const l = _n();
  let c, p = !1;
  const d = (g) => {
    const b = new Ki.Point(g.x, g.y), { x, y: E } = o.viewport.pointFromPixel(b);
    return o.viewport.viewportToImageCoordinates(x, E);
  }, f = (g) => (b) => {
    const { x, y: E } = d(new Ki.Point(b.offsetX, b.offsetY)), v = a.getAt(x, E);
    v ? (g.classList.add("hover"), i !== v.id && h.set(v.id)) : (g.classList.remove("hover"), i && h.set(null));
  }, y = (g) => {
    const b = g.originalEvent;
    if (!p) {
      const { x, y: E } = d(g.position), v = a.getAt(x, E);
      v ? l("click", { originalEvent: b, annotation: v }) : l("click", { originalEvent: b });
    }
    p = !1;
  }, m = () => p = !0;
  let _;
  return mn(() => {
    const { offsetWidth: g, offsetHeight: b } = o.canvas, x = document.createElement("canvas");
    x.width = g, x.height = b, x.className = "a9s-gl-canvas", o.element.querySelector(".openseadragon-canvas").appendChild(x), t(4, c = Ib(o, x));
    const E = f(x);
    x.addEventListener("pointermove", E), new ResizeObserver((T) => {
      const { width: S, height: R } = T[0].contentRect;
      x.width = S, x.height = R, c.resize(S, R);
    }).observe(x);
    const v = () => {
      const T = o.viewport.getBounds();
      _ = o.viewport.viewportToImageRectangle(T);
      const { x: S, y: R, width: O, height: w } = _, C = a.getIntersecting(S, R, O, w);
      u.set(C.map((B) => B.id));
    };
    return o.addHandler("canvas-drag", m), o.addHandler("canvas-release", y), o.addHandler("update-viewport", c.redraw), o.addHandler("animation-finish", v), () => {
      x.removeEventListener("pointermove", E), o.removeHandler("canvas-drag", m), o.removeHandler("canvas-release", y), o.removeHandler("update-viewport", c.redraw), o.removeHandler("animation-finish", v), x.parentNode.removeChild(x);
    };
  }), a.observe((g) => {
    const { created: b, updated: x, deleted: E } = g.changes;
    if (b.forEach((v) => c.addAnnotation(v)), x.forEach(({ oldValue: v, newValue: T }) => c.updateAnnotation(v, T)), E.forEach((v) => c.removeAnnotation(v)), _) {
      const { x: v, y: T, width: S, height: R } = _, O = a.getIntersecting(v, T, S, R);
      u.set(O.map((w) => w.id));
    } else
      u.set(a.all().map((v) => v.id));
    c.redraw();
  }), r.$$set = (g) => {
    "state" in g && t(1, n = g.state), "viewer" in g && t(2, o = g.viewer), "style" in g && t(3, s = g.style);
  }, r.$$.update = () => {
    r.$$.dirty & /*stage, style*/
    24 && (c == null || c.setStyle(s));
  }, [h, n, o, s, c];
}
class Mb extends $t {
  constructor(e) {
    super(), Wt(this, e, Pb, null, Vt, { state: 1, viewer: 2, style: 3 });
  }
}
const Db = (r) => ({
  transform: r & /*layerTransform*/
  2,
  scale: r & /*scale*/
  1
}), Ih = (r) => ({
  transform: (
    /*layerTransform*/
    r[1]
  ),
  scale: (
    /*scale*/
    r[0]
  )
});
function Cb(r) {
  let e;
  const t = (
    /*#slots*/
    r[4].default
  ), i = Uh(
    t,
    r,
    /*$$scope*/
    r[3],
    Ih
  );
  return {
    c() {
      i && i.c();
    },
    m(n, o) {
      i && i.m(n, o), e = !0;
    },
    p(n, [o]) {
      i && i.p && (!e || o & /*$$scope, layerTransform, scale*/
      11) && jh(
        i,
        t,
        n,
        /*$$scope*/
        n[3],
        e ? Xh(
          t,
          /*$$scope*/
          n[3],
          o,
          Db
        ) : Hh(
          /*$$scope*/
          n[3]
        ),
        Ih
      );
    },
    i(n) {
      e || (at(i, n), e = !0);
    },
    o(n) {
      ft(i, n), e = !1;
    },
    d(n) {
      i && i.d(n);
    }
  };
}
function Fb(r, e, t) {
  let { $$slots: i = {}, $$scope: n } = e, { viewer: o } = e, s = 1, a;
  const h = () => {
    const u = o.viewport.getContainerSize().x, l = o.viewport.getZoom(!0), c = o.viewport.getFlip(), p = o.viewport.pixelFromPoint(new Ki.Point(0, 0), !0);
    c && (p.x = u - p.x);
    const d = l * u / o.world.getContentFactor(), f = c ? -d : d, y = o.viewport.getRotation();
    t(1, a = `translate(${p.x}, ${p.y}) scale(${f}, ${d}) rotate(${y})`), t(0, s = l * u / o.world.getContentFactor());
  };
  return mn(() => (o.addHandler("update-viewport", h), () => {
    o.removeHandler("update-viewport", h);
  })), r.$$set = (u) => {
    "viewer" in u && t(2, o = u.viewer), "$$scope" in u && t(3, n = u.$$scope);
  }, [s, a, o, n, i];
}
class sl extends $t {
  constructor(e) {
    super(), Wt(this, e, Fb, Cb, Vt, { viewer: 2 });
  }
}
const { Boolean: Nb } = Yh;
function Ph(r, e, t) {
  const i = r.slice();
  return i[19] = e[t], i;
}
function Lb(r) {
  let e, t, i;
  var n = (
    /*tool*/
    r[0]
  );
  function o(s) {
    return {
      props: {
        transform: { elementToImage: (
          /*toolTransform*/
          s[4]
        ) },
        viewportScale: (
          /*scale*/
          s[18]
        )
      }
    };
  }
  return n && (e = Zi(n, o(r)), e.$on(
    "create",
    /*onSelectionCreated*/
    r[8]
  )), {
    c() {
      e && zt(e.$$.fragment), t = Me();
    },
    m(s, a) {
      e && Ht(e, s, a), Y(s, t, a), i = !0;
    },
    p(s, a) {
      const h = {};
      if (a & /*scale*/
      262144 && (h.viewportScale = /*scale*/
      s[18]), a & /*tool*/
      1 && n !== (n = /*tool*/
      s[0])) {
        if (e) {
          De();
          const u = e;
          ft(u.$$.fragment, 1, 0, () => {
            Yt(u, 1);
          }), Ce();
        }
        n ? (e = Zi(n, o(s)), e.$on(
          "create",
          /*onSelectionCreated*/
          s[8]
        ), zt(e.$$.fragment), at(e.$$.fragment, 1), Ht(e, t.parentNode, t)) : e = null;
      } else
        n && e.$set(h);
    },
    i(s) {
      i || (e && at(e.$$.fragment, s), i = !0);
    },
    o(s) {
      e && ft(e.$$.fragment, s), i = !1;
    },
    d(s) {
      s && H(t), e && Yt(e, s);
    }
  };
}
function Bb(r) {
  let e, t, i = (
    /*editableAnnotations*/
    r[2]
  ), n = [];
  for (let s = 0; s < i.length; s += 1)
    n[s] = Mh(Ph(r, i, s));
  const o = (s) => ft(n[s], 1, 1, () => {
    n[s] = null;
  });
  return {
    c() {
      for (let s = 0; s < n.length; s += 1)
        n[s].c();
      e = Me();
    },
    m(s, a) {
      for (let h = 0; h < n.length; h += 1)
        n[h] && n[h].m(s, a);
      Y(s, e, a), t = !0;
    },
    p(s, a) {
      if (a & /*getEditor, editableAnnotations, cast, toolTransform, scale, onGrab, onChangeSelected, onRelease*/
      262900) {
        i = /*editableAnnotations*/
        s[2];
        let h;
        for (h = 0; h < i.length; h += 1) {
          const u = Ph(s, i, h);
          n[h] ? (n[h].p(u, a), at(n[h], 1)) : (n[h] = Mh(u), n[h].c(), at(n[h], 1), n[h].m(e.parentNode, e));
        }
        for (De(), h = i.length; h < n.length; h += 1)
          o(h);
        Ce();
      }
    },
    i(s) {
      if (!t) {
        for (let a = 0; a < i.length; a += 1)
          at(n[a]);
        t = !0;
      }
    },
    o(s) {
      n = n.filter(Nb);
      for (let a = 0; a < n.length; a += 1)
        ft(n[a]);
      t = !1;
    },
    d(s) {
      ps(n, s), s && H(e);
    }
  };
}
function Mh(r) {
  let e, t, i;
  var n = Ws(
    /*editable*/
    r[19].target.selector
  );
  function o(s) {
    return {
      props: {
        shape: (
          /*cast*/
          s[9](
            /*editable*/
            s[19].target.selector
          )
        ),
        transform: { elementToImage: (
          /*toolTransform*/
          s[4]
        ) },
        viewportScale: (
          /*scale*/
          s[18]
        )
      }
    };
  }
  return n && (e = Zi(n, o(r)), e.$on(
    "grab",
    /*onGrab*/
    r[5]
  ), e.$on("change", function() {
    Ft(
      /*onChangeSelected*/
      r[7](
        /*editable*/
        r[19]
      )
    ) && r[7](
      /*editable*/
      r[19]
    ).apply(this, arguments);
  }), e.$on(
    "release",
    /*onRelease*/
    r[6]
  )), {
    c() {
      e && zt(e.$$.fragment), t = Me();
    },
    m(s, a) {
      e && Ht(e, s, a), Y(s, t, a), i = !0;
    },
    p(s, a) {
      r = s;
      const h = {};
      if (a & /*editableAnnotations*/
      4 && (h.shape = /*cast*/
      r[9](
        /*editable*/
        r[19].target.selector
      )), a & /*scale*/
      262144 && (h.viewportScale = /*scale*/
      r[18]), a & /*editableAnnotations*/
      4 && n !== (n = Ws(
        /*editable*/
        r[19].target.selector
      ))) {
        if (e) {
          De();
          const u = e;
          ft(u.$$.fragment, 1, 0, () => {
            Yt(u, 1);
          }), Ce();
        }
        n ? (e = Zi(n, o(r)), e.$on(
          "grab",
          /*onGrab*/
          r[5]
        ), e.$on("change", function() {
          Ft(
            /*onChangeSelected*/
            r[7](
              /*editable*/
              r[19]
            )
          ) && r[7](
            /*editable*/
            r[19]
          ).apply(this, arguments);
        }), e.$on(
          "release",
          /*onRelease*/
          r[6]
        ), zt(e.$$.fragment), at(e.$$.fragment, 1), Ht(e, t.parentNode, t)) : e = null;
      } else
        n && e.$set(h);
    },
    i(s) {
      i || (e && at(e.$$.fragment, s), i = !0);
    },
    o(s) {
      e && ft(e.$$.fragment, s), i = !1;
    },
    d(s) {
      s && H(t), e && Yt(e, s);
    }
  };
}
function Gb(r) {
  let e, t, i, n, o, s, a;
  const h = [Bb, Lb], u = [];
  function l(c, p) {
    return p & /*tool*/
    1 && (i = null), /*editableAnnotations*/
    c[2] ? 0 : (i == null && (i = !!/*tool*/
    c[0]), i ? 1 : -1);
  }
  return ~(n = l(r, -1)) && (o = u[n] = h[n](r)), {
    c() {
      e = st("svg"), t = st("g"), o && o.c(), A(t, "transform", s = /*transform*/
      r[17]), A(t, "class", "svelte-190cqdf"), A(e, "class", "a9s-annotationlayer a9s-osd-drawinglayer svelte-190cqdf"), Us(
        e,
        "drawing",
        /*tool*/
        r[0]
      );
    },
    m(c, p) {
      Y(c, e, p), $e(e, t), ~n && u[n].m(t, null), a = !0;
    },
    p(c, p) {
      let d = n;
      n = l(c, p), n === d ? ~n && u[n].p(c, p) : (o && (De(), ft(u[d], 1, 1, () => {
        u[d] = null;
      }), Ce()), ~n ? (o = u[n], o ? o.p(c, p) : (o = u[n] = h[n](c), o.c()), at(o, 1), o.m(t, null)) : o = null), (!a || p & /*transform*/
      131072 && s !== (s = /*transform*/
      c[17])) && A(t, "transform", s), (!a || p & /*tool*/
      1) && Us(
        e,
        "drawing",
        /*tool*/
        c[0]
      );
    },
    i(c) {
      a || (at(o), a = !0);
    },
    o(c) {
      ft(o), a = !1;
    },
    d(c) {
      c && H(e), ~n && u[n].d();
    }
  };
}
function Ub(r) {
  let e, t;
  return e = new sl({
    props: {
      viewer: (
        /*viewer*/
        r[1]
      ),
      $$slots: {
        default: [
          Gb,
          ({ transform: i, scale: n }) => ({ 17: i, 18: n }),
          ({ transform: i, scale: n }) => (i ? 131072 : 0) | (n ? 262144 : 0)
        ]
      },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      zt(e.$$.fragment);
    },
    m(i, n) {
      Ht(e, i, n), t = !0;
    },
    p(i, [n]) {
      const o = {};
      n & /*viewer*/
      2 && (o.viewer = /*viewer*/
      i[1]), n & /*$$scope, tool, transform, editableAnnotations, scale*/
      4587525 && (o.$$scope = { dirty: n, ctx: i }), e.$set(o);
    },
    i(i) {
      t || (at(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ft(e.$$.fragment, i), t = !1;
    },
    d(i) {
      Yt(e, i);
    }
  };
}
function kb(r, e, t) {
  let i, { state: n } = e, { viewer: o } = e, { user: s } = e, { tool: a = null } = e, { keepEnabled: h = !1 } = e;
  const { store: u, selection: l } = n;
  Gh(r, l, (x) => t(13, i = x));
  let c = null, p = null;
  const d = (x) => {
    u.unobserve(c);
    const E = x.filter(({ editable: v }) => v).map(({ id: v }) => v);
    E.length > 0 ? (t(2, p = E.map((v) => u.getAnnotation(v))), c = (v) => {
      const { updated: T } = v.changes;
      t(2, p = T.map((S) => S.newValue));
    }, u.observe(c, { annotations: E })) : t(2, p = null);
  }, f = (x, E) => {
    const { x: v, y: T } = o.viewport.viewerElementToImageCoordinates(new Ki.Point(x, E));
    return [v, T];
  }, y = () => o.setMouseNavEnabled(!1), m = () => o.setMouseNavEnabled(!0), _ = (x) => (E) => {
    var v;
    const { target: T } = x, S = 10 * 60 * 1e3, R = ((v = T.creator) == null ? void 0 : v.id) !== s.id || !T.created || (/* @__PURE__ */ new Date()).getTime() - T.created.getTime() > S;
    u.updateTarget({
      ...T,
      selector: E.detail,
      created: R ? T.created : /* @__PURE__ */ new Date(),
      updated: R ? /* @__PURE__ */ new Date() : null,
      updatedBy: R ? s : null
    });
  }, g = (x) => {
    const E = wl(), v = {
      id: E,
      bodies: [],
      target: {
        annotation: E,
        selector: x.detail,
        creator: s,
        created: /* @__PURE__ */ new Date()
      }
    };
    u.addAnnotation(v), l.setSelected(v.id), o.setMouseNavEnabled(!0), h || t(0, a = null);
  }, b = (x) => x;
  return r.$$set = (x) => {
    "state" in x && t(10, n = x.state), "viewer" in x && t(1, o = x.viewer), "user" in x && t(11, s = x.user), "tool" in x && t(0, a = x.tool), "keepEnabled" in x && t(12, h = x.keepEnabled);
  }, r.$$.update = () => {
    r.$$.dirty & /*tool, viewer*/
    3 && (a ? o.setMouseNavEnabled(!1) : o.setMouseNavEnabled(!0)), r.$$.dirty & /*tool*/
    1 && a && l.clear(), r.$$.dirty & /*$selection, keepEnabled, tool, viewer*/
    12291 && i.selected.length === 0 && h && a && o.setMouseNavEnabled(!1), r.$$.dirty & /*$selection*/
    8192 && d(i.selected);
  }, [
    a,
    o,
    p,
    l,
    f,
    y,
    m,
    _,
    g,
    b,
    n,
    s,
    h,
    i
  ];
}
class Xb extends $t {
  constructor(e) {
    super(), Wt(this, e, kb, Ub, Vt, {
      state: 10,
      viewer: 1,
      user: 11,
      tool: 0,
      keepEnabled: 12
    });
  }
}
function jb(r) {
  let e, t, i, n, o, s, a, h = (
    /*user*/
    r[2].appearance.label + ""
  ), u, l, c, p;
  return {
    c() {
      e = st("g"), t = st("rect"), a = st("text"), u = ds(h), A(t, "class", "a9s-presence-label-bg svelte-1rehw2p"), A(
        t,
        "x",
        /*x*/
        r[0]
      ), A(t, "y", i = /*y*/
      r[1] - 18 / /*scale*/
      r[3]), A(t, "height", n = 18 / /*scale*/
      r[3]), A(t, "fill", o = /*user*/
      r[2].appearance.color), A(t, "stroke", s = /*user*/
      r[2].appearance.color), A(a, "font-size", l = 12 / /*scale*/
      r[3]), A(a, "x", c = /*x*/
      r[0] + Math.round(5 / /*scale*/
      r[3])), A(a, "y", p = /*y*/
      r[1] - 5 / /*scale*/
      r[3]), A(a, "class", "svelte-1rehw2p"), A(e, "class", "a9s-presence-label");
    },
    m(d, f) {
      Y(d, e, f), $e(e, t), $e(e, a), $e(a, u), r[6](e);
    },
    p(d, [f]) {
      f & /*x*/
      1 && A(
        t,
        "x",
        /*x*/
        d[0]
      ), f & /*y, scale*/
      10 && i !== (i = /*y*/
      d[1] - 18 / /*scale*/
      d[3]) && A(t, "y", i), f & /*scale*/
      8 && n !== (n = 18 / /*scale*/
      d[3]) && A(t, "height", n), f & /*user*/
      4 && o !== (o = /*user*/
      d[2].appearance.color) && A(t, "fill", o), f & /*user*/
      4 && s !== (s = /*user*/
      d[2].appearance.color) && A(t, "stroke", s), f & /*user*/
      4 && h !== (h = /*user*/
      d[2].appearance.label + "") && dl(u, h), f & /*scale*/
      8 && l !== (l = 12 / /*scale*/
      d[3]) && A(a, "font-size", l), f & /*x, scale*/
      9 && c !== (c = /*x*/
      d[0] + Math.round(5 / /*scale*/
      d[3])) && A(a, "x", c), f & /*y, scale*/
      10 && p !== (p = /*y*/
      d[1] - 5 / /*scale*/
      d[3]) && A(a, "y", p);
    },
    i: jt,
    o: jt,
    d(d) {
      d && H(e), r[6](null);
    }
  };
}
function Hb(r, e, t) {
  let { x: i } = e, { y: n } = e, { user: o } = e, { scale: s } = e, { hAlign: a = null } = e, h;
  const u = (c) => {
    const p = h.querySelector("text"), d = h.querySelector("rect"), f = p.getBBox().width + 10 / c;
    a === "CENTER" && h.setAttribute("style", `transform: translateX(-${f / 2}px)`), d.setAttribute("width", `${f}`);
  };
  function l(c) {
    Zr[c ? "unshift" : "push"](() => {
      h = c, t(4, h);
    });
  }
  return r.$$set = (c) => {
    "x" in c && t(0, i = c.x), "y" in c && t(1, n = c.y), "user" in c && t(2, o = c.user), "scale" in c && t(3, s = c.scale), "hAlign" in c && t(5, a = c.hAlign);
  }, r.$$.update = () => {
    r.$$.dirty & /*g, scale*/
    24 && h && u(s);
  }, [i, n, o, s, h, a, l];
}
class al extends $t {
  constructor(e) {
    super(), Wt(this, e, Hb, jb, Vt, { x: 0, y: 1, user: 2, scale: 3, hAlign: 5 });
  }
}
function Yb(r) {
  let e, t, i, n, o, s;
  return t = new al({
    props: {
      scale: (
        /*scale*/
        r[1]
      ),
      user: (
        /*user*/
        r[0]
      ),
      x: (
        /*origin*/
        r[3][0]
      ),
      y: (
        /*origin*/
        r[3][1]
      ),
      hAlign: "CENTER"
    }
  }), {
    c() {
      e = st("g"), zt(t.$$.fragment), i = st("polygon"), A(i, "class", "a9s-presence-shape a9s-presence-polygon svelte-fgq4n0"), A(i, "stroke", n = /*user*/
      r[0].appearance.color), A(i, "fill", "transparent"), A(i, "points", o = /*geom*/
      r[2].points.map(Dh).join(" ")), A(e, "class", "a9s-presence-overlay");
    },
    m(a, h) {
      Y(a, e, h), Ht(t, e, null), $e(e, i), s = !0;
    },
    p(a, [h]) {
      const u = {};
      h & /*scale*/
      2 && (u.scale = /*scale*/
      a[1]), h & /*user*/
      1 && (u.user = /*user*/
      a[0]), h & /*origin*/
      8 && (u.x = /*origin*/
      a[3][0]), h & /*origin*/
      8 && (u.y = /*origin*/
      a[3][1]), t.$set(u), (!s || h & /*user*/
      1 && n !== (n = /*user*/
      a[0].appearance.color)) && A(i, "stroke", n), (!s || h & /*geom*/
      4 && o !== (o = /*geom*/
      a[2].points.map(Dh).join(" "))) && A(i, "points", o);
    },
    i(a) {
      s || (at(t.$$.fragment, a), s = !0);
    },
    o(a) {
      ft(t.$$.fragment, a), s = !1;
    },
    d(a) {
      a && H(e), Yt(t);
    }
  };
}
const Dh = (r) => r.join(",");
function Vb(r, e, t) {
  let i, n, { annotation: o } = e, { user: s } = e, { scale: a } = e;
  const h = (u) => {
    let [l, ...c] = u.points;
    return c.forEach(([p, d]) => {
      d < l[1] && (l = [p, d]);
    }), l;
  };
  return r.$$set = (u) => {
    "annotation" in u && t(4, o = u.annotation), "user" in u && t(0, s = u.user), "scale" in u && t(1, a = u.scale);
  }, r.$$.update = () => {
    r.$$.dirty & /*annotation*/
    16 && t(2, i = o.target.selector.geometry), r.$$.dirty & /*geom*/
    4 && t(3, n = h(i));
  }, [s, a, i, n, o];
}
class zb extends $t {
  constructor(e) {
    super(), Wt(this, e, Vb, Yb, Vt, { annotation: 4, user: 0, scale: 1 });
  }
}
function Wb(r) {
  let e, t, i, n, o, s, a, h, u;
  return t = new al({
    props: {
      scale: (
        /*scale*/
        r[1]
      ),
      user: (
        /*user*/
        r[0]
      ),
      x: (
        /*geom*/
        r[2].x
      ),
      y: (
        /*geom*/
        r[2].y
      )
    }
  }), {
    c() {
      e = st("g"), zt(t.$$.fragment), i = st("rect"), A(i, "class", "a9s-presence-shape a9s-presence-rectangle svelte-gze948"), A(i, "stroke", n = /*user*/
      r[0].appearance.color), A(i, "fill", "transparent"), A(i, "x", o = /*geom*/
      r[2].x), A(i, "y", s = /*geom*/
      r[2].y), A(i, "width", a = /*geom*/
      r[2].w), A(i, "height", h = /*geom*/
      r[2].h), A(e, "class", "a9s-presence-overlay");
    },
    m(l, c) {
      Y(l, e, c), Ht(t, e, null), $e(e, i), u = !0;
    },
    p(l, [c]) {
      const p = {};
      c & /*scale*/
      2 && (p.scale = /*scale*/
      l[1]), c & /*user*/
      1 && (p.user = /*user*/
      l[0]), c & /*geom*/
      4 && (p.x = /*geom*/
      l[2].x), c & /*geom*/
      4 && (p.y = /*geom*/
      l[2].y), t.$set(p), (!u || c & /*user*/
      1 && n !== (n = /*user*/
      l[0].appearance.color)) && A(i, "stroke", n), (!u || c & /*geom*/
      4 && o !== (o = /*geom*/
      l[2].x)) && A(i, "x", o), (!u || c & /*geom*/
      4 && s !== (s = /*geom*/
      l[2].y)) && A(i, "y", s), (!u || c & /*geom*/
      4 && a !== (a = /*geom*/
      l[2].w)) && A(i, "width", a), (!u || c & /*geom*/
      4 && h !== (h = /*geom*/
      l[2].h)) && A(i, "height", h);
    },
    i(l) {
      u || (at(t.$$.fragment, l), u = !0);
    },
    o(l) {
      ft(t.$$.fragment, l), u = !1;
    },
    d(l) {
      l && H(e), Yt(t);
    }
  };
}
function $b(r, e, t) {
  let i, { annotation: n } = e, { user: o } = e, { scale: s } = e;
  return r.$$set = (a) => {
    "annotation" in a && t(3, n = a.annotation), "user" in a && t(0, o = a.user), "scale" in a && t(1, s = a.scale);
  }, r.$$.update = () => {
    r.$$.dirty & /*annotation*/
    8 && t(2, i = n.target.selector.geometry);
  }, [o, s, i, n];
}
class qb extends $t {
  constructor(e) {
    super(), Wt(this, e, $b, Wb, Vt, { annotation: 3, user: 0, scale: 1 });
  }
}
const { Boolean: Kb } = Yh;
function Ch(r, e, t) {
  const i = r.slice();
  return i[8] = e[t], i;
}
function Fh(r) {
  let e, t;
  return e = new sl({
    props: {
      viewer: (
        /*viewer*/
        r[0]
      ),
      $$slots: {
        default: [
          Qb,
          ({ transform: i, scale: n }) => ({ 6: i, 7: n }),
          ({ transform: i, scale: n }) => (i ? 64 : 0) | (n ? 128 : 0)
        ]
      },
      $$scope: { ctx: r }
    }
  }), {
    c() {
      zt(e.$$.fragment);
    },
    m(i, n) {
      Ht(e, i, n), t = !0;
    },
    p(i, n) {
      const o = {};
      n & /*viewer*/
      1 && (o.viewer = /*viewer*/
      i[0]), n & /*$$scope, transform, trackedAnnotations, scale*/
      2244 && (o.$$scope = { dirty: n, ctx: i }), e.$set(o);
    },
    i(i) {
      t || (at(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ft(e.$$.fragment, i), t = !1;
    },
    d(i) {
      Yt(e, i);
    }
  };
}
function Nh(r) {
  let e, t, i = (
    /*trackedAnnotations*/
    r[2]
  ), n = [];
  for (let s = 0; s < i.length; s += 1)
    n[s] = Lh(Ch(r, i, s));
  const o = (s) => ft(n[s], 1, 1, () => {
    n[s] = null;
  });
  return {
    c() {
      for (let s = 0; s < n.length; s += 1)
        n[s].c();
      e = Me();
    },
    m(s, a) {
      for (let h = 0; h < n.length; h += 1)
        n[h] && n[h].m(s, a);
      Y(s, e, a), t = !0;
    },
    p(s, a) {
      if (a & /*trackedAnnotations, scale, ShapeType*/
      132) {
        i = /*trackedAnnotations*/
        s[2];
        let h;
        for (h = 0; h < i.length; h += 1) {
          const u = Ch(s, i, h);
          n[h] ? (n[h].p(u, a), at(n[h], 1)) : (n[h] = Lh(u), n[h].c(), at(n[h], 1), n[h].m(e.parentNode, e));
        }
        for (De(), h = i.length; h < n.length; h += 1)
          o(h);
        Ce();
      }
    },
    i(s) {
      if (!t) {
        for (let a = 0; a < i.length; a += 1)
          at(n[a]);
        t = !0;
      }
    },
    o(s) {
      n = n.filter(Kb);
      for (let a = 0; a < n.length; a += 1)
        ft(n[a]);
      t = !1;
    },
    d(s) {
      ps(n, s), s && H(e);
    }
  };
}
function Zb(r) {
  let e, t;
  return e = new zb({
    props: {
      annotation: (
        /*tracked*/
        r[8].annotation
      ),
      user: (
        /*tracked*/
        r[8].selectedBy
      ),
      scale: (
        /*scale*/
        r[7]
      )
    }
  }), {
    c() {
      zt(e.$$.fragment);
    },
    m(i, n) {
      Ht(e, i, n), t = !0;
    },
    p(i, n) {
      const o = {};
      n & /*trackedAnnotations*/
      4 && (o.annotation = /*tracked*/
      i[8].annotation), n & /*trackedAnnotations*/
      4 && (o.user = /*tracked*/
      i[8].selectedBy), n & /*scale*/
      128 && (o.scale = /*scale*/
      i[7]), e.$set(o);
    },
    i(i) {
      t || (at(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ft(e.$$.fragment, i), t = !1;
    },
    d(i) {
      Yt(e, i);
    }
  };
}
function Jb(r) {
  let e, t;
  return e = new qb({
    props: {
      annotation: (
        /*tracked*/
        r[8].annotation
      ),
      user: (
        /*tracked*/
        r[8].selectedBy
      ),
      scale: (
        /*scale*/
        r[7]
      )
    }
  }), {
    c() {
      zt(e.$$.fragment);
    },
    m(i, n) {
      Ht(e, i, n), t = !0;
    },
    p(i, n) {
      const o = {};
      n & /*trackedAnnotations*/
      4 && (o.annotation = /*tracked*/
      i[8].annotation), n & /*trackedAnnotations*/
      4 && (o.user = /*tracked*/
      i[8].selectedBy), n & /*scale*/
      128 && (o.scale = /*scale*/
      i[7]), e.$set(o);
    },
    i(i) {
      t || (at(e.$$.fragment, i), t = !0);
    },
    o(i) {
      ft(e.$$.fragment, i), t = !1;
    },
    d(i) {
      Yt(e, i);
    }
  };
}
function Lh(r) {
  let e, t, i, n;
  const o = [Jb, Zb], s = [];
  function a(h, u) {
    return (
      /*tracked*/
      h[8].annotation.target.selector.type === kt.RECTANGLE ? 0 : (
        /*tracked*/
        h[8].annotation.target.selector.type === kt.POLYGON ? 1 : -1
      )
    );
  }
  return ~(e = a(r)) && (t = s[e] = o[e](r)), {
    c() {
      t && t.c(), i = Me();
    },
    m(h, u) {
      ~e && s[e].m(h, u), Y(h, i, u), n = !0;
    },
    p(h, u) {
      let l = e;
      e = a(h), e === l ? ~e && s[e].p(h, u) : (t && (De(), ft(s[l], 1, 1, () => {
        s[l] = null;
      }), Ce()), ~e ? (t = s[e], t ? t.p(h, u) : (t = s[e] = o[e](h), t.c()), at(t, 1), t.m(i.parentNode, i)) : t = null);
    },
    i(h) {
      n || (at(t), n = !0);
    },
    o(h) {
      ft(t), n = !1;
    },
    d(h) {
      ~e && s[e].d(h), h && H(i);
    }
  };
}
function Qb(r) {
  let e, t, i, n, o = (
    /*trackedAnnotations*/
    r[2].length > 0 && Nh(r)
  );
  return {
    c() {
      e = st("svg"), t = st("g"), o && o.c(), A(t, "transform", i = /*transform*/
      r[6]), A(e, "class", "a9s-osd-presencelayer svelte-1krwc4m");
    },
    m(s, a) {
      Y(s, e, a), $e(e, t), o && o.m(t, null), n = !0;
    },
    p(s, a) {
      s[2].length > 0 ? o ? (o.p(s, a), a & /*trackedAnnotations*/
      4 && at(o, 1)) : (o = Nh(s), o.c(), at(o, 1), o.m(t, null)) : o && (De(), ft(o, 1, 1, () => {
        o = null;
      }), Ce()), (!n || a & /*transform*/
      64 && i !== (i = /*transform*/
      s[6])) && A(t, "transform", i);
    },
    i(s) {
      n || (at(o), n = !0);
    },
    o(s) {
      ft(o), n = !1;
    },
    d(s) {
      s && H(e), o && o.d();
    }
  };
}
function t1(r) {
  let e = !!/*provider*/
  r[1], t, i, n = e && Fh(r);
  return {
    c() {
      n && n.c(), t = Me();
    },
    m(o, s) {
      n && n.m(o, s), Y(o, t, s), i = !0;
    },
    p(o, [s]) {
      s & /*provider*/
      2 && (e = !!/*provider*/
      o[1]), e ? n ? (n.p(o, s), s & /*provider*/
      2 && at(n, 1)) : (n = Fh(o), n.c(), at(n, 1), n.m(t.parentNode, t)) : n && (De(), ft(n, 1, 1, () => {
        n = null;
      }), Ce());
    },
    i(o) {
      i || (at(n), i = !0);
    },
    o(o) {
      ft(n), i = !1;
    },
    d(o) {
      n && n.d(o), o && H(t);
    }
  };
}
function e1(r, e, t) {
  let { store: i } = e, { viewer: n } = e, { provider: o = null } = e, s = [], a = null;
  const h = (u, l) => {
    t(2, s = [
      ...s.filter(({ selectedBy: c }) => c.presenceKey !== u.presenceKey),
      ...(l || []).map((c) => ({
        // Warning - could be undefined!
        annotation: i.getAnnotation(c),
        selectedBy: u
      }))
    ].filter(({ annotation: c }) => (c || console.warn("Selection event on unknown annotation"), !!c))), a && i.unobserve(a), a = (c) => {
      const { deleted: p, updated: d } = c.changes, f = new Set(p.map((m) => m.id)), y = s.filter(({ annotation: m }) => !f.has(m.id)).map((m) => {
        const _ = d.find((g) => g.oldValue.id === m.annotation.id);
        return _ ? {
          selectedBy: m.selectedBy,
          annotation: _.newValue
        } : m;
      });
      t(2, s = y);
    }, i.observe(a, {
      annotations: s.map((c) => c.annotation.id)
    });
  };
  return yl(() => {
    a && i.unobserve(a);
  }), r.$$set = (u) => {
    "store" in u && t(3, i = u.store), "viewer" in u && t(0, n = u.viewer), "provider" in u && t(1, o = u.provider);
  }, r.$$.update = () => {
    r.$$.dirty & /*provider*/
    2 && o && o.on("selectionChange", h);
  }, [n, o, s, i];
}
class r1 extends $t {
  constructor(e) {
    super(), Wt(this, e, e1, t1, Vt, { store: 3, viewer: 0, provider: 1 });
  }
}
const i1 = (r, e, t) => {
  const i = () => {
    const { selected: n } = e;
    if (n) {
      const o = n.filter((s) => s.editable);
      o.length > 0 && t.bulkDeleteAnnotation(o.map((s) => s.id));
    }
  };
  r.addEventListener("keydown", (n) => {
    n.key === "Delete" && i();
  });
}, n1 = (r) => {
  r.addHandler("open", (e) => {
    const t = r.world.getItemCount();
    r.world.getItemAt(t - 1).addOnceHandler("fully-loaded-change", (i) => {
      const { fullyLoaded: n } = i;
      if (n) {
        const o = r.canvas.querySelector("canvas");
        wc(o, r.element);
      }
    });
  });
}, hl = (r, e, t) => (i, n = {}) => {
  const o = typeof i == "string" ? i : i.id, s = e.getAnnotation(o);
  if (!s)
    return;
  const a = r.container.getBoundingClientRect(), { padding: h } = n;
  let [u, l, c, p] = h ? Array.isArray(h) ? h : [h, h, h, h] : [0, 0, 0, 0];
  u = u / a.height, l = l / a.width, c = c / a.height, p = p / a.width;
  const { minX: d, minY: f, maxX: y, maxY: m } = s.target.selector.geometry.bounds, _ = y - d, g = m - f, b = d - p * _, x = f - u * g, E = _ + (l + p) * _, v = g + (u + c) * g, T = r.viewport.imageToViewportRectangle(b, x, E, v);
  r.viewport[t](T, n.immediately);
}, o1 = (r, e) => hl(r, e, "fitBounds"), s1 = (r, e) => hl(r, e, "fitBoundsWithConstraints"), d1 = (r, e = {}) => {
  const t = Ic(e), i = Rc(t), { hover: n, selection: o, store: s } = i, a = Gl(
    s,
    o,
    n,
    void 0,
    t.adapter,
    t.autoSave
  );
  let h = t.style, u = t.readOnly ? null : Vl();
  i1(r.element, o, s);
  const l = new Mb({
    target: r.element,
    props: { state: i, viewer: r, style: h }
  }), c = new r1({
    target: r.element.querySelector(".openseadragon-canvas"),
    props: { store: s, viewer: r, provider: null }
  }), p = new Xb({
    target: r.element.querySelector(".openseadragon-canvas"),
    props: { state: i, viewer: r, user: u }
  });
  l.$on("click", (S) => {
    const { originalEvent: R, annotation: O } = S.detail;
    O ? o.clickSelect(O.id, R) : o.isEmpty() || o.clear();
  }), r.element.addEventListener("pointerdown", (S) => {
    if (n.current) {
      const R = s.getAnnotation(n.current);
      a.emit("clickAnnotation", R, S);
    }
  }), n1(r);
  const d = kl(s, t.adapter), f = (S) => {
    h = S, l.$set({ style: S });
  }, y = () => {
    l.$destroy(), c.$destroy(), p.$destroy();
  }, m = o1(r, s), _ = s1(r, s), g = () => u, b = (S) => {
    S ? o.setSelected(S) : o.clear();
  }, x = (S) => c.$set({ provider: S }), E = (S) => {
    u = S, p.$set({ user: S });
  }, v = (S, R = !1) => {
    const O = mc(S);
    p.$set({ tool: O, keepEnabled: R });
  }, T = () => {
    p.$set({ tool: null });
  };
  return {
    ...d,
    get style() {
      return h;
    },
    set style(S) {
      f(S);
    },
    destroy: y,
    fitBounds: m,
    fitBoundsWithConstraints: _,
    getUser: g,
    listTools: yc,
    on: a.on,
    off: a.off,
    setPresenceProvider: x,
    setSelected: b,
    setUser: E,
    startDrawing: v,
    state: i,
    stopDrawing: T,
    viewer: r
  };
};
var Mr = /* @__PURE__ */ ((r) => (r.ELLIPSE = "ELLIPSE", r.POLYGON = "POLYGON", r.RECTANGLE = "RECTANGLE", r))(Mr || {});
const Ds = (r, e) => e, a1 = {
  area: (r) => Math.PI * r.geometry.rx * r.geometry.ry,
  intersects: (r, e, t) => {
    const { cx: i, cy: n, rx: o, ry: s } = r.geometry, a = 0, h = Math.cos(a), u = Math.sin(a), l = e - i, c = t - n, p = h * l + u * c, d = u * l - h * c;
    return p * p / (o * o) + d * d / (s * s) <= 1;
  }
};
Ds(Mr.ELLIPSE, a1);
const h1 = {
  area: (r) => {
    const { points: e } = r.geometry;
    let t = 0, i = e.length - 1;
    for (let n = 0; n < e.length; n++)
      t += (e[i][0] + e[n][0]) * (e[i][1] - e[n][1]), i = n;
    return Math.abs(0.5 * t);
  },
  intersects: (r, e, t) => {
    const { points: i } = r.geometry;
    let n = !1;
    for (let o = 0, s = i.length - 1; o < i.length; s = o++) {
      const a = i[o][0], h = i[o][1], u = i[s][0], l = i[s][1];
      h > t != l > t && e < (u - a) * (t - h) / (l - h) + a && (n = !n);
    }
    return n;
  }
};
Ds(Mr.POLYGON, h1);
const u1 = {
  area: (r) => r.geometry.w * r.geometry.h,
  intersects: (r, e, t) => e >= r.geometry.x && e <= r.geometry.x + r.geometry.w && t >= r.geometry.y && t <= r.geometry.y + r.geometry.h
};
Ds(Mr.RECTANGLE, u1);
const l1 = [];
for (let r = 0; r < 256; ++r)
  l1.push((r + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
let c1 = (r = 21) => crypto.getRandomValues(new Uint8Array(r)).reduce((e, t) => (t &= 63, t < 36 ? e += t.toString(36) : t < 62 ? e += (t - 26).toString(36).toUpperCase() : t > 62 ? e += "-" : e += "_", e), "");
c1();
Mr.RECTANGLE, Mr.POLYGON;
export {
  d1 as createOSDAnnotator
};
//# sourceMappingURL=annotorious-react.es20.js.map
