function N() {
}
function We(t, e) {
  for (const n in e)
    t[n] = e[n];
  return t;
}
function Xe(t) {
  return t();
}
function ie() {
  return /* @__PURE__ */ Object.create(null);
}
function ot(t) {
  t.forEach(Xe);
}
function U(t) {
  return typeof t == "function";
}
function z(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}
function qe(t) {
  return Object.keys(t).length === 0;
}
function Pe(t, ...e) {
  if (t == null)
    return N;
  const n = t.subscribe(...e);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function se(t, e, n) {
  t.$$.on_destroy.push(Pe(e, n));
}
function Je(t, e, n, o) {
  if (t) {
    const r = Se(t, e, n, o);
    return t[0](r);
  }
}
function Se(t, e, n, o) {
  return t[1] && o ? We(n.ctx.slice(), t[1](o(e))) : n.ctx;
}
function ke(t, e, n, o) {
  if (t[2] && o) {
    const r = t[2](o(n));
    if (e.dirty === void 0)
      return r;
    if (typeof r == "object") {
      const i = [], s = Math.max(e.dirty.length, r.length);
      for (let a = 0; a < s; a += 1)
        i[a] = e.dirty[a] | r[a];
      return i;
    }
    return e.dirty | r;
  }
  return e.dirty;
}
function Ke(t, e, n, o, r, i) {
  if (r) {
    const s = Se(e, n, o, i);
    t.p(s, r);
  }
}
function Qe(t) {
  if (t.ctx.length > 32) {
    const e = [], n = t.ctx.length / 32;
    for (let o = 0; o < n; o++)
      e[o] = -1;
    return e;
  }
  return -1;
}
function st(t, e) {
  t.appendChild(e);
}
function O(t, e, n) {
  t.insertBefore(e, n || null);
}
function T(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function ee(t, e) {
  for (let n = 0; n < t.length; n += 1)
    t[n] && t[n].d(e);
}
function _(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
function Ce(t) {
  return document.createTextNode(t);
}
function K() {
  return Ce(" ");
}
function rt() {
  return Ce("");
}
function j(t, e, n, o) {
  return t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o);
}
function d(t, e, n) {
  n == null ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n);
}
function Ze(t) {
  return Array.from(t.childNodes);
}
function ae(t, e, n) {
  t.classList[n ? "add" : "remove"](e);
}
function tn(t, e, { bubbles: n = !1, cancelable: o = !1 } = {}) {
  const r = document.createEvent("CustomEvent");
  return r.initCustomEvent(t, n, o, e), r;
}
let Tt;
function At(t) {
  Tt = t;
}
function Re() {
  if (!Tt)
    throw new Error("Function called outside component initialization");
  return Tt;
}
function Ot(t) {
  Re().$$.on_mount.push(t);
}
function wt() {
  const t = Re();
  return (e, n, { cancelable: o = !1 } = {}) => {
    const r = t.$$.callbacks[e];
    if (r) {
      const i = tn(e, n, { cancelable: o });
      return r.slice().forEach((s) => {
        s.call(t, i);
      }), !i.defaultPrevented;
    }
    return !0;
  };
}
function yt(t, e) {
  const n = t.$$.callbacks[e.type];
  n && n.slice().forEach((o) => o.call(this, e));
}
const mt = [], xt = [];
let $t = [];
const le = [], en = /* @__PURE__ */ Promise.resolve();
let Zt = !1;
function nn() {
  Zt || (Zt = !0, en.then(Ge));
}
function te(t) {
  $t.push(t);
}
const Wt = /* @__PURE__ */ new Set();
let ht = 0;
function Ge() {
  if (ht !== 0)
    return;
  const t = Tt;
  do {
    try {
      for (; ht < mt.length; ) {
        const e = mt[ht];
        ht++, At(e), on(e.$$);
      }
    } catch (e) {
      throw mt.length = 0, ht = 0, e;
    }
    for (At(null), mt.length = 0, ht = 0; xt.length; )
      xt.pop()();
    for (let e = 0; e < $t.length; e += 1) {
      const n = $t[e];
      Wt.has(n) || (Wt.add(n), n());
    }
    $t.length = 0;
  } while (mt.length);
  for (; le.length; )
    le.pop()();
  Zt = !1, Wt.clear(), At(t);
}
function on(t) {
  if (t.fragment !== null) {
    t.update(), ot(t.before_update);
    const e = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(te);
  }
}
function rn(t) {
  const e = [], n = [];
  $t.forEach((o) => t.indexOf(o) === -1 ? e.push(o) : n.push(o)), n.forEach((o) => o()), $t = e;
}
const Gt = /* @__PURE__ */ new Set();
let ct;
function et() {
  ct = {
    r: 0,
    c: [],
    p: ct
    // parent group
  };
}
function nt() {
  ct.r || ot(ct.c), ct = ct.p;
}
function P(t, e) {
  t && t.i && (Gt.delete(t), t.i(e));
}
function R(t, e, n, o) {
  if (t && t.o) {
    if (Gt.has(t))
      return;
    Gt.add(t), ct.c.push(() => {
      Gt.delete(t), o && (n && t.d(1), o());
    }), t.o(e);
  } else
    o && o();
}
function ut(t) {
  t && t.c();
}
function at(t, e, n, o) {
  const { fragment: r, after_update: i } = t.$$;
  r && r.m(e, n), o || te(() => {
    const s = t.$$.on_mount.map(Xe).filter(U);
    t.$$.on_destroy ? t.$$.on_destroy.push(...s) : ot(s), t.$$.on_mount = [];
  }), i.forEach(te);
}
function lt(t, e) {
  const n = t.$$;
  n.fragment !== null && (rn(n.after_update), ot(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []);
}
function sn(t, e) {
  t.$$.dirty[0] === -1 && (mt.push(t), nn(), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;
}
function Q(t, e, n, o, r, i, s, a = [-1]) {
  const l = Tt;
  At(t);
  const c = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: i,
    update: N,
    not_equal: r,
    bound: ie(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(e.context || (l ? l.$$.context : [])),
    // everything else
    callbacks: ie(),
    dirty: a,
    skip_bound: !1,
    root: e.target || l.$$.root
  };
  s && s(c.root);
  let h = !1;
  if (c.ctx = n ? n(t, e.props || {}, (u, f, ...p) => {
    const g = p.length ? p[0] : f;
    return c.ctx && r(c.ctx[u], c.ctx[u] = g) && (!c.skip_bound && c.bound[u] && c.bound[u](g), h && sn(t, u)), f;
  }) : [], c.update(), h = !0, ot(c.before_update), c.fragment = o ? o(c.ctx) : !1, e.target) {
    if (e.hydrate) {
      const u = Ze(e.target);
      c.fragment && c.fragment.l(u), u.forEach(T);
    } else
      c.fragment && c.fragment.c();
    e.intro && P(t.$$.fragment), at(t, e.target, e.anchor, e.customElement), Ge();
  }
  At(l);
}
class Z {
  $destroy() {
    lt(this, 1), this.$destroy = N;
  }
  $on(e, n) {
    if (!U(n))
      return N;
    const o = this.$$.callbacks[e] || (this.$$.callbacks[e] = []);
    return o.push(n), () => {
      const r = o.indexOf(n);
      r !== -1 && o.splice(r, 1);
    };
  }
  $set(e) {
    this.$$set && !qe(e) && (this.$$.skip_bound = !0, this.$$set(e), this.$$.skip_bound = !1);
  }
}
var F = /* @__PURE__ */ ((t) => (t.ELLIPSE = "ELLIPSE", t.POLYGON = "POLYGON", t.RECTANGLE = "RECTANGLE", t))(F || {});
const ne = {}, oe = (t, e) => ne[t] = e, ce = (t) => ne[t.type].area(t), an = (t, e, n) => ne[t.type].intersects(t, e, n), Nt = (t) => {
  let e = 1 / 0, n = 1 / 0, o = -1 / 0, r = -1 / 0;
  return t.forEach(([i, s]) => {
    e = Math.min(e, i), n = Math.min(n, s), o = Math.max(o, i), r = Math.max(r, s);
  }), { minX: e, minY: n, maxX: o, maxY: r };
}, ln = {
  area: (t) => Math.PI * t.geometry.rx * t.geometry.ry,
  intersects: (t, e, n) => {
    const { cx: o, cy: r, rx: i, ry: s } = t.geometry, a = 0, l = Math.cos(a), c = Math.sin(a), h = e - o, u = n - r, f = l * h + c * u, p = c * h - l * u;
    return f * f / (i * i) + p * p / (s * s) <= 1;
  }
};
oe(F.ELLIPSE, ln);
const cn = {
  area: (t) => {
    const { points: e } = t.geometry;
    let n = 0, o = e.length - 1;
    for (let r = 0; r < e.length; r++)
      n += (e[o][0] + e[r][0]) * (e[o][1] - e[r][1]), o = r;
    return Math.abs(0.5 * n);
  },
  intersects: (t, e, n) => {
    const { points: o } = t.geometry;
    let r = !1;
    for (let i = 0, s = o.length - 1; i < o.length; s = i++) {
      const a = o[i][0], l = o[i][1], c = o[s][0], h = o[s][1];
      l > n != h > n && e < (c - a) * (n - l) / (h - l) + a && (r = !r);
    }
    return r;
  }
};
oe(F.POLYGON, cn);
const dn = {
  area: (t) => t.geometry.w * t.geometry.h,
  intersects: (t, e, n) => e >= t.geometry.x && e <= t.geometry.x + t.geometry.w && n >= t.geometry.y && n <= t.geometry.y + t.geometry.h
};
oe(F.RECTANGLE, dn);
const un = (t, e = !1) => {
  const n = typeof t == "string" ? t : t.value, o = /^(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, r = [...n.matchAll(o)][0], [i, s, a, l, c, h, u] = r;
  if (s !== "xywh")
    throw new Error("Unsupported MediaFragment: " + n);
  if (a && a !== "pixel")
    throw new Error(`Unsupported MediaFragment unit: ${a}`);
  const [f, p, g, $] = [l, c, h, u].map(parseFloat);
  return {
    type: F.RECTANGLE,
    geometry: {
      x: f,
      y: p,
      w: g,
      h: $,
      bounds: {
        minX: f,
        minY: e ? p - $ : p,
        maxX: f + g,
        maxY: e ? p : p + $
      }
    }
  };
}, hn = (t) => {
  const { x: e, y: n, w: o, h: r } = t;
  return {
    type: "FragmentSelector",
    conformsTo: "http://www.w3.org/TR/media-frags/",
    value: `xywh=pixel:${e},${n},${o},${r}`
  };
}, Ne = "http://www.w3.org/2000/svg", de = (t) => {
  const e = (o) => {
    Array.from(o.attributes).forEach((r) => {
      r.name.startsWith("on") && o.removeAttribute(r.name);
    });
  }, n = t.getElementsByTagName("script");
  return Array.from(n).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(t.querySelectorAll("*")).forEach(e), t;
}, pn = (t) => {
  const e = new XMLSerializer().serializeToString(t.documentElement).replace("<svg>", `<svg xmlns="${Ne}">`);
  return new DOMParser().parseFromString(e, "image/svg+xml").documentElement;
}, fn = (t) => {
  const e = new DOMParser().parseFromString(t, "image/svg+xml"), n = e.lookupPrefix(Ne), o = e.lookupNamespaceURI(null);
  return n || o ? de(e).firstChild : de(pn(e)).firstChild;
}, mn = (t) => {
  const [e, n, o] = t.match(/(<polygon points=["|'])([^("|')]*)/) || [];
  if (!o)
    return;
  const r = o.split(" ").map((i) => i.split(",").map(parseFloat));
  return {
    type: F.POLYGON,
    geometry: {
      points: r,
      bounds: Nt(r)
    }
  };
}, gn = (t) => {
  const e = fn(t), n = parseFloat(e.getAttribute("cx")), o = parseFloat(e.getAttribute("cy")), r = parseFloat(e.getAttribute("rx")), i = parseFloat(e.getAttribute("ry")), s = {
    minX: n - r,
    minY: o - i,
    maxX: n + r,
    maxY: o + i
  };
  return {
    type: F.ELLIPSE,
    geometry: {
      cx: n,
      cy: o,
      rx: r,
      ry: i,
      bounds: s
    }
  };
}, yn = (t) => {
  const e = typeof t == "string" ? t : t.value;
  if (e.includes("<polygon points="))
    return mn(e);
  if (e.includes("<ellipse "))
    return gn(e);
}, $n = (t) => {
  let e;
  if (t.type === F.POLYGON) {
    const n = t.geometry, { points: o } = n;
    e = `<svg><polygon points="${o.map((r) => r.join(",")).join(" ")}" /></svg>`;
  } else if (t.type === F.ELLIPSE) {
    const n = t.geometry;
    e = `<svg><ellipse cx="${n.cx}" cy="${n.cy}" rx="${n.rx}" ry="${n.ry}" /></svg>`;
  }
  if (e)
    return { type: "SvgSelector", value: e };
  throw `Unsupported shape type: ${t.type}`;
};
let St;
const xn = new Uint8Array(16);
function wn() {
  if (!St && (St = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !St))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return St(xn);
}
const V = [];
for (let t = 0; t < 256; ++t)
  V.push((t + 256).toString(16).slice(1));
function bn(t, e = 0) {
  return V[t[e + 0]] + V[t[e + 1]] + V[t[e + 2]] + V[t[e + 3]] + "-" + V[t[e + 4]] + V[t[e + 5]] + "-" + V[t[e + 6]] + V[t[e + 7]] + "-" + V[t[e + 8]] + V[t[e + 9]] + "-" + V[t[e + 10]] + V[t[e + 11]] + V[t[e + 12]] + V[t[e + 13]] + V[t[e + 14]] + V[t[e + 15]];
}
const vn = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), ue = {
  randomUUID: vn
};
function He(t, e, n) {
  if (ue.randomUUID && !e && !t)
    return ue.randomUUID();
  t = t || {};
  const o = t.random || (t.rng || wn)();
  if (o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, e) {
    n = n || 0;
    for (let r = 0; r < 16; ++r)
      e[n + r] = o[r];
    return e;
  }
  return bn(o);
}
var he = Object.prototype.hasOwnProperty;
function dt(t, e) {
  var n, o;
  if (t === e)
    return !0;
  if (t && e && (n = t.constructor) === e.constructor) {
    if (n === Date)
      return t.getTime() === e.getTime();
    if (n === RegExp)
      return t.toString() === e.toString();
    if (n === Array) {
      if ((o = t.length) === e.length)
        for (; o-- && dt(t[o], e[o]); )
          ;
      return o === -1;
    }
    if (!n || typeof t == "object") {
      o = 0;
      for (n in t)
        if (he.call(t, n) && ++o && !he.call(e, n) || !(n in e) || !dt(t[n], e[n]))
          return !1;
      return Object.keys(e).length === o;
    }
  }
  return t !== t && e !== e;
}
const pt = [];
function Ht(t, e = N) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function r(a) {
    if (z(t, a) && (t = a, n)) {
      const l = !pt.length;
      for (const c of o)
        c[1](), pt.push(c, t);
      if (l) {
        for (let c = 0; c < pt.length; c += 2)
          pt[c][0](pt[c + 1]);
        pt.length = 0;
      }
    }
  }
  function i(a) {
    r(a(t));
  }
  function s(a, l = N) {
    const c = [a, l];
    return o.add(c), o.size === 1 && (n = e(r) || N), a(t), () => {
      o.delete(c), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: r, update: i, subscribe: s };
}
const En = (t) => {
  const { subscribe: e, set: n } = Ht(null);
  let o = null;
  return e((r) => o = r), t.observe(({ changes: r }) => {
    if (o) {
      r.deleted.some((s) => s.id === o) && n(null);
      const i = r.updated.find(({ oldValue: s }) => s.id === o);
      i && n(i.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: e,
    set: n
  };
};
var Fe = /* @__PURE__ */ ((t) => (t.EDIT = "EDIT", t.HIGHLIGHT = "HIGHLIGHT", t.NONE = "NONE", t))(Fe || {});
const qt = { selected: [] }, An = (t, e = "EDIT") => {
  const { subscribe: n, set: o } = Ht(qt);
  let r = qt;
  n((u) => r = u);
  const i = () => o(qt), s = () => {
    var u;
    return ((u = r.selected) == null ? void 0 : u.length) === 0;
  }, a = (u) => {
    if (r.selected.length === 0)
      return !1;
    const f = typeof u == "string" ? u : u.id;
    return r.selected.some((p) => p.id === f);
  }, l = (u, f) => {
    const p = t.getAnnotation(u);
    if (p) {
      const g = Tn(p, e);
      o(g === "EDIT" ? { selected: [{ id: u, editable: !0 }], pointerEvent: f } : g === "HIGHLIGHT" ? { selected: [{ id: u }], pointerEvent: f } : { selected: [], pointerEvent: f });
    } else
      console.warn("Invalid selection: " + u);
  }, c = (u, f = !0) => {
    const p = Array.isArray(u) ? u : [u], g = p.map(($) => t.getAnnotation($)).filter(($) => $);
    o({ selected: g.map(({ id: $ }) => ({ id: $, editable: f })) }), g.length !== p.length && console.warn("Invalid selection", u);
  }, h = (u) => {
    if (r.selected.length === 0)
      return !1;
    const { selected: f } = r;
    f.filter(({ id: p }) => u.includes(p)).length > 0 && o({ selected: f.filter(({ id: p }) => !u.includes(p)) });
  };
  return t.observe(({ changes: u }) => h(u.deleted.map((f) => f.id))), {
    clear: i,
    clickSelect: l,
    get selected() {
      return r ? [...r.selected] : null;
    },
    get pointerEvent() {
      return r ? r.pointerEvent : null;
    },
    isEmpty: s,
    isSelected: a,
    setSelected: c,
    subscribe: n
  };
}, Tn = (t, e) => typeof e == "function" ? e(t) || "EDIT" : e || "EDIT", On = (t, e) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
}, Mn = (t, e) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
}, Ln = (t, e) => e.bodies.map((n) => {
  const o = t.bodies.find((r) => r.id === n.id);
  return { newBody: n, oldBody: o && !dt(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n), Yn = (t, e) => !dt(t.target, e.target), Bn = (t, e) => ({
  oldValue: t,
  newValue: e,
  bodiesCreated: On(t, e),
  bodiesDeleted: Mn(t, e),
  bodiesUpdated: Ln(t, e),
  targetUpdated: Yn(t, e) ? { oldTarget: t.target, newTarget: e.target } : void 0
});
var H = /* @__PURE__ */ ((t) => (t.LOCAL = "LOCAL", t.REMOTE = "REMOTE", t))(H || {});
const In = (t, e) => {
  var n, o;
  const { changes: r, origin: i } = e;
  if (!(!t.options.origin || t.options.origin === i))
    return !1;
  if (t.options.ignore) {
    const { ignore: s } = t.options, a = (l) => (l == null ? void 0 : l.length) > 0;
    if (!(a(r.created) || a(r.deleted))) {
      const l = (n = r.updated) == null ? void 0 : n.some((h) => a(h.bodiesCreated) || a(h.bodiesDeleted) || a(h.bodiesUpdated)), c = (o = r.updated) == null ? void 0 : o.some((h) => h.targetUpdated);
      if (s === "BODY_ONLY" && l && !c || s === "TARGET_ONLY" && c && !l)
        return !1;
    }
  }
  if (t.options.annotations) {
    const s = /* @__PURE__ */ new Set([
      ...r.created.map((a) => a.id),
      ...r.deleted.map((a) => a.id),
      ...r.updated.map(({ oldValue: a }) => a.id)
    ]);
    return !!(Array.isArray(t.options.annotations) ? t.options.annotations : [t.options.annotations]).find((a) => s.has(a));
  } else
    return !0;
}, _n = (t) => t.id !== void 0, Xn = () => {
  const t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), n = [], o = (y, b = {}) => n.push({ onChange: y, options: b }), r = (y) => {
    const b = n.findIndex((w) => w.onChange == y);
    b > -1 && n.splice(b, 1);
  }, i = (y, b) => {
    const w = {
      origin: y,
      changes: {
        created: b.created || [],
        updated: b.updated || [],
        deleted: b.deleted || []
      },
      state: [...t.values()]
    };
    n.forEach((A) => {
      In(A, w) && A.onChange(w);
    });
  }, s = (y, b = H.LOCAL) => {
    if (t.get(y.id))
      throw Error(`Cannot add annotation ${y.id} - exists already`);
    t.set(y.id, y), y.bodies.forEach((w) => e.set(w.id, y.id)), i(b, { created: [y] });
  }, a = (y, b = H.LOCAL, w = H.LOCAL) => {
    const A = _n(b) ? w : b, M = typeof y == "string" ? b : y, S = typeof y == "string" ? y : y.id, B = t.get(S);
    if (B) {
      const C = Bn(B, M);
      S === M.id ? t.set(S, M) : (t.delete(S), t.set(M.id, M)), B.bodies.forEach((G) => e.delete(G.id)), M.bodies.forEach((G) => e.set(G.id, M.id)), i(A, { updated: [C] });
    } else
      throw Error(`Cannot update annotation ${S} - does not exist`);
  }, l = (y, b = H.LOCAL) => {
    const w = t.get(y.annotation);
    if (w) {
      const A = {
        ...w,
        bodies: [...w.bodies, y]
      };
      t.set(w.id, A), e.set(y.id, A.id), i(b, { updated: [{
        oldValue: w,
        newValue: A,
        bodiesCreated: [y]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${y.annotation}`);
  }, c = () => [...t.values()], h = (y = H.LOCAL) => {
    const b = [...t.values()];
    t.clear(), e.clear(), i(y, { deleted: b });
  }, u = (y, b = !0, w = H.LOCAL) => {
    if (b) {
      const A = [...t.values()];
      t.clear(), e.clear(), y.forEach((M) => {
        t.set(M.id, M), M.bodies.forEach((S) => e.set(S.id, M.id));
      }), i(w, { created: y, deleted: A });
    } else {
      const A = y.reduce((M, S) => {
        const B = t.get(S.id);
        return B ? [...M, B] : M;
      }, []);
      if (A.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${A.map((M) => M.id).join(", ")}`);
      y.forEach((M) => {
        t.set(M.id, M), M.bodies.forEach((S) => e.set(S.id, M.id));
      }), i(w, { created: y });
    }
  }, f = (y) => {
    const b = typeof y == "string" ? y : y.id, w = t.get(b);
    if (w)
      return t.delete(b), w.bodies.forEach((A) => e.delete(A.id)), w;
    console.warn(`Attempt to delete missing annotation: ${b}`);
  }, p = (y, b = H.LOCAL) => {
    const w = f(y);
    w && i(b, { deleted: [w] });
  }, g = (y, b = H.LOCAL) => {
    const w = y.reduce((A, M) => {
      const S = f(M);
      return S ? [...A, S] : A;
    }, []);
    w.length > 0 && i(b, { deleted: w });
  }, $ = (y, b = H.LOCAL) => {
    const w = t.get(y.annotation);
    if (w) {
      const A = w.bodies.find((M) => M.id === y.id);
      if (A) {
        e.delete(A.id);
        const M = {
          ...w,
          bodies: w.bodies.filter((S) => S.id !== y.id)
        };
        t.set(w.id, M), i(b, { updated: [{
          oldValue: w,
          newValue: M,
          bodiesDeleted: [A]
        }] });
      } else
        console.warn(`Attempt to delete missing body ${y.id} from annotation ${y.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${y.annotation}`);
  }, m = (y) => {
    const b = t.get(y);
    return b ? { ...b } : void 0;
  }, x = (y) => {
    const b = e.get(y);
    if (b) {
      const w = m(b).bodies.find((A) => A.id === y);
      if (w)
        return w;
      console.error(`Store integrity error: body ${y} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${y}`);
  }, Y = (y, b) => {
    if (y.annotation !== b.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const w = t.get(y.annotation);
    if (w) {
      const A = w.bodies.find((S) => S.id === y.id), M = {
        ...w,
        bodies: w.bodies.map((S) => S.id === A.id ? b : S)
      };
      return t.set(w.id, M), A.id !== b.id && (e.delete(A.id), e.set(b.id, M.id)), {
        oldValue: w,
        newValue: M,
        bodiesUpdated: [{ oldBody: A, newBody: b }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${y.annotation}`);
  }, I = (y, b, w = H.LOCAL) => {
    const A = Y(y, b);
    i(w, { updated: [A] });
  }, X = (y, b = H.LOCAL) => {
    const w = y.map((A) => Y({ id: A.id, annotation: A.annotation }, A));
    i(b, { updated: w });
  }, D = (y) => {
    const b = t.get(y.annotation);
    if (b) {
      const w = {
        ...b,
        target: {
          ...b.target,
          ...y
        }
      };
      return t.set(b.id, w), {
        oldValue: b,
        newValue: w,
        targetUpdated: {
          oldTarget: b.target,
          newTarget: y
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${y.annotation}`);
  };
  return {
    addAnnotation: s,
    addBody: l,
    all: c,
    bulkAddAnnotation: u,
    bulkDeleteAnnotation: g,
    bulkUpdateBodies: X,
    bulkUpdateTargets: (y, b = H.LOCAL) => {
      const w = y.map(D).filter((A) => A);
      w.length > 0 && i(b, { updated: w });
    },
    clear: h,
    deleteAnnotation: p,
    deleteBody: $,
    getAnnotation: m,
    getBody: x,
    observe: o,
    unobserve: r,
    updateAnnotation: a,
    updateBody: I,
    updateTarget: (y, b = H.LOCAL) => {
      const w = D(y);
      w && i(b, { updated: [w] });
    }
  };
}, Pn = (t) => ({
  ...t,
  subscribe: (e) => {
    const n = (o) => e(o.state);
    return t.observe(n), e(t.all()), () => t.unobserve(n);
  }
}), Sn = () => {
  const { subscribe: t, set: e } = Ht([]);
  return {
    subscribe: t,
    set: e
  };
}, Cn = (t, e, n, o, r, i) => {
  const s = /* @__PURE__ */ new Map();
  let a = [], l, c;
  const h = (g, $) => {
    s.has(g) ? s.get(g).push($) : s.set(g, [$]);
  }, u = (g, $) => {
    const m = s.get(g);
    m && m.indexOf($) > 0 && m.splice(m.indexOf($), 1);
  }, f = (g, $, m) => {
    s.has(g) && setTimeout(() => {
      s.get(g).forEach((x) => {
        if (r) {
          const Y = Array.isArray($) ? $.map((X) => r.serialize(X)) : r.serialize($), I = m ? m instanceof PointerEvent ? m : r.serialize(m) : void 0;
          x(Y, I);
        } else
          x($, m);
      });
    }, 1);
  }, p = () => {
    const { selected: g } = e, $ = g.map(({ id: m }) => t.getAnnotation(m));
    $.forEach((m) => {
      const x = a.find((Y) => Y.id === m.id);
      (!x || !dt(x, m)) && f("updateAnnotation", m, x);
    }), a = a.map((m) => $.find(({ id: Y }) => Y === m.id) || m);
  };
  return e.subscribe(({ selected: g }) => {
    if (!(a.length === 0 && g.length === 0)) {
      if (a.length === 0 && g.length > 0)
        a = g.map(({ id: $ }) => t.getAnnotation($));
      else if (a.length > 0 && g.length === 0)
        a.forEach(($) => {
          const m = t.getAnnotation($.id);
          m && !dt(m, $) && f("updateAnnotation", m, $);
        }), a = [];
      else {
        const $ = new Set(a.map((x) => x.id)), m = new Set(g.map(({ id: x }) => x));
        a.filter((x) => !m.has(x.id)).forEach((x) => {
          const Y = t.getAnnotation(x.id);
          Y && !dt(Y, x) && f("updateAnnotation", Y, x);
        }), a = [
          // Remove annotations that were deselected
          ...a.filter((x) => m.has(x.id)),
          // Add editable annotations that were selected
          ...g.filter(({ id: x }) => !$.has(x)).map(({ id: x }) => t.getAnnotation(x))
        ];
      }
      f("selectionChanged", a);
    }
  }), n.subscribe((g) => {
    !l && g ? f("mouseEnterAnnotation", t.getAnnotation(g)) : l && !g ? f("mouseLeaveAnnotation", t.getAnnotation(l)) : l && g && (f("mouseLeaveAnnotation", t.getAnnotation(l)), f("mouseEnterAnnotation", t.getAnnotation(g))), l = g;
  }), o == null || o.subscribe((g) => f("viewportIntersect", g.map(t.getAnnotation))), t.observe((g) => {
    i && (c && clearTimeout(c), c = setTimeout(p, 1e3));
    const { created: $, deleted: m } = g.changes;
    $.forEach((x) => f("createAnnotation", x)), m.forEach((x) => f("deleteAnnotation", x)), g.changes.updated.filter((x) => [
      ...x.bodiesCreated || [],
      ...x.bodiesDeleted || [],
      ...x.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: x, newValue: Y }) => {
      const I = a.find((X) => X.id === x.id) || x;
      a = a.map((X) => X.id === x.id ? Y : X), f("updateAnnotation", Y, I);
    });
  }, { origin: H.LOCAL }), t.observe((g) => {
    if (a) {
      const $ = new Set(a.map((x) => x.id)), m = g.changes.updated.filter(({ newValue: x }) => $.has(x.id)).map(({ newValue: x }) => x);
      m.length > 0 && (a = a.map((x) => m.find((I) => I.id === x.id) || x));
    }
  }, { origin: H.REMOTE }), { on: h, off: u, emit: f };
}, Rn = (t) => (e) => e.reduce((n, o) => {
  const { parsed: r, error: i } = t.parse(o);
  return i ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : {
    parsed: [...n.parsed, r],
    failed: n.failed
  };
}, { parsed: [], failed: [] }), Gn = (t, e) => {
  const n = (c) => {
    if (e) {
      const { parsed: h, error: u } = e.parse(c);
      h ? t.addAnnotation(h, H.REMOTE) : console.error(u);
    } else
      t.addAnnotation(c, H.REMOTE);
  }, o = () => t.clear(), r = (c) => {
    const h = t.getAnnotation(c);
    return e && h ? e.serialize(h) : h;
  }, i = () => e ? t.all().map(e.serialize) : t.all(), s = (c) => fetch(c).then((h) => h.json()).then((h) => (l(h), h)), a = (c) => {
    if (typeof c == "string") {
      const h = t.getAnnotation(c);
      return t.deleteAnnotation(c), e ? e.serialize(h) : h;
    } else {
      const h = e ? e.parse(c).parsed : c;
      return t.deleteAnnotation(h), c;
    }
  }, l = (c) => {
    if (e) {
      const { parsed: h, failed: u } = Rn(e)(c);
      u.length > 0 && console.warn(`Discarded ${u.length} invalid annotations`, u), t.bulkAddAnnotation(h, !0, H.REMOTE);
    } else
      t.bulkAddAnnotation(c, !0, H.REMOTE);
  };
  return {
    addAnnotation: n,
    clearAnnotations: o,
    getAnnotationById: r,
    getAnnotations: i,
    loadAnnotations: s,
    removeAnnotation: a,
    setAnnotations: l,
    updateAnnotation: (c) => {
      if (e) {
        const h = e.parse(c).parsed, u = e.serialize(t.getAnnotation(h.id));
        return t.updateAnnotation(h), u;
      } else {
        const h = t.getAnnotation(c.id);
        return t.updateAnnotation(c), h;
      }
    }
  };
};
let Nn = (t) => crypto.getRandomValues(new Uint8Array(t)), Hn = (t, e, n) => {
  let o = (2 << Math.log(t.length - 1) / Math.LN2) - 1, r = -~(1.6 * o * e / t.length);
  return (i = e) => {
    let s = "";
    for (; ; ) {
      let a = n(r), l = r;
      for (; l--; )
        if (s += t[a[l] & o] || "", s.length === i)
          return s;
    }
  };
}, Fn = (t, e = 21) => Hn(t, e, Nn), Dn = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, n) => (n &= 63, n < 36 ? e += n.toString(36) : n < 62 ? e += (n - 26).toString(36).toUpperCase() : n > 62 ? e += "-" : e += "_", e), "");
const Un = () => ({ isGuest: !0, id: Fn("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), Vn = (t) => {
  const e = JSON.stringify(t);
  let n = 0;
  for (let o = 0, r = e.length; o < r; o++) {
    let i = e.charCodeAt(o);
    n = (n << 5) - n + i, n |= 0;
  }
  return `${n}`;
}, jn = (t, e) => (Array.isArray(t) ? t : [t]).map((n) => {
  const { id: o, type: r, purpose: i, value: s, created: a, creator: l, ...c } = n;
  return {
    id: o || Vn(n),
    annotation: e,
    type: r,
    purpose: i,
    value: s,
    created: a,
    creator: l ? typeof l == "object" ? { ...l } : l : void 0,
    ...c
  };
}), zn = (t) => t.map((e) => {
  const n = { ...e };
  return delete n.annotation, delete n.id, n;
});
Dn();
const sr = (t, e = !1) => ({ parse: (n) => Wn(n, e), serialize: (n) => qn(n, t) }), Wn = (t, e = !1) => {
  const n = t.id || He(), o = jn(t.body, n), r = Array.isArray(t.target) ? t.target[0] : t.target, i = Array.isArray(r.selector) ? r.selector[0] : r.selector, s = i.type === "FragmentSelector" ? un(i, e) : i.type === "SvgSelector" ? yn(i) : void 0;
  return s ? {
    parsed: {
      id: n,
      bodies: o,
      target: {
        annotation: n,
        selector: s
      }
    }
  } : {
    error: Error(`Unknown selector type: ${s.type}`)
  };
}, qn = (t, e) => {
  const n = t.target.selector, o = n.type == F.RECTANGLE ? hn(n.geometry) : $n(n);
  return {
    "@context": "http://www.w3.org/ns/anno.jsonld",
    id: t.id,
    type: "Annotation",
    body: zn(t.bodies),
    target: {
      source: e,
      selector: o
    }
  };
};
function pe(t, e, n) {
  const o = t.slice();
  return o[11] = e[n], o[13] = n, o;
}
function fe(t) {
  let e, n, o, r, i;
  return {
    c() {
      e = _("rect"), d(e, "class", "a9s-corner-handle"), d(e, "x", n = /*point*/
      t[11][0] - /*handleSize*/
      t[3] / 2), d(e, "y", o = /*point*/
      t[11][1] - /*handleSize*/
      t[3] / 2), d(
        e,
        "height",
        /*handleSize*/
        t[3]
      ), d(
        e,
        "width",
        /*handleSize*/
        t[3]
      );
    },
    m(s, a) {
      O(s, e, a), r || (i = j(e, "pointerdown", function() {
        U(
          /*grab*/
          t[10](E(
            /*idx*/
            t[13]
          ))
        ) && t[10](E(
          /*idx*/
          t[13]
        )).apply(this, arguments);
      }), r = !0);
    },
    p(s, a) {
      t = s, a & /*geom, handleSize*/
      24 && n !== (n = /*point*/
      t[11][0] - /*handleSize*/
      t[3] / 2) && d(e, "x", n), a & /*geom, handleSize*/
      24 && o !== (o = /*point*/
      t[11][1] - /*handleSize*/
      t[3] / 2) && d(e, "y", o), a & /*handleSize*/
      8 && d(
        e,
        "height",
        /*handleSize*/
        t[3]
      ), a & /*handleSize*/
      8 && d(
        e,
        "width",
        /*handleSize*/
        t[3]
      );
    },
    d(s) {
      s && T(e), r = !1, i();
    }
  };
}
function Jn(t) {
  let e, n, o, r, i, s, a, l, c, h, u = (
    /*geom*/
    t[4].points
  ), f = [];
  for (let p = 0; p < u.length; p += 1)
    f[p] = fe(pe(t, u, p));
  return {
    c() {
      e = _("polygon"), r = K(), i = _("polygon"), a = K();
      for (let p = 0; p < f.length; p += 1)
        f[p].c();
      l = rt(), d(e, "class", "a9s-outer"), d(e, "style", n = /*computedStyle*/
      t[1] ? "display:none;" : void 0), d(e, "points", o = /*geom*/
      t[4].points.map(me).join(" ")), d(i, "class", "a9s-inner a9s-shape-handle"), d(
        i,
        "style",
        /*computedStyle*/
        t[1]
      ), d(i, "points", s = /*geom*/
      t[4].points.map(ge).join(" "));
    },
    m(p, g) {
      O(p, e, g), O(p, r, g), O(p, i, g), O(p, a, g);
      for (let $ = 0; $ < f.length; $ += 1)
        f[$] && f[$].m(p, g);
      O(p, l, g), c || (h = [
        j(e, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.SHAPE)
          ) && t[10](E.SHAPE).apply(this, arguments);
        }),
        j(i, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.SHAPE)
          ) && t[10](E.SHAPE).apply(this, arguments);
        })
      ], c = !0);
    },
    p(p, g) {
      if (t = p, g & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      t[1] ? "display:none;" : void 0) && d(e, "style", n), g & /*geom*/
      16 && o !== (o = /*geom*/
      t[4].points.map(me).join(" ")) && d(e, "points", o), g & /*computedStyle*/
      2 && d(
        i,
        "style",
        /*computedStyle*/
        t[1]
      ), g & /*geom*/
      16 && s !== (s = /*geom*/
      t[4].points.map(ge).join(" ")) && d(i, "points", s), g & /*geom, handleSize, grab, Handle*/
      1048) {
        u = /*geom*/
        t[4].points;
        let $;
        for ($ = 0; $ < u.length; $ += 1) {
          const m = pe(t, u, $);
          f[$] ? f[$].p(m, g) : (f[$] = fe(m), f[$].c(), f[$].m(l.parentNode, l));
        }
        for (; $ < f.length; $ += 1)
          f[$].d(1);
        f.length = u.length;
      }
    },
    d(p) {
      p && T(e), p && T(r), p && T(i), p && T(a), ee(f, p), p && T(l), c = !1, ot(h);
    }
  };
}
function kn(t) {
  let e, n;
  return e = new Ue({
    props: {
      shape: (
        /*shape*/
        t[0]
      ),
      transform: (
        /*transform*/
        t[2]
      ),
      editor: (
        /*editor*/
        t[5]
      ),
      $$slots: {
        default: [
          Jn,
          ({ grab: o }) => ({ 10: o }),
          ({ grab: o }) => o ? 1024 : 0
        ]
      },
      $$scope: { ctx: t }
    }
  }), e.$on(
    "change",
    /*change_handler*/
    t[7]
  ), e.$on(
    "grab",
    /*grab_handler*/
    t[8]
  ), e.$on(
    "release",
    /*release_handler*/
    t[9]
  ), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, [r]) {
      const i = {};
      r & /*shape*/
      1 && (i.shape = /*shape*/
      o[0]), r & /*transform*/
      4 && (i.transform = /*transform*/
      o[2]), r & /*$$scope, geom, handleSize, grab, computedStyle*/
      17434 && (i.$$scope = { dirty: r, ctx: o }), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
const me = (t) => t.join(","), ge = (t) => t.join(",");
function Kn(t, e, n) {
  let o, r, { shape: i } = e, { computedStyle: s = void 0 } = e, { transform: a } = e, { viewportScale: l = 1 } = e;
  const c = (p, g, $) => {
    let m;
    g === E.SHAPE ? m = p.geometry.points.map(([Y, I]) => [Y + $[0], I + $[1]]) : m = p.geometry.points.map(([Y, I], X) => g === E(X) ? [Y + $[0], I + $[1]] : [Y, I]);
    const x = Nt(m);
    return { ...p, geometry: { points: m, bounds: x } };
  };
  function h(p) {
    yt.call(this, t, p);
  }
  function u(p) {
    yt.call(this, t, p);
  }
  function f(p) {
    yt.call(this, t, p);
  }
  return t.$$set = (p) => {
    "shape" in p && n(0, i = p.shape), "computedStyle" in p && n(1, s = p.computedStyle), "transform" in p && n(2, a = p.transform), "viewportScale" in p && n(6, l = p.viewportScale);
  }, t.$$.update = () => {
    t.$$.dirty & /*shape*/
    1 && n(4, o = i.geometry), t.$$.dirty & /*viewportScale*/
    64 && n(3, r = 10 / l);
  }, [
    i,
    s,
    a,
    r,
    o,
    c,
    l,
    h,
    u,
    f
  ];
}
class Qn extends Z {
  constructor(e) {
    super(), Q(this, e, Kn, kn, z, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 6
    });
  }
}
function Zn(t) {
  let e, n, o, r, i, s, a, l, c, h, u, f, p, g, $, m, x, Y, I, X, D, y, b, w, A, M, S, B, C, G, it, tt, Dt, W, Mt, Lt, Ut, q, Yt, Bt, Vt, J, It, _t, jt, k, Xt, Pt, zt, re;
  return {
    c() {
      e = _("rect"), a = K(), l = _("rect"), p = K(), g = _("rect"), Y = K(), I = _("rect"), b = K(), w = _("rect"), B = K(), C = _("rect"), Dt = K(), W = _("rect"), Ut = K(), q = _("rect"), Vt = K(), J = _("rect"), jt = K(), k = _("rect"), d(e, "class", "a9s-outer"), d(e, "style", n = /*computedStyle*/
      t[1] ? "display:none;" : void 0), d(e, "x", o = /*geom*/
      t[4].x), d(e, "y", r = /*geom*/
      t[4].y), d(e, "width", i = /*geom*/
      t[4].w), d(e, "height", s = /*geom*/
      t[4].h), d(l, "class", "a9s-inner a9s-shape-handle"), d(
        l,
        "style",
        /*computedStyle*/
        t[1]
      ), d(l, "x", c = /*geom*/
      t[4].x), d(l, "y", h = /*geom*/
      t[4].y), d(l, "width", u = /*geom*/
      t[4].w), d(l, "height", f = /*geom*/
      t[4].h), d(g, "class", "a9s-edge-handle a9s-edge-handle-top"), d(g, "x", $ = /*geom*/
      t[4].x), d(g, "y", m = /*geom*/
      t[4].y), d(g, "height", 1), d(g, "width", x = /*geom*/
      t[4].w), d(I, "class", "a9s-edge-handle a9s-edge-handle-right"), d(I, "x", X = /*geom*/
      t[4].x + /*geom*/
      t[4].w), d(I, "y", D = /*geom*/
      t[4].y), d(I, "height", y = /*geom*/
      t[4].h), d(I, "width", 1), d(w, "class", "a9s-edge-handle a9s-edge-handle-bottom"), d(w, "x", A = /*geom*/
      t[4].x), d(w, "y", M = /*geom*/
      t[4].y + /*geom*/
      t[4].h), d(w, "height", 1), d(w, "width", S = /*geom*/
      t[4].w), d(C, "class", "a9s-edge-handle a9s-edge-handle-left"), d(C, "x", G = /*geom*/
      t[4].x), d(C, "y", it = /*geom*/
      t[4].y), d(C, "height", tt = /*geom*/
      t[4].h), d(C, "width", 1), d(W, "class", "a9s-corner-handle a9s-corner-handle-topleft"), d(W, "x", Mt = /*geom*/
      t[4].x - /*handleSize*/
      t[3] / 2), d(W, "y", Lt = /*geom*/
      t[4].y - /*handleSize*/
      t[3] / 2), d(
        W,
        "height",
        /*handleSize*/
        t[3]
      ), d(
        W,
        "width",
        /*handleSize*/
        t[3]
      ), d(q, "class", "a9s-corner-handle a9s-corner-handle-topright"), d(q, "x", Yt = /*geom*/
      t[4].x + /*geom*/
      t[4].w - /*handleSize*/
      t[3] / 2), d(q, "y", Bt = /*geom*/
      t[4].y - /*handleSize*/
      t[3] / 2), d(
        q,
        "height",
        /*handleSize*/
        t[3]
      ), d(
        q,
        "width",
        /*handleSize*/
        t[3]
      ), d(J, "class", "a9s-corner-handle a9s-corner-handle-bottomright"), d(J, "x", It = /*geom*/
      t[4].x + /*geom*/
      t[4].w - /*handleSize*/
      t[3] / 2), d(J, "y", _t = /*geom*/
      t[4].y + /*geom*/
      t[4].h - /*handleSize*/
      t[3] / 2), d(
        J,
        "height",
        /*handleSize*/
        t[3]
      ), d(
        J,
        "width",
        /*handleSize*/
        t[3]
      ), d(k, "class", "a9s-corner-handle a9s-corner-handle-bottomleft"), d(k, "x", Xt = /*geom*/
      t[4].x - /*handleSize*/
      t[3] / 2), d(k, "y", Pt = /*geom*/
      t[4].y + /*geom*/
      t[4].h - /*handleSize*/
      t[3] / 2), d(
        k,
        "height",
        /*handleSize*/
        t[3]
      ), d(
        k,
        "width",
        /*handleSize*/
        t[3]
      );
    },
    m(L, v) {
      O(L, e, v), O(L, a, v), O(L, l, v), O(L, p, v), O(L, g, v), O(L, Y, v), O(L, I, v), O(L, b, v), O(L, w, v), O(L, B, v), O(L, C, v), O(L, Dt, v), O(L, W, v), O(L, Ut, v), O(L, q, v), O(L, Vt, v), O(L, J, v), O(L, jt, v), O(L, k, v), zt || (re = [
        j(e, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.SHAPE)
          ) && t[10](E.SHAPE).apply(this, arguments);
        }),
        j(l, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.SHAPE)
          ) && t[10](E.SHAPE).apply(this, arguments);
        }),
        j(g, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.TOP)
          ) && t[10](E.TOP).apply(this, arguments);
        }),
        j(I, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.RIGHT)
          ) && t[10](E.RIGHT).apply(this, arguments);
        }),
        j(w, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.BOTTOM)
          ) && t[10](E.BOTTOM).apply(this, arguments);
        }),
        j(C, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.LEFT)
          ) && t[10](E.LEFT).apply(this, arguments);
        }),
        j(W, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.TOP_LEFT)
          ) && t[10](E.TOP_LEFT).apply(this, arguments);
        }),
        j(q, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.TOP_RIGHT)
          ) && t[10](E.TOP_RIGHT).apply(this, arguments);
        }),
        j(J, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.BOTTOM_RIGHT)
          ) && t[10](E.BOTTOM_RIGHT).apply(this, arguments);
        }),
        j(k, "pointerdown", function() {
          U(
            /*grab*/
            t[10](E.BOTTOM_LEFT)
          ) && t[10](E.BOTTOM_LEFT).apply(this, arguments);
        })
      ], zt = !0);
    },
    p(L, v) {
      t = L, v & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      t[1] ? "display:none;" : void 0) && d(e, "style", n), v & /*geom*/
      16 && o !== (o = /*geom*/
      t[4].x) && d(e, "x", o), v & /*geom*/
      16 && r !== (r = /*geom*/
      t[4].y) && d(e, "y", r), v & /*geom*/
      16 && i !== (i = /*geom*/
      t[4].w) && d(e, "width", i), v & /*geom*/
      16 && s !== (s = /*geom*/
      t[4].h) && d(e, "height", s), v & /*computedStyle*/
      2 && d(
        l,
        "style",
        /*computedStyle*/
        t[1]
      ), v & /*geom*/
      16 && c !== (c = /*geom*/
      t[4].x) && d(l, "x", c), v & /*geom*/
      16 && h !== (h = /*geom*/
      t[4].y) && d(l, "y", h), v & /*geom*/
      16 && u !== (u = /*geom*/
      t[4].w) && d(l, "width", u), v & /*geom*/
      16 && f !== (f = /*geom*/
      t[4].h) && d(l, "height", f), v & /*geom*/
      16 && $ !== ($ = /*geom*/
      t[4].x) && d(g, "x", $), v & /*geom*/
      16 && m !== (m = /*geom*/
      t[4].y) && d(g, "y", m), v & /*geom*/
      16 && x !== (x = /*geom*/
      t[4].w) && d(g, "width", x), v & /*geom*/
      16 && X !== (X = /*geom*/
      t[4].x + /*geom*/
      t[4].w) && d(I, "x", X), v & /*geom*/
      16 && D !== (D = /*geom*/
      t[4].y) && d(I, "y", D), v & /*geom*/
      16 && y !== (y = /*geom*/
      t[4].h) && d(I, "height", y), v & /*geom*/
      16 && A !== (A = /*geom*/
      t[4].x) && d(w, "x", A), v & /*geom*/
      16 && M !== (M = /*geom*/
      t[4].y + /*geom*/
      t[4].h) && d(w, "y", M), v & /*geom*/
      16 && S !== (S = /*geom*/
      t[4].w) && d(w, "width", S), v & /*geom*/
      16 && G !== (G = /*geom*/
      t[4].x) && d(C, "x", G), v & /*geom*/
      16 && it !== (it = /*geom*/
      t[4].y) && d(C, "y", it), v & /*geom*/
      16 && tt !== (tt = /*geom*/
      t[4].h) && d(C, "height", tt), v & /*geom, handleSize*/
      24 && Mt !== (Mt = /*geom*/
      t[4].x - /*handleSize*/
      t[3] / 2) && d(W, "x", Mt), v & /*geom, handleSize*/
      24 && Lt !== (Lt = /*geom*/
      t[4].y - /*handleSize*/
      t[3] / 2) && d(W, "y", Lt), v & /*handleSize*/
      8 && d(
        W,
        "height",
        /*handleSize*/
        t[3]
      ), v & /*handleSize*/
      8 && d(
        W,
        "width",
        /*handleSize*/
        t[3]
      ), v & /*geom, handleSize*/
      24 && Yt !== (Yt = /*geom*/
      t[4].x + /*geom*/
      t[4].w - /*handleSize*/
      t[3] / 2) && d(q, "x", Yt), v & /*geom, handleSize*/
      24 && Bt !== (Bt = /*geom*/
      t[4].y - /*handleSize*/
      t[3] / 2) && d(q, "y", Bt), v & /*handleSize*/
      8 && d(
        q,
        "height",
        /*handleSize*/
        t[3]
      ), v & /*handleSize*/
      8 && d(
        q,
        "width",
        /*handleSize*/
        t[3]
      ), v & /*geom, handleSize*/
      24 && It !== (It = /*geom*/
      t[4].x + /*geom*/
      t[4].w - /*handleSize*/
      t[3] / 2) && d(J, "x", It), v & /*geom, handleSize*/
      24 && _t !== (_t = /*geom*/
      t[4].y + /*geom*/
      t[4].h - /*handleSize*/
      t[3] / 2) && d(J, "y", _t), v & /*handleSize*/
      8 && d(
        J,
        "height",
        /*handleSize*/
        t[3]
      ), v & /*handleSize*/
      8 && d(
        J,
        "width",
        /*handleSize*/
        t[3]
      ), v & /*geom, handleSize*/
      24 && Xt !== (Xt = /*geom*/
      t[4].x - /*handleSize*/
      t[3] / 2) && d(k, "x", Xt), v & /*geom, handleSize*/
      24 && Pt !== (Pt = /*geom*/
      t[4].y + /*geom*/
      t[4].h - /*handleSize*/
      t[3] / 2) && d(k, "y", Pt), v & /*handleSize*/
      8 && d(
        k,
        "height",
        /*handleSize*/
        t[3]
      ), v & /*handleSize*/
      8 && d(
        k,
        "width",
        /*handleSize*/
        t[3]
      );
    },
    d(L) {
      L && T(e), L && T(a), L && T(l), L && T(p), L && T(g), L && T(Y), L && T(I), L && T(b), L && T(w), L && T(B), L && T(C), L && T(Dt), L && T(W), L && T(Ut), L && T(q), L && T(Vt), L && T(J), L && T(jt), L && T(k), zt = !1, ot(re);
    }
  };
}
function to(t) {
  let e, n;
  return e = new Ue({
    props: {
      shape: (
        /*shape*/
        t[0]
      ),
      transform: (
        /*transform*/
        t[2]
      ),
      editor: (
        /*editor*/
        t[5]
      ),
      $$slots: {
        default: [
          Zn,
          ({ grab: o }) => ({ 10: o }),
          ({ grab: o }) => o ? 1024 : 0
        ]
      },
      $$scope: { ctx: t }
    }
  }), e.$on(
    "grab",
    /*grab_handler*/
    t[7]
  ), e.$on(
    "change",
    /*change_handler*/
    t[8]
  ), e.$on(
    "release",
    /*release_handler*/
    t[9]
  ), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, [r]) {
      const i = {};
      r & /*shape*/
      1 && (i.shape = /*shape*/
      o[0]), r & /*transform*/
      4 && (i.transform = /*transform*/
      o[2]), r & /*$$scope, geom, handleSize, grab, computedStyle*/
      3098 && (i.$$scope = { dirty: r, ctx: o }), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
function eo(t, e, n) {
  let o, r, { shape: i } = e, { computedStyle: s = void 0 } = e, { transform: a } = e, { viewportScale: l = 1 } = e;
  const c = (p, g, $) => {
    const m = p.geometry.bounds;
    let [x, Y] = [m.minX, m.minY], [I, X] = [m.maxX, m.maxY];
    const [D, y] = $;
    if (g === E.SHAPE)
      x += D, I += D, Y += y, X += y;
    else {
      switch (g) {
        case E.TOP:
        case E.TOP_LEFT:
        case E.TOP_RIGHT: {
          Y += y;
          break;
        }
        case E.BOTTOM:
        case E.BOTTOM_LEFT:
        case E.BOTTOM_RIGHT: {
          X += y;
          break;
        }
      }
      switch (g) {
        case E.LEFT:
        case E.TOP_LEFT:
        case E.BOTTOM_LEFT: {
          x += D;
          break;
        }
        case E.RIGHT:
        case E.TOP_RIGHT:
        case E.BOTTOM_RIGHT: {
          I += D;
          break;
        }
      }
    }
    const b = Math.min(x, I), w = Math.min(Y, X), A = Math.abs(I - x), M = Math.abs(X - Y);
    return {
      ...p,
      geometry: {
        x: b,
        y: w,
        w: A,
        h: M,
        bounds: {
          minX: b,
          minY: w,
          maxX: b + A,
          maxY: w + M
        }
      }
    };
  };
  function h(p) {
    yt.call(this, t, p);
  }
  function u(p) {
    yt.call(this, t, p);
  }
  function f(p) {
    yt.call(this, t, p);
  }
  return t.$$set = (p) => {
    "shape" in p && n(0, i = p.shape), "computedStyle" in p && n(1, s = p.computedStyle), "transform" in p && n(2, a = p.transform), "viewportScale" in p && n(6, l = p.viewportScale);
  }, t.$$.update = () => {
    t.$$.dirty & /*shape*/
    1 && n(4, o = i.geometry), t.$$.dirty & /*viewportScale*/
    64 && n(3, r = 10 / l);
  }, [
    i,
    s,
    a,
    r,
    o,
    c,
    l,
    h,
    u,
    f
  ];
}
class no extends Z {
  constructor(e) {
    super(), Q(this, e, eo, to, z, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 6
    });
  }
}
const De = /* @__PURE__ */ new Map([
  [F.RECTANGLE, no],
  [F.POLYGON, Qn]
]), ye = (t) => De.get(t.type), oo = (t, e) => De.set(t, e), E = (t) => `HANDLE-${t}`;
E.SHAPE = "SHAPE";
E.TOP = "TOP";
E.RIGHT = "RIGHT";
E.BOTTOM = "BOTTOM";
E.LEFT = "LEFT";
E.TOP_LEFT = "TOP_LEFT";
E.TOP_RIGHT = "TOP_RIGHT";
E.BOTTOM_RIGHT = "BOTTOM_RIGHT";
E.BOTTOM_LEFT = "BOTTOM_LEFT";
const ro = (t) => ({}), $e = (t) => ({ grab: (
  /*onGrab*/
  t[0]
) });
function io(t) {
  let e, n, o, r;
  const i = (
    /*#slots*/
    t[7].default
  ), s = Je(
    i,
    t,
    /*$$scope*/
    t[6],
    $e
  );
  return {
    c() {
      e = _("g"), s && s.c(), d(e, "class", "a9s-annotation selected");
    },
    m(a, l) {
      O(a, e, l), s && s.m(e, null), n = !0, o || (r = [
        j(
          e,
          "pointerup",
          /*onRelease*/
          t[2]
        ),
        j(
          e,
          "pointermove",
          /*onPointerMove*/
          t[1]
        )
      ], o = !0);
    },
    p(a, [l]) {
      s && s.p && (!n || l & /*$$scope*/
      64) && Ke(
        s,
        i,
        a,
        /*$$scope*/
        a[6],
        n ? ke(
          i,
          /*$$scope*/
          a[6],
          l,
          ro
        ) : Qe(
          /*$$scope*/
          a[6]
        ),
        $e
      );
    },
    i(a) {
      n || (P(s, a), n = !0);
    },
    o(a) {
      R(s, a), n = !1;
    },
    d(a) {
      a && T(e), s && s.d(a), o = !1, ot(r);
    }
  };
}
function so(t, e, n) {
  let { $$slots: o = {}, $$scope: r } = e;
  const i = wt();
  let { shape: s } = e, { editor: a } = e, { transform: l } = e, c = null, h, u = null;
  const f = ($) => (m) => {
    c = $, h = l.elementToImage(m.offsetX, m.offsetY), u = s, m.target.setPointerCapture(m.pointerId), i("grab");
  }, p = ($) => {
    if (c) {
      const [m, x] = l.elementToImage($.offsetX, $.offsetY), Y = [m - h[0], x - h[1]];
      n(3, s = a(u, c, Y)), i("change", s);
    }
  }, g = ($) => {
    $.target.releasePointerCapture($.pointerId), c = null, u = s, i("release");
  };
  return t.$$set = ($) => {
    "shape" in $ && n(3, s = $.shape), "editor" in $ && n(4, a = $.editor), "transform" in $ && n(5, l = $.transform), "$$scope" in $ && n(6, r = $.$$scope);
  }, [f, p, g, s, a, l, r, o];
}
class Ue extends Z {
  constructor(e) {
    super(), Q(this, e, so, io, z, { shape: 3, editor: 4, transform: 5 });
  }
}
const Ft = (t, e) => {
  const n = typeof e == "function" ? e(t) : e;
  if (n) {
    const { fill: o, fillOpacity: r } = n;
    let i = "";
    return o && (i += `fill:${o};stroke:${o};`), i += `fill-opacity:${r || "0.25"};`, i;
  }
};
function ao(t, e, n) {
  let o;
  const r = wt();
  let { annotation: i } = e, { editor: s } = e, { style: a = void 0 } = e, { target: l } = e, { transform: c } = e, { viewportScale: h } = e, u;
  return Ot(() => (n(6, u = new s({
    target: l,
    props: {
      shape: i.target.selector,
      computedStyle: o,
      transform: c,
      viewportScale: h
    }
  })), u.$on("change", (f) => {
    u.$$set({ shape: f.detail }), r("change", f.detail);
  }), () => {
    u.$destroy();
  })), t.$$set = (f) => {
    "annotation" in f && n(0, i = f.annotation), "editor" in f && n(1, s = f.editor), "style" in f && n(2, a = f.style), "target" in f && n(3, l = f.target), "transform" in f && n(4, c = f.transform), "viewportScale" in f && n(5, h = f.viewportScale);
  }, t.$$.update = () => {
    t.$$.dirty & /*annotation, style*/
    5 && (o = Ft(i, a)), t.$$.dirty & /*editorComponent, transform*/
    80 && u && u.$set({ transform: c }), t.$$.dirty & /*editorComponent, viewportScale*/
    96 && u && u.$set({ viewportScale: h });
  }, [i, s, a, l, c, h, u];
}
class lo extends Z {
  constructor(e) {
    super(), Q(this, e, ao, null, z, {
      annotation: 0,
      editor: 1,
      style: 2,
      target: 3,
      transform: 4,
      viewportScale: 5
    });
  }
}
function co(t, e, n) {
  const o = wt();
  let { target: r } = e, { tool: i } = e, { transform: s } = e, { viewportScale: a } = e, l;
  return Ot(() => (n(4, l = new i({
    target: r,
    props: { transform: s, viewportScale: a }
  })), l.$on("create", (c) => o("create", c.detail)), () => {
    l.$destroy();
  })), t.$$set = (c) => {
    "target" in c && n(0, r = c.target), "tool" in c && n(1, i = c.tool), "transform" in c && n(2, s = c.transform), "viewportScale" in c && n(3, a = c.viewportScale);
  }, t.$$.update = () => {
    t.$$.dirty & /*toolComponent, transform*/
    20 && l && l.$set({ transform: s }), t.$$.dirty & /*toolComponent, viewportScale*/
    24 && l && l.$set({ viewportScale: a });
  }, [r, i, s, a, l];
}
class uo extends Z {
  constructor(e) {
    super(), Q(this, e, co, null, z, {
      target: 0,
      tool: 1,
      transform: 2,
      viewportScale: 3
    });
  }
}
function xe(t) {
  let e, n;
  return {
    c() {
      e = _("rect"), n = _("rect"), d(e, "class", "a9s-outer"), d(
        e,
        "x",
        /*x*/
        t[2]
      ), d(
        e,
        "y",
        /*y*/
        t[3]
      ), d(
        e,
        "width",
        /*w*/
        t[4]
      ), d(
        e,
        "height",
        /*h*/
        t[5]
      ), d(n, "class", "a9s-inner"), d(
        n,
        "x",
        /*x*/
        t[2]
      ), d(
        n,
        "y",
        /*y*/
        t[3]
      ), d(
        n,
        "width",
        /*w*/
        t[4]
      ), d(
        n,
        "height",
        /*h*/
        t[5]
      );
    },
    m(o, r) {
      O(o, e, r), O(o, n, r);
    },
    p(o, r) {
      r & /*x*/
      4 && d(
        e,
        "x",
        /*x*/
        o[2]
      ), r & /*y*/
      8 && d(
        e,
        "y",
        /*y*/
        o[3]
      ), r & /*w*/
      16 && d(
        e,
        "width",
        /*w*/
        o[4]
      ), r & /*h*/
      32 && d(
        e,
        "height",
        /*h*/
        o[5]
      ), r & /*x*/
      4 && d(
        n,
        "x",
        /*x*/
        o[2]
      ), r & /*y*/
      8 && d(
        n,
        "y",
        /*y*/
        o[3]
      ), r & /*w*/
      16 && d(
        n,
        "width",
        /*w*/
        o[4]
      ), r & /*h*/
      32 && d(
        n,
        "height",
        /*h*/
        o[5]
      );
    },
    d(o) {
      o && T(e), o && T(n);
    }
  };
}
function ho(t) {
  let e, n = (
    /*origin*/
    t[1] && xe(t)
  );
  return {
    c() {
      e = _("g"), n && n.c(), d(e, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, r) {
      O(o, e, r), n && n.m(e, null), t[7](e);
    },
    p(o, [r]) {
      o[1] ? n ? n.p(o, r) : (n = xe(o), n.c(), n.m(e, null)) : n && (n.d(1), n = null);
    },
    i: N,
    o: N,
    d(o) {
      o && T(e), n && n.d(), t[7](null);
    }
  };
}
function po(t, e, n) {
  const o = wt();
  let { transform: r } = e, i, s, a, l, c, h, u;
  const f = (m) => {
    n(1, s = r.elementToImage(m.offsetX, m.offsetY)), a = s, n(2, l = s[0]), n(3, c = s[1]), n(4, h = 1), n(5, u = 1);
  }, p = (m) => {
    s && (a = r.elementToImage(m.offsetX, m.offsetY), n(2, l = Math.min(a[0], s[0])), n(3, c = Math.min(a[1], s[1])), n(4, h = Math.abs(a[0] - s[0])), n(5, u = Math.abs(a[1] - s[1])));
  }, g = () => {
    if (h * u > 15) {
      const m = {
        type: F.RECTANGLE,
        geometry: {
          bounds: {
            minX: l,
            minY: c,
            maxX: l + h,
            maxY: c + u
          },
          x: l,
          y: c,
          w: h,
          h: u
        }
      };
      o("create", m);
    }
    n(1, s = null), a = null;
  };
  Ot(() => {
    const m = i.closest("svg");
    return m.addEventListener("pointerdown", f), m.addEventListener("pointermove", p), m.addEventListener("pointerup", g), () => {
      m.removeEventListener("pointerdown", f), m.removeEventListener("pointermove", p), m.removeEventListener("pointerup", g);
    };
  });
  function $(m) {
    xt[m ? "unshift" : "push"](() => {
      i = m, n(0, i);
    });
  }
  return t.$$set = (m) => {
    "transform" in m && n(6, r = m.transform);
  }, [i, s, l, c, h, u, r, $];
}
class fo extends Z {
  constructor(e) {
    super(), Q(this, e, po, ho, z, { transform: 6 });
  }
}
const we = (t, e) => {
  const n = Math.abs(e[0] - t[0]), o = Math.abs(e[1] - t[1]);
  return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));
}, mo = (t, e) => {
  const { naturalWidth: n, naturalHeight: o } = t;
  if (!n && !o) {
    const { width: r, height: i } = t;
    e.setAttribute("viewBox", `0 0 ${r} ${i}`), t.addEventListener("load", (s) => {
      const a = s.target;
      e.setAttribute("viewBox", `0 0 ${a.naturalWidth} ${a.naturalHeight}`);
    });
  } else
    e.setAttribute("viewBox", `0 0 ${n} ${o}`);
}, go = (t, e) => {
  mo(t, e);
  const { subscribe: n, set: o } = Ht(1);
  let r;
  return window.ResizeObserver && (r = new ResizeObserver(() => {
    const i = e.getBoundingClientRect(), { width: s, height: a } = e.viewBox.baseVal, l = Math.max(
      i.width / s,
      i.height / a
    );
    o(l);
  }), r.observe(e.parentElement)), { destroy: () => {
    r && r.disconnect();
  }, subscribe: n };
}, yo = "ontouchstart" in window || navigator.maxTouchPoints > 0;
function Jt(t) {
  const e = t.slice(), n = (
    /*isClosable*/
    (e[3] ? (
      /*points*/
      e[1]
    ) : [
      .../*points*/
      e[1],
      /*cursor*/
      e[2]
    ]).map((o) => o.join(",")).join(" ")
  );
  return e[13] = n, e;
}
function be(t) {
  let e, n, o, r, i, s = (
    /*isClosable*/
    t[3] && ve(t)
  );
  return {
    c() {
      e = _("polygon"), o = _("polygon"), s && s.c(), i = rt(), d(e, "class", "a9s-outer"), d(e, "points", n = /*coords*/
      t[13]), d(o, "class", "a9s-inner"), d(o, "points", r = /*coords*/
      t[13]);
    },
    m(a, l) {
      O(a, e, l), O(a, o, l), s && s.m(a, l), O(a, i, l);
    },
    p(a, l) {
      l & /*isClosable, points, cursor*/
      14 && n !== (n = /*coords*/
      a[13]) && d(e, "points", n), l & /*isClosable, points, cursor*/
      14 && r !== (r = /*coords*/
      a[13]) && d(o, "points", r), /*isClosable*/
      a[3] ? s ? s.p(a, l) : (s = ve(a), s.c(), s.m(i.parentNode, i)) : s && (s.d(1), s = null);
    },
    d(a) {
      a && T(e), a && T(o), s && s.d(a), a && T(i);
    }
  };
}
function ve(t) {
  let e, n, o;
  return {
    c() {
      e = _("rect"), d(e, "class", "a9s-corner-handle"), d(e, "x", n = /*points*/
      t[1][0][0] - /*handleSize*/
      t[4] / 2), d(e, "y", o = /*points*/
      t[1][0][1] - /*handleSize*/
      t[4] / 2), d(
        e,
        "height",
        /*handleSize*/
        t[4]
      ), d(
        e,
        "width",
        /*handleSize*/
        t[4]
      );
    },
    m(r, i) {
      O(r, e, i);
    },
    p(r, i) {
      i & /*points, handleSize*/
      18 && n !== (n = /*points*/
      r[1][0][0] - /*handleSize*/
      r[4] / 2) && d(e, "x", n), i & /*points, handleSize*/
      18 && o !== (o = /*points*/
      r[1][0][1] - /*handleSize*/
      r[4] / 2) && d(e, "y", o), i & /*handleSize*/
      16 && d(
        e,
        "height",
        /*handleSize*/
        r[4]
      ), i & /*handleSize*/
      16 && d(
        e,
        "width",
        /*handleSize*/
        r[4]
      );
    },
    d(r) {
      r && T(e);
    }
  };
}
function $o(t) {
  let e, n = (
    /*cursor*/
    t[2] && be(Jt(t))
  );
  return {
    c() {
      e = _("g"), n && n.c(), d(e, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, r) {
      O(o, e, r), n && n.m(e, null), t[7](e);
    },
    p(o, [r]) {
      o[2] ? n ? n.p(Jt(o), r) : (n = be(Jt(o)), n.c(), n.m(e, null)) : n && (n.d(1), n = null);
    },
    i: N,
    o: N,
    d(o) {
      o && T(e), n && n.d(), t[7](null);
    }
  };
}
const xo = 20;
function wo(t, e, n) {
  let o;
  const r = wt();
  let { transform: i } = e, { viewportScale: s = 1 } = e, a, l = [], c = null, h = !1;
  const u = (m) => {
    const x = i.elementToImage(m.offsetX, m.offsetY);
    l.length === 0 && l.push(x), n(2, c = x);
  }, f = (m) => {
    if (l.length > 0 && (n(2, c = i.elementToImage(m.offsetX, m.offsetY)), l.length > 2)) {
      const x = we(c, l[0]) * s;
      n(3, h = x < xo);
    }
  }, p = (m) => {
    if (l.length === 1 && we(l[0], c) <= 4) {
      n(1, l = []), n(2, c = null);
      return;
    }
    if (m.stopImmediatePropagation(), h) {
      const x = {
        type: F.POLYGON,
        geometry: {
          bounds: Nt(l),
          points: [...l]
        }
      };
      n(1, l = []), n(2, c = null), r("create", x);
    } else
      l.push(c);
  }, g = () => {
    const m = [...l, c], x = {
      type: F.POLYGON,
      geometry: { bounds: Nt(m), points: m }
    };
    n(1, l = []), n(2, c = null), r("create", x);
  };
  Ot(() => {
    const m = a.closest("svg");
    return m.addEventListener("pointerdown", u, !0), m.addEventListener("pointermove", f), m.addEventListener("pointerup", p, !0), m.addEventListener("dblclick", g, !0), () => {
      m.removeEventListener("pointerdown", u, !0), m.removeEventListener("pointermove", f, !0), m.removeEventListener("pointerup", p, !0), m.removeEventListener("dblclick", g, !0);
    };
  });
  function $(m) {
    xt[m ? "unshift" : "push"](() => {
      a = m, n(0, a);
    });
  }
  return t.$$set = (m) => {
    "transform" in m && n(5, i = m.transform), "viewportScale" in m && n(6, s = m.viewportScale);
  }, t.$$.update = () => {
    t.$$.dirty & /*viewportScale*/
    64 && n(4, o = 10 / s);
  }, [
    a,
    l,
    c,
    h,
    o,
    i,
    s,
    $
  ];
}
class bo extends Z {
  constructor(e) {
    super(), Q(this, e, wo, $o, z, { transform: 5, viewportScale: 6 });
  }
}
const Ve = /* @__PURE__ */ new Map([
  ["rectangle", fo],
  ["polygon", bo]
]), je = (t) => Ve.get(t), vo = (t, e) => Ve.set(t, e);
function Eo(t) {
  let e, n, o, r, i;
  return {
    c() {
      e = _("g"), n = _("ellipse"), r = _("ellipse"), d(n, "class", "a9s-outer"), d(n, "style", o = /*computedStyle*/
      t[1] ? "display:none;" : void 0), d(
        n,
        "cx",
        /*cx*/
        t[2]
      ), d(
        n,
        "cy",
        /*cy*/
        t[3]
      ), d(
        n,
        "rx",
        /*rx*/
        t[4]
      ), d(
        n,
        "ry",
        /*ry*/
        t[5]
      ), d(r, "class", "a9s-inner"), d(
        r,
        "style",
        /*computedStyle*/
        t[1]
      ), d(
        r,
        "cx",
        /*cx*/
        t[2]
      ), d(
        r,
        "cy",
        /*cy*/
        t[3]
      ), d(
        r,
        "rx",
        /*rx*/
        t[4]
      ), d(
        r,
        "ry",
        /*ry*/
        t[5]
      ), d(e, "data-id", i = /*annotation*/
      t[0].id);
    },
    m(s, a) {
      O(s, e, a), st(e, n), st(e, r);
    },
    p(s, [a]) {
      a & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      s[1] ? "display:none;" : void 0) && d(n, "style", o), a & /*computedStyle*/
      2 && d(
        r,
        "style",
        /*computedStyle*/
        s[1]
      ), a & /*annotation*/
      1 && i !== (i = /*annotation*/
      s[0].id) && d(e, "data-id", i);
    },
    i: N,
    o: N,
    d(s) {
      s && T(e);
    }
  };
}
function Ao(t, e, n) {
  let o, { annotation: r } = e, { geom: i } = e, { style: s = void 0 } = e;
  const { cx: a, cy: l, rx: c, ry: h } = i;
  return t.$$set = (u) => {
    "annotation" in u && n(0, r = u.annotation), "geom" in u && n(6, i = u.geom), "style" in u && n(7, s = u.style);
  }, t.$$.update = () => {
    t.$$.dirty & /*annotation, style*/
    129 && n(1, o = Ft(r, s));
  }, [r, o, a, l, c, h, i, s];
}
class To extends Z {
  constructor(e) {
    super(), Q(this, e, Ao, Eo, z, { annotation: 0, geom: 6, style: 7 });
  }
}
function Oo(t) {
  let e, n, o, r, i;
  return {
    c() {
      e = _("g"), n = _("polygon"), r = _("polygon"), d(n, "class", "a9s-outer"), d(n, "style", o = /*computedStyle*/
      t[1] ? "display:none;" : void 0), d(
        n,
        "points",
        /*points*/
        t[2].map(Mo).join(" ")
      ), d(r, "class", "a9s-inner"), d(
        r,
        "style",
        /*computedStyle*/
        t[1]
      ), d(
        r,
        "points",
        /*points*/
        t[2].map(Lo).join(" ")
      ), d(e, "data-id", i = /*annotation*/
      t[0].id);
    },
    m(s, a) {
      O(s, e, a), st(e, n), st(e, r);
    },
    p(s, [a]) {
      a & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      s[1] ? "display:none;" : void 0) && d(n, "style", o), a & /*computedStyle*/
      2 && d(
        r,
        "style",
        /*computedStyle*/
        s[1]
      ), a & /*annotation*/
      1 && i !== (i = /*annotation*/
      s[0].id) && d(e, "data-id", i);
    },
    i: N,
    o: N,
    d(s) {
      s && T(e);
    }
  };
}
const Mo = (t) => t.join(","), Lo = (t) => t.join(",");
function Yo(t, e, n) {
  let o, { annotation: r } = e, { geom: i } = e, { style: s = void 0 } = e;
  const { points: a } = i;
  return t.$$set = (l) => {
    "annotation" in l && n(0, r = l.annotation), "geom" in l && n(3, i = l.geom), "style" in l && n(4, s = l.style);
  }, t.$$.update = () => {
    t.$$.dirty & /*annotation, style*/
    17 && n(1, o = Ft(r, s));
  }, [r, o, a, i, s];
}
class Bo extends Z {
  constructor(e) {
    super(), Q(this, e, Yo, Oo, z, { annotation: 0, geom: 3, style: 4 });
  }
}
function Io(t) {
  let e, n, o, r, i;
  return {
    c() {
      e = _("g"), n = _("rect"), r = _("rect"), d(n, "class", "a9s-outer"), d(n, "style", o = /*computedStyle*/
      t[1] ? "display:none;" : void 0), d(
        n,
        "x",
        /*x*/
        t[2]
      ), d(
        n,
        "y",
        /*y*/
        t[3]
      ), d(
        n,
        "width",
        /*w*/
        t[4]
      ), d(
        n,
        "height",
        /*h*/
        t[5]
      ), d(r, "class", "a9s-inner"), d(
        r,
        "style",
        /*computedStyle*/
        t[1]
      ), d(
        r,
        "x",
        /*x*/
        t[2]
      ), d(
        r,
        "y",
        /*y*/
        t[3]
      ), d(
        r,
        "width",
        /*w*/
        t[4]
      ), d(
        r,
        "height",
        /*h*/
        t[5]
      ), d(e, "data-id", i = /*annotation*/
      t[0].id);
    },
    m(s, a) {
      O(s, e, a), st(e, n), st(e, r);
    },
    p(s, [a]) {
      a & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      s[1] ? "display:none;" : void 0) && d(n, "style", o), a & /*computedStyle*/
      2 && d(
        r,
        "style",
        /*computedStyle*/
        s[1]
      ), a & /*annotation*/
      1 && i !== (i = /*annotation*/
      s[0].id) && d(e, "data-id", i);
    },
    i: N,
    o: N,
    d(s) {
      s && T(e);
    }
  };
}
function _o(t, e, n) {
  let o, { annotation: r } = e, { geom: i } = e, { style: s = void 0 } = e;
  const { x: a, y: l, w: c, h } = i;
  return t.$$set = (u) => {
    "annotation" in u && n(0, r = u.annotation), "geom" in u && n(6, i = u.geom), "style" in u && n(7, s = u.style);
  }, t.$$.update = () => {
    t.$$.dirty & /*annotation, style*/
    129 && n(1, o = Ft(r, s));
  }, [r, o, a, l, c, h, i, s];
}
class Xo extends Z {
  constructor(e) {
    super(), Q(this, e, _o, Io, z, { annotation: 0, geom: 6, style: 7 });
  }
}
const Po = (t) => ({
  elementToImage: (e, n) => {
    const o = t.createSVGPoint();
    o.x = e, o.y = n;
    const { x: r, y: i } = o.matrixTransform(t.getCTM().inverse());
    return [r, i];
  }
}), So = 200, Co = (t, e) => {
  const n = wt();
  let o;
  return { onPointerDown: () => o = (/* @__PURE__ */ new Date()).getTime(), onPointerUp: (r) => {
    if ((/* @__PURE__ */ new Date()).getTime() - o < So) {
      const { x: i, y: s } = Ro(r, t), a = e.getAt(i, s);
      a ? n("click", { originalEvent: r, annotation: a }) : n("click", { originalEvent: r });
    }
  } };
}, Ro = (t, e) => {
  const n = e.createSVGPoint();
  if (yo) {
    const o = e.getBoundingClientRect(), r = t.clientX - o.x, i = t.clientY - o.y, { left: s, top: a } = e.getBoundingClientRect();
    return n.x = r + s, n.y = i + a, n.matrixTransform(e.getScreenCTM().inverse());
  } else
    return n.x = t.offsetX, n.y = t.offsetY, n.matrixTransform(e.getCTM().inverse());
};
function Ee(t, e, n) {
  const o = t.slice();
  return o[23] = e[n], o;
}
function Ae(t, e, n) {
  const o = t.slice();
  return o[26] = e[n], o;
}
function kt(t) {
  const e = t.slice(), n = (
    /*annotation*/
    e[26].target.selector
  );
  return e[29] = n, e;
}
function Te(t) {
  let e = (
    /*annotation*/
    t[26].id
  ), n, o, r = Oe(t);
  return {
    c() {
      r.c(), n = rt();
    },
    m(i, s) {
      r.m(i, s), O(i, n, s), o = !0;
    },
    p(i, s) {
      s & /*$store*/
      1024 && z(e, e = /*annotation*/
      i[26].id) ? (et(), R(r, 1, 1, N), nt(), r = Oe(i), r.c(), P(r, 1), r.m(n.parentNode, n)) : r.p(i, s);
    },
    i(i) {
      o || (P(r), o = !0);
    },
    o(i) {
      R(r), o = !1;
    },
    d(i) {
      i && T(n), r.d(i);
    }
  };
}
function Go(t) {
  let e, n;
  return e = new Bo({
    props: {
      annotation: (
        /*annotation*/
        t[26]
      ),
      geom: (
        /*selector*/
        t[29].geometry
      ),
      style: (
        /*style*/
        t[0]
      )
    }
  }), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, r) {
      const i = {};
      r & /*$store*/
      1024 && (i.annotation = /*annotation*/
      o[26]), r & /*$store*/
      1024 && (i.geom = /*selector*/
      o[29].geometry), r & /*style*/
      1 && (i.style = /*style*/
      o[0]), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
function No(t) {
  let e, n;
  return e = new Xo({
    props: {
      annotation: (
        /*annotation*/
        t[26]
      ),
      geom: (
        /*selector*/
        t[29].geometry
      ),
      style: (
        /*style*/
        t[0]
      )
    }
  }), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, r) {
      const i = {};
      r & /*$store*/
      1024 && (i.annotation = /*annotation*/
      o[26]), r & /*$store*/
      1024 && (i.geom = /*selector*/
      o[29].geometry), r & /*style*/
      1 && (i.style = /*style*/
      o[0]), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
function Ho(t) {
  let e, n;
  return e = new To({
    props: {
      annotation: (
        /*annotation*/
        t[26]
      ),
      geom: (
        /*selector*/
        t[29].geometry
      ),
      style: (
        /*style*/
        t[0]
      )
    }
  }), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, r) {
      const i = {};
      r & /*$store*/
      1024 && (i.annotation = /*annotation*/
      o[26]), r & /*$store*/
      1024 && (i.geom = /*selector*/
      o[29].geometry), r & /*style*/
      1 && (i.style = /*style*/
      o[0]), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
function Oe(t) {
  let e, n, o, r;
  const i = [Ho, No, Go], s = [];
  function a(l, c) {
    return (
      /*selector*/
      l[29].type === F.ELLIPSE ? 0 : (
        /*selector*/
        l[29].type === F.RECTANGLE ? 1 : (
          /*selector*/
          l[29].type === F.POLYGON ? 2 : -1
        )
      )
    );
  }
  return ~(e = a(t)) && (n = s[e] = i[e](t)), {
    c() {
      n && n.c(), o = rt();
    },
    m(l, c) {
      ~e && s[e].m(l, c), O(l, o, c), r = !0;
    },
    p(l, c) {
      let h = e;
      e = a(l), e === h ? ~e && s[e].p(l, c) : (n && (et(), R(s[h], 1, 1, () => {
        s[h] = null;
      }), nt()), ~e ? (n = s[e], n ? n.p(l, c) : (n = s[e] = i[e](l), n.c()), P(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(l) {
      r || (P(n), r = !0);
    },
    o(l) {
      R(n), r = !1;
    },
    d(l) {
      ~e && s[e].d(l), l && T(o);
    }
  };
}
function Me(t) {
  let e = !/*isEditable*/
  t[6](
    /*annotation*/
    t[26]
  ), n, o, r = e && Te(kt(t));
  return {
    c() {
      r && r.c(), n = rt();
    },
    m(i, s) {
      r && r.m(i, s), O(i, n, s), o = !0;
    },
    p(i, s) {
      s & /*isEditable, $store*/
      1088 && (e = !/*isEditable*/
      i[6](
        /*annotation*/
        i[26]
      )), e ? r ? (r.p(kt(i), s), s & /*isEditable, $store*/
      1088 && P(r, 1)) : (r = Te(kt(i)), r.c(), P(r, 1), r.m(n.parentNode, n)) : r && (et(), R(r, 1, 1, () => {
        r = null;
      }), nt());
    },
    i(i) {
      o || (P(r), o = !0);
    },
    o(i) {
      R(r), o = !1;
    },
    d(i) {
      r && r.d(i), i && T(n);
    }
  };
}
function Le(t) {
  let e, n, o, r;
  const i = [Do, Fo], s = [];
  function a(l, c) {
    return (
      /*editableAnnotations*/
      l[5] ? 0 : (
        /*tool*/
        l[1] ? 1 : -1
      )
    );
  }
  return ~(e = a(t)) && (n = s[e] = i[e](t)), {
    c() {
      n && n.c(), o = rt();
    },
    m(l, c) {
      ~e && s[e].m(l, c), O(l, o, c), r = !0;
    },
    p(l, c) {
      let h = e;
      e = a(l), e === h ? ~e && s[e].p(l, c) : (n && (et(), R(s[h], 1, 1, () => {
        s[h] = null;
      }), nt()), ~e ? (n = s[e], n ? n.p(l, c) : (n = s[e] = i[e](l), n.c()), P(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(l) {
      r || (P(n), r = !0);
    },
    o(l) {
      R(n), r = !1;
    },
    d(l) {
      ~e && s[e].d(l), l && T(o);
    }
  };
}
function Fo(t) {
  let e = (
    /*tool*/
    t[1]
  ), n, o, r = Ye(t);
  return {
    c() {
      r.c(), n = rt();
    },
    m(i, s) {
      r.m(i, s), O(i, n, s), o = !0;
    },
    p(i, s) {
      s & /*tool*/
      2 && z(e, e = /*tool*/
      i[1]) ? (et(), R(r, 1, 1, N), nt(), r = Ye(i), r.c(), P(r, 1), r.m(n.parentNode, n)) : r.p(i, s);
    },
    i(i) {
      o || (P(r), o = !0);
    },
    o(i) {
      R(r), o = !1;
    },
    d(i) {
      i && T(n), r.d(i);
    }
  };
}
function Do(t) {
  let e, n, o = (
    /*editableAnnotations*/
    t[5]
  ), r = [];
  for (let s = 0; s < o.length; s += 1)
    r[s] = Ie(Ee(t, o, s));
  const i = (s) => R(r[s], 1, 1, () => {
    r[s] = null;
  });
  return {
    c() {
      for (let s = 0; s < r.length; s += 1)
        r[s].c();
      e = rt();
    },
    m(s, a) {
      for (let l = 0; l < r.length; l += 1)
        r[l] && r[l].m(s, a);
      O(s, e, a), n = !0;
    },
    p(s, a) {
      if (a & /*editableAnnotations, drawingEl, getEditor, style, transform, $scale, onChangeSelected*/
      35369) {
        o = /*editableAnnotations*/
        s[5];
        let l;
        for (l = 0; l < o.length; l += 1) {
          const c = Ee(s, o, l);
          r[l] ? (r[l].p(c, a), P(r[l], 1)) : (r[l] = Ie(c), r[l].c(), P(r[l], 1), r[l].m(e.parentNode, e));
        }
        for (et(), l = o.length; l < r.length; l += 1)
          i(l);
        nt();
      }
    },
    i(s) {
      if (!n) {
        for (let a = 0; a < o.length; a += 1)
          P(r[a]);
        n = !0;
      }
    },
    o(s) {
      r = r.filter(Boolean);
      for (let a = 0; a < r.length; a += 1)
        R(r[a]);
      n = !1;
    },
    d(s) {
      ee(r, s), s && T(e);
    }
  };
}
function Ye(t) {
  let e, n;
  return e = new uo({
    props: {
      target: (
        /*drawingEl*/
        t[3]
      ),
      tool: (
        /*tool*/
        t[1]
      ),
      transform: (
        /*transform*/
        t[9]
      ),
      viewportScale: (
        /*$scale*/
        t[11]
      )
    }
  }), e.$on(
    "create",
    /*onSelectionCreated*/
    t[14]
  ), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, r) {
      const i = {};
      r & /*drawingEl*/
      8 && (i.target = /*drawingEl*/
      o[3]), r & /*tool*/
      2 && (i.tool = /*tool*/
      o[1]), r & /*transform*/
      512 && (i.transform = /*transform*/
      o[9]), r & /*$scale*/
      2048 && (i.viewportScale = /*$scale*/
      o[11]), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
function Be(t) {
  let e, n;
  return e = new lo({
    props: {
      target: (
        /*drawingEl*/
        t[3]
      ),
      editor: ye(
        /*editable*/
        t[23].target.selector
      ),
      annotation: (
        /*editable*/
        t[23]
      ),
      style: (
        /*style*/
        t[0]
      ),
      transform: (
        /*transform*/
        t[9]
      ),
      viewportScale: (
        /*$scale*/
        t[11]
      )
    }
  }), e.$on("change", function() {
    U(
      /*onChangeSelected*/
      t[15](
        /*editable*/
        t[23]
      )
    ) && t[15](
      /*editable*/
      t[23]
    ).apply(this, arguments);
  }), {
    c() {
      ut(e.$$.fragment);
    },
    m(o, r) {
      at(e, o, r), n = !0;
    },
    p(o, r) {
      t = o;
      const i = {};
      r & /*drawingEl*/
      8 && (i.target = /*drawingEl*/
      t[3]), r & /*editableAnnotations*/
      32 && (i.editor = ye(
        /*editable*/
        t[23].target.selector
      )), r & /*editableAnnotations*/
      32 && (i.annotation = /*editable*/
      t[23]), r & /*style*/
      1 && (i.style = /*style*/
      t[0]), r & /*transform*/
      512 && (i.transform = /*transform*/
      t[9]), r & /*$scale*/
      2048 && (i.viewportScale = /*$scale*/
      t[11]), e.$set(i);
    },
    i(o) {
      n || (P(e.$$.fragment, o), n = !0);
    },
    o(o) {
      R(e.$$.fragment, o), n = !1;
    },
    d(o) {
      lt(e, o);
    }
  };
}
function Ie(t) {
  let e = (
    /*editable*/
    t[23].id
  ), n, o, r = Be(t);
  return {
    c() {
      r.c(), n = rt();
    },
    m(i, s) {
      r.m(i, s), O(i, n, s), o = !0;
    },
    p(i, s) {
      s & /*editableAnnotations*/
      32 && z(e, e = /*editable*/
      i[23].id) ? (et(), R(r, 1, 1, N), nt(), r = Be(i), r.c(), P(r, 1), r.m(n.parentNode, n)) : r.p(i, s);
    },
    i(i) {
      o || (P(r), o = !0);
    },
    o(i) {
      R(r), o = !1;
    },
    d(i) {
      i && T(n), r.d(i);
    }
  };
}
function Uo(t) {
  let e, n, o, r, i, s, a = (
    /*$store*/
    t[10]
  ), l = [];
  for (let u = 0; u < a.length; u += 1)
    l[u] = Me(Ae(t, a, u));
  const c = (u) => R(l[u], 1, 1, () => {
    l[u] = null;
  });
  let h = (
    /*drawingEl*/
    t[3] && Le(t)
  );
  return {
    c() {
      e = _("svg"), n = _("g");
      for (let u = 0; u < l.length; u += 1)
        l[u].c();
      o = _("g"), h && h.c(), d(o, "class", "drawing"), d(e, "class", "a9s-annotationlayer"), ae(
        e,
        "drawing",
        /*tool*/
        t[1]
      );
    },
    m(u, f) {
      O(u, e, f), st(e, n);
      for (let p = 0; p < l.length; p += 1)
        l[p] && l[p].m(n, null);
      st(e, o), h && h.m(o, null), t[19](o), t[20](e), r = !0, i || (s = [
        j(e, "pointerup", function() {
          U(
            /*onPointerUp*/
            t[7]
          ) && t[7].apply(this, arguments);
        }),
        j(e, "pointerdown", function() {
          U(
            /*onPointerDown*/
            t[8]
          ) && t[8].apply(this, arguments);
        })
      ], i = !0);
    },
    p(u, [f]) {
      if (t = u, f & /*$store, style, ShapeType, isEditable*/
      1089) {
        a = /*$store*/
        t[10];
        let p;
        for (p = 0; p < a.length; p += 1) {
          const g = Ae(t, a, p);
          l[p] ? (l[p].p(g, f), P(l[p], 1)) : (l[p] = Me(g), l[p].c(), P(l[p], 1), l[p].m(n, null));
        }
        for (et(), p = a.length; p < l.length; p += 1)
          c(p);
        nt();
      }
      t[3] ? h ? (h.p(t, f), f & /*drawingEl*/
      8 && P(h, 1)) : (h = Le(t), h.c(), P(h, 1), h.m(o, null)) : h && (et(), R(h, 1, 1, () => {
        h = null;
      }), nt()), (!r || f & /*tool*/
      2) && ae(
        e,
        "drawing",
        /*tool*/
        t[1]
      );
    },
    i(u) {
      if (!r) {
        for (let f = 0; f < a.length; f += 1)
          P(l[f]);
        P(h), r = !0;
      }
    },
    o(u) {
      l = l.filter(Boolean);
      for (let f = 0; f < l.length; f += 1)
        R(l[f]);
      R(h), r = !1;
    },
    d(u) {
      u && T(e), ee(l, u), h && h.d(), t[19](null), t[20](null), i = !1, ot(s);
    }
  };
}
function Vo(t, e, n) {
  let o, r, i, s, a, l, c, h = N, u = () => (h(), h = Pe(Y, (B) => n(11, c = B)), Y);
  t.$$.on_destroy.push(() => h());
  let { image: f } = e, { state: p } = e, { style: g = void 0 } = e, { tool: $ = je("rectangle") } = e, m, x, Y;
  Ot(() => u(n(4, Y = go(f, x))));
  const { selection: I, store: X } = p;
  se(t, I, (B) => n(18, a = B)), se(t, X, (B) => n(10, l = B));
  let D = null, y = null;
  const b = (B) => {
    X.unobserve(D);
    const C = B.filter(({ editable: G }) => G).map(({ id: G }) => G);
    C.length > 0 ? (n(5, y = C.map((G) => X.getAnnotation(G))), D = (G) => {
      const { updated: it } = G.changes;
      n(5, y = it.map((tt) => tt.newValue));
    }, X.observe(D, { annotations: C })) : n(5, y = null);
  }, w = (B) => {
    const C = He(), G = {
      id: C,
      bodies: [],
      target: {
        annotation: C,
        selector: B.detail,
        creator: null,
        created: /* @__PURE__ */ new Date()
      }
    };
    X.addAnnotation(G), I.setSelected(G.id);
  }, A = (B) => (C) => {
    const { target: G } = B, it = 10 * 60 * 1e3, tt = (
      // target.creator?.id !== user.id ||
      !G.created || (/* @__PURE__ */ new Date()).getTime() - G.created.getTime() > it
    );
    X.updateTarget({
      ...G,
      selector: C.detail,
      created: tt ? G.created : /* @__PURE__ */ new Date(),
      updated: tt ? /* @__PURE__ */ new Date() : null
    });
  };
  function M(B) {
    xt[B ? "unshift" : "push"](() => {
      m = B, n(3, m);
    });
  }
  function S(B) {
    xt[B ? "unshift" : "push"](() => {
      x = B, n(2, x);
    });
  }
  return t.$$set = (B) => {
    "image" in B && n(16, f = B.image), "state" in B && n(17, p = B.state), "style" in B && n(0, g = B.style), "tool" in B && n(1, $ = B.tool);
  }, t.$$.update = () => {
    t.$$.dirty & /*svgEl*/
    4 && n(9, o = Po(x)), t.$$.dirty & /*svgEl*/
    4 && n(8, { onPointerDown: r, onPointerUp: i } = Co(x, X), r, (n(7, i), n(2, x))), t.$$.dirty & /*$selection*/
    262144 && n(6, s = (B) => a.selected.find((C) => C.id === B.id && C.editable)), t.$$.dirty & /*$selection*/
    262144 && b(a.selected);
  }, [
    g,
    $,
    x,
    m,
    Y,
    y,
    s,
    i,
    r,
    o,
    l,
    c,
    I,
    X,
    w,
    A,
    f,
    p,
    a,
    M,
    S
  ];
}
class jo extends Z {
  constructor(e) {
    super(), Q(this, e, Vo, Uo, z, { image: 16, state: 17, style: 0, tool: 1 });
  }
}
function zo(t, e, n, o, r) {
  ze(t, e, n || 0, o || t.length - 1, r || Wo);
}
function ze(t, e, n, o, r) {
  for (; o > n; ) {
    if (o - n > 600) {
      var i = o - n + 1, s = e - n + 1, a = Math.log(i), l = 0.5 * Math.exp(2 * a / 3), c = 0.5 * Math.sqrt(a * l * (i - l) / i) * (s - i / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(e - s * l / i + c)), u = Math.min(o, Math.floor(e + (i - s) * l / i + c));
      ze(t, e, h, u, r);
    }
    var f = t[e], p = n, g = o;
    for (bt(t, n, e), r(t[o], f) > 0 && bt(t, n, o); p < g; ) {
      for (bt(t, p, g), p++, g--; r(t[p], f) < 0; )
        p++;
      for (; r(t[g], f) > 0; )
        g--;
    }
    r(t[n], f) === 0 ? bt(t, n, g) : (g++, bt(t, g, o)), g <= e && (n = g + 1), e <= g && (o = g - 1);
  }
}
function bt(t, e, n) {
  var o = t[e];
  t[e] = t[n], t[n] = o;
}
function Wo(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
class qo {
  constructor(e = 9) {
    this._maxEntries = Math.max(4, e), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let n = this.data;
    const o = [];
    if (!Rt(e, n))
      return o;
    const r = this.toBBox, i = [];
    for (; n; ) {
      for (let s = 0; s < n.children.length; s++) {
        const a = n.children[s], l = n.leaf ? r(a) : a;
        Rt(e, l) && (n.leaf ? o.push(a) : Qt(e, l) ? this._all(a, o) : i.push(a));
      }
      n = i.pop();
    }
    return o;
  }
  collides(e) {
    let n = this.data;
    if (!Rt(e, n))
      return !1;
    const o = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const i = n.children[r], s = n.leaf ? this.toBBox(i) : i;
        if (Rt(e, s)) {
          if (n.leaf || Qt(e, s))
            return !0;
          o.push(i);
        }
      }
      n = o.pop();
    }
    return !1;
  }
  load(e) {
    if (!(e && e.length))
      return this;
    if (e.length < this._minEntries) {
      for (let o = 0; o < e.length; o++)
        this.insert(e[o]);
      return this;
    }
    let n = this._build(e.slice(), 0, e.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const o = this.data;
        this.data = n, n = o;
      }
      this._insert(n, this.data.height - n.height - 1, !0);
    }
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return this.data = gt([]), this;
  }
  remove(e, n) {
    if (!e)
      return this;
    let o = this.data;
    const r = this.toBBox(e), i = [], s = [];
    let a, l, c;
    for (; o || i.length; ) {
      if (o || (o = i.pop(), l = i[i.length - 1], a = s.pop(), c = !0), o.leaf) {
        const h = Jo(e, o.children, n);
        if (h !== -1)
          return o.children.splice(h, 1), i.push(o), this._condense(i), this;
      }
      !c && !o.leaf && Qt(o, r) ? (i.push(o), s.push(a), a = 0, l = o, o = o.children[0]) : l ? (a++, o = l.children[a], c = !1) : o = null;
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, n) {
    return e.minX - n.minX;
  }
  compareMinY(e, n) {
    return e.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return this.data = e, this;
  }
  _all(e, n) {
    const o = [];
    for (; e; )
      e.leaf ? n.push(...e.children) : o.push(...e.children), e = o.pop();
    return n;
  }
  _build(e, n, o, r) {
    const i = o - n + 1;
    let s = this._maxEntries, a;
    if (i <= s)
      return a = gt(e.slice(n, o + 1)), ft(a, this.toBBox), a;
    r || (r = Math.ceil(Math.log(i) / Math.log(s)), s = Math.ceil(i / Math.pow(s, r - 1))), a = gt([]), a.leaf = !1, a.height = r;
    const l = Math.ceil(i / s), c = l * Math.ceil(Math.sqrt(s));
    _e(e, n, o, c, this.compareMinX);
    for (let h = n; h <= o; h += c) {
      const u = Math.min(h + c - 1, o);
      _e(e, h, u, l, this.compareMinY);
      for (let f = h; f <= u; f += l) {
        const p = Math.min(f + l - 1, u);
        a.children.push(this._build(e, f, p, r - 1));
      }
    }
    return ft(a, this.toBBox), a;
  }
  _chooseSubtree(e, n, o, r) {
    for (; r.push(n), !(n.leaf || r.length - 1 === o); ) {
      let i = 1 / 0, s = 1 / 0, a;
      for (let l = 0; l < n.children.length; l++) {
        const c = n.children[l], h = Kt(c), u = Qo(e, c) - h;
        u < s ? (s = u, i = h < i ? h : i, a = c) : u === s && h < i && (i = h, a = c);
      }
      n = a || n.children[0];
    }
    return n;
  }
  _insert(e, n, o) {
    const r = o ? e : this.toBBox(e), i = [], s = this._chooseSubtree(r, this.data, n, i);
    for (s.children.push(e), Et(s, r); n >= 0 && i[n].children.length > this._maxEntries; )
      this._split(i, n), n--;
    this._adjustParentBBoxes(r, i, n);
  }
  // split overflowed node into two
  _split(e, n) {
    const o = e[n], r = o.children.length, i = this._minEntries;
    this._chooseSplitAxis(o, i, r);
    const s = this._chooseSplitIndex(o, i, r), a = gt(o.children.splice(s, o.children.length - s));
    a.height = o.height, a.leaf = o.leaf, ft(o, this.toBBox), ft(a, this.toBBox), n ? e[n - 1].children.push(a) : this._splitRoot(o, a);
  }
  _splitRoot(e, n) {
    this.data = gt([e, n]), this.data.height = e.height + 1, this.data.leaf = !1, ft(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, n, o) {
    let r, i = 1 / 0, s = 1 / 0;
    for (let a = n; a <= o - n; a++) {
      const l = vt(e, 0, a, this.toBBox), c = vt(e, a, o, this.toBBox), h = Zo(l, c), u = Kt(l) + Kt(c);
      h < i ? (i = h, r = a, s = u < s ? u : s) : h === i && u < s && (s = u, r = a);
    }
    return r || o - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(e, n, o) {
    const r = e.leaf ? this.compareMinX : ko, i = e.leaf ? this.compareMinY : Ko, s = this._allDistMargin(e, n, o, r), a = this._allDistMargin(e, n, o, i);
    s < a && e.children.sort(r);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(e, n, o, r) {
    e.children.sort(r);
    const i = this.toBBox, s = vt(e, 0, n, i), a = vt(e, o - n, o, i);
    let l = Ct(s) + Ct(a);
    for (let c = n; c < o - n; c++) {
      const h = e.children[c];
      Et(s, e.leaf ? i(h) : h), l += Ct(s);
    }
    for (let c = o - n - 1; c >= n; c--) {
      const h = e.children[c];
      Et(a, e.leaf ? i(h) : h), l += Ct(a);
    }
    return l;
  }
  _adjustParentBBoxes(e, n, o) {
    for (let r = o; r >= 0; r--)
      Et(n[r], e);
  }
  _condense(e) {
    for (let n = e.length - 1, o; n >= 0; n--)
      e[n].children.length === 0 ? n > 0 ? (o = e[n - 1].children, o.splice(o.indexOf(e[n]), 1)) : this.clear() : ft(e[n], this.toBBox);
  }
}
function Jo(t, e, n) {
  if (!n)
    return e.indexOf(t);
  for (let o = 0; o < e.length; o++)
    if (n(t, e[o]))
      return o;
  return -1;
}
function ft(t, e) {
  vt(t, 0, t.children.length, e, t);
}
function vt(t, e, n, o, r) {
  r || (r = gt(null)), r.minX = 1 / 0, r.minY = 1 / 0, r.maxX = -1 / 0, r.maxY = -1 / 0;
  for (let i = e; i < n; i++) {
    const s = t.children[i];
    Et(r, t.leaf ? o(s) : s);
  }
  return r;
}
function Et(t, e) {
  return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t;
}
function ko(t, e) {
  return t.minX - e.minX;
}
function Ko(t, e) {
  return t.minY - e.minY;
}
function Kt(t) {
  return (t.maxX - t.minX) * (t.maxY - t.minY);
}
function Ct(t) {
  return t.maxX - t.minX + (t.maxY - t.minY);
}
function Qo(t, e) {
  return (Math.max(e.maxX, t.maxX) - Math.min(e.minX, t.minX)) * (Math.max(e.maxY, t.maxY) - Math.min(e.minY, t.minY));
}
function Zo(t, e) {
  const n = Math.max(t.minX, e.minX), o = Math.max(t.minY, e.minY), r = Math.min(t.maxX, e.maxX), i = Math.min(t.maxY, e.maxY);
  return Math.max(0, r - n) * Math.max(0, i - o);
}
function Qt(t, e) {
  return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY;
}
function Rt(t, e) {
  return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY;
}
function gt(t) {
  return {
    children: t,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function _e(t, e, n, o, r) {
  const i = [e, n];
  for (; i.length; ) {
    if (n = i.pop(), e = i.pop(), n - e <= o)
      continue;
    const s = e + Math.ceil((n - e) / o / 2) * o;
    zo(t, s, e, n, r), i.push(e, s, s, n);
  }
}
const tr = () => {
  const t = new qo(), e = /* @__PURE__ */ new Map(), n = () => [...e.values()], o = () => {
    t.clear(), e.clear();
  }, r = (s) => {
    const { minX: a, minY: l, maxX: c, maxY: h } = s.selector.geometry.bounds, u = { minX: a, minY: l, maxX: c, maxY: h, target: s };
    t.insert(u), e.set(s.annotation, u);
  }, i = (s) => {
    const a = e.get(s.annotation);
    t.remove(a), e.delete(s.annotation);
  };
  return {
    all: n,
    clear: o,
    getAt: (s, a) => {
      const l = t.search({
        minX: s,
        minY: a,
        maxX: s,
        maxY: a
      }).map((c) => c.target).filter((c) => c.selector.type === F.RECTANGLE || an(c.selector, s, a));
      if (l.length > 0)
        return l.sort((c, h) => ce(c.selector) - ce(h.selector)), l[0];
    },
    getIntersecting: (s, a, l, c) => t.search({
      minX: s,
      minY: a,
      maxX: s + l,
      maxY: a + c
    }).map((h) => h.target),
    insert: r,
    remove: i,
    set: (s, a = !0) => {
      a && o();
      const l = s.map((c) => {
        const { minX: h, minY: u, maxX: f, maxY: p } = c.selector.geometry.bounds;
        return { minX: h, minY: u, maxX: f, maxY: p, target: c };
      });
      l.forEach((c) => e.set(c.target.annotation, c)), t.load(l);
    },
    size: () => t.all().length,
    update: (s, a) => {
      i(s), r(a);
    }
  };
}, er = (t) => {
  const e = Xn(), n = tr(), o = An(e, t.pointerSelectAction), r = En(e), i = Sn();
  return e.observe(({ changes: s }) => {
    n.set(s.created.map((a) => a.target), !1), s.deleted.forEach((a) => n.remove(a.target)), s.updated.forEach(({ oldValue: a, newValue: l }) => n.update(a.target, l.target));
  }), {
    store: {
      ...e,
      getAt: (s, a) => {
        const l = n.getAt(s, a);
        return l ? e.getAnnotation(l.annotation) : void 0;
      },
      getIntersecting: (s, a, l, c) => n.getIntersecting(s, a, l, c).map((h) => e.getAnnotation(h.annotation))
    },
    selection: o,
    hover: r,
    viewport: i
  };
}, nr = (t) => {
  const e = er(t);
  return {
    ...e,
    store: Pn(e.store)
  };
}, or = (t) => {
  let e, n;
  if (t.nodeName === "CANVAS")
    e = t, n = e.getContext("2d", { willReadFrequently: !0 });
  else {
    const r = t;
    e = document.createElement("canvas"), e.width = r.width, e.height = r.height, n = e.getContext("2d", { willReadFrequently: !0 }), n.drawImage(r, 0, 0, r.width, r.height);
  }
  let o = 0;
  for (let r = 1; r < 10; r++)
    for (let i = 1; i < 10; i++) {
      const s = Math.round(i * e.width / 10), a = Math.round(r * e.height / 10), l = n.getImageData(s, a, 1, 1).data, c = (0.299 * l[0] + 0.587 * l[1] + 0.114 * l[2]) / 255;
      o += c;
    }
  return o / 81;
}, rr = (t, e) => {
  const n = or(t), o = n > 0.6 ? "dark" : "light";
  console.log(`[Annotorious] Image brightness: ${n.toFixed(1)}. Setting ${o} theme.`), e.setAttribute("data-theme", o);
}, ir = (t) => ({
  ...t,
  pointerSelectAction: t.pointerSelectAction || Fe.EDIT
}), ar = (t, e = {}) => {
  if (!t)
    throw "Missing argument: image";
  const n = typeof t == "string" ? document.getElementById(t) : t, o = ir(e), r = nr(o), { hover: i, selection: s, store: a } = r, l = Cn(
    a,
    s,
    i,
    void 0,
    o.adapter,
    o.autoSave
  );
  let c = o.style, h = o.readOnly ? null : Un();
  const u = document.createElement("DIV");
  u.style.position = "relative", u.style.display = "inline-block", n.style.display = "block", n.parentNode.insertBefore(u, n), u.appendChild(n), rr(n, u);
  const f = new jo({
    target: u,
    props: { image: n, state: r, style: c }
  });
  f.$on("click", (y) => {
    const { originalEvent: b, annotation: w } = y.detail;
    w ? s.clickSelect(w.id, b) : s.isEmpty() || s.clear();
  });
  const p = Gn(a, o.adapter), g = (y) => {
    c = y, f.$set({ style: y });
  }, $ = () => {
    f.$destroy(), u.parentNode.insertBefore(n, u), u.parentNode.removeChild(u);
  }, m = (y, b) => vo(y, b), x = (y, b) => oo(y, b), Y = () => h, I = (y) => {
    const b = je(y);
    f.$set({ tool: b });
  }, X = (y) => {
    y ? s.setSelected(y) : s.clear();
  }, D = (y) => {
    h = y;
  };
  return {
    ...p,
    get style() {
      return c;
    },
    set style(y) {
      g(y);
    },
    destroy: $,
    getUser: Y,
    on: l.on,
    off: l.off,
    registerDrawingTool: m,
    registerShapeEditor: x,
    setDrawingTool: I,
    setSelected: X,
    setUser: D,
    state: r
  };
};
export {
  Ue as Editor,
  lo as EditorMount,
  E as Handle,
  Qn as PolygonEditor,
  no as RectangleEditor,
  dn as RectangleUtil,
  fo as RubberbandRectangle,
  jo as SVGAnnotationLayer,
  F as ShapeType,
  uo as ToolMount,
  sr as W3CImageFormat,
  Co as addEventListeners,
  Nt as boundsFromPoints,
  ce as computeArea,
  Un as createAnonymousGuest,
  Gn as createBaseAnnotator,
  ar as createImageAnnotator,
  er as createImageAnnotatorState,
  Po as createSVGTransform,
  nr as createSvelteImageAnnotatorState,
  Bn as diffAnnotations,
  we as distance,
  go as enableResponsive,
  ir as fillDefaults,
  ye as getEditor,
  je as getTool,
  an as intersects,
  yo as isTouch,
  Rn as parseAll,
  un as parseFragmentSelector,
  yn as parseSVGSelector,
  jn as parseW3CBodies,
  Wn as parseW3CImageAnnotation,
  oo as registerEditor,
  oe as registerShapeUtil,
  vo as registerTool,
  or as sampleBrightness,
  hn as serializeFragmentSelector,
  $n as serializeSVGSelector,
  zn as serializeW3CBodies,
  qn as serializeW3CImageAnnotation,
  rr as setTheme
};
//# sourceMappingURL=annotorious-react.es12.js.map
