import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// ../../node_modules/openseadragon/build/openseadragon/openseadragon.js
var require_openseadragon = __commonJS({
  "../../node_modules/openseadragon/build/openseadragon/openseadragon.js"(exports, module) {
    function OpenSeadragon(options) {
      return new OpenSeadragon.Viewer(options);
    }
    (function($) {
      $.version = {
        versionStr: "4.1.0",
        major: parseInt("4", 10),
        minor: parseInt("1", 10),
        revision: parseInt("0", 10)
      };
      var class2type = {
        "[object Boolean]": "boolean",
        "[object Number]": "number",
        "[object String]": "string",
        "[object Function]": "function",
        "[object AsyncFunction]": "function",
        "[object Promise]": "promise",
        "[object Array]": "array",
        "[object Date]": "date",
        "[object RegExp]": "regexp",
        "[object Object]": "object"
      }, toString = Object.prototype.toString, hasOwn = Object.prototype.hasOwnProperty;
      $.isFunction = function(obj) {
        return $.type(obj) === "function";
      };
      $.isArray = Array.isArray || function(obj) {
        return $.type(obj) === "array";
      };
      $.isWindow = function(obj) {
        return obj && typeof obj === "object" && "setInterval" in obj;
      };
      $.type = function(obj) {
        return obj === null || obj === void 0 ? String(obj) : class2type[toString.call(obj)] || "object";
      };
      $.isPlainObject = function(obj) {
        if (!obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $.isWindow(obj)) {
          return false;
        }
        if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
          return false;
        }
        var lastKey;
        for (var key in obj) {
          lastKey = key;
        }
        return lastKey === void 0 || hasOwn.call(obj, lastKey);
      };
      $.isEmptyObject = function(obj) {
        for (var name in obj) {
          return false;
        }
        return true;
      };
      $.freezeObject = function(obj) {
        if (Object.freeze) {
          $.freezeObject = Object.freeze;
        } else {
          $.freezeObject = function(obj2) {
            return obj2;
          };
        }
        return $.freezeObject(obj);
      };
      $.supportsCanvas = function() {
        var canvasElement = document.createElement("canvas");
        return !!($.isFunction(canvasElement.getContext) && canvasElement.getContext("2d"));
      }();
      $.isCanvasTainted = function(canvas) {
        var isTainted = false;
        try {
          canvas.getContext("2d").getImageData(0, 0, 1, 1);
        } catch (e) {
          isTainted = true;
        }
        return isTainted;
      };
      $.supportsAddEventListener = function() {
        return !!(document.documentElement.addEventListener && document.addEventListener);
      }();
      $.supportsRemoveEventListener = function() {
        return !!(document.documentElement.removeEventListener && document.removeEventListener);
      }();
      $.supportsEventListenerOptions = function() {
        var supported = 0;
        if ($.supportsAddEventListener) {
          try {
            var options = {
              get capture() {
                supported++;
                return false;
              },
              get once() {
                supported++;
                return false;
              },
              get passive() {
                supported++;
                return false;
              }
            };
            window.addEventListener("test", null, options);
            window.removeEventListener("test", null, options);
          } catch (e) {
            supported = 0;
          }
        }
        return supported >= 3;
      }();
      $.getCurrentPixelDensityRatio = function() {
        if ($.supportsCanvas) {
          var context = document.createElement("canvas").getContext("2d");
          var devicePixelRatio = window.devicePixelRatio || 1;
          var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
          return Math.max(devicePixelRatio, 1) / backingStoreRatio;
        } else {
          return 1;
        }
      };
      $.pixelDensityRatio = $.getCurrentPixelDensityRatio();
    })(OpenSeadragon);
    (function($) {
      $.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, length = arguments.length, deep = false, i = 1;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[1] || {};
          i = 2;
        }
        if (typeof target !== "object" && !OpenSeadragon.isFunction(target)) {
          target = {};
        }
        if (length === i) {
          target = this;
          --i;
        }
        for (; i < length; i++) {
          options = arguments[i];
          if (options !== null || options !== void 0) {
            for (name in options) {
              var descriptor = Object.getOwnPropertyDescriptor(options, name);
              if (descriptor !== void 0) {
                if (descriptor.get || descriptor.set) {
                  Object.defineProperty(target, name, descriptor);
                  continue;
                }
                copy = descriptor.value;
              } else {
                $.console.warn('Could not copy inherited property "' + name + '".');
                continue;
              }
              if (target === copy) {
                continue;
              }
              if (deep && copy && (OpenSeadragon.isPlainObject(copy) || (copyIsArray = OpenSeadragon.isArray(copy)))) {
                src = target[name];
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && OpenSeadragon.isArray(src) ? src : [];
                } else {
                  clone = src && OpenSeadragon.isPlainObject(src) ? src : {};
                }
                target[name] = OpenSeadragon.extend(deep, clone, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      var isIOSDevice = function() {
        if (typeof navigator !== "object") {
          return false;
        }
        var userAgent = navigator.userAgent;
        if (typeof userAgent !== "string") {
          return false;
        }
        return userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1 || userAgent.indexOf("iPod") !== -1;
      };
      $.extend(
        $,
        /** @lends OpenSeadragon */
        {
          /**
           * The default values for the optional settings documented at {@link OpenSeadragon.Options}.
           * @static
           * @type {Object}
           */
          DEFAULT_SETTINGS: {
            //DATA SOURCE DETAILS
            xmlPath: null,
            tileSources: null,
            tileHost: null,
            initialPage: 0,
            crossOriginPolicy: false,
            ajaxWithCredentials: false,
            loadTilesWithAjax: false,
            ajaxHeaders: {},
            splitHashDataForPost: false,
            //PAN AND ZOOM SETTINGS AND CONSTRAINTS
            panHorizontal: true,
            panVertical: true,
            constrainDuringPan: false,
            wrapHorizontal: false,
            wrapVertical: false,
            visibilityRatio: 0.5,
            //-> how much of the viewer can be negative space
            minPixelRatio: 0.5,
            //->closer to 0 draws tiles meant for a higher zoom at this zoom
            defaultZoomLevel: 0,
            minZoomLevel: null,
            maxZoomLevel: null,
            homeFillsViewer: false,
            //UI RESPONSIVENESS AND FEEL
            clickTimeThreshold: 300,
            clickDistThreshold: 5,
            dblClickTimeThreshold: 300,
            dblClickDistThreshold: 20,
            springStiffness: 6.5,
            animationTime: 1.2,
            gestureSettingsMouse: {
              dragToPan: true,
              scrollToZoom: true,
              clickToZoom: true,
              dblClickToZoom: false,
              dblClickDragToZoom: false,
              pinchToZoom: false,
              zoomToRefPoint: true,
              flickEnabled: false,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsTouch: {
              dragToPan: true,
              scrollToZoom: false,
              clickToZoom: false,
              dblClickToZoom: true,
              dblClickDragToZoom: true,
              pinchToZoom: true,
              zoomToRefPoint: true,
              flickEnabled: true,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsPen: {
              dragToPan: true,
              scrollToZoom: false,
              clickToZoom: true,
              dblClickToZoom: false,
              dblClickDragToZoom: false,
              pinchToZoom: false,
              zoomToRefPoint: true,
              flickEnabled: false,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsUnknown: {
              dragToPan: true,
              scrollToZoom: false,
              clickToZoom: false,
              dblClickToZoom: true,
              dblClickDragToZoom: false,
              pinchToZoom: true,
              zoomToRefPoint: true,
              flickEnabled: true,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            zoomPerClick: 2,
            zoomPerScroll: 1.2,
            zoomPerDblClickDrag: 1.2,
            zoomPerSecond: 1,
            blendTime: 0,
            alwaysBlend: false,
            autoHideControls: true,
            immediateRender: false,
            minZoomImageRatio: 0.9,
            //-> closer to 0 allows zoom out to infinity
            maxZoomPixelRatio: 1.1,
            //-> higher allows 'over zoom' into pixels
            smoothTileEdgesMinZoom: 1.1,
            //-> higher than maxZoomPixelRatio disables it
            iOSDevice: isIOSDevice(),
            pixelsPerWheelLine: 40,
            pixelsPerArrowPress: 40,
            autoResize: true,
            preserveImageSizeOnResize: false,
            // requires autoResize=true
            minScrollDeltaTime: 50,
            rotationIncrement: 90,
            //DEFAULT CONTROL SETTINGS
            showSequenceControl: true,
            //SEQUENCE
            sequenceControlAnchor: null,
            //SEQUENCE
            preserveViewport: false,
            //SEQUENCE
            preserveOverlays: false,
            //SEQUENCE
            navPrevNextWrap: false,
            //SEQUENCE
            showNavigationControl: true,
            //ZOOM/HOME/FULL/ROTATION
            navigationControlAnchor: null,
            //ZOOM/HOME/FULL/ROTATION
            showZoomControl: true,
            //ZOOM
            showHomeControl: true,
            //HOME
            showFullPageControl: true,
            //FULL
            showRotationControl: false,
            //ROTATION
            showFlipControl: false,
            //FLIP
            controlsFadeDelay: 2e3,
            //ZOOM/HOME/FULL/SEQUENCE
            controlsFadeLength: 1500,
            //ZOOM/HOME/FULL/SEQUENCE
            mouseNavEnabled: true,
            //GENERAL MOUSE INTERACTIVITY
            //VIEWPORT NAVIGATOR SETTINGS
            showNavigator: false,
            navigatorElement: null,
            navigatorId: null,
            navigatorPosition: null,
            navigatorSizeRatio: 0.2,
            navigatorMaintainSizeRatio: false,
            navigatorTop: null,
            navigatorLeft: null,
            navigatorHeight: null,
            navigatorWidth: null,
            navigatorAutoResize: true,
            navigatorAutoFade: true,
            navigatorRotate: true,
            navigatorBackground: "#000",
            navigatorOpacity: 0.8,
            navigatorBorderColor: "#555",
            navigatorDisplayRegionColor: "#900",
            // INITIAL ROTATION
            degrees: 0,
            // INITIAL FLIP STATE
            flipped: false,
            // APPEARANCE
            opacity: 1,
            preload: false,
            compositeOperation: null,
            imageSmoothingEnabled: true,
            placeholderFillStyle: null,
            subPixelRoundingForTransparency: null,
            //REFERENCE STRIP SETTINGS
            showReferenceStrip: false,
            referenceStripScroll: "horizontal",
            referenceStripElement: null,
            referenceStripHeight: null,
            referenceStripWidth: null,
            referenceStripPosition: "BOTTOM_LEFT",
            referenceStripSizeRatio: 0.2,
            //COLLECTION VISUALIZATION SETTINGS
            collectionRows: 3,
            //or columns depending on layout
            collectionColumns: 0,
            //columns in horizontal layout, rows in vertical layout
            collectionLayout: "horizontal",
            //vertical
            collectionMode: false,
            collectionTileSize: 800,
            collectionTileMargin: 80,
            //PERFORMANCE SETTINGS
            imageLoaderLimit: 0,
            maxImageCacheCount: 200,
            timeout: 3e4,
            useCanvas: true,
            // Use canvas element for drawing if available
            tileRetryMax: 0,
            tileRetryDelay: 2500,
            //INTERFACE RESOURCE SETTINGS
            prefixUrl: "/images/",
            navImages: {
              zoomIn: {
                REST: "zoomin_rest.png",
                GROUP: "zoomin_grouphover.png",
                HOVER: "zoomin_hover.png",
                DOWN: "zoomin_pressed.png"
              },
              zoomOut: {
                REST: "zoomout_rest.png",
                GROUP: "zoomout_grouphover.png",
                HOVER: "zoomout_hover.png",
                DOWN: "zoomout_pressed.png"
              },
              home: {
                REST: "home_rest.png",
                GROUP: "home_grouphover.png",
                HOVER: "home_hover.png",
                DOWN: "home_pressed.png"
              },
              fullpage: {
                REST: "fullpage_rest.png",
                GROUP: "fullpage_grouphover.png",
                HOVER: "fullpage_hover.png",
                DOWN: "fullpage_pressed.png"
              },
              rotateleft: {
                REST: "rotateleft_rest.png",
                GROUP: "rotateleft_grouphover.png",
                HOVER: "rotateleft_hover.png",
                DOWN: "rotateleft_pressed.png"
              },
              rotateright: {
                REST: "rotateright_rest.png",
                GROUP: "rotateright_grouphover.png",
                HOVER: "rotateright_hover.png",
                DOWN: "rotateright_pressed.png"
              },
              flip: {
                // Flip icon designed by Yaroslav Samoylov from the Noun Project and modified by Nelson Campos ncampos@criteriamarathon.com, https://thenounproject.com/term/flip/136289/
                REST: "flip_rest.png",
                GROUP: "flip_grouphover.png",
                HOVER: "flip_hover.png",
                DOWN: "flip_pressed.png"
              },
              previous: {
                REST: "previous_rest.png",
                GROUP: "previous_grouphover.png",
                HOVER: "previous_hover.png",
                DOWN: "previous_pressed.png"
              },
              next: {
                REST: "next_rest.png",
                GROUP: "next_grouphover.png",
                HOVER: "next_hover.png",
                DOWN: "next_pressed.png"
              }
            },
            //DEVELOPER SETTINGS
            debugMode: false,
            debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"],
            silenceMultiImageWarnings: false
          },
          /**
           * TODO: get rid of this.  I can't see how it's required at all.  Looks
           *       like an early legacy code artifact.
           * @static
           * @ignore
           */
          SIGNAL: "----seadragon----",
          /**
           * Returns a function which invokes the method as if it were a method belonging to the object.
           * @function
           * @param {Object} object
           * @param {Function} method
           * @returns {Function}
           */
          delegate: function(object, method) {
            return function() {
              var args = arguments;
              if (args === void 0) {
                args = [];
              }
              return method.apply(object, args);
            };
          },
          /**
           * An enumeration of Browser vendors.
           * @static
           * @type {Object}
           * @property {Number} UNKNOWN
           * @property {Number} IE
           * @property {Number} FIREFOX
           * @property {Number} SAFARI
           * @property {Number} CHROME
           * @property {Number} OPERA
           * @property {Number} EDGE
           * @property {Number} CHROMEEDGE
           */
          BROWSERS: {
            UNKNOWN: 0,
            IE: 1,
            FIREFOX: 2,
            SAFARI: 3,
            CHROME: 4,
            OPERA: 5,
            EDGE: 6,
            CHROMEEDGE: 7
          },
          /**
           * An enumeration of when subpixel rounding should occur.
           * @static
           * @type {Object}
           * @property {Number} NEVER Never apply subpixel rounding for transparency.
           * @property {Number} ONLY_AT_REST Do not apply subpixel rounding for transparency during animation (panning, zoom, rotation) and apply it once animation is over.
           * @property {Number} ALWAYS Apply subpixel rounding for transparency during animation and when animation is over.
           */
          SUBPIXEL_ROUNDING_OCCURRENCES: {
            NEVER: 0,
            ONLY_AT_REST: 1,
            ALWAYS: 2
          },
          /**
           * Keep track of which {@link Viewer}s have been created.
           * - Key: {@link Element} to which a Viewer is attached.
           * - Value: {@link Viewer} of the element defined by the key.
           * @private
           * @static
           * @type {Object}
           */
          _viewers: /* @__PURE__ */ new Map(),
          /**
            * Returns the {@link Viewer} attached to a given DOM element. If there is
            * no viewer attached to the provided element, undefined is returned.
            * @function
            * @param {String|Element} element Accepts an id or element.
            * @returns {Viewer} The viewer attached to the given element, or undefined.
            */
          getViewer: function(element) {
            return $._viewers.get(this.getElement(element));
          },
          /**
           * Returns a DOM Element for the given id or element.
           * @function
           * @param {String|Element} element Accepts an id or element.
           * @returns {Element} The element with the given id, null, or the element itself.
           */
          getElement: function(element) {
            if (typeof element === "string") {
              element = document.getElementById(element);
            }
            return element;
          },
          /**
           * Determines the position of the upper-left corner of the element.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element.
           */
          getElementPosition: function(element) {
            var result = new $.Point(), isFixed, offsetParent;
            element = $.getElement(element);
            isFixed = $.getElementStyle(element).position === "fixed";
            offsetParent = getOffsetParent(element, isFixed);
            while (offsetParent) {
              result.x += element.offsetLeft;
              result.y += element.offsetTop;
              if (isFixed) {
                result = result.plus($.getPageScroll());
              }
              element = offsetParent;
              isFixed = $.getElementStyle(element).position === "fixed";
              offsetParent = getOffsetParent(element, isFixed);
            }
            return result;
          },
          /**
           * Determines the position of the upper-left corner of the element adjusted for current page and/or element scroll.
           * @function
           * @param {Element|String} element - the element we want the position for.
           * @returns {OpenSeadragon.Point} - the position of the upper left corner of the element adjusted for current page and/or element scroll.
           */
          getElementOffset: function(element) {
            element = $.getElement(element);
            var doc = element && element.ownerDocument, docElement, win, boundingRect = { top: 0, left: 0 };
            if (!doc) {
              return new $.Point();
            }
            docElement = doc.documentElement;
            if (typeof element.getBoundingClientRect !== "undefined") {
              boundingRect = element.getBoundingClientRect();
            }
            win = doc === doc.window ? doc : doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;
            return new $.Point(
              boundingRect.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0),
              boundingRect.top + (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0)
            );
          },
          /**
           * Determines the height and width of the given element.
           * @function
           * @param {Element|String} element
           * @returns {OpenSeadragon.Point}
           */
          getElementSize: function(element) {
            element = $.getElement(element);
            return new $.Point(
              element.clientWidth,
              element.clientHeight
            );
          },
          /**
           * Returns the CSSStyle object for the given element.
           * @function
           * @param {Element|String} element
           * @returns {CSSStyle}
           */
          getElementStyle: document.documentElement.currentStyle ? function(element) {
            element = $.getElement(element);
            return element.currentStyle;
          } : function(element) {
            element = $.getElement(element);
            return window.getComputedStyle(element, "");
          },
          /**
           * Returns the property with the correct vendor prefix appended.
           * @param {String} property the property name
           * @returns {String} the property with the correct prefix or null if not
           * supported.
           */
          getCssPropertyWithVendorPrefix: function(property) {
            var memo = {};
            $.getCssPropertyWithVendorPrefix = function(property2) {
              if (memo[property2] !== void 0) {
                return memo[property2];
              }
              var style = document.createElement("div").style;
              var result = null;
              if (style[property2] !== void 0) {
                result = property2;
              } else {
                var prefixes = [
                  "Webkit",
                  "Moz",
                  "MS",
                  "O",
                  "webkit",
                  "moz",
                  "ms",
                  "o"
                ];
                var suffix = $.capitalizeFirstLetter(property2);
                for (var i = 0; i < prefixes.length; i++) {
                  var prop = prefixes[i] + suffix;
                  if (style[prop] !== void 0) {
                    result = prop;
                    break;
                  }
                }
              }
              memo[property2] = result;
              return result;
            };
            return $.getCssPropertyWithVendorPrefix(property);
          },
          /**
           * Capitalizes the first letter of a string
           * @param {String} string
           * @returns {String} The string with the first letter capitalized
           */
          capitalizeFirstLetter: function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
          },
          /**
           * Compute the modulo of a number but makes sure to always return
           * a positive value (also known as Euclidean modulo).
           * @param {Number} number the number to compute the modulo of
           * @param {Number} modulo the modulo
           * @returns {Number} the result of the modulo of number
           */
          positiveModulo: function(number, modulo) {
            var result = number % modulo;
            if (result < 0) {
              result += modulo;
            }
            return result;
          },
          /**
           * Determines if a point is within the bounding rectangle of the given element (hit-test).
           * @function
           * @param {Element|String} element
           * @param {OpenSeadragon.Point} point
           * @returns {Boolean}
           */
          pointInElement: function(element, point) {
            element = $.getElement(element);
            var offset = $.getElementOffset(element), size = $.getElementSize(element);
            return point.x >= offset.x && point.x < offset.x + size.x && point.y < offset.y + size.y && point.y >= offset.y;
          },
          /**
           * Gets the position of the mouse on the screen for a given event.
           * @function
           * @param {Event} [event]
           * @returns {OpenSeadragon.Point}
           */
          getMousePosition: function(event) {
            if (typeof event.pageX === "number") {
              $.getMousePosition = function(event2) {
                var result = new $.Point();
                result.x = event2.pageX;
                result.y = event2.pageY;
                return result;
              };
            } else if (typeof event.clientX === "number") {
              $.getMousePosition = function(event2) {
                var result = new $.Point();
                result.x = event2.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                result.y = event2.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                return result;
              };
            } else {
              throw new Error(
                "Unknown event mouse position, no known technique."
              );
            }
            return $.getMousePosition(event);
          },
          /**
           * Determines the page's current scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getPageScroll: function() {
            var docElement = document.documentElement || {}, body = document.body || {};
            if (typeof window.pageXOffset === "number") {
              $.getPageScroll = function() {
                return new $.Point(
                  window.pageXOffset,
                  window.pageYOffset
                );
              };
            } else if (body.scrollLeft || body.scrollTop) {
              $.getPageScroll = function() {
                return new $.Point(
                  document.body.scrollLeft,
                  document.body.scrollTop
                );
              };
            } else if (docElement.scrollLeft || docElement.scrollTop) {
              $.getPageScroll = function() {
                return new $.Point(
                  document.documentElement.scrollLeft,
                  document.documentElement.scrollTop
                );
              };
            } else {
              return new $.Point(0, 0);
            }
            return $.getPageScroll();
          },
          /**
           * Set the page scroll position.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          setPageScroll: function(scroll) {
            if (typeof window.scrollTo !== "undefined") {
              $.setPageScroll = function(scroll2) {
                window.scrollTo(scroll2.x, scroll2.y);
              };
            } else {
              var originalScroll = $.getPageScroll();
              if (originalScroll.x === scroll.x && originalScroll.y === scroll.y) {
                return;
              }
              document.body.scrollLeft = scroll.x;
              document.body.scrollTop = scroll.y;
              var currentScroll = $.getPageScroll();
              if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                $.setPageScroll = function(scroll2) {
                  document.body.scrollLeft = scroll2.x;
                  document.body.scrollTop = scroll2.y;
                };
                return;
              }
              document.documentElement.scrollLeft = scroll.x;
              document.documentElement.scrollTop = scroll.y;
              currentScroll = $.getPageScroll();
              if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                $.setPageScroll = function(scroll2) {
                  document.documentElement.scrollLeft = scroll2.x;
                  document.documentElement.scrollTop = scroll2.y;
                };
                return;
              }
              $.setPageScroll = function(scroll2) {
              };
            }
            $.setPageScroll(scroll);
          },
          /**
           * Determines the size of the browsers window.
           * @function
           * @returns {OpenSeadragon.Point}
           */
          getWindowSize: function() {
            var docElement = document.documentElement || {}, body = document.body || {};
            if (typeof window.innerWidth === "number") {
              $.getWindowSize = function() {
                return new $.Point(
                  window.innerWidth,
                  window.innerHeight
                );
              };
            } else if (docElement.clientWidth || docElement.clientHeight) {
              $.getWindowSize = function() {
                return new $.Point(
                  document.documentElement.clientWidth,
                  document.documentElement.clientHeight
                );
              };
            } else if (body.clientWidth || body.clientHeight) {
              $.getWindowSize = function() {
                return new $.Point(
                  document.body.clientWidth,
                  document.body.clientHeight
                );
              };
            } else {
              throw new Error("Unknown window size, no known technique.");
            }
            return $.getWindowSize();
          },
          /**
           * Wraps the given element in a nest of divs so that the element can
           * be easily centered using CSS tables
           * @function
           * @param {Element|String} element
           * @returns {Element} outermost wrapper element
           */
          makeCenteredNode: function(element) {
            element = $.getElement(element);
            var wrappers = [
              $.makeNeutralElement("div"),
              $.makeNeutralElement("div"),
              $.makeNeutralElement("div")
            ];
            $.extend(wrappers[0].style, {
              display: "table",
              height: "100%",
              width: "100%"
            });
            $.extend(wrappers[1].style, {
              display: "table-row"
            });
            $.extend(wrappers[2].style, {
              display: "table-cell",
              verticalAlign: "middle",
              textAlign: "center"
            });
            wrappers[0].appendChild(wrappers[1]);
            wrappers[1].appendChild(wrappers[2]);
            wrappers[2].appendChild(element);
            return wrappers[0];
          },
          /**
           * Creates an easily positionable element of the given type that therefor
           * serves as an excellent container element.
           * @function
           * @param {String} tagName
           * @returns {Element}
           */
          makeNeutralElement: function(tagName) {
            var element = document.createElement(tagName), style = element.style;
            style.background = "transparent none";
            style.border = "none";
            style.margin = "0px";
            style.padding = "0px";
            style.position = "static";
            return element;
          },
          /**
           * Returns the current milliseconds, using Date.now() if available
           * @function
           */
          now: function() {
            if (Date.now) {
              $.now = Date.now;
            } else {
              $.now = function() {
                return (/* @__PURE__ */ new Date()).getTime();
              };
            }
            return $.now();
          },
          /**
           * Ensures an image is loaded correctly to support alpha transparency.
           * @function
           * @param {String} src
           * @returns {Element}
           */
          makeTransparentImage: function(src) {
            var img = $.makeNeutralElement("img");
            img.src = src;
            return img;
          },
          /**
           * Sets the opacity of the specified element.
           * @function
           * @param {Element|String} element
           * @param {Number} opacity
           * @param {Boolean} [usesAlpha]
           */
          setElementOpacity: function(element, opacity, usesAlpha) {
            var ieOpacity, ieFilter;
            element = $.getElement(element);
            if (usesAlpha && !$.Browser.alpha) {
              opacity = Math.round(opacity);
            }
            if ($.Browser.opacity) {
              element.style.opacity = opacity < 1 ? opacity : "";
            } else {
              if (opacity < 1) {
                ieOpacity = Math.round(100 * opacity);
                ieFilter = "alpha(opacity=" + ieOpacity + ")";
                element.style.filter = ieFilter;
              } else {
                element.style.filter = "";
              }
            }
          },
          /**
           * Sets the specified element's touch-action style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementTouchActionNone: function(element) {
            element = $.getElement(element);
            if (typeof element.style.touchAction !== "undefined") {
              element.style.touchAction = "none";
            } else if (typeof element.style.msTouchAction !== "undefined") {
              element.style.msTouchAction = "none";
            }
          },
          /**
           * Sets the specified element's pointer-events style attribute to the passed value.
           * @function
           * @param {Element|String} element
           * @param {String} value
           */
          setElementPointerEvents: function(element, value) {
            element = $.getElement(element);
            if (typeof element.style !== "undefined" && typeof element.style.pointerEvents !== "undefined") {
              element.style.pointerEvents = value;
            }
          },
          /**
           * Sets the specified element's pointer-events style attribute to 'none'.
           * @function
           * @param {Element|String} element
           */
          setElementPointerEventsNone: function(element) {
            $.setElementPointerEvents(element, "none");
          },
          /**
           * Add the specified CSS class to the element if not present.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          addClass: function(element, className) {
            element = $.getElement(element);
            if (!element.className) {
              element.className = className;
            } else if ((" " + element.className + " ").indexOf(" " + className + " ") === -1) {
              element.className += " " + className;
            }
          },
          /**
           * Find the first index at which an element is found in an array or -1
           * if not present.
           *
           * Code taken and adapted from
           * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Compatibility
           *
           * @function
           * @param {Array} array The array from which to find the element
           * @param {Object} searchElement The element to find
           * @param {Number} [fromIndex=0] Index to start research.
           * @returns {Number} The index of the element in the array.
           */
          indexOf: function(array, searchElement, fromIndex) {
            if (Array.prototype.indexOf) {
              this.indexOf = function(array2, searchElement2, fromIndex2) {
                return array2.indexOf(searchElement2, fromIndex2);
              };
            } else {
              this.indexOf = function(array2, searchElement2, fromIndex2) {
                var i, pivot = fromIndex2 ? fromIndex2 : 0, length;
                if (!array2) {
                  throw new TypeError();
                }
                length = array2.length;
                if (length === 0 || pivot >= length) {
                  return -1;
                }
                if (pivot < 0) {
                  pivot = length - Math.abs(pivot);
                }
                for (i = pivot; i < length; i++) {
                  if (array2[i] === searchElement2) {
                    return i;
                  }
                }
                return -1;
              };
            }
            return this.indexOf(array, searchElement, fromIndex);
          },
          /**
           * Remove the specified CSS class from the element.
           * @function
           * @param {Element|String} element
           * @param {String} className
           */
          removeClass: function(element, className) {
            var oldClasses, newClasses = [], i;
            element = $.getElement(element);
            oldClasses = element.className.split(/\s+/);
            for (i = 0; i < oldClasses.length; i++) {
              if (oldClasses[i] && oldClasses[i] !== className) {
                newClasses.push(oldClasses[i]);
              }
            }
            element.className = newClasses.join(" ");
          },
          /**
           * Convert passed addEventListener() options to boolean or options object,
           * depending on browser support.
           * @function
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           * @param {Boolean} [options.passive]
           * @param {Boolean} [options.once]
           * @returns {String} The protocol (http:, https:, file:, ftp: ...)
           */
          normalizeEventListenerOptions: function(options) {
            var opts;
            if (typeof options !== "undefined") {
              if (typeof options === "boolean") {
                opts = $.supportsEventListenerOptions ? { capture: options } : options;
              } else {
                opts = $.supportsEventListenerOptions ? options : typeof options.capture !== "undefined" ? options.capture : false;
              }
            } else {
              opts = $.supportsEventListenerOptions ? { capture: false } : false;
            }
            return opts;
          },
          /**
           * Adds an event listener for the given element, eventName and handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           * @param {Boolean} [options.passive]
           * @param {Boolean} [options.once]
           */
          addEvent: function() {
            if ($.supportsAddEventListener) {
              return function(element, eventName, handler, options) {
                options = $.normalizeEventListenerOptions(options);
                element = $.getElement(element);
                element.addEventListener(eventName, handler, options);
              };
            } else if (document.documentElement.attachEvent && document.attachEvent) {
              return function(element, eventName, handler) {
                element = $.getElement(element);
                element.attachEvent("on" + eventName, handler);
              };
            } else {
              throw new Error("No known event model.");
            }
          }(),
          /**
           * Remove a given event listener for the given element, event type and
           * handler.
           * @function
           * @param {Element|String} element
           * @param {String} eventName
           * @param {Function} handler
           * @param {Boolean|Object} [options] Boolean useCapture, or if [supportsEventListenerOptions]{@link OpenSeadragon.supportsEventListenerOptions}, can be an object
           * @param {Boolean} [options.capture]
           */
          removeEvent: function() {
            if ($.supportsRemoveEventListener) {
              return function(element, eventName, handler, options) {
                options = $.normalizeEventListenerOptions(options);
                element = $.getElement(element);
                element.removeEventListener(eventName, handler, options);
              };
            } else if (document.documentElement.detachEvent && document.detachEvent) {
              return function(element, eventName, handler) {
                element = $.getElement(element);
                element.detachEvent("on" + eventName, handler);
              };
            } else {
              throw new Error("No known event model.");
            }
          }(),
          /**
           * Cancels the default browser behavior had the event propagated all
           * the way up the DOM to the window object.
           * @function
           * @param {Event} [event]
           */
          cancelEvent: function(event) {
            event.preventDefault();
          },
          /**
           * Returns true if {@link OpenSeadragon.cancelEvent|cancelEvent} has been called on
           * the event, otherwise returns false.
           * @function
           * @param {Event} [event]
           */
          eventIsCanceled: function(event) {
            return event.defaultPrevented;
          },
          /**
           * Stops the propagation of the event through the DOM in the capturing and bubbling phases.
           * @function
           * @param {Event} [event]
           */
          stopEvent: function(event) {
            event.stopPropagation();
          },
          /**
           * Similar to OpenSeadragon.delegate, but it does not immediately call
           * the method on the object, returning a function which can be called
           * repeatedly to delegate the method. It also allows additional arguments
           * to be passed during construction which will be added during each
           * invocation, and each invocation can add additional arguments as well.
           *
           * @function
           * @param {Object} object
           * @param {Function} method
           * @param [args] any additional arguments are passed as arguments to the
           *  created callback
           * @returns {Function}
           */
          createCallback: function(object, method) {
            var initialArgs = [], i;
            for (i = 2; i < arguments.length; i++) {
              initialArgs.push(arguments[i]);
            }
            return function() {
              var args = initialArgs.concat([]), i2;
              for (i2 = 0; i2 < arguments.length; i2++) {
                args.push(arguments[i2]);
              }
              return method.apply(object, args);
            };
          },
          /**
           * Retrieves the value of a url parameter from the window.location string.
           * @function
           * @param {String} key
           * @returns {String} The value of the url parameter or null if no param matches.
           */
          getUrlParameter: function(key) {
            var value = URLPARAMS[key];
            return value ? value : null;
          },
          /**
           * Retrieves the protocol used by the url. The url can either be absolute
           * or relative.
           * @function
           * @private
           * @param {String} url The url to retrieve the protocol from.
           * @returns {String} The protocol (http:, https:, file:, ftp: ...)
           */
          getUrlProtocol: function(url) {
            var match = url.match(/^([a-z]+:)\/\//i);
            if (match === null) {
              return window.location.protocol;
            }
            return match[1].toLowerCase();
          },
          /**
           * Create an XHR object
           * @private
           * @param {type} [local] If set to true, the XHR will be file: protocol
           * compatible if possible (but may raise a warning in the browser).
           * @returns {XMLHttpRequest}
           */
          createAjaxRequest: function(local) {
            var supportActiveX;
            try {
              supportActiveX = !!new ActiveXObject("Microsoft.XMLHTTP");
            } catch (e) {
              supportActiveX = false;
            }
            if (supportActiveX) {
              if (window.XMLHttpRequest) {
                $.createAjaxRequest = function(local2) {
                  if (local2) {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                  }
                  return new XMLHttpRequest();
                };
              } else {
                $.createAjaxRequest = function() {
                  return new ActiveXObject("Microsoft.XMLHTTP");
                };
              }
            } else if (window.XMLHttpRequest) {
              $.createAjaxRequest = function() {
                return new XMLHttpRequest();
              };
            } else {
              throw new Error("Browser doesn't support XMLHttpRequest.");
            }
            return $.createAjaxRequest(local);
          },
          /**
           * Makes an AJAX request.
           * @param {Object} options
           * @param {String} options.url - the url to request
           * @param {Function} options.success - a function to call on a successful response
           * @param {Function} options.error - a function to call on when an error occurs
           * @param {Object} options.headers - headers to add to the AJAX request
           * @param {String} options.responseType - the response type of the AJAX request
           * @param {String} options.postData - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
           *      see TileSource::getPostData), GET method used if null
           * @param {Boolean} [options.withCredentials=false] - whether to set the XHR's withCredentials
           * @throws {Error}
           * @returns {XMLHttpRequest}
           */
          makeAjaxRequest: function(url, onSuccess, onError) {
            var withCredentials;
            var headers;
            var responseType;
            var postData;
            if ($.isPlainObject(url)) {
              onSuccess = url.success;
              onError = url.error;
              withCredentials = url.withCredentials;
              headers = url.headers;
              responseType = url.responseType || null;
              postData = url.postData || null;
              url = url.url;
            }
            var protocol = $.getUrlProtocol(url);
            var request = $.createAjaxRequest(protocol === "file:");
            if (!$.isFunction(onSuccess)) {
              throw new Error("makeAjaxRequest requires a success callback");
            }
            request.onreadystatechange = function() {
              if (request.readyState === 4) {
                request.onreadystatechange = function() {
                };
                if (request.status >= 200 && request.status < 300 || request.status === 0 && protocol !== "http:" && protocol !== "https:") {
                  onSuccess(request);
                } else {
                  if ($.isFunction(onError)) {
                    onError(request);
                  } else {
                    $.console.error("AJAX request returned %d: %s", request.status, url);
                  }
                }
              }
            };
            var method = postData ? "POST" : "GET";
            try {
              request.open(method, url, true);
              if (responseType) {
                request.responseType = responseType;
              }
              if (headers) {
                for (var headerName in headers) {
                  if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
                    request.setRequestHeader(headerName, headers[headerName]);
                  }
                }
              }
              if (withCredentials) {
                request.withCredentials = true;
              }
              request.send(postData);
            } catch (e) {
              $.console.error("%s while making AJAX request: %s", e.name, e.message);
              request.onreadystatechange = function() {
              };
              if ($.isFunction(onError)) {
                onError(request, e);
              }
            }
            return request;
          },
          /**
           * Taken from jQuery 1.6.1
           * @function
           * @param {Object} options
           * @param {String} options.url
           * @param {Function} options.callback
           * @param {String} [options.param='callback'] The name of the url parameter
           *      to request the jsonp provider with.
           * @param {String} [options.callbackName=] The name of the callback to
           *      request the jsonp provider with.
           */
          jsonp: function(options) {
            var script, url = options.url, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement, jsonpCallback = options.callbackName || "openseadragon" + $.now(), previous = window[jsonpCallback], replace = "$1" + jsonpCallback + "$2", callbackParam = options.param || "callback", callback = options.callback;
            url = url.replace(/(=)\?(&|$)|\?\?/i, replace);
            url += (/\?/.test(url) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
            window[jsonpCallback] = function(response) {
              if (!previous) {
                try {
                  delete window[jsonpCallback];
                } catch (e) {
                }
              } else {
                window[jsonpCallback] = previous;
              }
              if (callback && $.isFunction(callback)) {
                callback(response);
              }
            };
            script = document.createElement("script");
            if (void 0 !== options.async || false !== options.async) {
              script.async = "async";
            }
            if (options.scriptCharset) {
              script.charset = options.scriptCharset;
            }
            script.src = url;
            script.onload = script.onreadystatechange = function(_, isAbort) {
              if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                script.onload = script.onreadystatechange = null;
                if (head && script.parentNode) {
                  head.removeChild(script);
                }
                script = void 0;
              }
            };
            head.insertBefore(script, head.firstChild);
          },
          /**
           * Fully deprecated. Will throw an error.
           * @function
           * @deprecated use {@link OpenSeadragon.Viewer#open}
           */
          createFromDZI: function() {
            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
          },
          /**
           * Parses an XML string into a DOM Document.
           * @function
           * @param {String} string
           * @returns {Document}
           */
          parseXml: function(string) {
            if (window.DOMParser) {
              $.parseXml = function(string2) {
                var xmlDoc = null, parser;
                parser = new DOMParser();
                xmlDoc = parser.parseFromString(string2, "text/xml");
                return xmlDoc;
              };
            } else if (window.ActiveXObject) {
              $.parseXml = function(string2) {
                var xmlDoc = null;
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(string2);
                return xmlDoc;
              };
            } else {
              throw new Error("Browser doesn't support XML DOM.");
            }
            return $.parseXml(string);
          },
          /**
           * Parses a JSON string into a Javascript object.
           * @function
           * @param {String} string
           * @returns {Object}
           */
          parseJSON: function(string) {
            $.parseJSON = window.JSON.parse;
            return $.parseJSON(string);
          },
          /**
           * Reports whether the image format is supported for tiling in this
           * version.
           * @function
           * @param {String} [extension]
           * @returns {Boolean}
           */
          imageFormatSupported: function(extension) {
            extension = extension ? extension : "";
            return !!FILEFORMATS[extension.toLowerCase()];
          },
          /**
           * Updates supported image formats with user-specified values.
           * Preexisting formats that are not being updated are left unchanged.
           * By default, the defined formats are
           * <pre><code>{
           *      bmp:  false,
           *      jpeg: true,
           *      jpg:  true,
           *      png:  true,
           *      tif:  false,
           *      wdp:  false
           * }
           * </code></pre>
           * @function
           * @example
           * // sets webp as supported and png as unsupported
           * setImageFormatsSupported({webp: true, png: false});
           * @param {Object} formats An object containing format extensions as
           * keys and booleans as values.
           */
          setImageFormatsSupported: function(formats) {
            $.extend(FILEFORMATS, formats);
          }
        }
      );
      var nullfunction = function(msg) {
      };
      $.console = window.console || {
        log: nullfunction,
        debug: nullfunction,
        info: nullfunction,
        warn: nullfunction,
        error: nullfunction,
        assert: nullfunction
      };
      $.Browser = {
        vendor: $.BROWSERS.UNKNOWN,
        version: 0,
        alpha: true
      };
      var FILEFORMATS = {
        bmp: false,
        jpeg: true,
        jpg: true,
        png: true,
        tif: false,
        wdp: false
      }, URLPARAMS = {};
      (function() {
        var ver = navigator.appVersion, ua = navigator.userAgent, regex;
        switch (navigator.appName) {
          case "Microsoft Internet Explorer":
            if (!!window.attachEvent && !!window.ActiveXObject) {
              $.Browser.vendor = $.BROWSERS.IE;
              $.Browser.version = parseFloat(
                ua.substring(
                  ua.indexOf("MSIE") + 5,
                  ua.indexOf(";", ua.indexOf("MSIE"))
                )
              );
            }
            break;
          case "Netscape":
            if (window.addEventListener) {
              if (ua.indexOf("Edge") >= 0) {
                $.Browser.vendor = $.BROWSERS.EDGE;
                $.Browser.version = parseFloat(
                  ua.substring(ua.indexOf("Edge") + 5)
                );
              } else if (ua.indexOf("Edg") >= 0) {
                $.Browser.vendor = $.BROWSERS.CHROMEEDGE;
                $.Browser.version = parseFloat(
                  ua.substring(ua.indexOf("Edg") + 4)
                );
              } else if (ua.indexOf("Firefox") >= 0) {
                $.Browser.vendor = $.BROWSERS.FIREFOX;
                $.Browser.version = parseFloat(
                  ua.substring(ua.indexOf("Firefox") + 8)
                );
              } else if (ua.indexOf("Safari") >= 0) {
                $.Browser.vendor = ua.indexOf("Chrome") >= 0 ? $.BROWSERS.CHROME : $.BROWSERS.SAFARI;
                $.Browser.version = parseFloat(
                  ua.substring(
                    ua.substring(0, ua.indexOf("Safari")).lastIndexOf("/") + 1,
                    ua.indexOf("Safari")
                  )
                );
              } else {
                regex = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
                if (regex.exec(ua) !== null) {
                  $.Browser.vendor = $.BROWSERS.IE;
                  $.Browser.version = parseFloat(RegExp.$1);
                }
              }
            }
            break;
          case "Opera":
            $.Browser.vendor = $.BROWSERS.OPERA;
            $.Browser.version = parseFloat(ver);
            break;
        }
        var query = window.location.search.substring(1), parts = query.split("&"), part, sep, i;
        for (i = 0; i < parts.length; i++) {
          part = parts[i];
          sep = part.indexOf("=");
          if (sep > 0) {
            var key = part.substring(0, sep), value = part.substring(sep + 1);
            try {
              URLPARAMS[key] = decodeURIComponent(value);
            } catch (e) {
              $.console.error("Ignoring malformed URL parameter: %s=%s", key, value);
            }
          }
        }
        $.Browser.alpha = !($.Browser.vendor === $.BROWSERS.CHROME && $.Browser.version < 2);
        $.Browser.opacity = true;
        if ($.Browser.vendor === $.BROWSERS.IE && $.Browser.version < 11) {
          $.console.error("Internet Explorer versions < 11 are not supported by OpenSeadragon");
        }
      })();
      (function(w) {
        var requestAnimationFrame = w.requestAnimationFrame || w.mozRequestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame;
        var cancelAnimationFrame = w.cancelAnimationFrame || w.mozCancelAnimationFrame || w.webkitCancelAnimationFrame || w.msCancelAnimationFrame;
        if (requestAnimationFrame && cancelAnimationFrame) {
          $.requestAnimationFrame = function() {
            return requestAnimationFrame.apply(w, arguments);
          };
          $.cancelAnimationFrame = function() {
            return cancelAnimationFrame.apply(w, arguments);
          };
        } else {
          var aAnimQueue = [], processing = [], iRequestId = 0, iIntervalId;
          $.requestAnimationFrame = function(callback) {
            aAnimQueue.push([++iRequestId, callback]);
            if (!iIntervalId) {
              iIntervalId = setInterval(function() {
                if (aAnimQueue.length) {
                  var time = $.now();
                  var temp = processing;
                  processing = aAnimQueue;
                  aAnimQueue = temp;
                  while (processing.length) {
                    processing.shift()[1](time);
                  }
                } else {
                  clearInterval(iIntervalId);
                  iIntervalId = void 0;
                }
              }, 1e3 / 50);
            }
            return iRequestId;
          };
          $.cancelAnimationFrame = function(requestId) {
            var i, j;
            for (i = 0, j = aAnimQueue.length; i < j; i += 1) {
              if (aAnimQueue[i][0] === requestId) {
                aAnimQueue.splice(i, 1);
                return;
              }
            }
            for (i = 0, j = processing.length; i < j; i += 1) {
              if (processing[i][0] === requestId) {
                processing.splice(i, 1);
                return;
              }
            }
          };
        }
      })(window);
      function getOffsetParent(element, isFixed) {
        if (isFixed && element !== document.body) {
          return document.body;
        } else {
          return element.offsetParent;
        }
      }
    })(OpenSeadragon);
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.OpenSeadragon = factory();
      }
    })(exports, function() {
      return OpenSeadragon;
    });
    (function($) {
      var fullScreenApi = {
        supportsFullScreen: false,
        isFullScreen: function() {
          return false;
        },
        getFullScreenElement: function() {
          return null;
        },
        requestFullScreen: function() {
        },
        exitFullScreen: function() {
        },
        cancelFullScreen: function() {
        },
        fullScreenEventName: "",
        fullScreenErrorEventName: ""
      };
      if (document.exitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.fullscreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.requestFullscreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.exitFullscreen();
        };
        fullScreenApi.fullScreenEventName = "fullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
      } else if (document.msExitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.msFullscreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.msRequestFullscreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.msExitFullscreen();
        };
        fullScreenApi.fullScreenEventName = "MSFullscreenChange";
        fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
      } else if (document.webkitExitFullscreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.webkitFullscreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.webkitRequestFullscreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.webkitExitFullscreen();
        };
        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
      } else if (document.webkitCancelFullScreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.webkitCurrentFullScreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.webkitRequestFullScreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.webkitCancelFullScreen();
        };
        fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
      } else if (document.mozCancelFullScreen) {
        fullScreenApi.supportsFullScreen = true;
        fullScreenApi.getFullScreenElement = function() {
          return document.mozFullScreenElement;
        };
        fullScreenApi.requestFullScreen = function(element) {
          return element.mozRequestFullScreen();
        };
        fullScreenApi.exitFullScreen = function() {
          document.mozCancelFullScreen();
        };
        fullScreenApi.fullScreenEventName = "mozfullscreenchange";
        fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
      }
      fullScreenApi.isFullScreen = function() {
        return fullScreenApi.getFullScreenElement() !== null;
      };
      fullScreenApi.cancelFullScreen = function() {
        $.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
        fullScreenApi.exitFullScreen();
      };
      $.extend($, fullScreenApi);
    })(OpenSeadragon);
    (function($) {
      $.EventSource = function() {
        this.events = {};
      };
      $.EventSource.prototype = {
        /**
         * Add an event handler to be triggered only once (or a given number of times)
         * for a given event. It is not removable with removeHandler().
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event
         * is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged
         * to the handler.
         * @param {Number} [times=1] - The number of times to handle the event
         * before removing it.
         * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
         */
        addOnceHandler: function(eventName, handler, userData, times, priority) {
          var self = this;
          times = times || 1;
          var count = 0;
          var onceHandler = function(event) {
            count++;
            if (count === times) {
              self.removeHandler(eventName, onceHandler);
            }
            return handler(event);
          };
          this.addHandler(eventName, onceHandler, userData, priority);
        },
        /**
         * Add an event handler for a given event.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {OpenSeadragon.EventHandler} handler - Function to call when event is triggered.
         * @param {Object} [userData=null] - Arbitrary object to be passed unchanged to the handler.
         * @param {Number} [priority=0] - Handler priority. By default, all priorities are 0. Higher number = priority.
         */
        addHandler: function(eventName, handler, userData, priority) {
          var events = this.events[eventName];
          if (!events) {
            this.events[eventName] = events = [];
          }
          if (handler && $.isFunction(handler)) {
            var index = events.length, event = { handler, userData: userData || null, priority: priority || 0 };
            events[index] = event;
            while (index > 0 && events[index - 1].priority < events[index].priority) {
              events[index] = events[index - 1];
              events[index - 1] = event;
              index--;
            }
          }
        },
        /**
         * Remove a specific event handler for a given event.
         * @function
         * @param {String} eventName - Name of event for which the handler is to be removed.
         * @param {OpenSeadragon.EventHandler} handler - Function to be removed.
         */
        removeHandler: function(eventName, handler) {
          var events = this.events[eventName], handlers = [], i;
          if (!events) {
            return;
          }
          if ($.isArray(events)) {
            for (i = 0; i < events.length; i++) {
              if (events[i].handler !== handler) {
                handlers.push(events[i]);
              }
            }
            this.events[eventName] = handlers;
          }
        },
        /**
         * Get the amount of handlers registered for a given event.
         * @param {String} eventName - Name of event to inspect.
         * @returns {number} amount of events
         */
        numberOfHandlers: function(eventName) {
          var events = this.events[eventName];
          if (!events) {
            return 0;
          }
          return events.length;
        },
        /**
         * Remove all event handlers for a given event type. If no type is given all
         * event handlers for every event type are removed.
         * @function
         * @param {String} eventName - Name of event for which all handlers are to be removed.
         */
        removeAllHandlers: function(eventName) {
          if (eventName) {
            this.events[eventName] = [];
          } else {
            for (var eventType in this.events) {
              this.events[eventType] = [];
            }
          }
        },
        /**
         * Get a function which iterates the list of all handlers registered for a given event, calling the handler for each.
         * @function
         * @param {String} eventName - Name of event to get handlers for.
         */
        getHandler: function(eventName) {
          var events = this.events[eventName];
          if (!events || !events.length) {
            return null;
          }
          events = events.length === 1 ? [events[0]] : Array.apply(null, events);
          return function(source, args) {
            var i, length = events.length;
            for (i = 0; i < length; i++) {
              if (events[i]) {
                args.eventSource = source;
                args.userData = events[i].userData;
                events[i].handler(args);
              }
            }
          };
        },
        /**
         * Trigger an event, optionally passing additional information.
         * @function
         * @param {String} eventName - Name of event to register.
         * @param {Object} eventArgs - Event-specific data.
         */
        raiseEvent: function(eventName, eventArgs) {
          var handler = this.getHandler(eventName);
          if (handler) {
            return handler(this, eventArgs || {});
          }
          return void 0;
        }
      };
    })(OpenSeadragon);
    (function($) {
      var MOUSETRACKERS = [];
      var THIS = {};
      $.MouseTracker = function(options) {
        MOUSETRACKERS.push(this);
        var args = arguments;
        if (!$.isPlainObject(options)) {
          options = {
            element: args[0],
            clickTimeThreshold: args[1],
            clickDistThreshold: args[2]
          };
        }
        this.hash = Math.random();
        this.element = $.getElement(options.element);
        this.clickTimeThreshold = options.clickTimeThreshold || $.DEFAULT_SETTINGS.clickTimeThreshold;
        this.clickDistThreshold = options.clickDistThreshold || $.DEFAULT_SETTINGS.clickDistThreshold;
        this.dblClickTimeThreshold = options.dblClickTimeThreshold || $.DEFAULT_SETTINGS.dblClickTimeThreshold;
        this.dblClickDistThreshold = options.dblClickDistThreshold || $.DEFAULT_SETTINGS.dblClickDistThreshold;
        this.userData = options.userData || null;
        this.stopDelay = options.stopDelay || 50;
        this.preProcessEventHandler = options.preProcessEventHandler || null;
        this.contextMenuHandler = options.contextMenuHandler || null;
        this.enterHandler = options.enterHandler || null;
        this.leaveHandler = options.leaveHandler || null;
        this.exitHandler = options.exitHandler || null;
        this.overHandler = options.overHandler || null;
        this.outHandler = options.outHandler || null;
        this.pressHandler = options.pressHandler || null;
        this.nonPrimaryPressHandler = options.nonPrimaryPressHandler || null;
        this.releaseHandler = options.releaseHandler || null;
        this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
        this.moveHandler = options.moveHandler || null;
        this.scrollHandler = options.scrollHandler || null;
        this.clickHandler = options.clickHandler || null;
        this.dblClickHandler = options.dblClickHandler || null;
        this.dragHandler = options.dragHandler || null;
        this.dragEndHandler = options.dragEndHandler || null;
        this.pinchHandler = options.pinchHandler || null;
        this.stopHandler = options.stopHandler || null;
        this.keyDownHandler = options.keyDownHandler || null;
        this.keyUpHandler = options.keyUpHandler || null;
        this.keyHandler = options.keyHandler || null;
        this.focusHandler = options.focusHandler || null;
        this.blurHandler = options.blurHandler || null;
        var _this = this;
        THIS[this.hash] = {
          click: function(event) {
            onClick(_this, event);
          },
          dblclick: function(event) {
            onDblClick(_this, event);
          },
          keydown: function(event) {
            onKeyDown(_this, event);
          },
          keyup: function(event) {
            onKeyUp(_this, event);
          },
          keypress: function(event) {
            onKeyPress(_this, event);
          },
          focus: function(event) {
            onFocus(_this, event);
          },
          blur: function(event) {
            onBlur(_this, event);
          },
          contextmenu: function(event) {
            onContextMenu(_this, event);
          },
          wheel: function(event) {
            onWheel(_this, event);
          },
          mousewheel: function(event) {
            onMouseWheel(_this, event);
          },
          DOMMouseScroll: function(event) {
            onMouseWheel(_this, event);
          },
          MozMousePixelScroll: function(event) {
            onMouseWheel(_this, event);
          },
          losecapture: function(event) {
            onLoseCapture(_this, event);
          },
          mouseenter: function(event) {
            onPointerEnter(_this, event);
          },
          mouseleave: function(event) {
            onPointerLeave(_this, event);
          },
          mouseover: function(event) {
            onPointerOver(_this, event);
          },
          mouseout: function(event) {
            onPointerOut(_this, event);
          },
          mousedown: function(event) {
            onPointerDown(_this, event);
          },
          mouseup: function(event) {
            onPointerUp(_this, event);
          },
          mousemove: function(event) {
            onPointerMove(_this, event);
          },
          touchstart: function(event) {
            onTouchStart(_this, event);
          },
          touchend: function(event) {
            onTouchEnd(_this, event);
          },
          touchmove: function(event) {
            onTouchMove(_this, event);
          },
          touchcancel: function(event) {
            onTouchCancel(_this, event);
          },
          gesturestart: function(event) {
            onGestureStart(_this, event);
          },
          // Safari/Safari iOS
          gesturechange: function(event) {
            onGestureChange(_this, event);
          },
          // Safari/Safari iOS
          gotpointercapture: function(event) {
            onGotPointerCapture(_this, event);
          },
          lostpointercapture: function(event) {
            onLostPointerCapture(_this, event);
          },
          pointerenter: function(event) {
            onPointerEnter(_this, event);
          },
          pointerleave: function(event) {
            onPointerLeave(_this, event);
          },
          pointerover: function(event) {
            onPointerOver(_this, event);
          },
          pointerout: function(event) {
            onPointerOut(_this, event);
          },
          pointerdown: function(event) {
            onPointerDown(_this, event);
          },
          pointerup: function(event) {
            onPointerUp(_this, event);
          },
          pointermove: function(event) {
            onPointerMove(_this, event);
          },
          pointercancel: function(event) {
            onPointerCancel(_this, event);
          },
          pointerupcaptured: function(event) {
            onPointerUpCaptured(_this, event);
          },
          pointermovecaptured: function(event) {
            onPointerMoveCaptured(_this, event);
          },
          tracking: false,
          // Active pointers lists. Array of GesturePointList objects, one for each pointer device type.
          // GesturePointList objects are added each time a pointer is tracked by a new pointer device type (see getActivePointersListByType()).
          // Active pointers are any pointer being tracked for this element which are in the hit-test area
          //     of the element (for hover-capable devices) and/or have contact or a button press initiated in the element.
          activePointersLists: [],
          // Tracking for double-click gesture
          lastClickPos: null,
          dblClickTimeOut: null,
          // Tracking for pinch gesture
          pinchGPoints: [],
          lastPinchDist: 0,
          currentPinchDist: 0,
          lastPinchCenter: null,
          currentPinchCenter: null,
          // Tracking for drag
          sentDragEvent: false
        };
        this.hasGestureHandlers = !!(this.pressHandler || this.nonPrimaryPressHandler || this.releaseHandler || this.nonPrimaryReleaseHandler || this.clickHandler || this.dblClickHandler || this.dragHandler || this.dragEndHandler || this.pinchHandler);
        this.hasScrollHandler = !!this.scrollHandler;
        if ($.MouseTracker.havePointerEvents) {
          $.setElementPointerEvents(this.element, "auto");
        }
        if (this.exitHandler) {
          $.console.error("MouseTracker.exitHandler is deprecated. Use MouseTracker.leaveHandler instead.");
        }
        if (!options.startDisabled) {
          this.setTracking(true);
        }
      };
      $.MouseTracker.prototype = {
        /**
         * Clean up any events or objects created by the tracker.
         * @function
         */
        destroy: function() {
          var i;
          stopTracking(this);
          this.element = null;
          for (i = 0; i < MOUSETRACKERS.length; i++) {
            if (MOUSETRACKERS[i] === this) {
              MOUSETRACKERS.splice(i, 1);
              break;
            }
          }
          THIS[this.hash] = null;
          delete THIS[this.hash];
        },
        /**
         * Are we currently tracking events on this element.
         * @deprecated Just use this.tracking
         * @function
         * @returns {Boolean} Are we currently tracking events on this element.
         */
        isTracking: function() {
          return THIS[this.hash].tracking;
        },
        /**
         * Enable or disable whether or not we are tracking events on this element.
         * @function
         * @param {Boolean} track True to start tracking, false to stop tracking.
         * @returns {OpenSeadragon.MouseTracker} Chainable.
         */
        setTracking: function(track) {
          if (track) {
            startTracking(this);
          } else {
            stopTracking(this);
          }
          return this;
        },
        /**
         * Returns the {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} for the given pointer device type,
         * creating and caching a new {@link OpenSeadragon.MouseTracker.GesturePointList|GesturePointList} if one doesn't already exist for the type.
         * @function
         * @param {String} type - The pointer device type: "mouse", "touch", "pen", etc.
         * @returns {OpenSeadragon.MouseTracker.GesturePointList}
         */
        getActivePointersListByType: function(type) {
          var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, list;
          for (i = 0; i < len; i++) {
            if (delegate.activePointersLists[i].type === type) {
              return delegate.activePointersLists[i];
            }
          }
          list = new $.MouseTracker.GesturePointList(type);
          delegate.activePointersLists.push(list);
          return list;
        },
        /**
         * Returns the total number of pointers currently active on the tracked element.
         * @function
         * @returns {Number}
         */
        getActivePointerCount: function() {
          var delegate = THIS[this.hash], i, len = delegate.activePointersLists.length, count = 0;
          for (i = 0; i < len; i++) {
            count += delegate.activePointersLists[i].getLength();
          }
          return count;
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {OpenSeadragon.MouseTracker.EventProcessInfo} eventInfo
         */
        preProcessEventHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the contextmenu event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        contextMenuHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        enterHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        leaveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @deprecated v2.5.0 Use leaveHandler instead
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        exitHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        overHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @since v2.5.0
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Number} event.pointers
         *      Number of pointers (all types) active in the tracked element.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.buttonDownAny
         *      Was the button down anywhere in the screen during the event. <span style="color:red;">Deprecated. Use buttons instead.</span>
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        outHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryPressHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.insideElementPressed
         *      True if the left mouse button is currently being pressed and was
         *      initiated inside the tracked element, otherwise false.
         * @param {Boolean} event.insideElementReleased
         *      True if the cursor inside the tracked element when the button was released.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        releaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.button
         *      Button which caused the event.
         *      -1: none, 0: primary/left, 1: aux/middle, 2: secondary/right, 3: X1/back, 4: X2/forward, 5: pen eraser.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        nonPrimaryReleaseHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        moveHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.scroll
         *      The scroll delta for the event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead. Touch devices no longer generate scroll event.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the wheel event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        scrollHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.quick
         *      True only if the clickDistThreshold and clickTimeThreshold are both passed. Useful for ignoring drag events.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Element} event.originalTarget
         *      The DOM element clicked on.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        clickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dblClickHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {OpenSeadragon.Point} event.delta
         *      The x,y components of the difference between the current position and the last drag event position.  Useful for ignoring or weighting the events.
         * @param {Number} event.speed
         *     Current computed speed, in pixels per second.
         * @param {Number} event.direction
         *     Current computed direction, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.speed
         *     Speed at the end of a drag gesture, in pixels per second.
         * @param {Number} event.direction
         *     Direction at the end of a drag gesture, expressed as an angle counterclockwise relative to the positive X axis (-pi to pi, in radians). Only valid if speed > 0.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        dragEndHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {Array.<OpenSeadragon.MouseTracker.GesturePoint>} event.gesturePoints
         *      Gesture points associated with the gesture. Velocity data can be found here.
         * @param {OpenSeadragon.Point} event.lastCenter
         *      The previous center point of the two pinch contact points relative to the tracked element.
         * @param {OpenSeadragon.Point} event.center
         *      The center point of the two pinch contact points relative to the tracked element.
         * @param {Number} event.lastDistance
         *      The previous distance between the two pinch contact points in CSS pixels.
         * @param {Number} event.distance
         *      The distance between the two pinch contact points in CSS pixels.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        pinchHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {String} event.pointerType
         *     "mouse", "touch", "pen", etc.
         * @param {OpenSeadragon.Point} event.position
         *      The position of the event relative to the tracked element.
         * @param {Number} event.buttons
         *      Current buttons pressed.
         *      Combination of bit flags 0: none, 1: primary (or touch contact), 2: secondary, 4: aux (often middle), 8: X1 (often back), 16: X2 (often forward), 32: pen eraser.
         * @param {Boolean} event.isTouchEvent
         *      True if the original event is a touch event, otherwise false. <span style="color:red;">Deprecated. Use pointerType and/or originalEvent instead.</span>
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        stopHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keydown event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyDownHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keyup event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyUpHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Number} event.keyCode
         *      The key code that was pressed.
         * @param {Boolean} event.ctrl
         *      True if the ctrl key was pressed during this event.
         * @param {Boolean} event.shift
         *      True if the shift key was pressed during this event.
         * @param {Boolean} event.alt
         *      True if the alt key was pressed during this event.
         * @param {Boolean} event.meta
         *      True if the meta key was pressed during this event.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Boolean} event.preventDefault
         *      Set to true to prevent the default user-agent's handling of the keypress event.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        keyHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        focusHandler: function() {
        },
        /**
         * Implement or assign implementation to these handlers during or after
         * calling the constructor.
         * @function
         * @param {Object} event
         * @param {OpenSeadragon.MouseTracker} event.eventSource
         *      A reference to the tracker instance.
         * @param {Object} event.originalEvent
         *      The original event object.
         * @param {Object} event.userData
         *      Arbitrary user-defined object.
         */
        blurHandler: function() {
        }
      };
      var isInIframe = function() {
        try {
          return window.self !== window.top;
        } catch (e) {
          return true;
        }
      }();
      function canAccessEvents(target) {
        try {
          return target.addEventListener && target.removeEventListener;
        } catch (e) {
          return false;
        }
      }
      $.MouseTracker.gesturePointVelocityTracker = function() {
        var trackerPoints = [], intervalId = 0, lastTime = 0;
        var _generateGuid = function(tracker, gPoint) {
          return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
        };
        var _doTracking = function() {
          var i, len = trackerPoints.length, trackPoint, gPoint, now = $.now(), elapsedTime, distance, speed;
          elapsedTime = now - lastTime;
          lastTime = now;
          for (i = 0; i < len; i++) {
            trackPoint = trackerPoints[i];
            gPoint = trackPoint.gPoint;
            gPoint.direction = Math.atan2(gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x);
            distance = trackPoint.lastPos.distanceTo(gPoint.currentPos);
            trackPoint.lastPos = gPoint.currentPos;
            speed = 1e3 * distance / (elapsedTime + 1);
            gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
          }
        };
        var addPoint = function(tracker, gPoint) {
          var guid = _generateGuid(tracker, gPoint);
          trackerPoints.push(
            {
              guid,
              gPoint,
              lastPos: gPoint.currentPos
            }
          );
          if (trackerPoints.length === 1) {
            lastTime = $.now();
            intervalId = window.setInterval(_doTracking, 50);
          }
        };
        var removePoint = function(tracker, gPoint) {
          var guid = _generateGuid(tracker, gPoint), i, len = trackerPoints.length;
          for (i = 0; i < len; i++) {
            if (trackerPoints[i].guid === guid) {
              trackerPoints.splice(i, 1);
              len--;
              if (len === 0) {
                window.clearInterval(intervalId);
              }
              break;
            }
          }
        };
        return {
          addPoint,
          removePoint
        };
      }();
      $.MouseTracker.captureElement = document;
      $.MouseTracker.wheelEventName = $.Browser.vendor === $.BROWSERS.IE && $.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : (
        // Modern browsers support 'wheel'
        document.onmousewheel !== void 0 ? "mousewheel" : (
          // Webkit and IE support at least 'mousewheel'
          "DOMMouseScroll"
        )
      );
      $.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", "contextmenu", $.MouseTracker.wheelEventName];
      if ($.MouseTracker.wheelEventName === "DOMMouseScroll") {
        $.MouseTracker.subscribeEvents.push("MozMousePixelScroll");
      }
      if (window.PointerEvent) {
        $.MouseTracker.havePointerEvents = true;
        $.MouseTracker.subscribeEvents.push("pointerenter", "pointerleave", "pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel");
        $.MouseTracker.havePointerCapture = function() {
          var divElement = document.createElement("div");
          return $.isFunction(divElement.setPointerCapture) && $.isFunction(divElement.releasePointerCapture);
        }();
        if ($.MouseTracker.havePointerCapture) {
          $.MouseTracker.subscribeEvents.push("gotpointercapture", "lostpointercapture");
        }
      } else {
        $.MouseTracker.havePointerEvents = false;
        $.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave", "mouseover", "mouseout", "mousedown", "mouseup", "mousemove");
        $.MouseTracker.mousePointerId = "legacy-mouse";
        $.MouseTracker.havePointerCapture = function() {
          var divElement = document.createElement("div");
          return $.isFunction(divElement.setCapture) && $.isFunction(divElement.releaseCapture);
        }();
        if ($.MouseTracker.havePointerCapture) {
          $.MouseTracker.subscribeEvents.push("losecapture");
        }
        if ("ontouchstart" in window) {
          $.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel");
        }
        if ("ongesturestart" in window) {
          $.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange");
        }
      }
      $.MouseTracker.GesturePointList = function(type) {
        this._gPoints = [];
        this.type = type;
        this.buttons = 0;
        this.contacts = 0;
        this.clicks = 0;
        this.captureCount = 0;
      };
      $.MouseTracker.GesturePointList.prototype = {
        /**
         * @function
         * @returns {Number} Number of gesture points in the list.
         */
        getLength: function() {
          return this._gPoints.length;
        },
        /**
         * @function
         * @returns {Array.<OpenSeadragon.MouseTracker.GesturePoint>} The list of gesture points in the list as an array (read-only).
         */
        asArray: function() {
          return this._gPoints;
        },
        /**
         * @function
         * @param {OpenSeadragon.MouseTracker.GesturePoint} gesturePoint - A gesture point to add to the list.
         * @returns {Number} Number of gesture points in the list.
         */
        add: function(gp) {
          return this._gPoints.push(gp);
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to remove from the list.
         * @returns {Number} Number of gesture points in the list.
         */
        removeById: function(id) {
          var i, len = this._gPoints.length;
          for (i = 0; i < len; i++) {
            if (this._gPoints[i].id === id) {
              this._gPoints.splice(i, 1);
              break;
            }
          }
          return this._gPoints.length;
        },
        /**
         * @function
         * @param {Number} index - The index of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point at the given index, or null if not found.
         */
        getByIndex: function(index) {
          if (index < this._gPoints.length) {
            return this._gPoints[index];
          }
          return null;
        },
        /**
         * @function
         * @param {Number} id - The id of the gesture point to retrieve from the list.
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The gesture point with the given id, or null if not found.
         */
        getById: function(id) {
          var i, len = this._gPoints.length;
          for (i = 0; i < len; i++) {
            if (this._gPoints[i].id === id) {
              return this._gPoints[i];
            }
          }
          return null;
        },
        /**
         * @function
         * @returns {OpenSeadragon.MouseTracker.GesturePoint|null} The primary gesture point in the list, or null if not found.
         */
        getPrimary: function(id) {
          var i, len = this._gPoints.length;
          for (i = 0; i < len; i++) {
            if (this._gPoints[i].isPrimary) {
              return this._gPoints[i];
            }
          }
          return null;
        },
        /**
         * Increment this pointer list's contact count.
         * It will evaluate whether this pointer type is allowed to have multiple contacts.
         * @function
         */
        addContact: function() {
          ++this.contacts;
          if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
            $.console.warn("GesturePointList.addContact() Implausible contacts value");
            this.contacts = 1;
          }
        },
        /**
         * Decrement this pointer list's contact count.
         * It will make sure the count does not go below 0.
         * @function
         */
        removeContact: function() {
          --this.contacts;
          if (this.contacts < 0) {
            this.contacts = 0;
          }
        }
      };
      function clearTrackedPointers(tracker) {
        var delegate = THIS[tracker.hash], i, j, pointsList, gPoints, gPointsToRemove, pointerListCount = delegate.activePointersLists.length;
        for (i = 0; i < pointerListCount; i++) {
          pointsList = delegate.activePointersLists[i];
          if (pointsList.getLength() > 0) {
            gPointsToRemove = [];
            gPoints = pointsList.asArray();
            for (j = 0; j < gPoints.length; j++) {
              gPointsToRemove.push(gPoints[j]);
            }
            for (j = 0; j < gPointsToRemove.length; j++) {
              stopTrackingPointer(tracker, pointsList, gPointsToRemove[j]);
            }
          }
        }
        for (i = 0; i < pointerListCount; i++) {
          delegate.activePointersLists.pop();
        }
        delegate.sentDragEvent = false;
      }
      function startTracking(tracker) {
        var delegate = THIS[tracker.hash], event, i;
        if (!delegate.tracking) {
          for (i = 0; i < $.MouseTracker.subscribeEvents.length; i++) {
            event = $.MouseTracker.subscribeEvents[i];
            $.addEvent(
              tracker.element,
              event,
              delegate[event],
              event === $.MouseTracker.wheelEventName ? { passive: false, capture: false } : false
            );
          }
          clearTrackedPointers(tracker);
          delegate.tracking = true;
        }
      }
      function stopTracking(tracker) {
        var delegate = THIS[tracker.hash], event, i;
        if (delegate.tracking) {
          for (i = 0; i < $.MouseTracker.subscribeEvents.length; i++) {
            event = $.MouseTracker.subscribeEvents[i];
            $.removeEvent(
              tracker.element,
              event,
              delegate[event],
              false
            );
          }
          clearTrackedPointers(tracker);
          delegate.tracking = false;
        }
      }
      function getCaptureEventParams(tracker, pointerType) {
        var delegate = THIS[tracker.hash];
        if (pointerType === "pointerevent") {
          return {
            upName: "pointerup",
            upHandler: delegate.pointerupcaptured,
            moveName: "pointermove",
            moveHandler: delegate.pointermovecaptured
          };
        } else if (pointerType === "mouse") {
          return {
            upName: "pointerup",
            upHandler: delegate.pointerupcaptured,
            moveName: "pointermove",
            moveHandler: delegate.pointermovecaptured
          };
        } else if (pointerType === "touch") {
          return {
            upName: "touchend",
            upHandler: delegate.touchendcaptured,
            moveName: "touchmove",
            moveHandler: delegate.touchmovecaptured
          };
        } else {
          throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
        }
      }
      function capturePointer(tracker, gPoint) {
        var eventParams;
        if ($.MouseTracker.havePointerCapture) {
          if ($.MouseTracker.havePointerEvents) {
            try {
              tracker.element.setPointerCapture(gPoint.id);
            } catch (e) {
              $.console.warn("setPointerCapture() called on invalid pointer ID");
              return;
            }
          } else {
            tracker.element.setCapture(true);
          }
        } else {
          eventParams = getCaptureEventParams(tracker, $.MouseTracker.havePointerEvents ? "pointerevent" : gPoint.type);
          if (isInIframe && canAccessEvents(window.top)) {
            $.addEvent(
              window.top,
              eventParams.upName,
              eventParams.upHandler,
              true
            );
          }
          $.addEvent(
            $.MouseTracker.captureElement,
            eventParams.upName,
            eventParams.upHandler,
            true
          );
          $.addEvent(
            $.MouseTracker.captureElement,
            eventParams.moveName,
            eventParams.moveHandler,
            true
          );
        }
        updatePointerCaptured(tracker, gPoint, true);
      }
      function releasePointer(tracker, gPoint) {
        var eventParams;
        var pointsList;
        var cachedGPoint;
        if ($.MouseTracker.havePointerCapture) {
          if ($.MouseTracker.havePointerEvents) {
            pointsList = tracker.getActivePointersListByType(gPoint.type);
            cachedGPoint = pointsList.getById(gPoint.id);
            if (!cachedGPoint || !cachedGPoint.captured) {
              return;
            }
            try {
              tracker.element.releasePointerCapture(gPoint.id);
            } catch (e) {
            }
          } else {
            tracker.element.releaseCapture();
          }
        } else {
          eventParams = getCaptureEventParams(tracker, $.MouseTracker.havePointerEvents ? "pointerevent" : gPoint.type);
          if (isInIframe && canAccessEvents(window.top)) {
            $.removeEvent(
              window.top,
              eventParams.upName,
              eventParams.upHandler,
              true
            );
          }
          $.removeEvent(
            $.MouseTracker.captureElement,
            eventParams.moveName,
            eventParams.moveHandler,
            true
          );
          $.removeEvent(
            $.MouseTracker.captureElement,
            eventParams.upName,
            eventParams.upHandler,
            true
          );
        }
        updatePointerCaptured(tracker, gPoint, false);
      }
      function getPointerId(event) {
        return $.MouseTracker.havePointerEvents ? event.pointerId : $.MouseTracker.mousePointerId;
      }
      function getPointerType(event) {
        if ($.MouseTracker.havePointerEvents) {
          return event.pointerType || ($.Browser.vendor === $.BROWSERS.IE ? "mouse" : "");
        } else {
          return "mouse";
        }
      }
      function getIsPrimary(event) {
        return $.MouseTracker.havePointerEvents ? event.isPrimary : true;
      }
      function getMouseAbsolute(event) {
        return $.getMousePosition(event);
      }
      function getMouseRelative(event, element) {
        return getPointRelativeToAbsolute(getMouseAbsolute(event), element);
      }
      function getPointRelativeToAbsolute(point, element) {
        var offset = $.getElementOffset(element);
        return point.minus(offset);
      }
      function getCenterPoint(point1, point2) {
        return new $.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
      }
      function onClick(tracker, event) {
        var eventInfo = {
          originalEvent: event,
          eventType: "click",
          pointerType: "mouse",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onDblClick(tracker, event) {
        var eventInfo = {
          originalEvent: event,
          eventType: "dblclick",
          pointerType: "mouse",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onKeyDown(tracker, event) {
        var eventArgs = null;
        var eventInfo = {
          originalEvent: event,
          eventType: "keydown",
          pointerType: "",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.keyDownHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventArgs = {
            eventSource: tracker,
            keyCode: event.keyCode ? event.keyCode : event.charCode,
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
            meta: event.metaKey,
            originalEvent: event,
            preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
            userData: tracker.userData
          };
          tracker.keyDownHandler(eventArgs);
        }
        if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onKeyUp(tracker, event) {
        var eventArgs = null;
        var eventInfo = {
          originalEvent: event,
          eventType: "keyup",
          pointerType: "",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.keyUpHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventArgs = {
            eventSource: tracker,
            keyCode: event.keyCode ? event.keyCode : event.charCode,
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
            meta: event.metaKey,
            originalEvent: event,
            preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
            userData: tracker.userData
          };
          tracker.keyUpHandler(eventArgs);
        }
        if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onKeyPress(tracker, event) {
        var eventArgs = null;
        var eventInfo = {
          originalEvent: event,
          eventType: "keypress",
          pointerType: "",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.keyHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventArgs = {
            eventSource: tracker,
            keyCode: event.keyCode ? event.keyCode : event.charCode,
            ctrl: event.ctrlKey,
            shift: event.shiftKey,
            alt: event.altKey,
            meta: event.metaKey,
            originalEvent: event,
            preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
            userData: tracker.userData
          };
          tracker.keyHandler(eventArgs);
        }
        if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onFocus(tracker, event) {
        var eventInfo = {
          originalEvent: event,
          eventType: "focus",
          pointerType: "",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.focusHandler && !eventInfo.preventGesture) {
          tracker.focusHandler(
            {
              eventSource: tracker,
              originalEvent: event,
              userData: tracker.userData
            }
          );
        }
      }
      function onBlur(tracker, event) {
        var eventInfo = {
          originalEvent: event,
          eventType: "blur",
          pointerType: "",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.blurHandler && !eventInfo.preventGesture) {
          tracker.blurHandler(
            {
              eventSource: tracker,
              originalEvent: event,
              userData: tracker.userData
            }
          );
        }
      }
      function onContextMenu(tracker, event) {
        var eventArgs = null;
        var eventInfo = {
          originalEvent: event,
          eventType: "contextmenu",
          pointerType: "mouse",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.contextMenuHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventArgs = {
            eventSource: tracker,
            position: getPointRelativeToAbsolute(getMouseAbsolute(event), tracker.element),
            originalEvent: eventInfo.originalEvent,
            preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
            userData: tracker.userData
          };
          tracker.contextMenuHandler(eventArgs);
        }
        if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onWheel(tracker, event) {
        handleWheelEvent(tracker, event, event);
      }
      function onMouseWheel(tracker, event) {
        var simulatedEvent = {
          target: event.target || event.srcElement,
          type: "wheel",
          shiftKey: event.shiftKey || false,
          clientX: event.clientX,
          clientY: event.clientY,
          pageX: event.pageX ? event.pageX : event.clientX,
          pageY: event.pageY ? event.pageY : event.clientY,
          deltaMode: event.type === "MozMousePixelScroll" ? 0 : 1,
          // 0=pixel, 1=line, 2=page
          deltaX: 0,
          deltaZ: 0
        };
        if ($.MouseTracker.wheelEventName === "mousewheel") {
          simulatedEvent.deltaY = -event.wheelDelta / $.DEFAULT_SETTINGS.pixelsPerWheelLine;
        } else {
          simulatedEvent.deltaY = event.detail;
        }
        handleWheelEvent(tracker, simulatedEvent, event);
      }
      function handleWheelEvent(tracker, event, originalEvent) {
        var nDelta = 0, eventInfo;
        var eventArgs = null;
        nDelta = event.deltaY < 0 ? 1 : -1;
        eventInfo = {
          originalEvent: event,
          eventType: "wheel",
          pointerType: "mouse",
          isEmulated: event !== originalEvent
        };
        preProcessEvent(tracker, eventInfo);
        if (tracker.scrollHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventArgs = {
            eventSource: tracker,
            pointerType: "mouse",
            position: getMouseRelative(event, tracker.element),
            scroll: nDelta,
            shift: event.shiftKey,
            isTouchEvent: false,
            originalEvent,
            preventDefault: eventInfo.preventDefault || eventInfo.defaultPrevented,
            userData: tracker.userData
          };
          tracker.scrollHandler(eventArgs);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(originalEvent);
        }
        if (eventArgs && eventArgs.preventDefault || eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(originalEvent);
        }
      }
      function onLoseCapture(tracker, event) {
        var gPoint = {
          id: $.MouseTracker.mousePointerId,
          type: "mouse"
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "lostpointercapture",
          pointerType: "mouse",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (event.target === tracker.element) {
          updatePointerCaptured(tracker, gPoint, false);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onTouchStart(tracker, event) {
        var time, i, touchCount = event.changedTouches.length, gPoint, pointsList = tracker.getActivePointersListByType("touch");
        time = $.now();
        if (pointsList.getLength() > event.touches.length - touchCount) {
          $.console.warn("Tracked touch contact count doesn't match event.touches.length");
        }
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerdown",
          pointerType: "touch",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        for (i = 0; i < touchCount; i++) {
          gPoint = {
            id: event.changedTouches[i].identifier,
            type: "touch",
            // Simulate isPrimary
            isPrimary: pointsList.getLength() === 0,
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
          };
          updatePointerEnter(tracker, eventInfo, gPoint);
          updatePointerDown(tracker, eventInfo, gPoint, 0);
          updatePointerCaptured(tracker, gPoint, true);
        }
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onTouchEnd(tracker, event) {
        var time, i, touchCount = event.changedTouches.length, gPoint;
        time = $.now();
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerup",
          pointerType: "touch",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        for (i = 0; i < touchCount; i++) {
          gPoint = {
            id: event.changedTouches[i].identifier,
            type: "touch",
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
          };
          updatePointerUp(tracker, eventInfo, gPoint, 0);
          updatePointerCaptured(tracker, gPoint, false);
          updatePointerLeave(tracker, eventInfo, gPoint);
        }
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onTouchMove(tracker, event) {
        var time, i, touchCount = event.changedTouches.length, gPoint;
        time = $.now();
        var eventInfo = {
          originalEvent: event,
          eventType: "pointermove",
          pointerType: "touch",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        for (i = 0; i < touchCount; i++) {
          gPoint = {
            id: event.changedTouches[i].identifier,
            type: "touch",
            currentPos: getMouseAbsolute(event.changedTouches[i]),
            currentTime: time
          };
          updatePointerMove(tracker, eventInfo, gPoint);
        }
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onTouchCancel(tracker, event) {
        var touchCount = event.changedTouches.length, i, gPoint;
        var eventInfo = {
          originalEvent: event,
          eventType: "pointercancel",
          pointerType: "touch",
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        for (i = 0; i < touchCount; i++) {
          gPoint = {
            id: event.changedTouches[i].identifier,
            type: "touch"
          };
          updatePointerCancel(tracker, eventInfo, gPoint);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onGestureStart(tracker, event) {
        if (!$.eventIsCanceled(event)) {
          event.preventDefault();
        }
        return false;
      }
      function onGestureChange(tracker, event) {
        if (!$.eventIsCanceled(event)) {
          event.preventDefault();
        }
        return false;
      }
      function onGotPointerCapture(tracker, event) {
        var eventInfo = {
          originalEvent: event,
          eventType: "gotpointercapture",
          pointerType: getPointerType(event),
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (event.target === tracker.element) {
          updatePointerCaptured(tracker, {
            id: event.pointerId,
            type: getPointerType(event)
          }, true);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onLostPointerCapture(tracker, event) {
        var eventInfo = {
          originalEvent: event,
          eventType: "lostpointercapture",
          pointerType: getPointerType(event),
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        if (event.target === tracker.element) {
          updatePointerCaptured(tracker, {
            id: event.pointerId,
            type: getPointerType(event)
          }, false);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onPointerEnter(tracker, event) {
        var gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerenter",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerEnter(tracker, eventInfo, gPoint);
      }
      function onPointerLeave(tracker, event) {
        var gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerleave",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerLeave(tracker, eventInfo, gPoint);
      }
      function onPointerOver(tracker, event) {
        var gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerover",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerOver(tracker, eventInfo, gPoint);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onPointerOut(tracker, event) {
        var gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerout",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerOut(tracker, eventInfo, gPoint);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onPointerDown(tracker, event) {
        var gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var implicitlyCaptured = $.MouseTracker.havePointerEvents && gPoint.type === "touch" && $.Browser.vendor !== $.BROWSERS.IE;
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerdown",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerDown(tracker, eventInfo, gPoint, event.button);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
        if (eventInfo.shouldCapture) {
          if (implicitlyCaptured) {
            updatePointerCaptured(tracker, gPoint, true);
          } else {
            capturePointer(tracker, gPoint);
          }
        }
      }
      function onPointerUp(tracker, event) {
        handlePointerUp(tracker, event);
      }
      function onPointerUpCaptured(tracker, event) {
        var pointsList = tracker.getActivePointersListByType(getPointerType(event));
        if (pointsList.getById(event.pointerId)) {
          handlePointerUp(tracker, event);
        }
        $.stopEvent(event);
      }
      function handlePointerUp(tracker, event) {
        var gPoint;
        gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointerup",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerUp(tracker, eventInfo, gPoint, event.button);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
        if (eventInfo.shouldReleaseCapture) {
          if (event.target === tracker.element) {
            releasePointer(tracker, gPoint);
          } else {
            updatePointerCaptured(tracker, gPoint, false);
          }
        }
      }
      function onPointerMove(tracker, event) {
        handlePointerMove(tracker, event);
      }
      function onPointerMoveCaptured(tracker, event) {
        var pointsList = tracker.getActivePointersListByType(getPointerType(event));
        if (pointsList.getById(event.pointerId)) {
          handlePointerMove(tracker, event);
        }
        $.stopEvent(event);
      }
      function handlePointerMove(tracker, event) {
        var gPoint = {
          id: getPointerId(event),
          type: getPointerType(event),
          isPrimary: getIsPrimary(event),
          currentPos: getMouseAbsolute(event),
          currentTime: $.now()
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointermove",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerMove(tracker, eventInfo, gPoint);
        if (eventInfo.preventDefault && !eventInfo.defaultPrevented) {
          $.cancelEvent(event);
        }
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function onPointerCancel(tracker, event) {
        var gPoint = {
          id: event.pointerId,
          type: getPointerType(event)
        };
        var eventInfo = {
          originalEvent: event,
          eventType: "pointercancel",
          pointerType: gPoint.type,
          isEmulated: false
        };
        preProcessEvent(tracker, eventInfo);
        updatePointerCancel(tracker, eventInfo, gPoint);
        if (eventInfo.stopPropagation) {
          $.stopEvent(event);
        }
      }
      function startTrackingPointer(pointsList, gPoint) {
        gPoint.speed = 0;
        gPoint.direction = 0;
        gPoint.contactPos = gPoint.currentPos;
        gPoint.contactTime = gPoint.currentTime;
        gPoint.lastPos = gPoint.currentPos;
        gPoint.lastTime = gPoint.currentTime;
        return pointsList.add(gPoint);
      }
      function stopTrackingPointer(tracker, pointsList, gPoint) {
        var listLength;
        var trackedGPoint = pointsList.getById(gPoint.id);
        if (trackedGPoint) {
          if (trackedGPoint.captured) {
            $.console.warn("stopTrackingPointer() called on captured pointer");
            releasePointer(tracker, trackedGPoint);
          }
          pointsList.removeContact();
          listLength = pointsList.removeById(gPoint.id);
        } else {
          listLength = pointsList.getLength();
        }
        return listLength;
      }
      function getEventProcessDefaults(tracker, eventInfo) {
        switch (eventInfo.eventType) {
          case "pointermove":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = !tracker.hasGestureHandlers;
            eventInfo.stopPropagation = false;
            break;
          case "pointerover":
          case "pointerout":
          case "contextmenu":
          case "keydown":
          case "keyup":
          case "keypress":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = false;
            eventInfo.stopPropagation = false;
            break;
          case "pointerdown":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = !tracker.hasGestureHandlers;
            eventInfo.stopPropagation = false;
            break;
          case "pointerup":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = !tracker.hasGestureHandlers;
            eventInfo.stopPropagation = false;
            break;
          case "wheel":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = !tracker.hasScrollHandler;
            eventInfo.stopPropagation = false;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = false;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = false;
            eventInfo.stopPropagation = false;
            break;
          case "click":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = !!tracker.clickHandler;
            eventInfo.preventGesture = false;
            eventInfo.stopPropagation = false;
            break;
          case "dblclick":
            eventInfo.isStoppable = true;
            eventInfo.isCancelable = true;
            eventInfo.preventDefault = !!tracker.dblClickHandler;
            eventInfo.preventGesture = false;
            eventInfo.stopPropagation = false;
            break;
          case "focus":
          case "blur":
          case "pointerenter":
          case "pointerleave":
          default:
            eventInfo.isStoppable = false;
            eventInfo.isCancelable = false;
            eventInfo.preventDefault = false;
            eventInfo.preventGesture = false;
            eventInfo.stopPropagation = false;
            break;
        }
      }
      function preProcessEvent(tracker, eventInfo) {
        eventInfo.eventSource = tracker;
        eventInfo.eventPhase = eventInfo.originalEvent ? typeof eventInfo.originalEvent.eventPhase !== "undefined" ? eventInfo.originalEvent.eventPhase : 0 : 0;
        eventInfo.defaultPrevented = $.eventIsCanceled(eventInfo.originalEvent);
        eventInfo.shouldCapture = false;
        eventInfo.shouldReleaseCapture = false;
        eventInfo.userData = tracker.userData;
        getEventProcessDefaults(tracker, eventInfo);
        if (tracker.preProcessEventHandler) {
          tracker.preProcessEventHandler(eventInfo);
        }
      }
      function updatePointerCaptured(tracker, gPoint, isCaptured) {
        var pointsList = tracker.getActivePointersListByType(gPoint.type);
        var updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          if (isCaptured && !updateGPoint.captured) {
            updateGPoint.captured = true;
            pointsList.captureCount++;
          } else if (!isCaptured && updateGPoint.captured) {
            updateGPoint.captured = false;
            pointsList.captureCount--;
            if (pointsList.captureCount < 0) {
              pointsList.captureCount = 0;
              $.console.warn("updatePointerCaptured() - pointsList.captureCount went negative");
            }
          }
        } else {
          $.console.warn("updatePointerCaptured() called on untracked pointer");
        }
      }
      function updatePointerEnter(tracker, eventInfo, gPoint) {
        var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          updateGPoint.insideElement = true;
          updateGPoint.lastPos = updateGPoint.currentPos;
          updateGPoint.lastTime = updateGPoint.currentTime;
          updateGPoint.currentPos = gPoint.currentPos;
          updateGPoint.currentTime = gPoint.currentTime;
          gPoint = updateGPoint;
        } else {
          gPoint.captured = false;
          gPoint.insideElementPressed = false;
          gPoint.insideElement = true;
          startTrackingPointer(pointsList, gPoint);
        }
        if (tracker.enterHandler) {
          tracker.enterHandler(
            {
              eventSource: tracker,
              pointerType: gPoint.type,
              position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
              buttons: pointsList.buttons,
              pointers: tracker.getActivePointerCount(),
              insideElementPressed: gPoint.insideElementPressed,
              buttonDownAny: pointsList.buttons !== 0,
              isTouchEvent: gPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
      }
      function updatePointerLeave(tracker, eventInfo, gPoint) {
        var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint, dispatchEventObj;
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          if (updateGPoint.captured) {
            updateGPoint.insideElement = false;
            updateGPoint.lastPos = updateGPoint.currentPos;
            updateGPoint.lastTime = updateGPoint.currentTime;
            updateGPoint.currentPos = gPoint.currentPos;
            updateGPoint.currentTime = gPoint.currentTime;
          } else {
            stopTrackingPointer(tracker, pointsList, updateGPoint);
          }
          gPoint = updateGPoint;
        } else {
          gPoint.captured = false;
          gPoint.insideElementPressed = false;
        }
        if (tracker.leaveHandler || tracker.exitHandler) {
          dispatchEventObj = {
            eventSource: tracker,
            pointerType: gPoint.type,
            // GitHub PR: https://github.com/openseadragon/openseadragon/pull/1754 (gPoint.currentPos && )
            position: gPoint.currentPos && getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            pointers: tracker.getActivePointerCount(),
            insideElementPressed: gPoint.insideElementPressed,
            buttonDownAny: pointsList.buttons !== 0,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          };
          if (tracker.leaveHandler) {
            tracker.leaveHandler(dispatchEventObj);
          }
          if (tracker.exitHandler) {
            tracker.exitHandler(dispatchEventObj);
          }
        }
      }
      function updatePointerOver(tracker, eventInfo, gPoint) {
        var pointsList, updateGPoint;
        pointsList = tracker.getActivePointersListByType(gPoint.type);
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          gPoint = updateGPoint;
        } else {
          gPoint.captured = false;
          gPoint.insideElementPressed = false;
        }
        if (tracker.overHandler) {
          tracker.overHandler(
            {
              eventSource: tracker,
              pointerType: gPoint.type,
              position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
              buttons: pointsList.buttons,
              pointers: tracker.getActivePointerCount(),
              insideElementPressed: gPoint.insideElementPressed,
              buttonDownAny: pointsList.buttons !== 0,
              isTouchEvent: gPoint.type === "touch",
              originalEvent: eventInfo.originalEvent,
              userData: tracker.userData
            }
          );
        }
      }
      function updatePointerOut(tracker, eventInfo, gPoint) {
        var pointsList, updateGPoint;
        pointsList = tracker.getActivePointersListByType(gPoint.type);
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          gPoint = updateGPoint;
        } else {
          gPoint.captured = false;
          gPoint.insideElementPressed = false;
        }
        if (tracker.outHandler) {
          tracker.outHandler({
            eventSource: tracker,
            pointerType: gPoint.type,
            position: gPoint.currentPos && getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
            buttons: pointsList.buttons,
            pointers: tracker.getActivePointerCount(),
            insideElementPressed: gPoint.insideElementPressed,
            buttonDownAny: pointsList.buttons !== 0,
            isTouchEvent: gPoint.type === "touch",
            originalEvent: eventInfo.originalEvent,
            userData: tracker.userData
          });
        }
      }
      function updatePointerDown(tracker, eventInfo, gPoint, buttonChanged) {
        var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
        if (typeof eventInfo.originalEvent.buttons !== "undefined") {
          pointsList.buttons = eventInfo.originalEvent.buttons;
        } else {
          if (buttonChanged === 0) {
            pointsList.buttons |= 1;
          } else if (buttonChanged === 1) {
            pointsList.buttons |= 4;
          } else if (buttonChanged === 2) {
            pointsList.buttons |= 2;
          } else if (buttonChanged === 3) {
            pointsList.buttons |= 8;
          } else if (buttonChanged === 4) {
            pointsList.buttons |= 16;
          } else if (buttonChanged === 5) {
            pointsList.buttons |= 32;
          }
        }
        if (buttonChanged !== 0) {
          eventInfo.shouldCapture = false;
          eventInfo.shouldReleaseCapture = false;
          if (tracker.nonPrimaryPressHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
            eventInfo.preventDefault = true;
            tracker.nonPrimaryPressHandler(
              {
                eventSource: tracker,
                pointerType: gPoint.type,
                position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
                button: buttonChanged,
                buttons: pointsList.buttons,
                isTouchEvent: gPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
          }
          return;
        }
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          updateGPoint.insideElementPressed = true;
          updateGPoint.insideElement = true;
          updateGPoint.originalTarget = eventInfo.originalEvent.target;
          updateGPoint.contactPos = gPoint.currentPos;
          updateGPoint.contactTime = gPoint.currentTime;
          updateGPoint.lastPos = updateGPoint.currentPos;
          updateGPoint.lastTime = updateGPoint.currentTime;
          updateGPoint.currentPos = gPoint.currentPos;
          updateGPoint.currentTime = gPoint.currentTime;
          gPoint = updateGPoint;
        } else {
          gPoint.captured = false;
          gPoint.insideElementPressed = true;
          gPoint.insideElement = true;
          gPoint.originalTarget = eventInfo.originalEvent.target;
          startTrackingPointer(pointsList, gPoint);
        }
        pointsList.addContact();
        if (!eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          eventInfo.shouldCapture = true;
          eventInfo.shouldReleaseCapture = false;
          eventInfo.preventDefault = true;
          if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
            $.MouseTracker.gesturePointVelocityTracker.addPoint(tracker, gPoint);
          }
          if (pointsList.contacts === 1) {
            if (tracker.pressHandler && !eventInfo.preventGesture) {
              tracker.pressHandler(
                {
                  eventSource: tracker,
                  pointerType: gPoint.type,
                  position: getPointRelativeToAbsolute(gPoint.contactPos, tracker.element),
                  buttons: pointsList.buttons,
                  isTouchEvent: gPoint.type === "touch",
                  originalEvent: eventInfo.originalEvent,
                  userData: tracker.userData
                }
              );
            }
          } else if (pointsList.contacts === 2) {
            if (tracker.pinchHandler && gPoint.type === "touch") {
              delegate.pinchGPoints = pointsList.asArray();
              delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
              delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
            }
          }
        } else {
          eventInfo.shouldCapture = false;
          eventInfo.shouldReleaseCapture = false;
        }
      }
      function updatePointerUp(tracker, eventInfo, gPoint, buttonChanged) {
        var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), releasePoint, releaseTime, updateGPoint, wasCaptured = false, quick;
        if (typeof eventInfo.originalEvent.buttons !== "undefined") {
          pointsList.buttons = eventInfo.originalEvent.buttons;
        } else {
          if (buttonChanged === 0) {
            pointsList.buttons ^= ~1;
          } else if (buttonChanged === 1) {
            pointsList.buttons ^= ~4;
          } else if (buttonChanged === 2) {
            pointsList.buttons ^= ~2;
          } else if (buttonChanged === 3) {
            pointsList.buttons ^= ~8;
          } else if (buttonChanged === 4) {
            pointsList.buttons ^= ~16;
          } else if (buttonChanged === 5) {
            pointsList.buttons ^= ~32;
          }
        }
        eventInfo.shouldCapture = false;
        if (buttonChanged !== 0) {
          eventInfo.shouldReleaseCapture = false;
          if (tracker.nonPrimaryReleaseHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
            eventInfo.preventDefault = true;
            tracker.nonPrimaryReleaseHandler(
              {
                eventSource: tracker,
                pointerType: gPoint.type,
                position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
                button: buttonChanged,
                buttons: pointsList.buttons,
                isTouchEvent: gPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
          }
          return;
        }
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          pointsList.removeContact();
          if (updateGPoint.captured) {
            wasCaptured = true;
          }
          updateGPoint.lastPos = updateGPoint.currentPos;
          updateGPoint.lastTime = updateGPoint.currentTime;
          updateGPoint.currentPos = gPoint.currentPos;
          updateGPoint.currentTime = gPoint.currentTime;
          if (!updateGPoint.insideElement) {
            stopTrackingPointer(tracker, pointsList, updateGPoint);
          }
          releasePoint = updateGPoint.currentPos;
          releaseTime = updateGPoint.currentTime;
        } else {
          gPoint.captured = false;
          gPoint.insideElementPressed = false;
          gPoint.insideElement = true;
          startTrackingPointer(pointsList, gPoint);
          updateGPoint = gPoint;
        }
        if (!eventInfo.preventGesture && !eventInfo.defaultPrevented) {
          if (wasCaptured) {
            eventInfo.shouldReleaseCapture = true;
            eventInfo.preventDefault = true;
            if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
              $.MouseTracker.gesturePointVelocityTracker.removePoint(tracker, updateGPoint);
            }
            if (pointsList.contacts === 0) {
              if (tracker.releaseHandler && releasePoint) {
                tracker.releaseHandler(
                  {
                    eventSource: tracker,
                    pointerType: updateGPoint.type,
                    position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                    buttons: pointsList.buttons,
                    insideElementPressed: updateGPoint.insideElementPressed,
                    insideElementReleased: updateGPoint.insideElement,
                    isTouchEvent: updateGPoint.type === "touch",
                    originalEvent: eventInfo.originalEvent,
                    userData: tracker.userData
                  }
                );
              }
              if (tracker.dragEndHandler && delegate.sentDragEvent) {
                tracker.dragEndHandler(
                  {
                    eventSource: tracker,
                    pointerType: updateGPoint.type,
                    position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                    speed: updateGPoint.speed,
                    direction: updateGPoint.direction,
                    shift: eventInfo.originalEvent.shiftKey,
                    isTouchEvent: updateGPoint.type === "touch",
                    originalEvent: eventInfo.originalEvent,
                    userData: tracker.userData
                  }
                );
              }
              delegate.sentDragEvent = false;
              if ((tracker.clickHandler || tracker.dblClickHandler) && updateGPoint.insideElement) {
                quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold && updateGPoint.contactPos.distanceTo(releasePoint) <= tracker.clickDistThreshold;
                if (tracker.clickHandler) {
                  tracker.clickHandler(
                    {
                      eventSource: tracker,
                      pointerType: updateGPoint.type,
                      position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                      quick,
                      shift: eventInfo.originalEvent.shiftKey,
                      isTouchEvent: updateGPoint.type === "touch",
                      originalEvent: eventInfo.originalEvent,
                      originalTarget: updateGPoint.originalTarget,
                      userData: tracker.userData
                    }
                  );
                }
                if (tracker.dblClickHandler && quick) {
                  pointsList.clicks++;
                  if (pointsList.clicks === 1) {
                    delegate.lastClickPos = releasePoint;
                    delegate.dblClickTimeOut = setTimeout(function() {
                      pointsList.clicks = 0;
                    }, tracker.dblClickTimeThreshold);
                  } else if (pointsList.clicks === 2) {
                    clearTimeout(delegate.dblClickTimeOut);
                    pointsList.clicks = 0;
                    if (delegate.lastClickPos.distanceTo(releasePoint) <= tracker.dblClickDistThreshold) {
                      tracker.dblClickHandler(
                        {
                          eventSource: tracker,
                          pointerType: updateGPoint.type,
                          position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                          shift: eventInfo.originalEvent.shiftKey,
                          isTouchEvent: updateGPoint.type === "touch",
                          originalEvent: eventInfo.originalEvent,
                          userData: tracker.userData
                        }
                      );
                    }
                    delegate.lastClickPos = null;
                  }
                }
              }
            } else if (pointsList.contacts === 2) {
              if (tracker.pinchHandler && updateGPoint.type === "touch") {
                delegate.pinchGPoints = pointsList.asArray();
                delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
              }
            }
          } else {
            eventInfo.shouldReleaseCapture = false;
            if (tracker.releaseHandler && releasePoint) {
              tracker.releaseHandler(
                {
                  eventSource: tracker,
                  pointerType: updateGPoint.type,
                  position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                  buttons: pointsList.buttons,
                  insideElementPressed: updateGPoint.insideElementPressed,
                  insideElementReleased: updateGPoint.insideElement,
                  isTouchEvent: updateGPoint.type === "touch",
                  originalEvent: eventInfo.originalEvent,
                  userData: tracker.userData
                }
              );
              eventInfo.preventDefault = true;
            }
          }
        }
      }
      function updatePointerMove(tracker, eventInfo, gPoint) {
        var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint, gPointArray, delta;
        if (typeof eventInfo.originalEvent.buttons !== "undefined") {
          pointsList.buttons = eventInfo.originalEvent.buttons;
        }
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          updateGPoint.lastPos = updateGPoint.currentPos;
          updateGPoint.lastTime = updateGPoint.currentTime;
          updateGPoint.currentPos = gPoint.currentPos;
          updateGPoint.currentTime = gPoint.currentTime;
        } else {
          return;
        }
        eventInfo.shouldCapture = false;
        eventInfo.shouldReleaseCapture = false;
        if (tracker.stopHandler && gPoint.type === "mouse") {
          clearTimeout(tracker.stopTimeOut);
          tracker.stopTimeOut = setTimeout(function() {
            handlePointerStop(tracker, eventInfo.originalEvent, gPoint.type);
          }, tracker.stopDelay);
        }
        if (pointsList.contacts === 0) {
          if (tracker.moveHandler) {
            tracker.moveHandler(
              {
                eventSource: tracker,
                pointerType: gPoint.type,
                position: getPointRelativeToAbsolute(gPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: gPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
          }
        } else if (pointsList.contacts === 1) {
          if (tracker.moveHandler) {
            updateGPoint = pointsList.asArray()[0];
            tracker.moveHandler(
              {
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
          }
          if (tracker.dragHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
            updateGPoint = pointsList.asArray()[0];
            delta = updateGPoint.currentPos.minus(updateGPoint.lastPos);
            tracker.dragHandler(
              {
                eventSource: tracker,
                pointerType: updateGPoint.type,
                position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                buttons: pointsList.buttons,
                delta,
                speed: updateGPoint.speed,
                direction: updateGPoint.direction,
                shift: eventInfo.originalEvent.shiftKey,
                isTouchEvent: updateGPoint.type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
            eventInfo.preventDefault = true;
            delegate.sentDragEvent = true;
          }
        } else if (pointsList.contacts === 2) {
          if (tracker.moveHandler) {
            gPointArray = pointsList.asArray();
            tracker.moveHandler(
              {
                eventSource: tracker,
                pointerType: gPointArray[0].type,
                position: getPointRelativeToAbsolute(getCenterPoint(gPointArray[0].currentPos, gPointArray[1].currentPos), tracker.element),
                buttons: pointsList.buttons,
                isTouchEvent: gPointArray[0].type === "touch",
                originalEvent: eventInfo.originalEvent,
                userData: tracker.userData
              }
            );
          }
          if (tracker.pinchHandler && gPoint.type === "touch" && !eventInfo.preventGesture && !eventInfo.defaultPrevented) {
            delta = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
            if (delta !== delegate.currentPinchDist) {
              delegate.lastPinchDist = delegate.currentPinchDist;
              delegate.currentPinchDist = delta;
              delegate.lastPinchCenter = delegate.currentPinchCenter;
              delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
              tracker.pinchHandler(
                {
                  eventSource: tracker,
                  pointerType: "touch",
                  gesturePoints: delegate.pinchGPoints,
                  lastCenter: getPointRelativeToAbsolute(delegate.lastPinchCenter, tracker.element),
                  center: getPointRelativeToAbsolute(delegate.currentPinchCenter, tracker.element),
                  lastDistance: delegate.lastPinchDist,
                  distance: delegate.currentPinchDist,
                  shift: eventInfo.originalEvent.shiftKey,
                  originalEvent: eventInfo.originalEvent,
                  userData: tracker.userData
                }
              );
              eventInfo.preventDefault = true;
            }
          }
        }
      }
      function updatePointerCancel(tracker, eventInfo, gPoint) {
        var pointsList = tracker.getActivePointersListByType(gPoint.type), updateGPoint;
        updateGPoint = pointsList.getById(gPoint.id);
        if (updateGPoint) {
          stopTrackingPointer(tracker, pointsList, updateGPoint);
        }
      }
      function handlePointerStop(tracker, originalMoveEvent, pointerType) {
        if (tracker.stopHandler) {
          tracker.stopHandler({
            eventSource: tracker,
            pointerType,
            position: getMouseRelative(originalMoveEvent, tracker.element),
            buttons: tracker.getActivePointersListByType(pointerType).buttons,
            isTouchEvent: pointerType === "touch",
            originalEvent: originalMoveEvent,
            userData: tracker.userData
          });
        }
      }
    })(OpenSeadragon);
    (function($) {
      $.ControlAnchor = {
        NONE: 0,
        TOP_LEFT: 1,
        TOP_RIGHT: 2,
        BOTTOM_RIGHT: 3,
        BOTTOM_LEFT: 4,
        ABSOLUTE: 5
      };
      $.Control = function(element, options, container) {
        var parent = element.parentNode;
        if (typeof options === "number") {
          $.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013");
          options = { anchor: options };
        }
        options.attachToViewer = typeof options.attachToViewer === "undefined" ? true : options.attachToViewer;
        this.autoFade = typeof options.autoFade === "undefined" ? true : options.autoFade;
        this.element = element;
        this.anchor = options.anchor;
        this.container = container;
        if (this.anchor === $.ControlAnchor.ABSOLUTE) {
          this.wrapper = $.makeNeutralElement("div");
          this.wrapper.style.position = "absolute";
          this.wrapper.style.top = typeof options.top === "number" ? options.top + "px" : options.top;
          this.wrapper.style.left = typeof options.left === "number" ? options.left + "px" : options.left;
          this.wrapper.style.height = typeof options.height === "number" ? options.height + "px" : options.height;
          this.wrapper.style.width = typeof options.width === "number" ? options.width + "px" : options.width;
          this.wrapper.style.margin = "0px";
          this.wrapper.style.padding = "0px";
          this.element.style.position = "relative";
          this.element.style.top = "0px";
          this.element.style.left = "0px";
          this.element.style.height = "100%";
          this.element.style.width = "100%";
        } else {
          this.wrapper = $.makeNeutralElement("div");
          this.wrapper.style.display = "inline-block";
          if (this.anchor === $.ControlAnchor.NONE) {
            this.wrapper.style.width = this.wrapper.style.height = "100%";
          }
        }
        this.wrapper.appendChild(this.element);
        if (options.attachToViewer) {
          if (this.anchor === $.ControlAnchor.TOP_RIGHT || this.anchor === $.ControlAnchor.BOTTOM_RIGHT) {
            this.container.insertBefore(
              this.wrapper,
              this.container.firstChild
            );
          } else {
            this.container.appendChild(this.wrapper);
          }
        } else {
          parent.appendChild(this.wrapper);
        }
      };
      $.Control.prototype = {
        /**
         * Removes the control from the container.
         * @function
         */
        destroy: function() {
          this.wrapper.removeChild(this.element);
          if (this.anchor !== $.ControlAnchor.NONE) {
            this.container.removeChild(this.wrapper);
          }
        },
        /**
         * Determines if the control is currently visible.
         * @function
         * @returns {Boolean} true if currently visible, false otherwise.
         */
        isVisible: function() {
          return this.wrapper.style.display !== "none";
        },
        /**
         * Toggles the visibility of the control.
         * @function
         * @param {Boolean} visible - true to make visible, false to hide.
         */
        setVisible: function(visible) {
          this.wrapper.style.display = visible ? this.anchor === $.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
        },
        /**
         * Sets the opacity level for the control.
         * @function
         * @param {Number} opactiy - a value between 1 and 0 inclusively.
         */
        setOpacity: function(opacity) {
          if (this.element[$.SIGNAL] && $.Browser.vendor === $.BROWSERS.IE) {
            $.setElementOpacity(this.element, opacity, true);
          } else {
            $.setElementOpacity(this.wrapper, opacity, true);
          }
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.ControlDock = function(options) {
        var layouts = ["topleft", "topright", "bottomright", "bottomleft"], layout, i;
        $.extend(true, this, {
          id: "controldock-" + $.now() + "-" + Math.floor(Math.random() * 1e6),
          container: $.makeNeutralElement("div"),
          controls: []
        }, options);
        this.container.onsubmit = function() {
          return false;
        };
        if (this.element) {
          this.element = $.getElement(this.element);
          this.element.appendChild(this.container);
          this.element.style.position = "relative";
          this.container.style.width = "100%";
          this.container.style.height = "100%";
        }
        for (i = 0; i < layouts.length; i++) {
          layout = layouts[i];
          this.controls[layout] = $.makeNeutralElement("div");
          this.controls[layout].style.position = "absolute";
          if (layout.match("left")) {
            this.controls[layout].style.left = "0px";
          }
          if (layout.match("right")) {
            this.controls[layout].style.right = "0px";
          }
          if (layout.match("top")) {
            this.controls[layout].style.top = "0px";
          }
          if (layout.match("bottom")) {
            this.controls[layout].style.bottom = "0px";
          }
        }
        this.container.appendChild(this.controls.topleft);
        this.container.appendChild(this.controls.topright);
        this.container.appendChild(this.controls.bottomright);
        this.container.appendChild(this.controls.bottomleft);
      };
      $.ControlDock.prototype = {
        /**
         * @function
         */
        addControl: function(element, controlOptions) {
          element = $.getElement(element);
          var div = null;
          if (getControlIndex(this, element) >= 0) {
            return;
          }
          switch (controlOptions.anchor) {
            case $.ControlAnchor.TOP_RIGHT:
              div = this.controls.topright;
              element.style.position = "relative";
              element.style.paddingRight = "0px";
              element.style.paddingTop = "0px";
              break;
            case $.ControlAnchor.BOTTOM_RIGHT:
              div = this.controls.bottomright;
              element.style.position = "relative";
              element.style.paddingRight = "0px";
              element.style.paddingBottom = "0px";
              break;
            case $.ControlAnchor.BOTTOM_LEFT:
              div = this.controls.bottomleft;
              element.style.position = "relative";
              element.style.paddingLeft = "0px";
              element.style.paddingBottom = "0px";
              break;
            case $.ControlAnchor.TOP_LEFT:
              div = this.controls.topleft;
              element.style.position = "relative";
              element.style.paddingLeft = "0px";
              element.style.paddingTop = "0px";
              break;
            case $.ControlAnchor.ABSOLUTE:
              div = this.container;
              element.style.margin = "0px";
              element.style.padding = "0px";
              break;
            default:
            case $.ControlAnchor.NONE:
              div = this.container;
              element.style.margin = "0px";
              element.style.padding = "0px";
              break;
          }
          this.controls.push(
            new $.Control(element, controlOptions, div)
          );
          element.style.display = "inline-block";
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        removeControl: function(element) {
          element = $.getElement(element);
          var i = getControlIndex(this, element);
          if (i >= 0) {
            this.controls[i].destroy();
            this.controls.splice(i, 1);
          }
          return this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        clearControls: function() {
          while (this.controls.length > 0) {
            this.controls.pop().destroy();
          }
          return this;
        },
        /**
         * @function
         * @returns {Boolean}
         */
        areControlsEnabled: function() {
          var i;
          for (i = this.controls.length - 1; i >= 0; i--) {
            if (this.controls[i].isVisible()) {
              return true;
            }
          }
          return false;
        },
        /**
         * @function
         * @returns {OpenSeadragon.ControlDock} Chainable.
         */
        setControlsEnabled: function(enabled) {
          var i;
          for (i = this.controls.length - 1; i >= 0; i--) {
            this.controls[i].setVisible(enabled);
          }
          return this;
        }
      };
      function getControlIndex(dock, element) {
        var controls = dock.controls, i;
        for (i = controls.length - 1; i >= 0; i--) {
          if (controls[i].element === element) {
            return i;
          }
        }
        return -1;
      }
    })(OpenSeadragon);
    (function($) {
      $.Placement = $.freezeObject({
        CENTER: 0,
        TOP_LEFT: 1,
        TOP: 2,
        TOP_RIGHT: 3,
        RIGHT: 4,
        BOTTOM_RIGHT: 5,
        BOTTOM: 6,
        BOTTOM_LEFT: 7,
        LEFT: 8,
        properties: {
          0: {
            isLeft: false,
            isHorizontallyCentered: true,
            isRight: false,
            isTop: false,
            isVerticallyCentered: true,
            isBottom: false
          },
          1: {
            isLeft: true,
            isHorizontallyCentered: false,
            isRight: false,
            isTop: true,
            isVerticallyCentered: false,
            isBottom: false
          },
          2: {
            isLeft: false,
            isHorizontallyCentered: true,
            isRight: false,
            isTop: true,
            isVerticallyCentered: false,
            isBottom: false
          },
          3: {
            isLeft: false,
            isHorizontallyCentered: false,
            isRight: true,
            isTop: true,
            isVerticallyCentered: false,
            isBottom: false
          },
          4: {
            isLeft: false,
            isHorizontallyCentered: false,
            isRight: true,
            isTop: false,
            isVerticallyCentered: true,
            isBottom: false
          },
          5: {
            isLeft: false,
            isHorizontallyCentered: false,
            isRight: true,
            isTop: false,
            isVerticallyCentered: false,
            isBottom: true
          },
          6: {
            isLeft: false,
            isHorizontallyCentered: true,
            isRight: false,
            isTop: false,
            isVerticallyCentered: false,
            isBottom: true
          },
          7: {
            isLeft: true,
            isHorizontallyCentered: false,
            isRight: false,
            isTop: false,
            isVerticallyCentered: false,
            isBottom: true
          },
          8: {
            isLeft: true,
            isHorizontallyCentered: false,
            isRight: false,
            isTop: false,
            isVerticallyCentered: true,
            isBottom: false
          }
        }
      });
    })(OpenSeadragon);
    (function($) {
      var THIS = {};
      var nextHash = 1;
      $.Viewer = function(options) {
        var args = arguments, _this = this, i;
        if (!$.isPlainObject(options)) {
          options = {
            id: args[0],
            xmlPath: args.length > 1 ? args[1] : void 0,
            prefixUrl: args.length > 2 ? args[2] : void 0,
            controls: args.length > 3 ? args[3] : void 0,
            overlays: args.length > 4 ? args[4] : void 0
          };
        }
        if (options.config) {
          $.extend(true, options, options.config);
          delete options.config;
        }
        $.extend(true, this, {
          //internal state and dom identifiers
          id: options.id,
          hash: options.hash || nextHash++,
          /**
           * Index for page to be shown first next time open() is called (only used in sequenceMode).
           * @member {Number} initialPage
           * @memberof OpenSeadragon.Viewer#
           */
          initialPage: 0,
          //dom nodes
          /**
           * The parent element of this Viewer instance, passed in when the Viewer was created.
           * @member {Element} element
           * @memberof OpenSeadragon.Viewer#
           */
          element: null,
          /**
           * A &lt;div&gt; element (provided by {@link OpenSeadragon.ControlDock}), the base element of this Viewer instance.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#element}.
           * @member {Element} container
           * @memberof OpenSeadragon.Viewer#
           */
          container: null,
          /**
           * A &lt;div&gt; element, the element where user-input events are handled for panning and zooming.<br><br>
           * Child element of {@link OpenSeadragon.Viewer#container},
           * positioned on top of {@link OpenSeadragon.Viewer#keyboardCommandArea}.<br><br>
           * The parent of {@link OpenSeadragon.Drawer#canvas} instances.
           * @member {Element} canvas
           * @memberof OpenSeadragon.Viewer#
           */
          canvas: null,
          // Overlays list. An overlay allows to add html on top of the viewer.
          overlays: [],
          // Container inside the canvas where overlays are drawn.
          overlaysContainer: null,
          //private state properties
          previousBody: [],
          //This was originally initialized in the constructor and so could never
          //have anything in it.  now it can because we allow it to be specified
          //in the options and is only empty by default if not specified. Also
          //this array was returned from get_controls which I find confusing
          //since this object has a controls property which is treated in other
          //functions like clearControls.  I'm removing the accessors.
          customControls: [],
          //These are originally not part options but declared as members
          //in initialize.  It's still considered idiomatic to put them here
          //source is here for backwards compatibility. It is not an official
          //part of the API and should not be relied upon.
          source: null,
          /**
           * Handles rendering of tiles in the viewer. Created for each TileSource opened.
           * @member {OpenSeadragon.Drawer} drawer
           * @memberof OpenSeadragon.Viewer#
           */
          drawer: null,
          /**
           * Keeps track of all of the tiled images in the scene.
           * @member {OpenSeadragon.World} world
           * @memberof OpenSeadragon.Viewer#
           */
          world: null,
          /**
           * Handles coordinate-related functionality - zoom, pan, rotation, etc. Created for each TileSource opened.
           * @member {OpenSeadragon.Viewport} viewport
           * @memberof OpenSeadragon.Viewer#
           */
          viewport: null,
          /**
           * @member {OpenSeadragon.Navigator} navigator
           * @memberof OpenSeadragon.Viewer#
           */
          navigator: null,
          //A collection viewport is a separate viewport used to provide
          //simultaneous rendering of sets of tiles
          collectionViewport: null,
          collectionDrawer: null,
          //UI image resources
          //TODO: rename navImages to uiImages
          navImages: null,
          //interface button controls
          buttonGroup: null,
          //TODO: this is defunct so safely remove it
          profiler: null
        }, $.DEFAULT_SETTINGS, options);
        if (typeof this.hash === "undefined") {
          throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
        }
        if (typeof THIS[this.hash] !== "undefined") {
          $.console.warn("Hash " + this.hash + " has already been used.");
        }
        THIS[this.hash] = {
          fsBoundsDelta: new $.Point(1, 1),
          prevContainerSize: null,
          animating: false,
          forceRedraw: false,
          needsResize: false,
          forceResize: false,
          mouseInside: false,
          group: null,
          // whether we should be continuously zooming
          zooming: false,
          // how much we should be continuously zooming by
          zoomFactor: null,
          lastZoomTime: null,
          fullPage: false,
          onfullscreenchange: null,
          lastClickTime: null,
          draggingToZoom: false
        };
        this._sequenceIndex = 0;
        this._firstOpen = true;
        this._updateRequestId = null;
        this._loadQueue = [];
        this.currentOverlays = [];
        this._updatePixelDensityRatioBind = null;
        this._lastScrollTime = $.now();
        $.EventSource.call(this);
        this.addHandler("open-failed", function(event) {
          var msg = $.getString("Errors.OpenFailed", event.eventSource, event.message);
          _this._showMessage(msg);
        });
        $.ControlDock.call(this, options);
        if (this.xmlPath) {
          this.tileSources = [this.xmlPath];
        }
        this.element = this.element || document.getElementById(this.id);
        this.canvas = $.makeNeutralElement("div");
        this.canvas.className = "openseadragon-canvas";
        (function(style) {
          style.width = "100%";
          style.height = "100%";
          style.overflow = "hidden";
          style.position = "absolute";
          style.top = "0px";
          style.left = "0px";
        })(this.canvas.style);
        $.setElementTouchActionNone(this.canvas);
        if (options.tabIndex !== "") {
          this.canvas.tabIndex = options.tabIndex === void 0 ? 0 : options.tabIndex;
        }
        this.container.className = "openseadragon-container";
        (function(style) {
          style.width = "100%";
          style.height = "100%";
          style.position = "relative";
          style.overflow = "hidden";
          style.left = "0px";
          style.top = "0px";
          style.textAlign = "left";
        })(this.container.style);
        $.setElementTouchActionNone(this.container);
        this.container.insertBefore(this.canvas, this.container.firstChild);
        this.element.appendChild(this.container);
        this.bodyWidth = document.body.style.width;
        this.bodyHeight = document.body.style.height;
        this.bodyOverflow = document.body.style.overflow;
        this.docOverflow = document.documentElement.style.overflow;
        this.innerTracker = new $.MouseTracker({
          userData: "Viewer.innerTracker",
          element: this.canvas,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          contextMenuHandler: $.delegate(this, onCanvasContextMenu),
          keyDownHandler: $.delegate(this, onCanvasKeyDown),
          keyHandler: $.delegate(this, onCanvasKeyPress),
          clickHandler: $.delegate(this, onCanvasClick),
          dblClickHandler: $.delegate(this, onCanvasDblClick),
          dragHandler: $.delegate(this, onCanvasDrag),
          dragEndHandler: $.delegate(this, onCanvasDragEnd),
          enterHandler: $.delegate(this, onCanvasEnter),
          leaveHandler: $.delegate(this, onCanvasLeave),
          pressHandler: $.delegate(this, onCanvasPress),
          releaseHandler: $.delegate(this, onCanvasRelease),
          nonPrimaryPressHandler: $.delegate(this, onCanvasNonPrimaryPress),
          nonPrimaryReleaseHandler: $.delegate(this, onCanvasNonPrimaryRelease),
          scrollHandler: $.delegate(this, onCanvasScroll),
          pinchHandler: $.delegate(this, onCanvasPinch),
          focusHandler: $.delegate(this, onCanvasFocus),
          blurHandler: $.delegate(this, onCanvasBlur)
        });
        this.outerTracker = new $.MouseTracker({
          userData: "Viewer.outerTracker",
          element: this.container,
          startDisabled: !this.mouseNavEnabled,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          dblClickTimeThreshold: this.dblClickTimeThreshold,
          dblClickDistThreshold: this.dblClickDistThreshold,
          enterHandler: $.delegate(this, onContainerEnter),
          leaveHandler: $.delegate(this, onContainerLeave)
        });
        if (this.toolbar) {
          this.toolbar = new $.ControlDock({ element: this.toolbar });
        }
        this.bindStandardControls();
        THIS[this.hash].prevContainerSize = _getSafeElemSize(this.container);
        if (window.ResizeObserver) {
          this._autoResizePolling = false;
          this._resizeObserver = new ResizeObserver(function() {
            THIS[_this.hash].needsResize = true;
          });
          this._resizeObserver.observe(this.container, {});
        } else {
          this._autoResizePolling = true;
        }
        this.world = new $.World({
          viewer: this
        });
        this.world.addHandler("add-item", function(event) {
          _this.source = _this.world.getItemAt(0).source;
          THIS[_this.hash].forceRedraw = true;
          if (!_this._updateRequestId) {
            _this._updateRequestId = scheduleUpdate(_this, updateMulti);
          }
        });
        this.world.addHandler("remove-item", function(event) {
          if (_this.world.getItemCount()) {
            _this.source = _this.world.getItemAt(0).source;
          } else {
            _this.source = null;
          }
          THIS[_this.hash].forceRedraw = true;
        });
        this.world.addHandler("metrics-change", function(event) {
          if (_this.viewport) {
            _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
          }
        });
        this.world.addHandler("item-index-change", function(event) {
          _this.source = _this.world.getItemAt(0).source;
        });
        this.viewport = new $.Viewport({
          containerSize: THIS[this.hash].prevContainerSize,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime,
          minZoomImageRatio: this.minZoomImageRatio,
          maxZoomPixelRatio: this.maxZoomPixelRatio,
          visibilityRatio: this.visibilityRatio,
          wrapHorizontal: this.wrapHorizontal,
          wrapVertical: this.wrapVertical,
          defaultZoomLevel: this.defaultZoomLevel,
          minZoomLevel: this.minZoomLevel,
          maxZoomLevel: this.maxZoomLevel,
          viewer: this,
          degrees: this.degrees,
          flipped: this.flipped,
          navigatorRotate: this.navigatorRotate,
          homeFillsViewer: this.homeFillsViewer,
          margins: this.viewportMargins,
          silenceMultiImageWarnings: this.silenceMultiImageWarnings
        });
        this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
        this.imageLoader = new $.ImageLoader({
          jobLimit: this.imageLoaderLimit,
          timeout: options.timeout,
          tileRetryMax: this.tileRetryMax,
          tileRetryDelay: this.tileRetryDelay
        });
        this.tileCache = new $.TileCache({
          maxImageCacheCount: this.maxImageCacheCount
        });
        this.drawer = new $.Drawer({
          viewer: this,
          viewport: this.viewport,
          element: this.canvas,
          debugGridColor: this.debugGridColor
        });
        this.overlaysContainer = $.makeNeutralElement("div");
        this.canvas.appendChild(this.overlaysContainer);
        if (!this.drawer.canRotate()) {
          if (this.rotateLeft) {
            i = this.buttonGroup.buttons.indexOf(this.rotateLeft);
            this.buttonGroup.buttons.splice(i, 1);
            this.buttonGroup.element.removeChild(this.rotateLeft.element);
          }
          if (this.rotateRight) {
            i = this.buttonGroup.buttons.indexOf(this.rotateRight);
            this.buttonGroup.buttons.splice(i, 1);
            this.buttonGroup.element.removeChild(this.rotateRight.element);
          }
        }
        this._addUpdatePixelDensityRatioEvent();
        if (this.showNavigator) {
          this.navigator = new $.Navigator({
            element: this.navigatorElement,
            id: this.navigatorId,
            position: this.navigatorPosition,
            sizeRatio: this.navigatorSizeRatio,
            maintainSizeRatio: this.navigatorMaintainSizeRatio,
            top: this.navigatorTop,
            left: this.navigatorLeft,
            width: this.navigatorWidth,
            height: this.navigatorHeight,
            autoResize: this.navigatorAutoResize,
            autoFade: this.navigatorAutoFade,
            prefixUrl: this.prefixUrl,
            viewer: this,
            navigatorRotate: this.navigatorRotate,
            background: this.navigatorBackground,
            opacity: this.navigatorOpacity,
            borderColor: this.navigatorBorderColor,
            displayRegionColor: this.navigatorDisplayRegionColor,
            crossOriginPolicy: this.crossOriginPolicy,
            animationTime: this.animationTime
          });
        }
        if (this.sequenceMode) {
          this.bindSequenceControls();
        }
        if (this.tileSources) {
          this.open(this.tileSources);
        }
        for (i = 0; i < this.customControls.length; i++) {
          this.addControl(
            this.customControls[i].id,
            { anchor: this.customControls[i].anchor }
          );
        }
        $.requestAnimationFrame(function() {
          beginControlsAutoHide(_this);
        });
        if (this.imageSmoothingEnabled !== void 0 && !this.imageSmoothingEnabled) {
          this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
        }
        $._viewers.set(this.element, this);
      };
      $.extend(
        $.Viewer.prototype,
        $.EventSource.prototype,
        $.ControlDock.prototype,
        /** @lends OpenSeadragon.Viewer.prototype */
        {
          /**
           * @function
           * @returns {Boolean}
           */
          isOpen: function() {
            return !!this.world.getItemCount();
          },
          // deprecated
          openDzi: function(dzi) {
            $.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead.");
            return this.open(dzi);
          },
          // deprecated
          openTileSource: function(tileSource) {
            $.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead.");
            return this.open(tileSource);
          },
          //deprecated
          get buttons() {
            $.console.warn("Viewer.buttons is deprecated; Please use Viewer.buttonGroup");
            return this.buttonGroup;
          },
          /**
           * Open tiled images into the viewer, closing any others.
           * To get the TiledImage instance created by open, add an event listener for
           * {@link OpenSeadragon.Viewer.html#.event:open}, which when fired can be used to get access
           * to the instance, i.e., viewer.world.getItemAt(0).
           * @function
           * @param {Array|String|Object|Function} tileSources - This can be a TiledImage
           * specifier, a TileSource specifier, or an array of either. A TiledImage specifier
           * is the same as the options parameter for {@link OpenSeadragon.Viewer#addTiledImage},
           * except for the index property; images are added in sequence.
           * A TileSource specifier is anything you could pass as the tileSource property
           * of the options parameter for {@link OpenSeadragon.Viewer#addTiledImage}.
           * @param {Number} initialPage - If sequenceMode is true, display this page initially
           * for the given tileSources. If specified, will overwrite the Viewer's existing initialPage property.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:open
           * @fires OpenSeadragon.Viewer.event:open-failed
           */
          open: function(tileSources, initialPage) {
            var _this = this;
            this.close();
            if (!tileSources) {
              return this;
            }
            if (this.sequenceMode && $.isArray(tileSources)) {
              if (this.referenceStrip) {
                this.referenceStrip.destroy();
                this.referenceStrip = null;
              }
              if (typeof initialPage !== "undefined" && !isNaN(initialPage)) {
                this.initialPage = initialPage;
              }
              this.tileSources = tileSources;
              this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
              if (this.tileSources.length) {
                this.open(this.tileSources[this._sequenceIndex]);
                if (this.showReferenceStrip) {
                  this.addReferenceStrip();
                }
              }
              this._updateSequenceButtons(this._sequenceIndex);
              return this;
            }
            if (!$.isArray(tileSources)) {
              tileSources = [tileSources];
            }
            if (!tileSources.length) {
              return this;
            }
            this._opening = true;
            var expected = tileSources.length;
            var successes = 0;
            var failures = 0;
            var failEvent;
            var checkCompletion = function() {
              if (successes + failures === expected) {
                if (successes) {
                  if (_this._firstOpen || !_this.preserveViewport) {
                    _this.viewport.goHome(true);
                    _this.viewport.update();
                  }
                  _this._firstOpen = false;
                  var source = tileSources[0];
                  if (source.tileSource) {
                    source = source.tileSource;
                  }
                  if (_this.overlays && !_this.preserveOverlays) {
                    for (var i2 = 0; i2 < _this.overlays.length; i2++) {
                      _this.currentOverlays[i2] = getOverlayObject(_this, _this.overlays[i2]);
                    }
                  }
                  _this._drawOverlays();
                  _this._opening = false;
                  _this.raiseEvent("open", { source });
                } else {
                  _this._opening = false;
                  _this.raiseEvent("open-failed", failEvent);
                }
              }
            };
            var doOne = function(options) {
              if (!$.isPlainObject(options) || !options.tileSource) {
                options = {
                  tileSource: options
                };
              }
              if (options.index !== void 0) {
                $.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead");
                delete options.index;
              }
              if (options.collectionImmediately === void 0) {
                options.collectionImmediately = true;
              }
              var originalSuccess = options.success;
              options.success = function(event) {
                successes++;
                if (options.tileSource.overlays) {
                  for (var i2 = 0; i2 < options.tileSource.overlays.length; i2++) {
                    _this.addOverlay(options.tileSource.overlays[i2]);
                  }
                }
                if (originalSuccess) {
                  originalSuccess(event);
                }
                checkCompletion();
              };
              var originalError = options.error;
              options.error = function(event) {
                failures++;
                if (!failEvent) {
                  failEvent = event;
                }
                if (originalError) {
                  originalError(event);
                }
                checkCompletion();
              };
              _this.addTiledImage(options);
            };
            for (var i = 0; i < tileSources.length; i++) {
              doOne(tileSources[i]);
            }
            return this;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:close
           */
          close: function() {
            if (!THIS[this.hash]) {
              return this;
            }
            this._opening = false;
            if (this.navigator) {
              this.navigator.close();
            }
            if (!this.preserveOverlays) {
              this.clearOverlays();
              this.overlaysContainer.innerHTML = "";
            }
            THIS[this.hash].animating = false;
            this.world.removeAll();
            this.imageLoader.clear();
            this.raiseEvent("close");
            return this;
          },
          /**
           * Function to destroy the viewer and clean up everything created by OpenSeadragon.
           *
           * Example:
           * var viewer = OpenSeadragon({
           *   [...]
           * });
           *
           * //when you are done with the viewer:
           * viewer.destroy();
           * viewer = null; //important
           *
           * @function
           * @fires OpenSeadragon.Viewer.event:before-destroy
           * @fires OpenSeadragon.Viewer.event:destroy
           */
          destroy: function() {
            if (!THIS[this.hash]) {
              return;
            }
            this.raiseEvent("before-destroy");
            this._removeUpdatePixelDensityRatioEvent();
            this.close();
            this.clearOverlays();
            this.overlaysContainer.innerHTML = "";
            if (this._resizeObserver) {
              this._resizeObserver.disconnect();
            }
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
            if (this._updateRequestId !== null) {
              $.cancelAnimationFrame(this._updateRequestId);
              this._updateRequestId = null;
            }
            if (this.drawer) {
              this.drawer.destroy();
            }
            if (this.navigator) {
              this.navigator.destroy();
              THIS[this.navigator.hash] = null;
              delete THIS[this.navigator.hash];
              this.navigator = null;
            }
            if (this.buttonGroup) {
              this.buttonGroup.destroy();
            } else if (this.customButtons) {
              while (this.customButtons.length) {
                this.customButtons.pop().destroy();
              }
            }
            if (this.paging) {
              this.paging.destroy();
            }
            if (this.element) {
              while (this.element.firstChild) {
                this.element.removeChild(this.element.firstChild);
              }
            }
            this.container.onsubmit = null;
            this.clearControls();
            if (this.innerTracker) {
              this.innerTracker.destroy();
            }
            if (this.outerTracker) {
              this.outerTracker.destroy();
            }
            THIS[this.hash] = null;
            delete THIS[this.hash];
            this.canvas = null;
            this.container = null;
            $._viewers.delete(this.element);
            this.element = null;
            this.raiseEvent("destroy");
            this.removeAllHandlers();
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isMouseNavEnabled: function() {
            return this.innerTracker.isTracking();
          },
          /**
           * @function
           * @param {Boolean} enabled - true to enable, false to disable
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:mouse-enabled
           */
          setMouseNavEnabled: function(enabled) {
            this.innerTracker.setTracking(enabled);
            this.outerTracker.setTracking(enabled);
            this.raiseEvent("mouse-enabled", { enabled });
            return this;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          areControlsEnabled: function() {
            var enabled = this.controls.length, i;
            for (i = 0; i < this.controls.length; i++) {
              enabled = enabled && this.controls[i].isVisible();
            }
            return enabled;
          },
          /**
           * Shows or hides the controls (e.g. the default navigation buttons).
           *
           * @function
           * @param {Boolean} true to show, false to hide.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:controls-enabled
           */
          setControlsEnabled: function(enabled) {
            if (enabled) {
              abortControlsAutoHide(this);
            } else {
              beginControlsAutoHide(this);
            }
            this.raiseEvent("controls-enabled", { enabled });
            return this;
          },
          /**
           * Turns debugging mode on or off for this viewer.
           *
           * @function
           * @param {Boolean} debugMode true to turn debug on, false to turn debug off.
           */
          setDebugMode: function(debugMode) {
            for (var i = 0; i < this.world.getItemCount(); i++) {
              this.world.getItemAt(i).debugMode = debugMode;
            }
            this.debugMode = debugMode;
            this.forceRedraw();
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
           * the updated headers are propagated to all tiled images, each of which will subsequently
           * propagate the changed headers to all their tiles.
           * If applicable, the headers of the viewer's navigator and reference strip will also be updated.
           *
           * Note that the rules for merging headers still apply, i.e. headers returned by
           * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
           * `TiledImage.ajaxHeaders`, which take precedence over the headers here in the viewer.
           *
           * @function
           * @param {Object} ajaxHeaders Updated AJAX headers.
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to tiled images, etc.
           */
          setAjaxHeaders: function(ajaxHeaders, propagate) {
            if (ajaxHeaders === null) {
              ajaxHeaders = {};
            }
            if (!$.isPlainObject(ajaxHeaders)) {
              console.error("[Viewer.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
              return;
            }
            if (propagate === void 0) {
              propagate = true;
            }
            this.ajaxHeaders = ajaxHeaders;
            if (propagate) {
              for (var i = 0; i < this.world.getItemCount(); i++) {
                this.world.getItemAt(i)._updateAjaxHeaders(true);
              }
              if (this.navigator) {
                this.navigator.setAjaxHeaders(this.ajaxHeaders, true);
              }
              if (this.referenceStrip && this.referenceStrip.miniViewers) {
                for (var key in this.referenceStrip.miniViewers) {
                  this.referenceStrip.miniViewers[key].setAjaxHeaders(this.ajaxHeaders, true);
                }
              }
            }
          },
          /**
           * Adds the given button to this viewer.
           *
           * @function
           * @param {OpenSeadragon.Button} button
           */
          addButton: function(button) {
            this.buttonGroup.addButton(button);
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isFullPage: function() {
            return THIS[this.hash].fullPage;
          },
          /**
           * Toggle full page mode.
           * @function
           * @param {Boolean} fullPage
           *      If true, enter full page mode.  If false, exit full page mode.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-page
           * @fires OpenSeadragon.Viewer.event:full-page
           */
          setFullPage: function(fullPage) {
            var body = document.body, bodyStyle = body.style, docStyle = document.documentElement.style, _this = this, nodes, i;
            if (fullPage === this.isFullPage()) {
              return this;
            }
            var fullPageEventArgs = {
              fullPage,
              preventDefaultAction: false
            };
            this.raiseEvent("pre-full-page", fullPageEventArgs);
            if (fullPageEventArgs.preventDefaultAction) {
              return this;
            }
            if (fullPage) {
              this.elementSize = $.getElementSize(this.element);
              this.pageScroll = $.getPageScroll();
              this.elementMargin = this.element.style.margin;
              this.element.style.margin = "0";
              this.elementPadding = this.element.style.padding;
              this.element.style.padding = "0";
              this.bodyMargin = bodyStyle.margin;
              this.docMargin = docStyle.margin;
              bodyStyle.margin = "0";
              docStyle.margin = "0";
              this.bodyPadding = bodyStyle.padding;
              this.docPadding = docStyle.padding;
              bodyStyle.padding = "0";
              docStyle.padding = "0";
              this.bodyWidth = bodyStyle.width;
              this.docWidth = docStyle.width;
              bodyStyle.width = "100%";
              docStyle.width = "100%";
              this.bodyHeight = bodyStyle.height;
              this.docHeight = docStyle.height;
              bodyStyle.height = "100%";
              docStyle.height = "100%";
              this.bodyDisplay = bodyStyle.display;
              bodyStyle.display = "block";
              this.previousBody = [];
              THIS[this.hash].prevElementParent = this.element.parentNode;
              THIS[this.hash].prevNextSibling = this.element.nextSibling;
              THIS[this.hash].prevElementWidth = this.element.style.width;
              THIS[this.hash].prevElementHeight = this.element.style.height;
              nodes = body.childNodes.length;
              for (i = 0; i < nodes; i++) {
                this.previousBody.push(body.childNodes[0]);
                body.removeChild(body.childNodes[0]);
              }
              if (this.toolbar && this.toolbar.element) {
                this.toolbar.parentNode = this.toolbar.element.parentNode;
                this.toolbar.nextSibling = this.toolbar.element.nextSibling;
                body.appendChild(this.toolbar.element);
                $.addClass(this.toolbar.element, "fullpage");
              }
              $.addClass(this.element, "fullpage");
              body.appendChild(this.element);
              this.element.style.height = "100vh";
              this.element.style.width = "100vw";
              if (this.toolbar && this.toolbar.element) {
                this.element.style.height = $.getElementSize(this.element).y - $.getElementSize(this.toolbar.element).y + "px";
              }
              THIS[this.hash].fullPage = true;
              $.delegate(this, onContainerEnter)({});
            } else {
              this.element.style.margin = this.elementMargin;
              this.element.style.padding = this.elementPadding;
              bodyStyle.margin = this.bodyMargin;
              docStyle.margin = this.docMargin;
              bodyStyle.padding = this.bodyPadding;
              docStyle.padding = this.docPadding;
              bodyStyle.width = this.bodyWidth;
              docStyle.width = this.docWidth;
              bodyStyle.height = this.bodyHeight;
              docStyle.height = this.docHeight;
              bodyStyle.display = this.bodyDisplay;
              body.removeChild(this.element);
              nodes = this.previousBody.length;
              for (i = 0; i < nodes; i++) {
                body.appendChild(this.previousBody.shift());
              }
              $.removeClass(this.element, "fullpage");
              THIS[this.hash].prevElementParent.insertBefore(
                this.element,
                THIS[this.hash].prevNextSibling
              );
              if (this.toolbar && this.toolbar.element) {
                body.removeChild(this.toolbar.element);
                $.removeClass(this.toolbar.element, "fullpage");
                this.toolbar.parentNode.insertBefore(
                  this.toolbar.element,
                  this.toolbar.nextSibling
                );
                delete this.toolbar.parentNode;
                delete this.toolbar.nextSibling;
              }
              this.element.style.width = THIS[this.hash].prevElementWidth;
              this.element.style.height = THIS[this.hash].prevElementHeight;
              var restoreScrollCounter = 0;
              var restoreScroll = function() {
                $.setPageScroll(_this.pageScroll);
                var pageScroll = $.getPageScroll();
                restoreScrollCounter++;
                if (restoreScrollCounter < 10 && (pageScroll.x !== _this.pageScroll.x || pageScroll.y !== _this.pageScroll.y)) {
                  $.requestAnimationFrame(restoreScroll);
                }
              };
              $.requestAnimationFrame(restoreScroll);
              THIS[this.hash].fullPage = false;
              $.delegate(this, onContainerLeave)({});
            }
            if (this.navigator && this.viewport) {
              this.navigator.update(this.viewport);
            }
            this.raiseEvent("full-page", { fullPage });
            return this;
          },
          /**
           * Toggle full screen mode if supported. Toggle full page mode otherwise.
           * @function
           * @param {Boolean} fullScreen
           *      If true, enter full screen mode.  If false, exit full screen mode.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:pre-full-screen
           * @fires OpenSeadragon.Viewer.event:full-screen
           */
          setFullScreen: function(fullScreen) {
            var _this = this;
            if (!$.supportsFullScreen) {
              return this.setFullPage(fullScreen);
            }
            if ($.isFullScreen() === fullScreen) {
              return this;
            }
            var fullScreeEventArgs = {
              fullScreen,
              preventDefaultAction: false
            };
            this.raiseEvent("pre-full-screen", fullScreeEventArgs);
            if (fullScreeEventArgs.preventDefaultAction) {
              return this;
            }
            if (fullScreen) {
              this.setFullPage(true);
              if (!this.isFullPage()) {
                return this;
              }
              this.fullPageStyleWidth = this.element.style.width;
              this.fullPageStyleHeight = this.element.style.height;
              this.element.style.width = "100%";
              this.element.style.height = "100%";
              var onFullScreenChange = function() {
                var isFullScreen = $.isFullScreen();
                if (!isFullScreen) {
                  $.removeEvent(document, $.fullScreenEventName, onFullScreenChange);
                  $.removeEvent(document, $.fullScreenErrorEventName, onFullScreenChange);
                  _this.setFullPage(false);
                  if (_this.isFullPage()) {
                    _this.element.style.width = _this.fullPageStyleWidth;
                    _this.element.style.height = _this.fullPageStyleHeight;
                  }
                }
                if (_this.navigator && _this.viewport) {
                  setTimeout(function() {
                    _this.navigator.update(_this.viewport);
                  });
                }
                _this.raiseEvent("full-screen", { fullScreen: isFullScreen });
              };
              $.addEvent(document, $.fullScreenEventName, onFullScreenChange);
              $.addEvent(document, $.fullScreenErrorEventName, onFullScreenChange);
              $.requestFullScreen(document.body);
            } else {
              $.exitFullScreen();
            }
            return this;
          },
          /**
           * @function
           * @returns {Boolean}
           */
          isVisible: function() {
            return this.container.style.visibility !== "hidden";
          },
          //
          /**
           * @function
           * @returns {Boolean} returns true if the viewer is in fullscreen
           */
          isFullScreen: function() {
            return $.isFullScreen() && this.isFullPage();
          },
          /**
           * @function
           * @param {Boolean} visible
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:visible
           */
          setVisible: function(visible) {
            this.container.style.visibility = visible ? "" : "hidden";
            this.raiseEvent("visible", { visible });
            return this;
          },
          /**
           * Add a tiled image to the viewer.
           * options.tileSource can be anything that {@link OpenSeadragon.Viewer#open}
           *  supports except arrays of images.
           * Note that you can specify options.width or options.height, but not both.
           * The other dimension will be calculated according to the item's aspect ratio.
           * If collectionMode is on (see {@link OpenSeadragon.Options}), the new image is
           * automatically arranged with the others.
           * @function
           * @param {Object} options
           * @param {String|Object|Function} options.tileSource - The TileSource specifier.
           * A String implies a url used to determine the tileSource implementation
           *      based on the file extension of url. JSONP is implied by *.js,
           *      otherwise the url is retrieved as text and the resulting text is
           *      introspected to determine if its json, xml, or text and parsed.
           * An Object implies an inline configuration which has a single
           *      property sufficient for being able to determine tileSource
           *      implementation. If the object has a property which is a function
           *      named 'getTileUrl', it is treated as a custom TileSource.
           * @param {Number} [options.index] The index of the item. Added on top of
           * all other items if not specified.
           * @param {Boolean} [options.replace=false] If true, the item at options.index will be
           * removed and the new item is added in its place. options.tileSource will be
           * interpreted and fetched if necessary before the old item is removed to avoid leaving
           * a gap in the world.
           * @param {Number} [options.x=0] The X position for the image in viewport coordinates.
           * @param {Number} [options.y=0] The Y position for the image in viewport coordinates.
           * @param {Number} [options.width=1] The width for the image in viewport coordinates.
           * @param {Number} [options.height] The height for the image in viewport coordinates.
           * @param {OpenSeadragon.Rect} [options.fitBounds] The bounds in viewport coordinates
           * to fit the image into. If specified, x, y, width and height get ignored.
           * @param {OpenSeadragon.Placement} [options.fitBoundsPlacement=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds if options.fitBounds is set.
           * @param {OpenSeadragon.Rect} [options.clip] - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @param {Number} [options.opacity=1] Proportional opacity of the tiled images (1=opaque, 0=hidden)
           * @param {Boolean} [options.preload=false]  Default switch for loading hidden images (true loads, false blocks)
           * @param {Number} [options.degrees=0] Initial rotation of the tiled image around
           * its top left corner in degrees.
           * @param {Boolean} [options.flipped=false] Whether to horizontally flip the image.
           * @param {String} [options.compositeOperation] How the image is composited onto other images.
           * @param {String} [options.crossOriginPolicy] The crossOriginPolicy for this specific image,
           * overriding viewer.crossOriginPolicy.
           * @param {Boolean} [options.ajaxWithCredentials] Whether to set withCredentials on tile AJAX
           * @param {Boolean} [options.loadTilesWithAjax]
           *      Whether to load tile data using AJAX requests.
           *      Defaults to the setting in {@link OpenSeadragon.Options}.
           * @param {Object} [options.ajaxHeaders]
           *      A set of headers to include when making tile AJAX requests.
           *      Note that these headers will be merged over any headers specified in {@link OpenSeadragon.Options}.
           *      Specifying a falsy value for a header will clear its existing value set at the Viewer level (if any).
           * @param {Function} [options.success] A function that gets called when the image is
           * successfully added. It's passed the event object which contains a single property:
           * "item", which is the resulting instance of TiledImage.
           * @param {Function} [options.error] A function that gets called if the image is
           * unable to be added. It's passed the error event object, which contains "message"
           * and "source" properties.
           * @param {Boolean} [options.collectionImmediately=false] If collectionMode is on,
           * specifies whether to snap to the new arrangement immediately or to animate to it.
           * @param {String|CanvasGradient|CanvasPattern|Function} [options.placeholderFillStyle] - See {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addTiledImage: function(options) {
            $.console.assert(options, "[Viewer.addTiledImage] options is required");
            $.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
            $.console.assert(
              !options.replace || options.index > -1 && options.index < this.world.getItemCount(),
              "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
            );
            var _this = this;
            if (options.replace) {
              options.replaceItem = _this.world.getItemAt(options.index);
            }
            this._hideMessage();
            if (options.placeholderFillStyle === void 0) {
              options.placeholderFillStyle = this.placeholderFillStyle;
            }
            if (options.opacity === void 0) {
              options.opacity = this.opacity;
            }
            if (options.preload === void 0) {
              options.preload = this.preload;
            }
            if (options.compositeOperation === void 0) {
              options.compositeOperation = this.compositeOperation;
            }
            if (options.crossOriginPolicy === void 0) {
              options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== void 0 ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
            }
            if (options.ajaxWithCredentials === void 0) {
              options.ajaxWithCredentials = this.ajaxWithCredentials;
            }
            if (options.loadTilesWithAjax === void 0) {
              options.loadTilesWithAjax = this.loadTilesWithAjax;
            }
            if (!$.isPlainObject(options.ajaxHeaders)) {
              options.ajaxHeaders = {};
            }
            var myQueueItem = {
              options
            };
            function raiseAddItemFailed(event) {
              for (var i = 0; i < _this._loadQueue.length; i++) {
                if (_this._loadQueue[i] === myQueueItem) {
                  _this._loadQueue.splice(i, 1);
                  break;
                }
              }
              if (_this._loadQueue.length === 0) {
                refreshWorld(myQueueItem);
              }
              _this.raiseEvent("add-item-failed", event);
              if (options.error) {
                options.error(event);
              }
            }
            function refreshWorld(theItem) {
              if (_this.collectionMode) {
                _this.world.arrange({
                  immediately: theItem.options.collectionImmediately,
                  rows: _this.collectionRows,
                  columns: _this.collectionColumns,
                  layout: _this.collectionLayout,
                  tileSize: _this.collectionTileSize,
                  tileMargin: _this.collectionTileMargin
                });
                _this.world.setAutoRefigureSizes(true);
              }
            }
            if ($.isArray(options.tileSource)) {
              setTimeout(function() {
                raiseAddItemFailed({
                  message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                  source: options.tileSource,
                  options
                });
              });
              return;
            }
            this._loadQueue.push(myQueueItem);
            function processReadyItems() {
              var queueItem, tiledImage, optionsClone;
              while (_this._loadQueue.length) {
                queueItem = _this._loadQueue[0];
                if (!queueItem.tileSource) {
                  break;
                }
                _this._loadQueue.splice(0, 1);
                if (queueItem.options.replace) {
                  var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
                  if (newIndex !== -1) {
                    queueItem.options.index = newIndex;
                  }
                  _this.world.removeItem(queueItem.options.replaceItem);
                }
                tiledImage = new $.TiledImage({
                  viewer: _this,
                  source: queueItem.tileSource,
                  viewport: _this.viewport,
                  drawer: _this.drawer,
                  tileCache: _this.tileCache,
                  imageLoader: _this.imageLoader,
                  x: queueItem.options.x,
                  y: queueItem.options.y,
                  width: queueItem.options.width,
                  height: queueItem.options.height,
                  fitBounds: queueItem.options.fitBounds,
                  fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
                  clip: queueItem.options.clip,
                  placeholderFillStyle: queueItem.options.placeholderFillStyle,
                  opacity: queueItem.options.opacity,
                  preload: queueItem.options.preload,
                  degrees: queueItem.options.degrees,
                  flipped: queueItem.options.flipped,
                  compositeOperation: queueItem.options.compositeOperation,
                  springStiffness: _this.springStiffness,
                  animationTime: _this.animationTime,
                  minZoomImageRatio: _this.minZoomImageRatio,
                  wrapHorizontal: _this.wrapHorizontal,
                  wrapVertical: _this.wrapVertical,
                  immediateRender: _this.immediateRender,
                  blendTime: _this.blendTime,
                  alwaysBlend: _this.alwaysBlend,
                  minPixelRatio: _this.minPixelRatio,
                  smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
                  iOSDevice: _this.iOSDevice,
                  crossOriginPolicy: queueItem.options.crossOriginPolicy,
                  ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
                  loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
                  ajaxHeaders: queueItem.options.ajaxHeaders,
                  debugMode: _this.debugMode,
                  subPixelRoundingForTransparency: _this.subPixelRoundingForTransparency
                });
                if (_this.collectionMode) {
                  _this.world.setAutoRefigureSizes(false);
                }
                if (_this.navigator) {
                  optionsClone = $.extend({}, queueItem.options, {
                    replace: false,
                    // navigator already removed the layer, nothing to replace
                    originalTiledImage: tiledImage,
                    tileSource: queueItem.tileSource
                  });
                  _this.navigator.addTiledImage(optionsClone);
                }
                _this.world.addItem(tiledImage, {
                  index: queueItem.options.index
                });
                if (_this._loadQueue.length === 0) {
                  refreshWorld(queueItem);
                }
                if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
                  _this.viewport.goHome(true);
                }
                if (queueItem.options.success) {
                  queueItem.options.success({
                    item: tiledImage
                  });
                }
              }
            }
            getTileSourceImplementation(this, options.tileSource, options, function(tileSource) {
              myQueueItem.tileSource = tileSource;
              processReadyItems();
            }, function(event) {
              event.options = options;
              raiseAddItemFailed(event);
              processReadyItems();
            });
          },
          /**
           * Add a simple image to the viewer.
           * The options are the same as the ones in {@link OpenSeadragon.Viewer#addTiledImage}
           * except for options.tileSource which is replaced by options.url.
           * @function
           * @param {Object} options - See {@link OpenSeadragon.Viewer#addTiledImage}
           * for all the options
           * @param {String} options.url - The URL of the image to add.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.Viewer.event:add-item-failed
           */
          addSimpleImage: function(options) {
            $.console.assert(options, "[Viewer.addSimpleImage] options is required");
            $.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
            var opts = $.extend({}, options, {
              tileSource: {
                type: "image",
                url: options.url
              }
            });
            delete opts.url;
            this.addTiledImage(opts);
          },
          // deprecated
          addLayer: function(options) {
            var _this = this;
            $.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
            var optionsClone = $.extend({}, options, {
              success: function(event) {
                _this.raiseEvent("add-layer", {
                  options,
                  drawer: event.item
                });
              },
              error: function(event) {
                _this.raiseEvent("add-layer-failed", event);
              }
            });
            this.addTiledImage(optionsClone);
            return this;
          },
          // deprecated
          getLayerAtLevel: function(level) {
            $.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead.");
            return this.world.getItemAt(level);
          },
          // deprecated
          getLevelOfLayer: function(drawer) {
            $.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead.");
            return this.world.getIndexOfItem(drawer);
          },
          // deprecated
          getLayersCount: function() {
            $.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead.");
            return this.world.getItemCount();
          },
          // deprecated
          setLayerLevel: function(drawer, level) {
            $.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead.");
            return this.world.setItemIndex(drawer, level);
          },
          // deprecated
          removeLayer: function(drawer) {
            $.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead.");
            return this.world.removeItem(drawer);
          },
          /**
           * Force the viewer to redraw its contents.
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          forceRedraw: function() {
            THIS[this.hash].forceRedraw = true;
            return this;
          },
          /**
           * Force the viewer to reset its size to match its container.
           */
          forceResize: function() {
            THIS[this.hash].needsResize = true;
            THIS[this.hash].forceResize = true;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          bindSequenceControls: function() {
            var onFocusHandler = $.delegate(this, onFocus), onBlurHandler = $.delegate(this, onBlur), onNextHandler = $.delegate(this, this.goToNextPage), onPreviousHandler = $.delegate(this, this.goToPreviousPage), navImages = this.navImages, useGroup = true;
            if (this.showSequenceControl) {
              if (this.previousButton || this.nextButton) {
                useGroup = false;
              }
              this.previousButton = new $.Button({
                element: this.previousButton ? $.getElement(this.previousButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $.getString("Tooltips.PreviousPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.previous.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.previous.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.previous.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.previous.DOWN),
                onRelease: onPreviousHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              });
              this.nextButton = new $.Button({
                element: this.nextButton ? $.getElement(this.nextButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $.getString("Tooltips.NextPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.next.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.next.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.next.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.next.DOWN),
                onRelease: onNextHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              });
              if (!this.navPrevNextWrap) {
                this.previousButton.disable();
              }
              if (!this.tileSources || !this.tileSources.length) {
                this.nextButton.disable();
              }
              if (useGroup) {
                this.paging = new $.ButtonGroup({
                  buttons: [
                    this.previousButton,
                    this.nextButton
                  ],
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold
                });
                this.pagingControl = this.paging.element;
                if (this.toolbar) {
                  this.toolbar.addControl(
                    this.pagingControl,
                    { anchor: $.ControlAnchor.BOTTOM_RIGHT }
                  );
                } else {
                  this.addControl(
                    this.pagingControl,
                    { anchor: this.sequenceControlAnchor || $.ControlAnchor.TOP_LEFT }
                  );
                }
              }
            }
            return this;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           */
          bindStandardControls: function() {
            var beginZoomingInHandler = $.delegate(this, beginZoomingIn), endZoomingHandler = $.delegate(this, endZooming), doSingleZoomInHandler = $.delegate(this, doSingleZoomIn), beginZoomingOutHandler = $.delegate(this, beginZoomingOut), doSingleZoomOutHandler = $.delegate(this, doSingleZoomOut), onHomeHandler = $.delegate(this, onHome), onFullScreenHandler = $.delegate(this, onFullScreen), onRotateLeftHandler = $.delegate(this, onRotateLeft), onRotateRightHandler = $.delegate(this, onRotateRight), onFlipHandler = $.delegate(this, onFlip), onFocusHandler = $.delegate(this, onFocus), onBlurHandler = $.delegate(this, onBlur), navImages = this.navImages, buttons = [], useGroup = true;
            if (this.showNavigationControl) {
              if (this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) {
                useGroup = false;
              }
              if (this.showZoomControl) {
                buttons.push(this.zoomInButton = new $.Button({
                  element: this.zoomInButton ? $.getElement(this.zoomInButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.ZoomIn"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.zoomIn.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.zoomIn.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.zoomIn.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.zoomIn.DOWN),
                  onPress: beginZoomingInHandler,
                  onRelease: endZoomingHandler,
                  onClick: doSingleZoomInHandler,
                  onEnter: beginZoomingInHandler,
                  onExit: endZoomingHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
                buttons.push(this.zoomOutButton = new $.Button({
                  element: this.zoomOutButton ? $.getElement(this.zoomOutButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.ZoomOut"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.zoomOut.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.zoomOut.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.zoomOut.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.zoomOut.DOWN),
                  onPress: beginZoomingOutHandler,
                  onRelease: endZoomingHandler,
                  onClick: doSingleZoomOutHandler,
                  onEnter: beginZoomingOutHandler,
                  onExit: endZoomingHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showHomeControl) {
                buttons.push(this.homeButton = new $.Button({
                  element: this.homeButton ? $.getElement(this.homeButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.Home"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.home.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.home.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.home.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.home.DOWN),
                  onRelease: onHomeHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showFullPageControl) {
                buttons.push(this.fullPageButton = new $.Button({
                  element: this.fullPageButton ? $.getElement(this.fullPageButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.FullPage"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.fullpage.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.fullpage.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.fullpage.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.fullpage.DOWN),
                  onRelease: onFullScreenHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showRotationControl) {
                buttons.push(this.rotateLeftButton = new $.Button({
                  element: this.rotateLeftButton ? $.getElement(this.rotateLeftButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.RotateLeft"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.rotateleft.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.rotateleft.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.rotateleft.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.rotateleft.DOWN),
                  onRelease: onRotateLeftHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
                buttons.push(this.rotateRightButton = new $.Button({
                  element: this.rotateRightButton ? $.getElement(this.rotateRightButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.RotateRight"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.rotateright.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.rotateright.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.rotateright.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.rotateright.DOWN),
                  onRelease: onRotateRightHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showFlipControl) {
                buttons.push(this.flipButton = new $.Button({
                  element: this.flipButton ? $.getElement(this.flipButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $.getString("Tooltips.Flip"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.flip.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.flip.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.flip.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.flip.DOWN),
                  onRelease: onFlipHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (useGroup) {
                this.buttonGroup = new $.ButtonGroup({
                  buttons,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold
                });
                this.navControl = this.buttonGroup.element;
                this.addHandler("open", $.delegate(this, lightUp));
                if (this.toolbar) {
                  this.toolbar.addControl(
                    this.navControl,
                    { anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT }
                  );
                } else {
                  this.addControl(
                    this.navControl,
                    { anchor: this.navigationControlAnchor || $.ControlAnchor.TOP_LEFT }
                  );
                }
              } else {
                this.customButtons = buttons;
              }
            }
            return this;
          },
          /**
           * Gets the active page of a sequence
           * @function
           * @returns {Number}
           */
          currentPage: function() {
            return this._sequenceIndex;
          },
          /**
           * @function
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:page
           */
          goToPage: function(page) {
            if (this.tileSources && page >= 0 && page < this.tileSources.length) {
              this._sequenceIndex = page;
              this._updateSequenceButtons(page);
              this.open(this.tileSources[page]);
              if (this.referenceStrip) {
                this.referenceStrip.setFocus(page);
              }
              this.raiseEvent("page", { page });
            }
            return this;
          },
          /**
            * Adds an html element as an overlay to the current viewport.  Useful for
            * highlighting words or areas of interest on an image or other zoomable
            * interface. The overlays added via this method are removed when the viewport
            * is closed which include when changing page.
            * @method
            * @param {Element|String|Object} element - A reference to an element or an id for
            *      the element which will be overlaid. Or an Object specifying the configuration for the overlay.
            *      If using an object, see {@link OpenSeadragon.Overlay} for a list of
            *      all available options.
            * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
            *      rectangle which will be overlaid. This is a viewport relative location.
            * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
            *      viewport which the location coordinates will be treated as relative
            *      to.
            * @param {function} [onDraw] - If supplied the callback is called when the overlay
            *      needs to be drawn. It it the responsibility of the callback to do any drawing/positioning.
            *      It is passed position, size and element.
            * @returns {OpenSeadragon.Viewer} Chainable.
            * @fires OpenSeadragon.Viewer.event:add-overlay
            */
          addOverlay: function(element, location, placement, onDraw) {
            var options;
            if ($.isPlainObject(element)) {
              options = element;
            } else {
              options = {
                element,
                location,
                placement,
                onDraw
              };
            }
            element = $.getElement(options.element);
            if (getOverlayIndex(this.currentOverlays, element) >= 0) {
              return this;
            }
            var overlay = getOverlayObject(this, options);
            this.currentOverlays.push(overlay);
            overlay.drawHTML(this.overlaysContainer, this.viewport);
            this.raiseEvent("add-overlay", {
              element,
              location: options.location,
              placement: options.placement
            });
            return this;
          },
          /**
           * Updates the overlay represented by the reference to the element or
           * element id moving it to the new location, relative to the new placement.
           * @method
           * @param {Element|String} element - A reference to an element or an id for
           *      the element which is overlaid.
           * @param {OpenSeadragon.Point|OpenSeadragon.Rect} location - The point or
           *      rectangle which will be overlaid. This is a viewport relative location.
           * @param {OpenSeadragon.Placement} [placement=OpenSeadragon.Placement.TOP_LEFT] - The position of the
           *      viewport which the location coordinates will be treated as relative
           *      to.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:update-overlay
           */
          updateOverlay: function(element, location, placement) {
            var i;
            element = $.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
              this.currentOverlays[i].update(location, placement);
              THIS[this.hash].forceRedraw = true;
              this.raiseEvent("update-overlay", {
                element,
                location,
                placement
              });
            }
            return this;
          },
          /**
           * Removes an overlay identified by the reference element or element id
           * and schedules an update.
           * @method
           * @param {Element|String} element - A reference to the element or an
           *      element id which represent the ovelay content to be removed.
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:remove-overlay
           */
          removeOverlay: function(element) {
            var i;
            element = $.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
              this.currentOverlays[i].destroy();
              this.currentOverlays.splice(i, 1);
              THIS[this.hash].forceRedraw = true;
              this.raiseEvent("remove-overlay", {
                element
              });
            }
            return this;
          },
          /**
           * Removes all currently configured Overlays from this Viewer and schedules
           * an update.
           * @method
           * @returns {OpenSeadragon.Viewer} Chainable.
           * @fires OpenSeadragon.Viewer.event:clear-overlay
           */
          clearOverlays: function() {
            while (this.currentOverlays.length > 0) {
              this.currentOverlays.pop().destroy();
            }
            THIS[this.hash].forceRedraw = true;
            this.raiseEvent("clear-overlay", {});
            return this;
          },
          /**
          * Finds an overlay identified by the reference element or element id
          * and returns it as an object, return null if not found.
          * @method
          * @param {Element|String} element - A reference to the element or an
          *      element id which represents the overlay content.
          * @returns {OpenSeadragon.Overlay} the matching overlay or null if none found.
          */
          getOverlayById: function(element) {
            var i;
            element = $.getElement(element);
            i = getOverlayIndex(this.currentOverlays, element);
            if (i >= 0) {
              return this.currentOverlays[i];
            } else {
              return null;
            }
          },
          /**
           * Updates the sequence buttons.
           * @function OpenSeadragon.Viewer.prototype._updateSequenceButtons
           * @private
           * @param {Number} Sequence Value
           */
          _updateSequenceButtons: function(page) {
            if (this.nextButton) {
              if (!this.tileSources || this.tileSources.length - 1 === page) {
                if (!this.navPrevNextWrap) {
                  this.nextButton.disable();
                }
              } else {
                this.nextButton.enable();
              }
            }
            if (this.previousButton) {
              if (page > 0) {
                this.previousButton.enable();
              } else {
                if (!this.navPrevNextWrap) {
                  this.previousButton.disable();
                }
              }
            }
          },
          /**
           * Display a message in the viewport
           * @function OpenSeadragon.Viewer.prototype._showMessage
           * @private
           * @param {String} text message
           */
          _showMessage: function(message) {
            this._hideMessage();
            var div = $.makeNeutralElement("div");
            div.appendChild(document.createTextNode(message));
            this.messageDiv = $.makeCenteredNode(div);
            $.addClass(this.messageDiv, "openseadragon-message");
            this.container.appendChild(this.messageDiv);
          },
          /**
           * Hide any currently displayed viewport message
           * @function OpenSeadragon.Viewer.prototype._hideMessage
           * @private
           */
          _hideMessage: function() {
            var div = this.messageDiv;
            if (div) {
              div.parentNode.removeChild(div);
              delete this.messageDiv;
            }
          },
          /**
           * Gets this viewer's gesture settings for the given pointer device type.
           * @method
           * @param {String} type - The pointer device type to get the gesture settings for ("mouse", "touch", "pen", etc.).
           * @returns {OpenSeadragon.GestureSettings}
           */
          gestureSettingsByDeviceType: function(type) {
            switch (type) {
              case "mouse":
                return this.gestureSettingsMouse;
              case "touch":
                return this.gestureSettingsTouch;
              case "pen":
                return this.gestureSettingsPen;
              default:
                return this.gestureSettingsUnknown;
            }
          },
          // private
          _drawOverlays: function() {
            var i, length = this.currentOverlays.length;
            for (i = 0; i < length; i++) {
              this.currentOverlays[i].drawHTML(this.overlaysContainer, this.viewport);
            }
          },
          /**
           * Cancel the "in flight" images.
           */
          _cancelPendingImages: function() {
            this._loadQueue = [];
          },
          /**
           * Removes the reference strip and disables displaying it.
           * @function
           */
          removeReferenceStrip: function() {
            this.showReferenceStrip = false;
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
          },
          /**
           * Enables and displays the reference strip based on the currently set tileSources.
           * Works only when the Viewer has sequenceMode set to true.
           * @function
           */
          addReferenceStrip: function() {
            this.showReferenceStrip = true;
            if (this.sequenceMode) {
              if (this.referenceStrip) {
                return;
              }
              if (this.tileSources.length && this.tileSources.length > 1) {
                this.referenceStrip = new $.ReferenceStrip({
                  id: this.referenceStripElement,
                  position: this.referenceStripPosition,
                  sizeRatio: this.referenceStripSizeRatio,
                  scroll: this.referenceStripScroll,
                  height: this.referenceStripHeight,
                  width: this.referenceStripWidth,
                  tileSources: this.tileSources,
                  prefixUrl: this.prefixUrl,
                  useCanvas: this.useCanvas,
                  viewer: this
                });
                this.referenceStrip.setFocus(this._sequenceIndex);
              }
            } else {
              $.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
            }
          },
          /**
           * Adds _updatePixelDensityRatio to the window resize event.
           * @private
           */
          _addUpdatePixelDensityRatioEvent: function() {
            this._updatePixelDensityRatioBind = this._updatePixelDensityRatio.bind(this);
            $.addEvent(window, "resize", this._updatePixelDensityRatioBind);
          },
          /**
           * Removes _updatePixelDensityRatio from the window resize event.
           * @private
           */
          _removeUpdatePixelDensityRatioEvent: function() {
            $.removeEvent(window, "resize", this._updatePixelDensityRatioBind);
          },
          /**
           * Update pixel density ratio, clears all tiles and triggers updates for
           * all items if the ratio has changed.
           * @private
           */
          _updatePixelDensityRatio: function() {
            var previusPixelDensityRatio = $.pixelDensityRatio;
            var currentPixelDensityRatio = $.getCurrentPixelDensityRatio();
            if (previusPixelDensityRatio !== currentPixelDensityRatio) {
              $.pixelDensityRatio = currentPixelDensityRatio;
              this.world.resetItems();
              this.forceRedraw();
            }
          },
          /**
           * Sets the image source to the source with index equal to
           * currentIndex - 1. Changes current image in sequence mode.
           * If specified, wraps around (see navPrevNextWrap in
           * {@link OpenSeadragon.Options})
           *
           * @method
           */
          goToPreviousPage: function() {
            var previous = this._sequenceIndex - 1;
            if (this.navPrevNextWrap && previous < 0) {
              previous += this.tileSources.length;
            }
            this.goToPage(previous);
          },
          /**
           * Sets the image source to the source with index equal to
           * currentIndex + 1. Changes current image in sequence mode.
           * If specified, wraps around (see navPrevNextWrap in
           * {@link OpenSeadragon.Options})
           *
           * @method
           */
          goToNextPage: function() {
            var next = this._sequenceIndex + 1;
            if (this.navPrevNextWrap && next >= this.tileSources.length) {
              next = 0;
            }
            this.goToPage(next);
          },
          isAnimating: function() {
            return THIS[this.hash].animating;
          }
        }
      );
      function _getSafeElemSize(oElement) {
        oElement = $.getElement(oElement);
        return new $.Point(
          oElement.clientWidth === 0 ? 1 : oElement.clientWidth,
          oElement.clientHeight === 0 ? 1 : oElement.clientHeight
        );
      }
      function getTileSourceImplementation(viewer, tileSource, imgOptions, successCallback, failCallback) {
        var _this = viewer;
        if ($.type(tileSource) === "string") {
          if (tileSource.match(/^\s*<.*>\s*$/)) {
            tileSource = $.parseXml(tileSource);
          } else if (tileSource.match(/^\s*[{[].*[}\]]\s*$/)) {
            try {
              var tileSourceJ = $.parseJSON(tileSource);
              tileSource = tileSourceJ;
            } catch (e) {
            }
          }
        }
        function waitUntilReady(tileSource2, originalTileSource) {
          if (tileSource2.ready) {
            successCallback(tileSource2);
          } else {
            tileSource2.addHandler("ready", function() {
              successCallback(tileSource2);
            });
            tileSource2.addHandler("open-failed", function(event) {
              failCallback({
                message: event.message,
                source: originalTileSource
              });
            });
          }
        }
        setTimeout(function() {
          if ($.type(tileSource) === "string") {
            tileSource = new $.TileSource({
              url: tileSource,
              crossOriginPolicy: imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
              ajaxWithCredentials: viewer.ajaxWithCredentials,
              ajaxHeaders: imgOptions.ajaxHeaders ? imgOptions.ajaxHeaders : viewer.ajaxHeaders,
              splitHashDataForPost: viewer.splitHashDataForPost,
              useCanvas: viewer.useCanvas,
              success: function(event) {
                successCallback(event.tileSource);
              }
            });
            tileSource.addHandler("open-failed", function(event) {
              failCallback(event);
            });
          } else if ($.isPlainObject(tileSource) || tileSource.nodeType) {
            if (tileSource.crossOriginPolicy === void 0 && (imgOptions.crossOriginPolicy !== void 0 || viewer.crossOriginPolicy !== void 0)) {
              tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
            }
            if (tileSource.ajaxWithCredentials === void 0) {
              tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
            }
            if (tileSource.useCanvas === void 0) {
              tileSource.useCanvas = viewer.useCanvas;
            }
            if ($.isFunction(tileSource.getTileUrl)) {
              var customTileSource = new $.TileSource(tileSource);
              customTileSource.getTileUrl = tileSource.getTileUrl;
              successCallback(customTileSource);
            } else {
              var $TileSource = $.TileSource.determineType(_this, tileSource);
              if (!$TileSource) {
                failCallback({
                  message: "Unable to load TileSource",
                  source: tileSource
                });
                return;
              }
              var options = $TileSource.prototype.configure.apply(_this, [tileSource]);
              waitUntilReady(new $TileSource(options), tileSource);
            }
          } else {
            waitUntilReady(tileSource, tileSource);
          }
        });
      }
      function getOverlayObject(viewer, overlay) {
        if (overlay instanceof $.Overlay) {
          return overlay;
        }
        var element = null;
        if (overlay.element) {
          element = $.getElement(overlay.element);
        } else {
          var id = overlay.id ? overlay.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
          element = $.getElement(overlay.id);
          if (!element) {
            element = document.createElement("a");
            element.href = "#/overlay/" + id;
          }
          element.id = id;
          $.addClass(
            element,
            overlay.className ? overlay.className : "openseadragon-overlay"
          );
        }
        var location = overlay.location;
        var width = overlay.width;
        var height = overlay.height;
        if (!location) {
          var x = overlay.x;
          var y = overlay.y;
          if (overlay.px !== void 0) {
            var rect = viewer.viewport.imageToViewportRectangle(new $.Rect(
              overlay.px,
              overlay.py,
              width || 0,
              height || 0
            ));
            x = rect.x;
            y = rect.y;
            width = width !== void 0 ? rect.width : void 0;
            height = height !== void 0 ? rect.height : void 0;
          }
          location = new $.Point(x, y);
        }
        var placement = overlay.placement;
        if (placement && $.type(placement) === "string") {
          placement = $.Placement[overlay.placement.toUpperCase()];
        }
        return new $.Overlay({
          element,
          location,
          placement,
          onDraw: overlay.onDraw,
          checkResize: overlay.checkResize,
          width,
          height,
          rotationMode: overlay.rotationMode
        });
      }
      function getOverlayIndex(overlays, element) {
        var i;
        for (i = overlays.length - 1; i >= 0; i--) {
          if (overlays[i].element === element) {
            return i;
          }
        }
        return -1;
      }
      function scheduleUpdate(viewer, updateFunc) {
        return $.requestAnimationFrame(function() {
          updateFunc(viewer);
        });
      }
      function scheduleControlsFade(viewer) {
        $.requestAnimationFrame(function() {
          updateControlsFade(viewer);
        });
      }
      function beginControlsAutoHide(viewer) {
        if (!viewer.autoHideControls) {
          return;
        }
        viewer.controlsShouldFade = true;
        viewer.controlsFadeBeginTime = $.now() + viewer.controlsFadeDelay;
        window.setTimeout(function() {
          scheduleControlsFade(viewer);
        }, viewer.controlsFadeDelay);
      }
      function updateControlsFade(viewer) {
        var currentTime, deltaTime, opacity, i;
        if (viewer.controlsShouldFade) {
          currentTime = $.now();
          deltaTime = currentTime - viewer.controlsFadeBeginTime;
          opacity = 1 - deltaTime / viewer.controlsFadeLength;
          opacity = Math.min(1, opacity);
          opacity = Math.max(0, opacity);
          for (i = viewer.controls.length - 1; i >= 0; i--) {
            if (viewer.controls[i].autoFade) {
              viewer.controls[i].setOpacity(opacity);
            }
          }
          if (opacity > 0) {
            scheduleControlsFade(viewer);
          }
        }
      }
      function abortControlsAutoHide(viewer) {
        var i;
        viewer.controlsShouldFade = false;
        for (i = viewer.controls.length - 1; i >= 0; i--) {
          viewer.controls[i].setOpacity(1);
        }
      }
      function onFocus() {
        abortControlsAutoHide(this);
      }
      function onBlur() {
        beginControlsAutoHide(this);
      }
      function onCanvasContextMenu(event) {
        var eventArgs = {
          tracker: event.eventSource,
          position: event.position,
          originalEvent: event.originalEvent,
          preventDefault: event.preventDefault
        };
        this.raiseEvent("canvas-contextmenu", eventArgs);
        event.preventDefault = eventArgs.preventDefault;
      }
      function onCanvasKeyDown(event) {
        var canvasKeyDownEventArgs = {
          originalEvent: event.originalEvent,
          preventDefaultAction: false,
          preventVerticalPan: event.preventVerticalPan || !this.panVertical,
          preventHorizontalPan: event.preventHorizontalPan || !this.panHorizontal
        };
        this.raiseEvent("canvas-key", canvasKeyDownEventArgs);
        if (!canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 38:
              if (!canvasKeyDownEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(1.1);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -this.pixelsPerArrowPress)));
                }
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 40:
              if (!canvasKeyDownEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(0.9);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, this.pixelsPerArrowPress)));
                }
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 37:
              if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-this.pixelsPerArrowPress, 0)));
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 39:
              if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(this.pixelsPerArrowPress, 0)));
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 187:
              this.viewport.zoomBy(1.1);
              this.viewport.applyConstraints();
              event.preventDefault = true;
              break;
            case 189:
              this.viewport.zoomBy(0.9);
              this.viewport.applyConstraints();
              event.preventDefault = true;
              break;
            case 48:
              this.viewport.goHome();
              this.viewport.applyConstraints();
              event.preventDefault = true;
              break;
            case 87:
              if (!canvasKeyDownEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(1.1);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, -40)));
                }
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 83:
              if (!canvasKeyDownEventArgs.preventVerticalPan) {
                if (event.shift) {
                  this.viewport.zoomBy(0.9);
                } else {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(0, 40)));
                }
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 65:
              if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(-40, 0)));
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 68:
              if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $.Point(40, 0)));
                this.viewport.applyConstraints();
              }
              event.preventDefault = true;
              break;
            case 82:
              if (event.shift) {
                if (this.viewport.flipped) {
                  this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
                } else {
                  this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
                }
              } else {
                if (this.viewport.flipped) {
                  this.viewport.setRotation(this.viewport.getRotation() - this.rotationIncrement);
                } else {
                  this.viewport.setRotation(this.viewport.getRotation() + this.rotationIncrement);
                }
              }
              this.viewport.applyConstraints();
              event.preventDefault = true;
              break;
            case 70:
              this.viewport.toggleFlip();
              event.preventDefault = true;
              break;
            case 74:
              this.goToPreviousPage();
              break;
            case 75:
              this.goToNextPage();
              break;
            default:
              event.preventDefault = false;
              break;
          }
        } else {
          event.preventDefault = false;
        }
      }
      function onCanvasKeyPress(event) {
        var canvasKeyPressEventArgs = {
          originalEvent: event.originalEvent
        };
        this.raiseEvent("canvas-key-press", canvasKeyPressEventArgs);
      }
      function onCanvasClick(event) {
        var gestureSettings;
        var haveKeyboardFocus = document.activeElement === this.canvas;
        if (!haveKeyboardFocus) {
          this.canvas.focus();
        }
        if (this.viewport.flipped) {
          event.position.x = this.viewport.getContainerSize().x - event.position.x;
        }
        var canvasClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          quick: event.quick,
          shift: event.shift,
          originalEvent: event.originalEvent,
          originalTarget: event.originalTarget,
          preventDefaultAction: false
        };
        this.raiseEvent("canvas-click", canvasClickEventArgs);
        if (!canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.clickToZoom === true) {
            this.viewport.zoomBy(
              event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
              gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
            );
            this.viewport.applyConstraints();
          }
          if (gestureSettings.dblClickDragToZoom) {
            if (THIS[this.hash].draggingToZoom === true) {
              THIS[this.hash].lastClickTime = null;
              THIS[this.hash].draggingToZoom = false;
            } else {
              THIS[this.hash].lastClickTime = $.now();
            }
          }
        }
      }
      function onCanvasDblClick(event) {
        var gestureSettings;
        var canvasDblClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false
        };
        this.raiseEvent("canvas-double-click", canvasDblClickEventArgs);
        if (!canvasDblClickEventArgs.preventDefaultAction && this.viewport) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.dblClickToZoom) {
            this.viewport.zoomBy(
              event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
              gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
            );
            this.viewport.applyConstraints();
          }
        }
      }
      function onCanvasDrag(event) {
        var gestureSettings;
        var canvasDragEventArgs = {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          delta: event.delta,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false
        };
        this.raiseEvent("canvas-drag", canvasDragEventArgs);
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (!canvasDragEventArgs.preventDefaultAction && this.viewport) {
          if (gestureSettings.dblClickDragToZoom && THIS[this.hash].draggingToZoom) {
            var factor = Math.pow(this.zoomPerDblClickDrag, event.delta.y / 50);
            this.viewport.zoomBy(factor);
          } else if (gestureSettings.dragToPan && !THIS[this.hash].draggingToZoom) {
            if (!this.panHorizontal) {
              event.delta.x = 0;
            }
            if (!this.panVertical) {
              event.delta.y = 0;
            }
            if (this.viewport.flipped) {
              event.delta.x = -event.delta.x;
            }
            if (this.constrainDuringPan) {
              var delta = this.viewport.deltaPointsFromPixels(event.delta.negate());
              this.viewport.centerSpringX.target.value += delta.x;
              this.viewport.centerSpringY.target.value += delta.y;
              var constrainedBounds = this.viewport.getConstrainedBounds();
              this.viewport.centerSpringX.target.value -= delta.x;
              this.viewport.centerSpringY.target.value -= delta.y;
              if (constrainedBounds.xConstrained) {
                event.delta.x = 0;
              }
              if (constrainedBounds.yConstrained) {
                event.delta.y = 0;
              }
            }
            this.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta.negate()), gestureSettings.flickEnabled && !this.constrainDuringPan);
          }
        }
      }
      function onCanvasDragEnd(event) {
        var gestureSettings;
        var canvasDragEndEventArgs = {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false
        };
        this.raiseEvent("canvas-drag-end", canvasDragEndEventArgs);
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (!canvasDragEndEventArgs.preventDefaultAction && this.viewport) {
          if (!THIS[this.hash].draggingToZoom && gestureSettings.flickEnabled && event.speed >= gestureSettings.flickMinSpeed) {
            var amplitudeX = 0;
            if (this.panHorizontal) {
              amplitudeX = gestureSettings.flickMomentum * event.speed * Math.cos(event.direction);
            }
            var amplitudeY = 0;
            if (this.panVertical) {
              amplitudeY = gestureSettings.flickMomentum * event.speed * Math.sin(event.direction);
            }
            var center = this.viewport.pixelFromPoint(
              this.viewport.getCenter(true)
            );
            var target = this.viewport.pointFromPixel(
              new $.Point(center.x - amplitudeX, center.y - amplitudeY)
            );
            this.viewport.panTo(target, false);
          }
          this.viewport.applyConstraints();
        }
        if (gestureSettings.dblClickDragToZoom && THIS[this.hash].draggingToZoom === true) {
          THIS[this.hash].draggingToZoom = false;
        }
      }
      function onCanvasEnter(event) {
        this.raiseEvent("canvas-enter", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasLeave(event) {
        this.raiseEvent("canvas-exit", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasPress(event) {
        var gestureSettings;
        this.raiseEvent("canvas-press", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          insideElementPressed: event.insideElementPressed,
          insideElementReleased: event.insideElementReleased,
          originalEvent: event.originalEvent
        });
        gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
        if (gestureSettings.dblClickDragToZoom) {
          var lastClickTime = THIS[this.hash].lastClickTime;
          var currClickTime = $.now();
          if (lastClickTime === null) {
            return;
          }
          if (currClickTime - lastClickTime < this.dblClickTimeThreshold) {
            THIS[this.hash].draggingToZoom = true;
          }
          THIS[this.hash].lastClickTime = null;
        }
      }
      function onCanvasRelease(event) {
        this.raiseEvent("canvas-release", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          insideElementPressed: event.insideElementPressed,
          insideElementReleased: event.insideElementReleased,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasNonPrimaryPress(event) {
        this.raiseEvent("canvas-nonprimary-press", {
          tracker: event.eventSource,
          position: event.position,
          pointerType: event.pointerType,
          button: event.button,
          buttons: event.buttons,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasNonPrimaryRelease(event) {
        this.raiseEvent("canvas-nonprimary-release", {
          tracker: event.eventSource,
          position: event.position,
          pointerType: event.pointerType,
          button: event.button,
          buttons: event.buttons,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasPinch(event) {
        var gestureSettings, centerPt, lastCenterPt, panByPt;
        var canvasPinchEventArgs = {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          gesturePoints: event.gesturePoints,
          lastCenter: event.lastCenter,
          center: event.center,
          lastDistance: event.lastDistance,
          distance: event.distance,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultPanAction: false,
          preventDefaultZoomAction: false,
          preventDefaultRotateAction: false
        };
        this.raiseEvent("canvas-pinch", canvasPinchEventArgs);
        if (this.viewport) {
          gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
          if (gestureSettings.pinchToZoom && (!canvasPinchEventArgs.preventDefaultPanAction || !canvasPinchEventArgs.preventDefaultZoomAction)) {
            centerPt = this.viewport.pointFromPixel(event.center, true);
            if (gestureSettings.zoomToRefPoint && !canvasPinchEventArgs.preventDefaultPanAction) {
              lastCenterPt = this.viewport.pointFromPixel(event.lastCenter, true);
              panByPt = lastCenterPt.minus(centerPt);
              if (!this.panHorizontal) {
                panByPt.x = 0;
              }
              if (!this.panVertical) {
                panByPt.y = 0;
              }
              this.viewport.panBy(panByPt, true);
            }
            if (!canvasPinchEventArgs.preventDefaultZoomAction) {
              this.viewport.zoomBy(event.distance / event.lastDistance, centerPt, true);
            }
            this.viewport.applyConstraints();
          }
          if (gestureSettings.pinchRotate && !canvasPinchEventArgs.preventDefaultRotateAction) {
            var angle1 = Math.atan2(
              event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
              event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x
            );
            var angle2 = Math.atan2(
              event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
              event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x
            );
            centerPt = this.viewport.pointFromPixel(event.center, true);
            this.viewport.rotateTo(this.viewport.getRotation(true) + (angle1 - angle2) * (180 / Math.PI), centerPt, true);
          }
        }
      }
      function onCanvasFocus(event) {
        this.raiseEvent("canvas-focus", {
          tracker: event.eventSource,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasBlur(event) {
        this.raiseEvent("canvas-blur", {
          tracker: event.eventSource,
          originalEvent: event.originalEvent
        });
      }
      function onCanvasScroll(event) {
        var canvasScrollEventArgs, gestureSettings, factor, thisScrollTime, deltaScrollTime;
        thisScrollTime = $.now();
        deltaScrollTime = thisScrollTime - this._lastScrollTime;
        if (deltaScrollTime > this.minScrollDeltaTime) {
          this._lastScrollTime = thisScrollTime;
          canvasScrollEventArgs = {
            tracker: event.eventSource,
            position: event.position,
            scroll: event.scroll,
            shift: event.shift,
            originalEvent: event.originalEvent,
            preventDefaultAction: false,
            preventDefault: true
          };
          this.raiseEvent("canvas-scroll", canvasScrollEventArgs);
          if (!canvasScrollEventArgs.preventDefaultAction && this.viewport) {
            if (this.viewport.flipped) {
              event.position.x = this.viewport.getContainerSize().x - event.position.x;
            }
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.scrollToZoom) {
              factor = Math.pow(this.zoomPerScroll, event.scroll);
              this.viewport.zoomBy(
                factor,
                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
              );
              this.viewport.applyConstraints();
            }
          }
          event.preventDefault = canvasScrollEventArgs.preventDefault;
        } else {
          event.preventDefault = true;
        }
      }
      function onContainerEnter(event) {
        THIS[this.hash].mouseInside = true;
        abortControlsAutoHide(this);
        this.raiseEvent("container-enter", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function onContainerLeave(event) {
        if (event.pointers < 1) {
          THIS[this.hash].mouseInside = false;
          if (!THIS[this.hash].animating) {
            beginControlsAutoHide(this);
          }
        }
        this.raiseEvent("container-exit", {
          tracker: event.eventSource,
          pointerType: event.pointerType,
          position: event.position,
          buttons: event.buttons,
          pointers: event.pointers,
          insideElementPressed: event.insideElementPressed,
          buttonDownAny: event.buttonDownAny,
          originalEvent: event.originalEvent
        });
      }
      function updateMulti(viewer) {
        updateOnce(viewer);
        if (viewer.isOpen()) {
          viewer._updateRequestId = scheduleUpdate(viewer, updateMulti);
        } else {
          viewer._updateRequestId = false;
        }
      }
      function doViewerResize(viewer, containerSize) {
        var viewport = viewer.viewport;
        var zoom = viewport.getZoom();
        var center = viewport.getCenter();
        viewport.resize(containerSize, viewer.preserveImageSizeOnResize);
        viewport.panTo(center, true);
        var resizeRatio;
        if (viewer.preserveImageSizeOnResize) {
          resizeRatio = THIS[viewer.hash].prevContainerSize.x / containerSize.x;
        } else {
          var origin = new $.Point(0, 0);
          var prevDiag = new $.Point(THIS[viewer.hash].prevContainerSize.x, THIS[viewer.hash].prevContainerSize.y).distanceTo(origin);
          var newDiag = new $.Point(containerSize.x, containerSize.y).distanceTo(origin);
          resizeRatio = newDiag / prevDiag * THIS[viewer.hash].prevContainerSize.x / containerSize.x;
        }
        viewport.zoomTo(zoom * resizeRatio, null, true);
        THIS[viewer.hash].prevContainerSize = containerSize;
        THIS[viewer.hash].forceRedraw = true;
        THIS[viewer.hash].needsResize = false;
        THIS[viewer.hash].forceResize = false;
      }
      function updateOnce(viewer) {
        if (viewer._opening || !THIS[viewer.hash]) {
          return;
        }
        if (viewer.autoResize || THIS[viewer.hash].forceResize) {
          var containerSize;
          if (viewer._autoResizePolling) {
            containerSize = _getSafeElemSize(viewer.container);
            var prevContainerSize = THIS[viewer.hash].prevContainerSize;
            if (!containerSize.equals(prevContainerSize)) {
              THIS[viewer.hash].needsResize = true;
            }
          }
          if (THIS[viewer.hash].needsResize) {
            doViewerResize(viewer, containerSize || _getSafeElemSize(viewer.container));
          }
        }
        var viewportChange = viewer.viewport.update();
        var animated = viewer.world.update() || viewportChange;
        if (viewportChange) {
          viewer.raiseEvent("viewport-change");
        }
        if (viewer.referenceStrip) {
          animated = viewer.referenceStrip.update(viewer.viewport) || animated;
        }
        var currentAnimating = THIS[viewer.hash].animating;
        if (!currentAnimating && animated) {
          viewer.raiseEvent("animation-start");
          abortControlsAutoHide(viewer);
        }
        var isAnimationFinished = currentAnimating && !animated;
        if (isAnimationFinished) {
          THIS[viewer.hash].animating = false;
        }
        if (animated || isAnimationFinished || THIS[viewer.hash].forceRedraw || viewer.world.needsDraw()) {
          drawWorld(viewer);
          viewer._drawOverlays();
          if (viewer.navigator) {
            viewer.navigator.update(viewer.viewport);
          }
          THIS[viewer.hash].forceRedraw = false;
          if (animated) {
            viewer.raiseEvent("animation");
          }
        }
        if (isAnimationFinished) {
          viewer.raiseEvent("animation-finish");
          if (!THIS[viewer.hash].mouseInside) {
            beginControlsAutoHide(viewer);
          }
        }
        THIS[viewer.hash].animating = animated;
      }
      function drawWorld(viewer) {
        viewer.imageLoader.clear();
        viewer.drawer.clear();
        viewer.world.draw();
        viewer.raiseEvent("update-viewport", {});
      }
      function resolveUrl(prefix, url) {
        return prefix ? prefix + url : url;
      }
      function beginZoomingIn() {
        THIS[this.hash].lastZoomTime = $.now();
        THIS[this.hash].zoomFactor = this.zoomPerSecond;
        THIS[this.hash].zooming = true;
        scheduleZoom(this);
      }
      function beginZoomingOut() {
        THIS[this.hash].lastZoomTime = $.now();
        THIS[this.hash].zoomFactor = 1 / this.zoomPerSecond;
        THIS[this.hash].zooming = true;
        scheduleZoom(this);
      }
      function endZooming() {
        THIS[this.hash].zooming = false;
      }
      function scheduleZoom(viewer) {
        $.requestAnimationFrame($.delegate(viewer, doZoom));
      }
      function doZoom() {
        var currentTime, deltaTime, adjustedFactor;
        if (THIS[this.hash].zooming && this.viewport) {
          currentTime = $.now();
          deltaTime = currentTime - THIS[this.hash].lastZoomTime;
          adjustedFactor = Math.pow(THIS[this.hash].zoomFactor, deltaTime / 1e3);
          this.viewport.zoomBy(adjustedFactor);
          this.viewport.applyConstraints();
          THIS[this.hash].lastZoomTime = currentTime;
          scheduleZoom(this);
        }
      }
      function doSingleZoomIn() {
        if (this.viewport) {
          THIS[this.hash].zooming = false;
          this.viewport.zoomBy(
            this.zoomPerClick / 1
          );
          this.viewport.applyConstraints();
        }
      }
      function doSingleZoomOut() {
        if (this.viewport) {
          THIS[this.hash].zooming = false;
          this.viewport.zoomBy(
            1 / this.zoomPerClick
          );
          this.viewport.applyConstraints();
        }
      }
      function lightUp() {
        if (this.buttonGroup) {
          this.buttonGroup.emulateEnter();
          this.buttonGroup.emulateLeave();
        }
      }
      function onHome() {
        if (this.viewport) {
          this.viewport.goHome();
        }
      }
      function onFullScreen() {
        if (this.isFullPage() && !$.isFullScreen()) {
          this.setFullPage(false);
        } else {
          this.setFullScreen(!this.isFullPage());
        }
        if (this.buttonGroup) {
          this.buttonGroup.emulateLeave();
        }
        this.fullPageButton.element.focus();
        if (this.viewport) {
          this.viewport.applyConstraints();
        }
      }
      function onRotateLeft() {
        if (this.viewport) {
          var currRotation = this.viewport.getRotation();
          if (this.viewport.flipped) {
            currRotation += this.rotationIncrement;
          } else {
            currRotation -= this.rotationIncrement;
          }
          this.viewport.setRotation(currRotation);
        }
      }
      function onRotateRight() {
        if (this.viewport) {
          var currRotation = this.viewport.getRotation();
          if (this.viewport.flipped) {
            currRotation -= this.rotationIncrement;
          } else {
            currRotation += this.rotationIncrement;
          }
          this.viewport.setRotation(currRotation);
        }
      }
      function onFlip() {
        this.viewport.toggleFlip();
      }
    })(OpenSeadragon);
    (function($) {
      $.Navigator = function(options) {
        var viewer = options.viewer, _this = this, viewerSize, navigatorSize;
        if (options.element || options.id) {
          if (options.element) {
            if (options.id) {
              $.console.warn("Given option.id for Navigator was ignored since option.element was provided and is being used instead.");
            }
            if (options.element.id) {
              options.id = options.element.id;
            } else {
              options.id = "navigator-" + $.now();
            }
            this.element = options.element;
          } else {
            this.element = document.getElementById(options.id);
          }
          options.controlOptions = {
            anchor: $.ControlAnchor.NONE,
            attachToViewer: false,
            autoFade: false
          };
        } else {
          options.id = "navigator-" + $.now();
          this.element = $.makeNeutralElement("div");
          options.controlOptions = {
            anchor: $.ControlAnchor.TOP_RIGHT,
            attachToViewer: true,
            autoFade: options.autoFade
          };
          if (options.position) {
            if ("BOTTOM_RIGHT" === options.position) {
              options.controlOptions.anchor = $.ControlAnchor.BOTTOM_RIGHT;
            } else if ("BOTTOM_LEFT" === options.position) {
              options.controlOptions.anchor = $.ControlAnchor.BOTTOM_LEFT;
            } else if ("TOP_RIGHT" === options.position) {
              options.controlOptions.anchor = $.ControlAnchor.TOP_RIGHT;
            } else if ("TOP_LEFT" === options.position) {
              options.controlOptions.anchor = $.ControlAnchor.TOP_LEFT;
            } else if ("ABSOLUTE" === options.position) {
              options.controlOptions.anchor = $.ControlAnchor.ABSOLUTE;
              options.controlOptions.top = options.top;
              options.controlOptions.left = options.left;
              options.controlOptions.height = options.height;
              options.controlOptions.width = options.width;
            }
          }
        }
        this.element.id = options.id;
        this.element.className += " navigator";
        options = $.extend(true, {
          sizeRatio: $.DEFAULT_SETTINGS.navigatorSizeRatio
        }, options, {
          element: this.element,
          tabIndex: -1,
          // No keyboard navigation, omit from tab order
          //These need to be overridden to prevent recursion since
          //the navigator is a viewer and a viewer has a navigator
          showNavigator: false,
          mouseNavEnabled: false,
          showNavigationControl: false,
          showSequenceControl: false,
          immediateRender: true,
          blendTime: 0,
          animationTime: options.animationTime,
          // disable autoResize since resize behavior is implemented differently by the navigator
          autoResize: false,
          // prevent resizing the navigator from adding unwanted space around the image
          minZoomImageRatio: 1,
          background: options.background,
          opacity: options.opacity,
          borderColor: options.borderColor,
          displayRegionColor: options.displayRegionColor
        });
        options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
        $.setElementTouchActionNone(this.element);
        this.borderWidth = 2;
        this.fudge = new $.Point(1, 1);
        this.totalBorderWidths = new $.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
        if (options.controlOptions.anchor !== $.ControlAnchor.NONE) {
          (function(style, borderWidth) {
            style.margin = "0px";
            style.border = borderWidth + "px solid " + options.borderColor;
            style.padding = "0px";
            style.background = options.background;
            style.opacity = options.opacity;
            style.overflow = "hidden";
          })(this.element.style, this.borderWidth);
        }
        this.displayRegion = $.makeNeutralElement("div");
        this.displayRegion.id = this.element.id + "-displayregion";
        this.displayRegion.className = "displayregion";
        (function(style, borderWidth) {
          style.position = "relative";
          style.top = "0px";
          style.left = "0px";
          style.fontSize = "0px";
          style.overflow = "hidden";
          style.border = borderWidth + "px solid " + options.displayRegionColor;
          style.margin = "0px";
          style.padding = "0px";
          style.background = "transparent";
          style["float"] = "left";
          style.cssFloat = "left";
          style.styleFloat = "left";
          style.zIndex = 999999999;
          style.cursor = "default";
          style.boxSizing = "content-box";
        })(this.displayRegion.style, this.borderWidth);
        $.setElementPointerEventsNone(this.displayRegion);
        $.setElementTouchActionNone(this.displayRegion);
        this.displayRegionContainer = $.makeNeutralElement("div");
        this.displayRegionContainer.id = this.element.id + "-displayregioncontainer";
        this.displayRegionContainer.className = "displayregioncontainer";
        this.displayRegionContainer.style.width = "100%";
        this.displayRegionContainer.style.height = "100%";
        $.setElementPointerEventsNone(this.displayRegionContainer);
        $.setElementTouchActionNone(this.displayRegionContainer);
        viewer.addControl(
          this.element,
          options.controlOptions
        );
        this._resizeWithViewer = options.controlOptions.anchor !== $.ControlAnchor.ABSOLUTE && options.controlOptions.anchor !== $.ControlAnchor.NONE;
        if (options.width && options.height) {
          this.setWidth(options.width);
          this.setHeight(options.height);
        } else if (this._resizeWithViewer) {
          viewerSize = $.getElementSize(viewer.element);
          this.element.style.height = Math.round(viewerSize.y * options.sizeRatio) + "px";
          this.element.style.width = Math.round(viewerSize.x * options.sizeRatio) + "px";
          this.oldViewerSize = viewerSize;
          navigatorSize = $.getElementSize(this.element);
          this.elementArea = navigatorSize.x * navigatorSize.y;
        }
        this.oldContainerSize = new $.Point(0, 0);
        $.Viewer.apply(this, [options]);
        this.displayRegionContainer.appendChild(this.displayRegion);
        this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
        function rotate(degrees2, immediately) {
          _setTransformRotate(_this.displayRegionContainer, degrees2);
          _setTransformRotate(_this.displayRegion, -degrees2);
          _this.viewport.setRotation(degrees2, immediately);
        }
        if (options.navigatorRotate) {
          var degrees = options.viewer.viewport ? options.viewer.viewport.getRotation() : options.viewer.degrees || 0;
          rotate(degrees, true);
          options.viewer.addHandler("rotate", function(args) {
            rotate(args.degrees, args.immediately);
          });
        }
        this.innerTracker.destroy();
        this.innerTracker = new $.MouseTracker({
          userData: "Navigator.innerTracker",
          element: this.element,
          //this.canvas,
          dragHandler: $.delegate(this, onCanvasDrag),
          clickHandler: $.delegate(this, onCanvasClick),
          releaseHandler: $.delegate(this, onCanvasRelease),
          scrollHandler: $.delegate(this, onCanvasScroll),
          preProcessEventHandler: function(eventInfo) {
            if (eventInfo.eventType === "wheel") {
              eventInfo.preventDefault = true;
            }
          }
        });
        this.outerTracker.userData = "Navigator.outerTracker";
        $.setElementPointerEventsNone(this.canvas);
        $.setElementPointerEventsNone(this.container);
        this.addHandler("reset-size", function() {
          if (_this.viewport) {
            _this.viewport.goHome(true);
          }
        });
        viewer.world.addHandler("item-index-change", function(event) {
          window.setTimeout(function() {
            var item = _this.world.getItemAt(event.previousIndex);
            _this.world.setItemIndex(item, event.newIndex);
          }, 1);
        });
        viewer.world.addHandler("remove-item", function(event) {
          var theirItem = event.item;
          var myItem = _this._getMatchingItem(theirItem);
          if (myItem) {
            _this.world.removeItem(myItem);
          }
        });
        this.update(viewer.viewport);
      };
      $.extend(
        $.Navigator.prototype,
        $.EventSource.prototype,
        $.Viewer.prototype,
        /** @lends OpenSeadragon.Navigator.prototype */
        {
          /**
           * Used to notify the navigator when its size has changed.
           * Especially useful when {@link OpenSeadragon.Options}.navigatorAutoResize is set to false and the navigator is resizable.
           * @function
           */
          updateSize: function() {
            if (this.viewport) {
              var containerSize = new $.Point(
                this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
                this.container.clientHeight === 0 ? 1 : this.container.clientHeight
              );
              if (!containerSize.equals(this.oldContainerSize)) {
                this.viewport.resize(containerSize, true);
                this.viewport.goHome(true);
                this.oldContainerSize = containerSize;
                this.drawer.clear();
                this.world.draw();
              }
            }
          },
          /**
           * Explicitly sets the width of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} width - the new width, either a number of pixels or a CSS string, such as "100%"
           */
          setWidth: function(width) {
            this.width = width;
            this.element.style.width = typeof width === "number" ? width + "px" : width;
            this._resizeWithViewer = false;
            this.updateSize();
          },
          /**
           * Explicitly sets the height of the navigator, in web coordinates. Disables automatic resizing.
           * @param {Number|String} height - the new height, either a number of pixels or a CSS string, such as "100%"
           */
          setHeight: function(height) {
            this.height = height;
            this.element.style.height = typeof height === "number" ? height + "px" : height;
            this._resizeWithViewer = false;
            this.updateSize();
          },
          /**
            * Flip navigator element
            * @param {Boolean} state - Flip state to set.
            */
          setFlip: function(state) {
            this.viewport.setFlip(state);
            this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
            return this;
          },
          setDisplayTransform: function(rule) {
            setElementTransform(this.displayRegion, rule);
            setElementTransform(this.canvas, rule);
            setElementTransform(this.element, rule);
          },
          /**
           * Used to update the navigator minimap's viewport rectangle when a change in the viewer's viewport occurs.
           * @function
           * @param {OpenSeadragon.Viewport} The viewport this navigator is tracking.
           */
          update: function(viewport) {
            var viewerSize, newWidth, newHeight, bounds, topleft, bottomright;
            viewerSize = $.getElementSize(this.viewer.element);
            if (this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals(this.oldViewerSize)) {
              this.oldViewerSize = viewerSize;
              if (this.maintainSizeRatio || !this.elementArea) {
                newWidth = viewerSize.x * this.sizeRatio;
                newHeight = viewerSize.y * this.sizeRatio;
              } else {
                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
                newHeight = this.elementArea / newWidth;
              }
              this.element.style.width = Math.round(newWidth) + "px";
              this.element.style.height = Math.round(newHeight) + "px";
              if (!this.elementArea) {
                this.elementArea = newWidth * newHeight;
              }
              this.updateSize();
            }
            if (viewport && this.viewport) {
              bounds = viewport.getBoundsNoRotate(true);
              topleft = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
              bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false).minus(this.totalBorderWidths);
              if (!this.navigatorRotate) {
                var degrees = viewport.getRotation(true);
                _setTransformRotate(this.displayRegion, -degrees);
              }
              var style = this.displayRegion.style;
              style.display = this.world.getItemCount() ? "block" : "none";
              style.top = topleft.y.toFixed(2) + "px";
              style.left = topleft.x.toFixed(2) + "px";
              var width = bottomright.x - topleft.x;
              var height = bottomright.y - topleft.y;
              style.width = Math.round(Math.max(width, 0)) + "px";
              style.height = Math.round(Math.max(height, 0)) + "px";
            }
          },
          // overrides Viewer.addTiledImage
          addTiledImage: function(options) {
            var _this = this;
            var original = options.originalTiledImage;
            delete options.original;
            var optionsClone = $.extend({}, options, {
              success: function(event) {
                var myItem = event.item;
                myItem._originalForNavigator = original;
                _this._matchBounds(myItem, original, true);
                _this._matchOpacity(myItem, original);
                _this._matchCompositeOperation(myItem, original);
                function matchBounds() {
                  _this._matchBounds(myItem, original);
                }
                function matchOpacity() {
                  _this._matchOpacity(myItem, original);
                }
                function matchCompositeOperation() {
                  _this._matchCompositeOperation(myItem, original);
                }
                original.addHandler("bounds-change", matchBounds);
                original.addHandler("clip-change", matchBounds);
                original.addHandler("opacity-change", matchOpacity);
                original.addHandler("composite-operation-change", matchCompositeOperation);
              }
            });
            return $.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
          },
          destroy: function() {
            return $.Viewer.prototype.destroy.apply(this);
          },
          // private
          _getMatchingItem: function(theirItem) {
            var count = this.world.getItemCount();
            var item;
            for (var i = 0; i < count; i++) {
              item = this.world.getItemAt(i);
              if (item._originalForNavigator === theirItem) {
                return item;
              }
            }
            return null;
          },
          // private
          _matchBounds: function(myItem, theirItem, immediately) {
            var bounds = theirItem.getBoundsNoRotate();
            myItem.setPosition(bounds.getTopLeft(), immediately);
            myItem.setWidth(bounds.width, immediately);
            myItem.setRotation(theirItem.getRotation(), immediately);
            myItem.setClip(theirItem.getClip());
            myItem.setFlip(theirItem.getFlip());
          },
          // private
          _matchOpacity: function(myItem, theirItem) {
            myItem.setOpacity(theirItem.opacity);
          },
          // private
          _matchCompositeOperation: function(myItem, theirItem) {
            myItem.setCompositeOperation(theirItem.compositeOperation);
          }
        }
      );
      function onCanvasClick(event) {
        var canvasClickEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          quick: event.quick,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false
        };
        this.viewer.raiseEvent("navigator-click", canvasClickEventArgs);
        if (!canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
          if (this.viewer.viewport.flipped) {
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
          var target = this.viewport.pointFromPixel(event.position);
          if (!this.panVertical) {
            target.y = this.viewer.viewport.getCenter(true).y;
          } else if (!this.panHorizontal) {
            target.x = this.viewer.viewport.getCenter(true).x;
          }
          this.viewer.viewport.panTo(target);
          this.viewer.viewport.applyConstraints();
        }
      }
      function onCanvasDrag(event) {
        var canvasDragEventArgs = {
          tracker: event.eventSource,
          position: event.position,
          delta: event.delta,
          speed: event.speed,
          direction: event.direction,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefaultAction: false
        };
        this.viewer.raiseEvent("navigator-drag", canvasDragEventArgs);
        if (!canvasDragEventArgs.preventDefaultAction && this.viewer.viewport) {
          if (!this.panHorizontal) {
            event.delta.x = 0;
          }
          if (!this.panVertical) {
            event.delta.y = 0;
          }
          if (this.viewer.viewport.flipped) {
            event.delta.x = -event.delta.x;
          }
          this.viewer.viewport.panBy(
            this.viewport.deltaPointsFromPixels(
              event.delta
            )
          );
          if (this.viewer.constrainDuringPan) {
            this.viewer.viewport.applyConstraints();
          }
        }
      }
      function onCanvasRelease(event) {
        if (event.insideElementPressed && this.viewer.viewport) {
          this.viewer.viewport.applyConstraints();
        }
      }
      function onCanvasScroll(event) {
        var eventArgs = {
          tracker: event.eventSource,
          position: event.position,
          scroll: event.scroll,
          shift: event.shift,
          originalEvent: event.originalEvent,
          preventDefault: event.preventDefault
        };
        this.viewer.raiseEvent("navigator-scroll", eventArgs);
        event.preventDefault = eventArgs.preventDefault;
      }
      function _setTransformRotate(element, degrees) {
        setElementTransform(element, "rotate(" + degrees + "deg)");
      }
      function setElementTransform(element, rule) {
        element.style.webkitTransform = rule;
        element.style.mozTransform = rule;
        element.style.msTransform = rule;
        element.style.oTransform = rule;
        element.style.transform = rule;
      }
    })(OpenSeadragon);
    (function($) {
      var I18N = {
        Errors: {
          Dzc: "Sorry, we don't support Deep Zoom Collections!",
          Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
          ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
          Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
          Status: "This space unintentionally left blank ({0} {1}).",
          OpenFailed: "Unable to open {0}: {1}"
        },
        Tooltips: {
          FullPage: "Toggle full page",
          Home: "Go home",
          ZoomIn: "Zoom in",
          ZoomOut: "Zoom out",
          NextPage: "Next page",
          PreviousPage: "Previous page",
          RotateLeft: "Rotate left",
          RotateRight: "Rotate right",
          Flip: "Flip Horizontally"
        }
      };
      $.extend(
        $,
        /** @lends OpenSeadragon */
        {
          /**
           * @function
           * @param {String} property
           */
          getString: function(prop) {
            var props = prop.split("."), string = null, args = arguments, container = I18N, i;
            for (i = 0; i < props.length - 1; i++) {
              container = container[props[i]] || {};
            }
            string = container[props[i]];
            if (typeof string !== "string") {
              $.console.error("Untranslated source string:", prop);
              string = "";
            }
            return string.replace(/\{\d+\}/g, function(capture) {
              var i2 = parseInt(capture.match(/\d+/), 10) + 1;
              return i2 < args.length ? args[i2] : "";
            });
          },
          /**
           * @function
           * @param {String} property
           * @param {*} value
           */
          setString: function(prop, value) {
            var props = prop.split("."), container = I18N, i;
            for (i = 0; i < props.length - 1; i++) {
              if (!container[props[i]]) {
                container[props[i]] = {};
              }
              container = container[props[i]];
            }
            container[props[i]] = value;
          }
        }
      );
    })(OpenSeadragon);
    (function($) {
      $.Point = function(x, y) {
        this.x = typeof x === "number" ? x : 0;
        this.y = typeof y === "number" ? y : 0;
      };
      $.Point.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Point} a duplicate of this Point
         */
        clone: function() {
          return new $.Point(this.x, this.y);
        },
        /**
         * Add another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to add vector components.
         * @returns {OpenSeadragon.Point} A new point representing the sum of the
         *  vector components
         */
        plus: function(point) {
          return new $.Point(
            this.x + point.x,
            this.y + point.y
          );
        },
        /**
         * Subtract another Point to this point and return a new Point.
         * @function
         * @param {OpenSeadragon.Point} point The point to subtract vector components.
         * @returns {OpenSeadragon.Point} A new point representing the subtraction of the
         *  vector components
         */
        minus: function(point) {
          return new $.Point(
            this.x - point.x,
            this.y - point.y
          );
        },
        /**
         * Multiply this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to multiply vector components.
         * @returns {OpenSeadragon.Point} A new point representing the multiplication
         *  of the vector components by the factor
         */
        times: function(factor) {
          return new $.Point(
            this.x * factor,
            this.y * factor
          );
        },
        /**
         * Divide this point by a factor and return a new Point.
         * @function
         * @param {Number} factor The factor to divide vector components.
         * @returns {OpenSeadragon.Point} A new point representing the division of the
         *  vector components by the factor
         */
        divide: function(factor) {
          return new $.Point(
            this.x / factor,
            this.y / factor
          );
        },
        /**
         * Compute the opposite of this point and return a new Point.
         * @function
         * @returns {OpenSeadragon.Point} A new point representing the opposite of the
         *  vector components
         */
        negate: function() {
          return new $.Point(-this.x, -this.y);
        },
        /**
         * Compute the distance between this point and another point.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the distance with.
         * @returns {Number} The distance between the 2 points
         */
        distanceTo: function(point) {
          return Math.sqrt(
            Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2)
          );
        },
        /**
         * Compute the squared distance between this point and another point.
         * Useful for optimizing things like comparing distances.
         * @function
         * @param {OpenSeadragon.Point} point The point to compute the squared distance with.
         * @returns {Number} The squared distance between the 2 points
         */
        squaredDistanceTo: function(point) {
          return Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2);
        },
        /**
         * Apply a function to each coordinate of this point and return a new point.
         * @function
         * @param {function} func The function to apply to each coordinate.
         * @returns {OpenSeadragon.Point} A new point with the coordinates computed
         * by the specified function
         */
        apply: function(func) {
          return new $.Point(func(this.x), func(this.y));
        },
        /**
         * Check if this point is equal to another one.
         * @function
         * @param {OpenSeadragon.Point} point The point to compare this point with.
         * @returns {Boolean} true if they are equal, false otherwise.
         */
        equals: function(point) {
          return point instanceof $.Point && this.x === point.x && this.y === point.y;
        },
        /**
         * Rotates the point around the specified pivot
         * From http://stackoverflow.com/questions/4465931/rotate-rectangle-around-a-point
         * @function
         * @param {Number} degress to rotate around the pivot.
         * @param {OpenSeadragon.Point} [pivot=(0,0)] Point around which to rotate.
         * Defaults to the origin.
         * @returns {OpenSeadragon.Point}. A new point representing the point rotated around the specified pivot
         */
        rotate: function(degrees, pivot) {
          pivot = pivot || new $.Point(0, 0);
          var cos;
          var sin;
          if (degrees % 90 === 0) {
            var d = $.positiveModulo(degrees, 360);
            switch (d) {
              case 0:
                cos = 1;
                sin = 0;
                break;
              case 90:
                cos = 0;
                sin = 1;
                break;
              case 180:
                cos = -1;
                sin = 0;
                break;
              case 270:
                cos = 0;
                sin = -1;
                break;
            }
          } else {
            var angle = degrees * Math.PI / 180;
            cos = Math.cos(angle);
            sin = Math.sin(angle);
          }
          var x = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
          var y = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
          return new $.Point(x, y);
        },
        /**
         * Convert this point to a string in the format (x,y) where x and y are
         * rounded to the nearest integer.
         * @function
         * @returns {String} A string representation of this point.
         */
        toString: function() {
          return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.TileSource = function(width, height, tileSize, tileOverlap, minLevel, maxLevel) {
        var _this = this;
        var args = arguments, options, i;
        if ($.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: args[0],
            height: args[1],
            tileSize: args[2],
            tileOverlap: args[3],
            minLevel: args[4],
            maxLevel: args[5]
          };
        }
        $.EventSource.call(this);
        $.extend(true, this, options);
        if (!this.success) {
          for (i = 0; i < arguments.length; i++) {
            if ($.isFunction(arguments[i])) {
              this.success = arguments[i];
              break;
            }
          }
        }
        if (this.success) {
          this.addHandler("ready", function(event) {
            _this.success(event);
          });
        }
        if ("string" === $.type(arguments[0])) {
          this.url = arguments[0];
        }
        if (this.url) {
          this.aspectRatio = 1;
          this.dimensions = new $.Point(10, 10);
          this._tileWidth = 0;
          this._tileHeight = 0;
          this.tileOverlap = 0;
          this.minLevel = 0;
          this.maxLevel = 0;
          this.ready = false;
          this.getImageInfo(this.url);
        } else {
          this.ready = true;
          this.aspectRatio = options.width && options.height ? options.width / options.height : 1;
          this.dimensions = new $.Point(options.width, options.height);
          if (this.tileSize) {
            this._tileWidth = this._tileHeight = this.tileSize;
            delete this.tileSize;
          } else {
            if (this.tileWidth) {
              this._tileWidth = this.tileWidth;
              delete this.tileWidth;
            } else {
              this._tileWidth = 0;
            }
            if (this.tileHeight) {
              this._tileHeight = this.tileHeight;
              delete this.tileHeight;
            } else {
              this._tileHeight = 0;
            }
          }
          this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
          this.minLevel = options.minLevel ? options.minLevel : 0;
          this.maxLevel = void 0 !== options.maxLevel && null !== options.maxLevel ? options.maxLevel : options.width && options.height ? Math.ceil(
            Math.log(Math.max(options.width, options.height)) / Math.log(2)
          ) : 0;
          if (this.success && $.isFunction(this.success)) {
            this.success(this);
          }
        }
      };
      $.TileSource.prototype = {
        getTileSize: function(level) {
          $.console.error(
            "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
          );
          return this._tileWidth;
        },
        /**
         * Return the tileWidth for a given level.
         * Subclasses should override this if tileWidth can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileWidth directly.
         * @function
         * @param {Number} level
         */
        getTileWidth: function(level) {
          if (!this._tileWidth) {
            return this.getTileSize(level);
          }
          return this._tileWidth;
        },
        /**
         * Return the tileHeight for a given level.
         * Subclasses should override this if tileHeight can be different at different levels
         *   such as in IIIFTileSource.  Code should use this function rather than reading
         *   from ._tileHeight directly.
         * @function
         * @param {Number} level
         */
        getTileHeight: function(level) {
          if (!this._tileHeight) {
            return this.getTileSize(level);
          }
          return this._tileHeight;
        },
        /**
         * Set the maxLevel to the given level, and perform the memoization of
         * getLevelScale with the new maxLevel. This function can be useful if the
         * memoization is required before the first call of getLevelScale, or both
         * memoized getLevelScale and maxLevel should be changed accordingly.
         * @function
         * @param {Number} level
         */
        setMaxLevel: function(level) {
          this.maxLevel = level;
          this._memoizeLevelScale();
        },
        /**
         * @function
         * @param {Number} level
         */
        getLevelScale: function(level) {
          this._memoizeLevelScale();
          return this.getLevelScale(level);
        },
        // private
        _memoizeLevelScale: function() {
          var levelScaleCache = {}, i;
          for (i = 0; i <= this.maxLevel; i++) {
            levelScaleCache[i] = 1 / Math.pow(2, this.maxLevel - i);
          }
          this.getLevelScale = function(_level) {
            return levelScaleCache[_level];
          };
        },
        /**
         * @function
         * @param {Number} level
         */
        getNumTiles: function(level) {
          var scale = this.getLevelScale(level), x = Math.ceil(scale * this.dimensions.x / this.getTileWidth(level)), y = Math.ceil(scale * this.dimensions.y / this.getTileHeight(level));
          return new $.Point(x, y);
        },
        /**
         * @function
         * @param {Number} level
         */
        getPixelRatio: function(level) {
          var imageSizeScaled = this.dimensions.times(this.getLevelScale(level)), rx = 1 / imageSizeScaled.x * $.pixelDensityRatio, ry = 1 / imageSizeScaled.y * $.pixelDensityRatio;
          return new $.Point(rx, ry);
        },
        /**
         * @function
         * @returns {Number} The highest level in this tile source that can be contained in a single tile.
         */
        getClosestLevel: function() {
          var i, tiles;
          for (i = this.minLevel + 1; i <= this.maxLevel; i++) {
            tiles = this.getNumTiles(i);
            if (tiles.x > 1 || tiles.y > 1) {
              break;
            }
          }
          return i - 1;
        },
        /**
         * @function
         * @param {Number} level
         * @param {OpenSeadragon.Point} point
         */
        getTileAtPoint: function(level, point) {
          var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
          $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
          var widthScaled = this.dimensions.x * this.getLevelScale(level);
          var pixelX = point.x * widthScaled;
          var pixelY = point.y * widthScaled;
          var x = Math.floor(pixelX / this.getTileWidth(level));
          var y = Math.floor(pixelY / this.getTileHeight(level));
          if (point.x >= 1) {
            x = this.getNumTiles(level).x - 1;
          }
          var EPSILON = 1e-15;
          if (point.y >= 1 / this.aspectRatio - EPSILON) {
            y = this.getNumTiles(level).y - 1;
          }
          return new $.Point(x, y);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @param {Boolean} [isSource=false] Whether to return the source bounds of the tile.
         * @returns {OpenSeadragon.Rect} Either where this tile fits (in normalized coordinates) or the
         * portion of the tile to use as the source of the drawing operation (in pixels), depending on
         * the isSource parameter.
         */
        getTileBounds: function(level, x, y, isSource) {
          var dimensionsScaled = this.dimensions.times(this.getLevelScale(level)), tileWidth = this.getTileWidth(level), tileHeight = this.getTileHeight(level), px = x === 0 ? 0 : tileWidth * x - this.tileOverlap, py = y === 0 ? 0 : tileHeight * y - this.tileOverlap, sx = tileWidth + (x === 0 ? 1 : 2) * this.tileOverlap, sy = tileHeight + (y === 0 ? 1 : 2) * this.tileOverlap, scale = 1 / dimensionsScaled.x;
          sx = Math.min(sx, dimensionsScaled.x - px);
          sy = Math.min(sy, dimensionsScaled.y - py);
          if (isSource) {
            return new $.Rect(0, 0, sx, sy);
          }
          return new $.Rect(px * scale, py * scale, sx * scale, sy * scale);
        },
        /**
         * Responsible for retrieving, and caching the
         * image metadata pertinent to this TileSources implementation.
         * @function
         * @param {String} url
         * @throws {Error}
         */
        getImageInfo: function(url) {
          var _this = this, callbackName, callback, readySource, options, urlParts, filename, lastDot;
          if (url) {
            urlParts = url.split("/");
            filename = urlParts[urlParts.length - 1];
            lastDot = filename.lastIndexOf(".");
            if (lastDot > -1) {
              urlParts[urlParts.length - 1] = filename.slice(0, lastDot);
            }
          }
          var postData = null;
          if (this.splitHashDataForPost) {
            var hashIdx = url.indexOf("#");
            if (hashIdx !== -1) {
              postData = url.substring(hashIdx + 1);
              url = url.substr(0, hashIdx);
            }
          }
          callback = function(data) {
            if (typeof data === "string") {
              data = $.parseXml(data);
            }
            var $TileSource = $.TileSource.determineType(_this, data, url);
            if (!$TileSource) {
              _this.raiseEvent("open-failed", { message: "Unable to load TileSource", source: url });
              return;
            }
            options = $TileSource.prototype.configure.apply(_this, [data, url, postData]);
            if (options.ajaxWithCredentials === void 0) {
              options.ajaxWithCredentials = _this.ajaxWithCredentials;
            }
            readySource = new $TileSource(options);
            _this.ready = true;
            _this.raiseEvent("ready", { tileSource: readySource });
          };
          if (url.match(/\.js$/)) {
            callbackName = url.split("/").pop().replace(".js", "");
            $.jsonp({
              url,
              async: false,
              callbackName,
              callback
            });
          } else {
            $.makeAjaxRequest({
              url,
              postData,
              withCredentials: this.ajaxWithCredentials,
              headers: this.ajaxHeaders,
              success: function(xhr) {
                var data = processResponse(xhr);
                callback(data);
              },
              error: function(xhr, exc) {
                var msg;
                try {
                  msg = "HTTP " + xhr.status + " attempting to load TileSource: " + url;
                } catch (e) {
                  var formattedExc;
                  if (typeof exc === "undefined" || !exc.toString) {
                    formattedExc = "Unknown error";
                  } else {
                    formattedExc = exc.toString();
                  }
                  msg = formattedExc + " attempting to load TileSource: " + url;
                }
                $.console.error(msg);
                _this.raiseEvent("open-failed", {
                  message: msg,
                  source: url,
                  postData
                });
              }
            });
          }
        },
        /**
         * Responsible determining if a the particular TileSource supports the
         * data format ( and allowed to apply logic against the url the data was
         * loaded from, if any ). Overriding implementations are expected to do
         * something smart with data and / or url to determine support.  Also
         * understand that iteration order of TileSources is not guarunteed so
         * please make sure your data or url is expressive enough to ensure a simple
         * and sufficient mechanisim for clear determination.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @returns {Boolean}
         */
        supports: function(data, url) {
          return false;
        },
        /**
         * Responsible for parsing and configuring the
         * image metadata pertinent to this TileSources implementation.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {String|Object|Array|Document} data
         * @param {String} url - the url the data was loaded
         *      from if any.
         * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null value obtained from
         *      the protocol URL after '#' sign if flag splitHashDataForPost set to 'true'
         * @returns {Object} options - A dictionary of keyword arguments sufficient
         *      to configure the tile source constructor (include all values you want to
         *      instantiate the TileSource subclass with - what _options_ object should contain).
         * @throws {Error}
         */
        configure: function(data, url, postData) {
          throw new Error("Method not implemented.");
        },
        /**
         * Responsible for retrieving the url which will return an image for the
         * region specified by the given x, y, and level components.
         * This method is not implemented by this class other than to throw an Error
         * announcing you have to implement it.  Because of the variety of tile
         * server technologies, and various specifications for building image
         * pyramids, this method is here to allow easy integration.
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {String|Function} url - A string for the url or a function that returns a url string.
         * @throws {Error}
         */
        getTileUrl: function(level, x, y) {
          throw new Error("Method not implemented.");
        },
        /**
         * Must use AJAX in order to work, i.e. loadTilesWithAjax = true is set.
         * If a value is returned, ajax issues POST request to the tile url.
         * If null is returned, ajax issues GET request.
         * The return value must comply to the header 'content type'.
         *
         * Examples (USED HEADER --> getTilePostData CODE):
         * 'Content-type': 'application/x-www-form-urlencoded' -->
         *   return "key1=value=1&key2=value2";
         *
         * 'Content-type': 'application/x-www-form-urlencoded' -->
         *   return JSON.stringify({key: "value", number: 5});
         *
         * 'Content-type': 'multipart/form-data' -->
         *   let result = new FormData();
         *   result.append("data", myData);
         *   return result;
         *
         * IMPORTANT: in case you move all the logic on image fetching
         * to post data, you must re-define 'getTileHashKey(...)' to
         * stay unique for different tile images.
         *
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {*|null} post data to send with tile configuration request
         */
        getTilePostData: function(level, x, y) {
          return null;
        },
        /**
         * Responsible for retrieving the headers which will be attached to the image request for the
         * region specified by the given x, y, and level components.
         * This option is only relevant if {@link OpenSeadragon.Options}.loadTilesWithAjax is set to true.
         * The headers returned here will override headers specified at the Viewer or TiledImage level.
         * Specifying a falsy value for a header will clear its existing value set at the Viewer or
         * TiledImage level (if any).
         *
         * Note that the headers of existing tiles don't automatically change when this function
         * returns updated headers. To do that, you need to call {@link OpenSeadragon.Viewer#setAjaxHeaders}
         * and propagate the changes.
         *
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         * @returns {Object}
         */
        getTileAjaxHeaders: function(level, x, y) {
          return {};
        },
        /**
         * The tile cache object is uniquely determined by this key and used to lookup
         * the image data in cache: keys should be different if images are different.
         *
         * In case a tile has context2D property defined (TileSource.prototype.getContext2D)
         * or its context2D is set manually; the cache is not used and this function
         * is irrelevant.
         * Note: default behaviour does not take into account post data.
         * @param {Number} level tile level it was fetched with
         * @param {Number} x x-coordinate in the pyramid level
         * @param {Number} y y-coordinate in the pyramid level
         * @param {String} url the tile was fetched with
         * @param {Object} ajaxHeaders the tile was fetched with
         * @param {*} postData data the tile was fetched with (type depends on getTilePostData(..) return type)
         */
        getTileHashKey: function(level, x, y, url, ajaxHeaders, postData) {
          function withHeaders(hash) {
            return ajaxHeaders ? hash + "+" + JSON.stringify(ajaxHeaders) : hash;
          }
          if (typeof url !== "string") {
            return withHeaders(level + "/" + x + "_" + y);
          }
          return withHeaders(url);
        },
        /**
         * @function
         * @param {Number} level
         * @param {Number} x
         * @param {Number} y
         */
        tileExists: function(level, x, y) {
          var numTiles = this.getNumTiles(level);
          return level >= this.minLevel && level <= this.maxLevel && x >= 0 && y >= 0 && x < numTiles.x && y < numTiles.y;
        },
        /**
         * Decide whether tiles have transparency: this is crucial for correct images blending.
         * @returns {boolean} true if the image has transparency
         */
        hasTransparency: function(context2D, url, ajaxHeaders, post) {
          return !!context2D || url.match(".png");
        },
        /**
         * Download tile data.
         * Note that if you override this function, you should override also downloadTileAbort().
         * @param {ImageJob} context job context that you have to call finish(...) on.
         * @param {String} [context.src] - URL of image to download.
         * @param {String} [context.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [context.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {Boolean} [context.ajaxWithCredentials] - Whether to set withCredentials on AJAX requests.
         * @param {String} [context.crossOriginPolicy] - CORS policy to use for downloads
         * @param {String} [context.postData] - HTTP POST data (usually but not necessarily in k=v&k2=v2... form,
         *   see TileSource::getPostData) or null
         * @param {*} [context.userData] - Empty object to attach your own data and helper variables to.
         * @param {Function} [context.finish] - Should be called unless abort() was executed, e.g. on all occasions,
         *   be it successful or unsuccessful request.
         *   Usage: context.finish(data, request, errMessage). Pass the downloaded data object or null upon failure.
         *   Add also reference to an ajax request if used. Provide error message in case of failure.
         * @param {Function} [context.abort] - Called automatically when the job times out.
         *   Usage: context.abort().
         * @param {Function} [context.callback] @private - Called automatically once image has been downloaded
         *   (triggered by finish).
         * @param {Number} [context.timeout] @private - The max number of milliseconds that
         *   this image job may take to complete.
         * @param {string} [context.errorMsg] @private - The final error message, default null (set by finish).
         */
        downloadTileStart: function(context) {
          var dataStore = context.userData, image = new Image();
          dataStore.image = image;
          dataStore.request = null;
          var finish = function(error) {
            if (!image) {
              context.finish(null, dataStore.request, "Image load failed: undefined Image instance.");
              return;
            }
            image.onload = image.onerror = image.onabort = null;
            context.finish(error ? null : image, dataStore.request, error);
          };
          image.onload = function() {
            finish();
          };
          image.onabort = image.onerror = function() {
            finish("Image load aborted.");
          };
          if (context.loadWithAjax) {
            dataStore.request = $.makeAjaxRequest({
              url: context.src,
              withCredentials: context.ajaxWithCredentials,
              headers: context.ajaxHeaders,
              responseType: "arraybuffer",
              postData: context.postData,
              success: function(request) {
                var blb;
                try {
                  blb = new window.Blob([request.response]);
                } catch (e) {
                  var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                  if (e.name === "TypeError" && BlobBuilder) {
                    var bb = new BlobBuilder();
                    bb.append(request.response);
                    blb = bb.getBlob();
                  }
                }
                if (blb.size === 0) {
                  finish("Empty image response.");
                } else {
                  image.src = (window.URL || window.webkitURL).createObjectURL(blb);
                }
              },
              error: function(request) {
                finish("Image load aborted - XHR error");
              }
            });
          } else {
            if (context.crossOriginPolicy !== false) {
              image.crossOrigin = context.crossOriginPolicy;
            }
            image.src = context.src;
          }
        },
        /**
         * Provide means of aborting the execution.
         * Note that if you override this function, you should override also downloadTileStart().
         * @param {ImageJob} context job, the same object as with downloadTileStart(..)
         * @param {*} [context.userData] - Empty object to attach (and mainly read) your own data.
         */
        downloadTileAbort: function(context) {
          if (context.userData.request) {
            context.userData.request.abort();
          }
          var image = context.userData.image;
          if (context.userData.image) {
            image.onload = image.onerror = image.onabort = null;
          }
        },
        /**
         * Create cache object from the result of the download process. The
         * cacheObject parameter should be used to attach the data to, there are no
         * conventions on how it should be stored - all the logic is implemented within *TileCache() functions.
         *
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
         * @param {Tile} tile instance the cache was created with
         */
        createTileCache: function(cacheObject, data, tile) {
          cacheObject._data = data;
        },
        /**
         * Cache object destructor, unset all properties you created to allow GC collection.
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         */
        destroyTileCache: function(cacheObject) {
          cacheObject._data = null;
          cacheObject._renderedContext = null;
        },
        /**
         * Raw data getter
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @returns {*} cache data
         */
        getTileCacheData: function(cacheObject) {
          return cacheObject._data;
        },
        /**
         * Compatibility image element getter
         *  - plugins might need image representation of the data
         *  - div HTML rendering relies on image element presence
         * Note that if you override any of *TileCache() functions, you should override all of them.
         *  @param {object} cacheObject context cache object
         *  @returns {Image} cache data as an Image
         */
        getTileCacheDataAsImage: function(cacheObject) {
          return cacheObject._data;
        },
        /**
         * Compatibility context 2D getter
         *  - most heavily used rendering method is a canvas-based approach,
         *    convert the data to a canvas and return it's 2D context
         * Note that if you override any of *TileCache() functions, you should override all of them.
         * @param {object} cacheObject context cache object
         * @returns {CanvasRenderingContext2D} context of the canvas representation of the cache data
         */
        getTileCacheDataAsContext2D: function(cacheObject) {
          if (!cacheObject._renderedContext) {
            var canvas = document.createElement("canvas");
            canvas.width = cacheObject._data.width;
            canvas.height = cacheObject._data.height;
            cacheObject._renderedContext = canvas.getContext("2d");
            cacheObject._renderedContext.drawImage(cacheObject._data, 0, 0);
            cacheObject._data = null;
          }
          return cacheObject._renderedContext;
        }
      };
      $.extend(true, $.TileSource.prototype, $.EventSource.prototype);
      function processResponse(xhr) {
        var responseText = xhr.responseText, status = xhr.status, statusText, data;
        if (!xhr) {
          throw new Error($.getString("Errors.Security"));
        } else if (xhr.status !== 200 && xhr.status !== 0) {
          status = xhr.status;
          statusText = status === 404 ? "Not Found" : xhr.statusText;
          throw new Error($.getString("Errors.Status", status, statusText));
        }
        if (responseText.match(/^\s*<.*/)) {
          try {
            data = xhr.responseXML && xhr.responseXML.documentElement ? xhr.responseXML : $.parseXml(responseText);
          } catch (e) {
            data = xhr.responseText;
          }
        } else if (responseText.match(/\s*[{[].*/)) {
          try {
            data = $.parseJSON(responseText);
          } catch (e) {
            data = responseText;
          }
        } else {
          data = responseText;
        }
        return data;
      }
      $.TileSource.determineType = function(tileSource, data, url) {
        var property;
        for (property in OpenSeadragon) {
          if (property.match(/.+TileSource$/) && $.isFunction(OpenSeadragon[property]) && $.isFunction(OpenSeadragon[property].prototype.supports) && OpenSeadragon[property].prototype.supports.call(tileSource, data, url)) {
            return OpenSeadragon[property];
          }
        }
        $.console.error("No TileSource was able to open %s %s", url, data);
        return null;
      };
    })(OpenSeadragon);
    (function($) {
      $.DziTileSource = function(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel) {
        var i, rect, level, options;
        if ($.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4],
            fileFormat: arguments[5],
            displayRects: arguments[6],
            minLevel: arguments[7],
            maxLevel: arguments[8]
          };
        }
        this._levelRects = {};
        this.tilesUrl = options.tilesUrl;
        this.fileFormat = options.fileFormat;
        this.displayRects = options.displayRects;
        if (this.displayRects) {
          for (i = this.displayRects.length - 1; i >= 0; i--) {
            rect = this.displayRects[i];
            for (level = rect.minLevel; level <= rect.maxLevel; level++) {
              if (!this._levelRects[level]) {
                this._levelRects[level] = [];
              }
              this._levelRects[level].push(rect);
            }
          }
        }
        $.TileSource.apply(this, [options]);
      };
      $.extend(
        $.DziTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.DziTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            var ns;
            if (data.Image) {
              ns = data.Image.xmlns;
            } else if (data.documentElement) {
              if ("Image" === data.documentElement.localName || "Image" === data.documentElement.tagName) {
                ns = data.documentElement.namespaceURI;
              }
            }
            ns = (ns || "").toLowerCase();
            return ns.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || ns.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url, postData) {
            var options;
            if (!$.isPlainObject(data)) {
              options = configureFromXML(this, data);
            } else {
              options = configureFromObject(this, data);
            }
            if (url && !options.tilesUrl) {
              options.tilesUrl = url.replace(
                /([^/]+?)(\.(dzi|xml|js)?(\?[^/]*)?)?\/?$/,
                "$1_files/"
              );
              if (url.search(/\.(dzi|xml|js)\?/) !== -1) {
                options.queryParams = url.match(/\?.*/);
              } else {
                options.queryParams = "";
              }
            }
            return options;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            return [this.tilesUrl, level, "/", x, "_", y, ".", this.fileFormat, this.queryParams].join("");
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          tileExists: function(level, x, y) {
            var rects = this._levelRects[level], rect, scale, xMin, yMin, xMax, yMax, i;
            if (this.minLevel && level < this.minLevel || this.maxLevel && level > this.maxLevel) {
              return false;
            }
            if (!rects || !rects.length) {
              return true;
            }
            for (i = rects.length - 1; i >= 0; i--) {
              rect = rects[i];
              if (level < rect.minLevel || level > rect.maxLevel) {
                continue;
              }
              scale = this.getLevelScale(level);
              xMin = rect.x * scale;
              yMin = rect.y * scale;
              xMax = xMin + rect.width * scale;
              yMax = yMin + rect.height * scale;
              xMin = Math.floor(xMin / this._tileWidth);
              yMin = Math.floor(yMin / this._tileWidth);
              xMax = Math.ceil(xMax / this._tileWidth);
              yMax = Math.ceil(yMax / this._tileWidth);
              if (xMin <= x && x < xMax && yMin <= y && y < yMax) {
                return true;
              }
            }
            return false;
          }
        }
      );
      function configureFromXML(tileSource, xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) {
          throw new Error($.getString("Errors.Xml"));
        }
        var root = xmlDoc.documentElement, rootName = root.localName || root.tagName, ns = xmlDoc.documentElement.namespaceURI, configuration = null, displayRects = [], dispRectNodes, dispRectNode, rectNode, sizeNode, i;
        if (rootName === "Image") {
          try {
            sizeNode = root.getElementsByTagName("Size")[0];
            if (sizeNode === void 0) {
              sizeNode = root.getElementsByTagNameNS(ns, "Size")[0];
            }
            configuration = {
              Image: {
                xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                Url: root.getAttribute("Url"),
                Format: root.getAttribute("Format"),
                DisplayRect: null,
                Overlap: parseInt(root.getAttribute("Overlap"), 10),
                TileSize: parseInt(root.getAttribute("TileSize"), 10),
                Size: {
                  Height: parseInt(sizeNode.getAttribute("Height"), 10),
                  Width: parseInt(sizeNode.getAttribute("Width"), 10)
                }
              }
            };
            if (!$.imageFormatSupported(configuration.Image.Format)) {
              throw new Error(
                $.getString("Errors.ImageFormat", configuration.Image.Format.toUpperCase())
              );
            }
            dispRectNodes = root.getElementsByTagName("DisplayRect");
            if (dispRectNodes === void 0) {
              dispRectNodes = root.getElementsByTagNameNS(ns, "DisplayRect")[0];
            }
            for (i = 0; i < dispRectNodes.length; i++) {
              dispRectNode = dispRectNodes[i];
              rectNode = dispRectNode.getElementsByTagName("Rect")[0];
              if (rectNode === void 0) {
                rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect")[0];
              }
              displayRects.push({
                Rect: {
                  X: parseInt(rectNode.getAttribute("X"), 10),
                  Y: parseInt(rectNode.getAttribute("Y"), 10),
                  Width: parseInt(rectNode.getAttribute("Width"), 10),
                  Height: parseInt(rectNode.getAttribute("Height"), 10),
                  MinLevel: parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                  MaxLevel: parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
                }
              });
            }
            if (displayRects.length) {
              configuration.Image.DisplayRect = displayRects;
            }
            return configureFromObject(tileSource, configuration);
          } catch (e) {
            throw e instanceof Error ? e : new Error($.getString("Errors.Dzi"));
          }
        } else if (rootName === "Collection") {
          throw new Error($.getString("Errors.Dzc"));
        } else if (rootName === "Error") {
          var messageNode = root.getElementsByTagName("Message")[0];
          var message = messageNode.firstChild.nodeValue;
          throw new Error(message);
        }
        throw new Error($.getString("Errors.Dzi"));
      }
      function configureFromObject(tileSource, configuration) {
        var imageData = configuration.Image, tilesUrl = imageData.Url, fileFormat = imageData.Format, sizeData = imageData.Size, dispRectData = imageData.DisplayRect || [], width = parseInt(sizeData.Width, 10), height = parseInt(sizeData.Height, 10), tileSize = parseInt(imageData.TileSize, 10), tileOverlap = parseInt(imageData.Overlap, 10), displayRects = [], rectData, i;
        for (i = 0; i < dispRectData.length; i++) {
          rectData = dispRectData[i].Rect;
          displayRects.push(new $.DisplayRect(
            parseInt(rectData.X, 10),
            parseInt(rectData.Y, 10),
            parseInt(rectData.Width, 10),
            parseInt(rectData.Height, 10),
            parseInt(rectData.MinLevel, 10),
            parseInt(rectData.MaxLevel, 10)
          ));
        }
        return $.extend(true, {
          width,
          /* width *required */
          height,
          /* height *required */
          tileSize,
          /* tileSize *required */
          tileOverlap,
          /* tileOverlap *required */
          minLevel: null,
          /* minLevel */
          maxLevel: null,
          /* maxLevel */
          tilesUrl,
          /* tilesUrl */
          fileFormat,
          /* fileFormat */
          displayRects
          /* displayRects */
        }, configuration);
      }
    })(OpenSeadragon);
    (function($) {
      $.IIIFTileSource = function(options) {
        $.extend(true, this, options);
        this._id = this["@id"] || this["id"] || this["identifier"] || null;
        if (!(this.height && this.width && this._id)) {
          throw new Error("IIIF required parameters (width, height, or id) not provided.");
        }
        options.tileSizePerScaleFactor = {};
        this.tileFormat = this.tileFormat || "jpg";
        this.version = options.version;
        if (this.tile_width && this.tile_height) {
          options.tileWidth = this.tile_width;
          options.tileHeight = this.tile_height;
        } else if (this.tile_width) {
          options.tileSize = this.tile_width;
        } else if (this.tile_height) {
          options.tileSize = this.tile_height;
        } else if (this.tiles) {
          if (this.tiles.length === 1) {
            options.tileWidth = this.tiles[0].width;
            options.tileHeight = this.tiles[0].height || this.tiles[0].width;
            this.scale_factors = this.tiles[0].scaleFactors;
          } else {
            this.scale_factors = [];
            for (var t = 0; t < this.tiles.length; t++) {
              for (var sf = 0; sf < this.tiles[t].scaleFactors.length; sf++) {
                var scaleFactor = this.tiles[t].scaleFactors[sf];
                this.scale_factors.push(scaleFactor);
                options.tileSizePerScaleFactor[scaleFactor] = {
                  width: this.tiles[t].width,
                  height: this.tiles[t].height || this.tiles[t].width
                };
              }
            }
          }
        } else if (canBeTiled(options)) {
          var shortDim = Math.min(this.height, this.width), tileOptions = [256, 512, 1024], smallerTiles = [];
          for (var c = 0; c < tileOptions.length; c++) {
            if (tileOptions[c] <= shortDim) {
              smallerTiles.push(tileOptions[c]);
            }
          }
          if (smallerTiles.length > 0) {
            options.tileSize = Math.max.apply(null, smallerTiles);
          } else {
            options.tileSize = shortDim;
          }
        } else if (this.sizes && this.sizes.length > 0) {
          this.emulateLegacyImagePyramid = true;
          options.levels = constructLevels(this);
          $.extend(true, options, {
            width: options.levels[options.levels.length - 1].width,
            height: options.levels[options.levels.length - 1].height,
            tileSize: Math.max(options.height, options.width),
            tileOverlap: 0,
            minLevel: 0,
            maxLevel: options.levels.length - 1
          });
          this.levels = options.levels;
        } else {
          $.console.error("Nothing in the info.json to construct image pyramids from");
        }
        if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
          if (!this.scale_factors) {
            options.maxLevel = Number(Math.round(Math.log(Math.max(this.width, this.height), 2)));
          } else {
            var maxScaleFactor = Math.max.apply(null, this.scale_factors);
            options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
          }
        }
        if (this.sizes) {
          var sizeLength = this.sizes.length;
          if (sizeLength === options.maxLevel || sizeLength === options.maxLevel + 1) {
            this.levelSizes = this.sizes;
            if (sizeLength === options.maxLevel) {
              this.levelSizes.push({ width: this.width, height: this.height });
            }
          }
        }
        $.TileSource.apply(this, [options]);
      };
      $.extend(
        $.IIIFTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.IIIFTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} [url] - url
           */
          supports: function(data, url) {
            if (data.protocol && data.protocol === "http://iiif.io/api/image") {
              return true;
            } else if (data["@context"] && (data["@context"] === "http://library.stanford.edu/iiif/image-api/1.1/context.json" || data["@context"] === "http://iiif.io/api/image/1/context.json")) {
              return true;
            } else if (data.profile && data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
              return true;
            } else if (data.identifier && data.width && data.height) {
              return true;
            } else if (data.documentElement && "info" === data.documentElement.tagName && "http://library.stanford.edu/iiif/image-api/ns/" === data.documentElement.namespaceURI) {
              return true;
            } else {
              return false;
            }
          },
          /**
           * A static function used to prepare an incoming IIIF Image API info.json
           * response for processing by the tile handler. Normalizes data for all
           * versions of IIIF (1.0, 1.1, 2.x, 3.x) and returns a data object that
           * may be passed to the IIIFTileSource.
           *
           * @function
           * @static
           * @param {Object} data - the raw configuration
           * @param {String} url - the url configuration was retrieved from
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} A normalized IIIF data object
           * @example <caption>IIIF 2.x Info Looks like this</caption>
           * {
           * "@context": "http://iiif.io/api/image/2/context.json",
           * "@id": "http://iiif.example.com/prefix/1E34750D-38DB-4825-A38A-B60A345E591C",
           * "protocol": "http://iiif.io/api/image",
           * "height": 1024,
           * "width": 775,
           * "tiles" : [{"width":256, "scaleFactors":[1,2,4,8]}],
           *  "profile": ["http://iiif.io/api/image/2/level1.json", {
           *    "qualities": [ "native", "bitonal", "grey", "color" ],
           *    "formats": [ "jpg", "png", "gif" ]
           *   }]
           * }
           */
          configure: function(data, url, postData) {
            if (!$.isPlainObject(data)) {
              var options = configureFromXml10(data);
              options["@context"] = "http://iiif.io/api/image/1.0/context.json";
              options["@id"] = url.replace("/info.xml", "");
              options.version = 1;
              return options;
            } else {
              if (!data["@context"]) {
                data["@context"] = "http://iiif.io/api/image/1.0/context.json";
                data["@id"] = url.replace("/info.json", "");
                data.version = 1;
              } else {
                var context = data["@context"];
                if (Array.isArray(context)) {
                  for (var i = 0; i < context.length; i++) {
                    if (typeof context[i] === "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i]) || context[i] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                      context = context[i];
                      break;
                    }
                  }
                }
                switch (context) {
                  case "http://iiif.io/api/image/1/context.json":
                  case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                    data.version = 1;
                    break;
                  case "http://iiif.io/api/image/2/context.json":
                    data.version = 2;
                    break;
                  case "http://iiif.io/api/image/3/context.json":
                    data.version = 3;
                    break;
                  default:
                    $.console.error("Data has a @context property which contains no known IIIF context URI.");
                }
              }
              if (data.preferredFormats) {
                for (var f = 0; f < data.preferredFormats.length; f++) {
                  if (OpenSeadragon.imageFormatSupported(data.preferredFormats[f])) {
                    data.tileFormat = data.preferredFormats[f];
                    break;
                  }
                }
              }
              return data;
            }
          },
          /**
           * Return the tileWidth for the given level.
           * @function
           * @param {Number} level
           */
          getTileWidth: function(level) {
            if (this.emulateLegacyImagePyramid) {
              return $.TileSource.prototype.getTileWidth.call(this, level);
            }
            var scaleFactor = Math.pow(2, this.maxLevel - level);
            if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].width;
            }
            return this._tileWidth;
          },
          /**
           * Return the tileHeight for the given level.
           * @function
           * @param {Number} level
           */
          getTileHeight: function(level) {
            if (this.emulateLegacyImagePyramid) {
              return $.TileSource.prototype.getTileHeight.call(this, level);
            }
            var scaleFactor = Math.pow(2, this.maxLevel - level);
            if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].height;
            }
            return this._tileHeight;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(level) {
            if (this.emulateLegacyImagePyramid) {
              var levelScale = NaN;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
              }
              return levelScale;
            }
            return $.TileSource.prototype.getLevelScale.call(this, level);
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(level) {
            if (this.emulateLegacyImagePyramid) {
              var scale = this.getLevelScale(level);
              if (scale) {
                return new $.Point(1, 1);
              } else {
                return new $.Point(0, 0);
              }
            }
            if (this.levelSizes) {
              var levelSize = this.levelSizes[level];
              var x = Math.ceil(levelSize.width / this.getTileWidth(level)), y = Math.ceil(levelSize.height / this.getTileHeight(level));
              return new $.Point(x, y);
            } else {
              return $.TileSource.prototype.getNumTiles.call(this, level);
            }
          },
          /**
           * @function
           * @param {Number} level
           * @param {OpenSeadragon.Point} point
           */
          getTileAtPoint: function(level, point) {
            if (this.emulateLegacyImagePyramid) {
              return new $.Point(0, 0);
            }
            if (this.levelSizes) {
              var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
              $.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
              var widthScaled = this.levelSizes[level].width;
              var pixelX = point.x * widthScaled;
              var pixelY = point.y * widthScaled;
              var x = Math.floor(pixelX / this.getTileWidth(level));
              var y = Math.floor(pixelY / this.getTileHeight(level));
              if (point.x >= 1) {
                x = this.getNumTiles(level).x - 1;
              }
              var EPSILON = 1e-15;
              if (point.y >= 1 / this.aspectRatio - EPSILON) {
                y = this.getNumTiles(level).y - 1;
              }
              return new $.Point(x, y);
            }
            return $.TileSource.prototype.getTileAtPoint.call(this, level, point);
          },
          /**
           * Responsible for retrieving the url which will return an image for the
           * region specified by the given x, y, and level components.
           * @function
           * @param {Number} level - z index
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(level, x, y) {
            if (this.emulateLegacyImagePyramid) {
              var url = null;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                url = this.levels[level].url;
              }
              return url;
            }
            var IIIF_ROTATION = "0", scale = Math.pow(0.5, this.maxLevel - level), levelWidth, levelHeight, tileWidth, tileHeight, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW, iiifTileH, iiifSize, iiifSizeW, iiifSizeH, iiifQuality, uri;
            if (this.levelSizes) {
              levelWidth = this.levelSizes[level].width;
              levelHeight = this.levelSizes[level].height;
            } else {
              levelWidth = Math.ceil(this.width * scale);
              levelHeight = Math.ceil(this.height * scale);
            }
            tileWidth = this.getTileWidth(level);
            tileHeight = this.getTileHeight(level);
            iiifTileSizeWidth = Math.round(tileWidth / scale);
            iiifTileSizeHeight = Math.round(tileHeight / scale);
            if (this.version === 1) {
              iiifQuality = "native." + this.tileFormat;
            } else {
              iiifQuality = "default." + this.tileFormat;
            }
            if (levelWidth < tileWidth && levelHeight < tileHeight) {
              if (this.version === 2 && levelWidth === this.width) {
                iiifSize = "full";
              } else if (this.version === 3 && levelWidth === this.width && levelHeight === this.height) {
                iiifSize = "max";
              } else if (this.version === 3) {
                iiifSize = levelWidth + "," + levelHeight;
              } else {
                iiifSize = levelWidth + ",";
              }
              iiifRegion = "full";
            } else {
              iiifTileX = x * iiifTileSizeWidth;
              iiifTileY = y * iiifTileSizeHeight;
              iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
              iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
              if (x === 0 && y === 0 && iiifTileW === this.width && iiifTileH === this.height) {
                iiifRegion = "full";
              } else {
                iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(",");
              }
              iiifSizeW = Math.min(tileWidth, levelWidth - x * tileWidth);
              iiifSizeH = Math.min(tileHeight, levelHeight - y * tileHeight);
              if (this.version === 2 && iiifSizeW === this.width) {
                iiifSize = "full";
              } else if (this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height) {
                iiifSize = "max";
              } else if (this.version === 3) {
                iiifSize = iiifSizeW + "," + iiifSizeH;
              } else {
                iiifSize = iiifSizeW + ",";
              }
            }
            uri = [this._id, iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality].join("/");
            return uri;
          },
          __testonly__: {
            canBeTiled,
            constructLevels
          }
        }
      );
      function canBeTiled(options) {
        var level0Profiles = [
          "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
          "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
          "http://iiif.io/api/image/2/level0.json",
          "level0",
          "https://iiif.io/api/image/3/level0.json"
        ];
        var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
        var isLevel0 = level0Profiles.indexOf(profileLevel) !== -1;
        var hasCanoncicalSizeFeature = false;
        if (options.version === 2 && options.profile.length > 1 && options.profile[1].supports) {
          hasCanoncicalSizeFeature = options.profile[1].supports.indexOf("sizeByW") !== -1;
        }
        if (options.version === 3 && options.extraFeatures) {
          hasCanoncicalSizeFeature = options.extraFeatures.indexOf("sizeByWh") !== -1;
        }
        return !isLevel0 || hasCanoncicalSizeFeature;
      }
      function constructLevels(options) {
        var levels = [];
        for (var i = 0; i < options.sizes.length; i++) {
          levels.push({
            url: options._id + "/full/" + options.sizes[i].width + "," + (options.version === 3 ? options.sizes[i].height : "") + "/0/default." + options.tileFormat,
            width: options.sizes[i].width,
            height: options.sizes[i].height
          });
        }
        return levels.sort(function(a, b) {
          return a.width - b.width;
        });
      }
      function configureFromXml10(xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) {
          throw new Error($.getString("Errors.Xml"));
        }
        var root = xmlDoc.documentElement, rootName = root.tagName, configuration = null;
        if (rootName === "info") {
          try {
            configuration = {};
            parseXML10(root, configuration);
            return configuration;
          } catch (e) {
            throw e instanceof Error ? e : new Error($.getString("Errors.IIIF"));
          }
        }
        throw new Error($.getString("Errors.IIIF"));
      }
      function parseXML10(node, configuration, property) {
        var i, value;
        if (node.nodeType === 3 && property) {
          value = node.nodeValue.trim();
          if (value.match(/^\d*$/)) {
            value = Number(value);
          }
          if (!configuration[property]) {
            configuration[property] = value;
          } else {
            if (!$.isArray(configuration[property])) {
              configuration[property] = [configuration[property]];
            }
            configuration[property].push(value);
          }
        } else if (node.nodeType === 1) {
          for (i = 0; i < node.childNodes.length; i++) {
            parseXML10(node.childNodes[i], configuration, node.nodeName);
          }
        }
      }
    })(OpenSeadragon);
    (function($) {
      $.OsmTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
        var options;
        if ($.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4]
          };
        }
        if (!options.width || !options.height) {
          options.width = 65572864;
          options.height = 65572864;
        }
        if (!options.tileSize) {
          options.tileSize = 256;
          options.tileOverlap = 0;
        }
        if (!options.tilesUrl) {
          options.tilesUrl = "http://tile.openstreetmap.org/";
        }
        options.minLevel = 8;
        $.TileSource.apply(this, [options]);
      };
      $.extend(
        $.OsmTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.OsmTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "openstreetmaps" === data.type;
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url, postData) {
            return data;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            return this.tilesUrl + (level - 8) + "/" + x + "/" + y + ".png";
          }
        }
      );
    })(OpenSeadragon);
    (function($) {
      $.TmsTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
        var options;
        if ($.isPlainObject(width)) {
          options = width;
        } else {
          options = {
            width: arguments[0],
            height: arguments[1],
            tileSize: arguments[2],
            tileOverlap: arguments[3],
            tilesUrl: arguments[4]
          };
        }
        var bufferedWidth = Math.ceil(options.width / 256) * 256, bufferedHeight = Math.ceil(options.height / 256) * 256, max;
        if (bufferedWidth > bufferedHeight) {
          max = bufferedWidth / 256;
        } else {
          max = bufferedHeight / 256;
        }
        options.maxLevel = Math.ceil(Math.log(max) / Math.log(2)) - 1;
        options.tileSize = 256;
        options.width = bufferedWidth;
        options.height = bufferedHeight;
        $.TileSource.apply(this, [options]);
      };
      $.extend(
        $.TmsTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.TmsTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "tiledmapservice" === data.type;
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url, postData) {
            return data;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            var yTiles = this.getNumTiles(level).y - 1;
            return this.tilesUrl + level + "/" + x + "/" + (yTiles - y) + ".png";
          }
        }
      );
    })(OpenSeadragon);
    (function($) {
      $.ZoomifyTileSource = function(options) {
        if (typeof options.tileSize === "undefined") {
          options.tileSize = 256;
        }
        if (typeof options.fileFormat === "undefined") {
          options.fileFormat = "jpg";
          this.fileFormat = options.fileFormat;
        }
        var currentImageSize = {
          x: options.width,
          y: options.height
        };
        options.imageSizes = [{
          x: options.width,
          y: options.height
        }];
        options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
        while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
          currentImageSize.x = Math.floor(currentImageSize.x / 2);
          currentImageSize.y = Math.floor(currentImageSize.y / 2);
          options.imageSizes.push({
            x: currentImageSize.x,
            y: currentImageSize.y
          });
          options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
        }
        options.imageSizes.reverse();
        options.gridSize.reverse();
        options.minLevel = 0;
        options.maxLevel = options.gridSize.length - 1;
        OpenSeadragon.TileSource.apply(this, [options]);
      };
      $.extend(
        $.ZoomifyTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.ZoomifyTileSource.prototype */
        {
          //private
          _getGridSize: function(width, height, tileSize) {
            return {
              x: Math.ceil(width / tileSize),
              y: Math.ceil(height / tileSize)
            };
          },
          //private
          _calculateAbsoluteTileNumber: function(level, x, y) {
            var num = 0;
            var size = {};
            for (var z = 0; z < level; z++) {
              size = this.gridSize[z];
              num += size.x * size.y;
            }
            size = this.gridSize[level];
            num += size.x * y + x;
            return num;
          },
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "zoomifytileservice" === data.type;
          },
          /**
           *
           * @function
           * @param {Object} data - the raw configuration
           * @param {String} url - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(data, url, postData) {
            return data;
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           */
          getTileUrl: function(level, x, y) {
            var result = 0;
            var num = this._calculateAbsoluteTileNumber(level, x, y);
            result = Math.floor(num / 256);
            return this.tilesUrl + "TileGroup" + result + "/" + level + "-" + x + "-" + y + "." + this.fileFormat;
          }
        }
      );
    })(OpenSeadragon);
    (function($) {
      $.LegacyTileSource = function(levels) {
        var options, width, height;
        if ($.isArray(levels)) {
          options = {
            type: "legacy-image-pyramid",
            levels
          };
        }
        options.levels = filterFiles(options.levels);
        if (options.levels.length > 0) {
          width = options.levels[options.levels.length - 1].width;
          height = options.levels[options.levels.length - 1].height;
        } else {
          width = 0;
          height = 0;
          $.console.error("No supported image formats found");
        }
        $.extend(true, options, {
          width,
          height,
          tileSize: Math.max(height, width),
          tileOverlap: 0,
          minLevel: 0,
          maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
        });
        $.TileSource.apply(this, [options]);
        this.levels = options.levels;
      };
      $.extend(
        $.LegacyTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.LegacyTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && "legacy-image-pyramid" === data.type || data.documentElement && "legacy-image-pyramid" === data.documentElement.getAttribute("type");
          },
          /**
           *
           * @function
           * @param {Object|XMLDocument} configuration - the raw configuration
           * @param {String} dataUrl - the url the data was retrieved from if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(configuration, dataUrl, postData) {
            var options;
            if (!$.isPlainObject(configuration)) {
              options = configureFromXML(this, configuration);
            } else {
              options = configureFromObject(this, configuration);
            }
            return options;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(level) {
            var levelScale = NaN;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $.Point(1, 1);
            } else {
              return new $.Point(0, 0);
            }
          },
          /**
           * This method is not implemented by this class other than to throw an Error
           * announcing you have to implement it.  Because of the variety of tile
           * server technologies, and various specifications for building image
           * pyramids, this method is here to allow easy integration.
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @throws {Error}
           */
          getTileUrl: function(level, x, y) {
            var url = null;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          }
        }
      );
      function filterFiles(files) {
        var filtered = [], file, i;
        for (i = 0; i < files.length; i++) {
          file = files[i];
          if (file.height && file.width && file.url) {
            filtered.push({
              url: file.url,
              width: Number(file.width),
              height: Number(file.height)
            });
          } else {
            $.console.error("Unsupported image format: %s", file.url ? file.url : "<no URL>");
          }
        }
        return filtered.sort(function(a, b) {
          return a.height - b.height;
        });
      }
      function configureFromXML(tileSource, xmlDoc) {
        if (!xmlDoc || !xmlDoc.documentElement) {
          throw new Error($.getString("Errors.Xml"));
        }
        var root = xmlDoc.documentElement, rootName = root.tagName, conf = null, levels = [], level, i;
        if (rootName === "image") {
          try {
            conf = {
              type: root.getAttribute("type"),
              levels: []
            };
            levels = root.getElementsByTagName("level");
            for (i = 0; i < levels.length; i++) {
              level = levels[i];
              conf.levels.push({
                url: level.getAttribute("url"),
                width: parseInt(level.getAttribute("width"), 10),
                height: parseInt(level.getAttribute("height"), 10)
              });
            }
            return configureFromObject(tileSource, conf);
          } catch (e) {
            throw e instanceof Error ? e : new Error("Unknown error parsing Legacy Image Pyramid XML.");
          }
        } else if (rootName === "collection") {
          throw new Error("Legacy Image Pyramid Collections not yet supported.");
        } else if (rootName === "error") {
          throw new Error("Error: " + xmlDoc);
        }
        throw new Error("Unknown element " + rootName);
      }
      function configureFromObject(tileSource, configuration) {
        return configuration.levels;
      }
    })(OpenSeadragon);
    (function($) {
      $.ImageTileSource = function(options) {
        options = $.extend({
          buildPyramid: true,
          crossOriginPolicy: false,
          ajaxWithCredentials: false,
          useCanvas: true
        }, options);
        $.TileSource.apply(this, [options]);
      };
      $.extend(
        $.ImageTileSource.prototype,
        $.TileSource.prototype,
        /** @lends OpenSeadragon.ImageTileSource.prototype */
        {
          /**
           * Determine if the data and/or url imply the image service is supported by
           * this tile source.
           * @function
           * @param {Object|Array} data
           * @param {String} optional - url
           */
          supports: function(data, url) {
            return data.type && data.type === "image";
          },
          /**
           *
           * @function
           * @param {Object} options - the options
           * @param {String} dataUrl - the url the image was retrieved from, if any.
           * @param {String} postData - HTTP POST data in k=v&k2=v2... form or null
           * @returns {Object} options - A dictionary of keyword arguments sufficient
           *      to configure this tile sources constructor.
           */
          configure: function(options, dataUrl, postData) {
            return options;
          },
          /**
           * Responsible for retrieving, and caching the
           * image metadata pertinent to this TileSources implementation.
           * @function
           * @param {String} url
           * @throws {Error}
           */
          getImageInfo: function(url) {
            var image = this._image = new Image();
            var _this = this;
            if (this.crossOriginPolicy) {
              image.crossOrigin = this.crossOriginPolicy;
            }
            if (this.ajaxWithCredentials) {
              image.useCredentials = this.ajaxWithCredentials;
            }
            $.addEvent(image, "load", function() {
              _this.width = image.naturalWidth;
              _this.height = image.naturalHeight;
              _this.aspectRatio = _this.width / _this.height;
              _this.dimensions = new $.Point(_this.width, _this.height);
              _this._tileWidth = _this.width;
              _this._tileHeight = _this.height;
              _this.tileOverlap = 0;
              _this.minLevel = 0;
              _this.levels = _this._buildLevels();
              _this.maxLevel = _this.levels.length - 1;
              _this.ready = true;
              _this.raiseEvent("ready", { tileSource: _this });
            });
            $.addEvent(image, "error", function() {
              _this.raiseEvent("open-failed", {
                message: "Error loading image at " + url,
                source: url
              });
            });
            image.src = url;
          },
          /**
           * @function
           * @param {Number} level
           */
          getLevelScale: function(level) {
            var levelScale = NaN;
            if (level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          },
          /**
           * @function
           * @param {Number} level
           */
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $.Point(1, 1);
            } else {
              return new $.Point(0, 0);
            }
          },
          /**
           * Retrieves a tile url
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getTileUrl: function(level, x, y) {
            var url = null;
            if (level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          },
          /**
           * Retrieves a tile context 2D
           * @function
           * @param {Number} level Level of the tile
           * @param {Number} x x coordinate of the tile
           * @param {Number} y y coordinate of the tile
           */
          getContext2D: function(level, x, y) {
            var context = null;
            if (level >= this.minLevel && level <= this.maxLevel) {
              context = this.levels[level].context2D;
            }
            return context;
          },
          /**
           * Destroys ImageTileSource
           * @function
           */
          destroy: function() {
            this._freeupCanvasMemory();
          },
          // private
          //
          // Builds the different levels of the pyramid if possible
          // (i.e. if canvas API enabled and no canvas tainting issue).
          _buildLevels: function() {
            var levels = [{
              url: this._image.src,
              width: this._image.naturalWidth,
              height: this._image.naturalHeight
            }];
            if (!this.buildPyramid || !$.supportsCanvas || !this.useCanvas) {
              delete this._image;
              return levels;
            }
            var currentWidth = this._image.naturalWidth;
            var currentHeight = this._image.naturalHeight;
            var bigCanvas = document.createElement("canvas");
            var bigContext = bigCanvas.getContext("2d");
            bigCanvas.width = currentWidth;
            bigCanvas.height = currentHeight;
            bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
            levels[0].context2D = bigContext;
            delete this._image;
            if ($.isCanvasTainted(bigCanvas)) {
              return levels;
            }
            while (currentWidth >= 2 && currentHeight >= 2) {
              currentWidth = Math.floor(currentWidth / 2);
              currentHeight = Math.floor(currentHeight / 2);
              var smallCanvas = document.createElement("canvas");
              var smallContext = smallCanvas.getContext("2d");
              smallCanvas.width = currentWidth;
              smallCanvas.height = currentHeight;
              smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);
              levels.splice(0, 0, {
                context2D: smallContext,
                width: currentWidth,
                height: currentHeight
              });
              bigCanvas = smallCanvas;
              bigContext = smallContext;
            }
            return levels;
          },
          /**
           * Free up canvas memory
           * (iOS 12 or higher on 2GB RAM device has only 224MB canvas memory,
           * and Safari keeps canvas until its height and width will be set to 0).
           * @function
           */
          _freeupCanvasMemory: function() {
            for (var i = 0; i < this.levels.length; i++) {
              if (this.levels[i].context2D) {
                this.levels[i].context2D.canvas.height = 0;
                this.levels[i].context2D.canvas.width = 0;
              }
            }
          }
        }
      );
    })(OpenSeadragon);
    (function($) {
      $.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
        $.console.error("TileSourceCollection is deprecated; use World instead");
      };
    })(OpenSeadragon);
    (function($) {
      $.ButtonState = {
        REST: 0,
        GROUP: 1,
        HOVER: 2,
        DOWN: 3
      };
      $.Button = function(options) {
        var _this = this;
        $.EventSource.call(this);
        $.extend(true, this, {
          tooltip: null,
          srcRest: null,
          srcGroup: null,
          srcHover: null,
          srcDown: null,
          clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
          /**
           * How long to wait before fading.
           * @member {Number} fadeDelay
           * @memberof OpenSeadragon.Button#
           */
          fadeDelay: 0,
          /**
           * How long should it take to fade the button.
           * @member {Number} fadeLength
           * @memberof OpenSeadragon.Button#
           */
          fadeLength: 2e3,
          onPress: null,
          onRelease: null,
          onClick: null,
          onEnter: null,
          onExit: null,
          onFocus: null,
          onBlur: null,
          userData: null
        }, options);
        this.element = options.element || $.makeNeutralElement("div");
        if (!options.element) {
          this.imgRest = $.makeTransparentImage(this.srcRest);
          this.imgGroup = $.makeTransparentImage(this.srcGroup);
          this.imgHover = $.makeTransparentImage(this.srcHover);
          this.imgDown = $.makeTransparentImage(this.srcDown);
          this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip;
          $.setElementPointerEventsNone(this.imgRest);
          $.setElementPointerEventsNone(this.imgGroup);
          $.setElementPointerEventsNone(this.imgHover);
          $.setElementPointerEventsNone(this.imgDown);
          this.element.style.position = "relative";
          $.setElementTouchActionNone(this.element);
          this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute";
          this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px";
          this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px";
          this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden";
          if ($.Browser.vendor === $.BROWSERS.FIREFOX && $.Browser.version < 3) {
            this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "";
          }
          this.element.appendChild(this.imgRest);
          this.element.appendChild(this.imgGroup);
          this.element.appendChild(this.imgHover);
          this.element.appendChild(this.imgDown);
        }
        this.addHandler("press", this.onPress);
        this.addHandler("release", this.onRelease);
        this.addHandler("click", this.onClick);
        this.addHandler("enter", this.onEnter);
        this.addHandler("exit", this.onExit);
        this.addHandler("focus", this.onFocus);
        this.addHandler("blur", this.onBlur);
        this.currentState = $.ButtonState.GROUP;
        this.fadeBeginTime = null;
        this.shouldFade = false;
        this.element.style.display = "inline-block";
        this.element.style.position = "relative";
        this.element.title = this.tooltip;
        this.tracker = new $.MouseTracker({
          userData: "Button.tracker",
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(event) {
            if (event.insideElementPressed) {
              inTo(_this, $.ButtonState.DOWN);
              _this.raiseEvent("enter", { originalEvent: event.originalEvent });
            } else if (!event.buttonDownAny) {
              inTo(_this, $.ButtonState.HOVER);
            }
          },
          focusHandler: function(event) {
            _this.tracker.enterHandler(event);
            _this.raiseEvent("focus", { originalEvent: event.originalEvent });
          },
          leaveHandler: function(event) {
            outTo(_this, $.ButtonState.GROUP);
            if (event.insideElementPressed) {
              _this.raiseEvent("exit", { originalEvent: event.originalEvent });
            }
          },
          blurHandler: function(event) {
            _this.tracker.leaveHandler(event);
            _this.raiseEvent("blur", { originalEvent: event.originalEvent });
          },
          pressHandler: function(event) {
            inTo(_this, $.ButtonState.DOWN);
            _this.raiseEvent("press", { originalEvent: event.originalEvent });
          },
          releaseHandler: function(event) {
            if (event.insideElementPressed && event.insideElementReleased) {
              outTo(_this, $.ButtonState.HOVER);
              _this.raiseEvent("release", { originalEvent: event.originalEvent });
            } else if (event.insideElementPressed) {
              outTo(_this, $.ButtonState.GROUP);
            } else {
              inTo(_this, $.ButtonState.HOVER);
            }
          },
          clickHandler: function(event) {
            if (event.quick) {
              _this.raiseEvent("click", { originalEvent: event.originalEvent });
            }
          },
          keyHandler: function(event) {
            if (13 === event.keyCode) {
              _this.raiseEvent("click", { originalEvent: event.originalEvent });
              _this.raiseEvent("release", { originalEvent: event.originalEvent });
              event.preventDefault = true;
            } else {
              event.preventDefault = false;
            }
          }
        });
        outTo(this, $.ButtonState.REST);
      };
      $.extend(
        $.Button.prototype,
        $.EventSource.prototype,
        /** @lends OpenSeadragon.Button.prototype */
        {
          /**
           * Used by a button container element (e.g. a ButtonGroup) to transition the button state
           * to ButtonState.GROUP.
           * @function
           */
          notifyGroupEnter: function() {
            inTo(this, $.ButtonState.GROUP);
          },
          /**
           * Used by a button container element (e.g. a ButtonGroup) to transition the button state
           * to ButtonState.REST.
           * @function
           */
          notifyGroupExit: function() {
            outTo(this, $.ButtonState.REST);
          },
          /**
           * @function
           */
          disable: function() {
            this.notifyGroupExit();
            this.element.disabled = true;
            this.tracker.setTracking(false);
            $.setElementOpacity(this.element, 0.2, true);
          },
          /**
           * @function
           */
          enable: function() {
            this.element.disabled = false;
            this.tracker.setTracking(true);
            $.setElementOpacity(this.element, 1, true);
            this.notifyGroupEnter();
          },
          destroy: function() {
            if (this.imgRest) {
              this.element.removeChild(this.imgRest);
              this.imgRest = null;
            }
            if (this.imgGroup) {
              this.element.removeChild(this.imgGroup);
              this.imgGroup = null;
            }
            if (this.imgHover) {
              this.element.removeChild(this.imgHover);
              this.imgHover = null;
            }
            if (this.imgDown) {
              this.element.removeChild(this.imgDown);
              this.imgDown = null;
            }
            this.removeAllHandlers();
            this.tracker.destroy();
            this.element = null;
          }
        }
      );
      function scheduleFade(button) {
        $.requestAnimationFrame(function() {
          updateFade(button);
        });
      }
      function updateFade(button) {
        var currentTime, deltaTime, opacity;
        if (button.shouldFade) {
          currentTime = $.now();
          deltaTime = currentTime - button.fadeBeginTime;
          opacity = 1 - deltaTime / button.fadeLength;
          opacity = Math.min(1, opacity);
          opacity = Math.max(0, opacity);
          if (button.imgGroup) {
            $.setElementOpacity(button.imgGroup, opacity, true);
          }
          if (opacity > 0) {
            scheduleFade(button);
          }
        }
      }
      function beginFading(button) {
        button.shouldFade = true;
        button.fadeBeginTime = $.now() + button.fadeDelay;
        window.setTimeout(function() {
          scheduleFade(button);
        }, button.fadeDelay);
      }
      function stopFading(button) {
        button.shouldFade = false;
        if (button.imgGroup) {
          $.setElementOpacity(button.imgGroup, 1, true);
        }
      }
      function inTo(button, newState) {
        if (button.element.disabled) {
          return;
        }
        if (newState >= $.ButtonState.GROUP && button.currentState === $.ButtonState.REST) {
          stopFading(button);
          button.currentState = $.ButtonState.GROUP;
        }
        if (newState >= $.ButtonState.HOVER && button.currentState === $.ButtonState.GROUP) {
          if (button.imgHover) {
            button.imgHover.style.visibility = "";
          }
          button.currentState = $.ButtonState.HOVER;
        }
        if (newState >= $.ButtonState.DOWN && button.currentState === $.ButtonState.HOVER) {
          if (button.imgDown) {
            button.imgDown.style.visibility = "";
          }
          button.currentState = $.ButtonState.DOWN;
        }
      }
      function outTo(button, newState) {
        if (button.element.disabled) {
          return;
        }
        if (newState <= $.ButtonState.HOVER && button.currentState === $.ButtonState.DOWN) {
          if (button.imgDown) {
            button.imgDown.style.visibility = "hidden";
          }
          button.currentState = $.ButtonState.HOVER;
        }
        if (newState <= $.ButtonState.GROUP && button.currentState === $.ButtonState.HOVER) {
          if (button.imgHover) {
            button.imgHover.style.visibility = "hidden";
          }
          button.currentState = $.ButtonState.GROUP;
        }
        if (newState <= $.ButtonState.REST && button.currentState === $.ButtonState.GROUP) {
          beginFading(button);
          button.currentState = $.ButtonState.REST;
        }
      }
    })(OpenSeadragon);
    (function($) {
      $.ButtonGroup = function(options) {
        $.extend(true, this, {
          /**
           * An array containing the buttons themselves.
           * @member {Array} buttons
           * @memberof OpenSeadragon.ButtonGroup#
           */
          buttons: [],
          clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold,
          clickDistThreshold: $.DEFAULT_SETTINGS.clickDistThreshold,
          labelText: ""
        }, options);
        var buttons = this.buttons.concat([]), _this = this, i;
        this.element = options.element || $.makeNeutralElement("div");
        if (!options.group) {
          this.element.style.display = "inline-block";
          for (i = 0; i < buttons.length; i++) {
            this.element.appendChild(buttons[i].element);
          }
        }
        $.setElementTouchActionNone(this.element);
        this.tracker = new $.MouseTracker({
          userData: "ButtonGroup.tracker",
          element: this.element,
          clickTimeThreshold: this.clickTimeThreshold,
          clickDistThreshold: this.clickDistThreshold,
          enterHandler: function(event) {
            var i2;
            for (i2 = 0; i2 < _this.buttons.length; i2++) {
              _this.buttons[i2].notifyGroupEnter();
            }
          },
          leaveHandler: function(event) {
            var i2;
            if (!event.insideElementPressed) {
              for (i2 = 0; i2 < _this.buttons.length; i2++) {
                _this.buttons[i2].notifyGroupExit();
              }
            }
          }
        });
      };
      $.ButtonGroup.prototype = {
        /**
         * Adds the given button to this button group.
         *
         * @function
         * @param {OpenSeadragon.Button} button
         */
        addButton: function(button) {
          this.buttons.push(button);
          this.element.appendChild(button.element);
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateEnter: function() {
          this.tracker.enterHandler({ eventSource: this.tracker });
        },
        /**
         * TODO: Figure out why this is used on the public API and if a more useful
         * api can be created.
         * @function
         * @private
         */
        emulateLeave: function() {
          this.tracker.leaveHandler({ eventSource: this.tracker });
        },
        destroy: function() {
          while (this.buttons.length) {
            var button = this.buttons.pop();
            this.element.removeChild(button.element);
            button.destroy();
          }
          this.tracker.destroy();
          this.element = null;
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.Rect = function(x, y, width, height, degrees) {
        this.x = typeof x === "number" ? x : 0;
        this.y = typeof y === "number" ? y : 0;
        this.width = typeof width === "number" ? width : 0;
        this.height = typeof height === "number" ? height : 0;
        this.degrees = typeof degrees === "number" ? degrees : 0;
        this.degrees = $.positiveModulo(this.degrees, 360);
        var newTopLeft, newWidth;
        if (this.degrees >= 270) {
          newTopLeft = this.getTopRight();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          newWidth = this.height;
          this.height = this.width;
          this.width = newWidth;
          this.degrees -= 270;
        } else if (this.degrees >= 180) {
          newTopLeft = this.getBottomRight();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          this.degrees -= 180;
        } else if (this.degrees >= 90) {
          newTopLeft = this.getBottomLeft();
          this.x = newTopLeft.x;
          this.y = newTopLeft.y;
          newWidth = this.height;
          this.height = this.width;
          this.width = newWidth;
          this.degrees -= 90;
        }
      };
      $.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
        var width = topLeft.distanceTo(topRight);
        var height = topLeft.distanceTo(bottomLeft);
        var diff = topRight.minus(topLeft);
        var radians = Math.atan(diff.y / diff.x);
        if (diff.x < 0) {
          radians += Math.PI;
        } else if (diff.y < 0) {
          radians += 2 * Math.PI;
        }
        return new $.Rect(
          topLeft.x,
          topLeft.y,
          width,
          height,
          radians / Math.PI * 180
        );
      };
      $.Rect.prototype = {
        /**
         * @function
         * @returns {OpenSeadragon.Rect} a duplicate of this Rect
         */
        clone: function() {
          return new $.Rect(
            this.x,
            this.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * The aspect ratio is simply the ratio of width to height.
         * @function
         * @returns {Number} The ratio of width to height.
         */
        getAspectRatio: function() {
          return this.width / this.height;
        },
        /**
         * Provides the coordinates of the upper-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the upper-left corner of
         *  the rectangle.
         */
        getTopLeft: function() {
          return new $.Point(
            this.x,
            this.y
          );
        },
        /**
         * Provides the coordinates of the bottom-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-right corner of
         *  the rectangle.
         */
        getBottomRight: function() {
          return new $.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the top-right corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the top-right corner of
         *  the rectangle.
         */
        getTopRight: function() {
          return new $.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Provides the coordinates of the bottom-left corner of the rectangle as a
         * point.
         * @function
         * @returns {OpenSeadragon.Point} The coordinate of the bottom-left corner of
         *  the rectangle.
         */
        getBottomLeft: function() {
          return new $.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Computes the center of the rectangle.
         * @function
         * @returns {OpenSeadragon.Point} The center of the rectangle as represented
         *  as represented by a 2-dimensional vector (x,y)
         */
        getCenter: function() {
          return new $.Point(
            this.x + this.width / 2,
            this.y + this.height / 2
          ).rotate(this.degrees, this.getTopLeft());
        },
        /**
         * Returns the width and height component as a vector OpenSeadragon.Point
         * @function
         * @returns {OpenSeadragon.Point} The 2 dimensional vector representing the
         *  width and height of the rectangle.
         */
        getSize: function() {
          return new $.Point(this.width, this.height);
        },
        /**
         * Determines if two Rectangles have equivalent components.
         * @function
         * @param {OpenSeadragon.Rect} rectangle The Rectangle to compare to.
         * @returns {Boolean} 'true' if all components are equal, otherwise 'false'.
         */
        equals: function(other) {
          return other instanceof $.Rect && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height && this.degrees === other.degrees;
        },
        /**
        * Multiply all dimensions (except degrees) in this Rect by a factor and
        * return a new Rect.
        * @function
        * @param {Number} factor The factor to multiply vector components.
        * @returns {OpenSeadragon.Rect} A new rect representing the multiplication
        *  of the vector components by the factor
        */
        times: function(factor) {
          return new $.Rect(
            this.x * factor,
            this.y * factor,
            this.width * factor,
            this.height * factor,
            this.degrees
          );
        },
        /**
        * Translate/move this Rect by a vector and return new Rect.
        * @function
        * @param {OpenSeadragon.Point} delta The translation vector.
        * @returns {OpenSeadragon.Rect} A new rect with altered position
        */
        translate: function(delta) {
          return new $.Rect(
            this.x + delta.x,
            this.y + delta.y,
            this.width,
            this.height,
            this.degrees
          );
        },
        /**
         * Returns the smallest rectangle that will contain this and the given
         * rectangle bounding boxes.
         * @param {OpenSeadragon.Rect} rect
         * @returns {OpenSeadragon.Rect} The new rectangle.
         */
        union: function(rect) {
          var thisBoundingBox = this.getBoundingBox();
          var otherBoundingBox = rect.getBoundingBox();
          var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
          var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
          var right = Math.max(
            thisBoundingBox.x + thisBoundingBox.width,
            otherBoundingBox.x + otherBoundingBox.width
          );
          var bottom = Math.max(
            thisBoundingBox.y + thisBoundingBox.height,
            otherBoundingBox.y + otherBoundingBox.height
          );
          return new $.Rect(
            left,
            top,
            right - left,
            bottom - top
          );
        },
        /**
         * Returns the bounding box of the intersection of this rectangle with the
         * given rectangle.
         * @param {OpenSeadragon.Rect} rect
         * @returns {OpenSeadragon.Rect} the bounding box of the intersection
         * or null if the rectangles don't intersect.
         */
        intersection: function(rect) {
          var EPSILON = 1e-10;
          var intersectionPoints = [];
          var thisTopLeft = this.getTopLeft();
          if (rect.containsPoint(thisTopLeft, EPSILON)) {
            intersectionPoints.push(thisTopLeft);
          }
          var thisTopRight = this.getTopRight();
          if (rect.containsPoint(thisTopRight, EPSILON)) {
            intersectionPoints.push(thisTopRight);
          }
          var thisBottomLeft = this.getBottomLeft();
          if (rect.containsPoint(thisBottomLeft, EPSILON)) {
            intersectionPoints.push(thisBottomLeft);
          }
          var thisBottomRight = this.getBottomRight();
          if (rect.containsPoint(thisBottomRight, EPSILON)) {
            intersectionPoints.push(thisBottomRight);
          }
          var rectTopLeft = rect.getTopLeft();
          if (this.containsPoint(rectTopLeft, EPSILON)) {
            intersectionPoints.push(rectTopLeft);
          }
          var rectTopRight = rect.getTopRight();
          if (this.containsPoint(rectTopRight, EPSILON)) {
            intersectionPoints.push(rectTopRight);
          }
          var rectBottomLeft = rect.getBottomLeft();
          if (this.containsPoint(rectBottomLeft, EPSILON)) {
            intersectionPoints.push(rectBottomLeft);
          }
          var rectBottomRight = rect.getBottomRight();
          if (this.containsPoint(rectBottomRight, EPSILON)) {
            intersectionPoints.push(rectBottomRight);
          }
          var thisSegments = this._getSegments();
          var rectSegments = rect._getSegments();
          for (var i = 0; i < thisSegments.length; i++) {
            var thisSegment = thisSegments[i];
            for (var j = 0; j < rectSegments.length; j++) {
              var rectSegment = rectSegments[j];
              var intersect = getIntersection(
                thisSegment[0],
                thisSegment[1],
                rectSegment[0],
                rectSegment[1]
              );
              if (intersect) {
                intersectionPoints.push(intersect);
              }
            }
          }
          function getIntersection(a, b, c, d) {
            var abVector = b.minus(a);
            var cdVector = d.minus(c);
            var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
            if (denom === 0) {
              return null;
            }
            var s = (abVector.x * (a.y - c.y) - abVector.y * (a.x - c.x)) / denom;
            var t = (cdVector.x * (a.y - c.y) - cdVector.y * (a.x - c.x)) / denom;
            if (-EPSILON <= s && s <= 1 - EPSILON && -EPSILON <= t && t <= 1 - EPSILON) {
              return new $.Point(a.x + t * abVector.x, a.y + t * abVector.y);
            }
            return null;
          }
          if (intersectionPoints.length === 0) {
            return null;
          }
          var minX = intersectionPoints[0].x;
          var maxX = intersectionPoints[0].x;
          var minY = intersectionPoints[0].y;
          var maxY = intersectionPoints[0].y;
          for (var k = 1; k < intersectionPoints.length; k++) {
            var point = intersectionPoints[k];
            if (point.x < minX) {
              minX = point.x;
            }
            if (point.x > maxX) {
              maxX = point.x;
            }
            if (point.y < minY) {
              minY = point.y;
            }
            if (point.y > maxY) {
              maxY = point.y;
            }
          }
          return new $.Rect(minX, minY, maxX - minX, maxY - minY);
        },
        // private
        _getSegments: function() {
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var bottomRight = this.getBottomRight();
          return [
            [topLeft, topRight],
            [topRight, bottomRight],
            [bottomRight, bottomLeft],
            [bottomLeft, topLeft]
          ];
        },
        /**
         * Rotates a rectangle around a point.
         * @function
         * @param {Number} degrees The angle in degrees to rotate.
         * @param {OpenSeadragon.Point} [pivot] The point about which to rotate.
         * Defaults to the center of the rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        rotate: function(degrees, pivot) {
          degrees = $.positiveModulo(degrees, 360);
          if (degrees === 0) {
            return this.clone();
          }
          pivot = pivot || this.getCenter();
          var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
          var newTopRight = this.getTopRight().rotate(degrees, pivot);
          var diff = newTopRight.minus(newTopLeft);
          diff = diff.apply(function(x) {
            var EPSILON = 1e-15;
            return Math.abs(x) < EPSILON ? 0 : x;
          });
          var radians = Math.atan(diff.y / diff.x);
          if (diff.x < 0) {
            radians += Math.PI;
          } else if (diff.y < 0) {
            radians += 2 * Math.PI;
          }
          return new $.Rect(
            newTopLeft.x,
            newTopLeft.y,
            this.width,
            this.height,
            radians / Math.PI * 180
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle.
         * @returns {OpenSeadragon.Rect}
         */
        getBoundingBox: function() {
          if (this.degrees === 0) {
            return this.clone();
          }
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var bottomRight = this.getBottomRight();
          var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
          var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
          return new $.Rect(
            minX,
            minY,
            maxX - minX,
            maxY - minY
          );
        },
        /**
         * Retrieves the smallest horizontal (degrees=0) rectangle which contains
         * this rectangle and has integers x, y, width and height
         * @returns {OpenSeadragon.Rect}
         */
        getIntegerBoundingBox: function() {
          var boundingBox = this.getBoundingBox();
          var x = Math.floor(boundingBox.x);
          var y = Math.floor(boundingBox.y);
          var width = Math.ceil(boundingBox.width + boundingBox.x - x);
          var height = Math.ceil(boundingBox.height + boundingBox.y - y);
          return new $.Rect(x, y, width, height);
        },
        /**
         * Determines whether a point is inside this rectangle (edge included).
         * @function
         * @param {OpenSeadragon.Point} point
         * @param {Number} [epsilon=0] the margin of error allowed
         * @returns {Boolean} true if the point is inside this rectangle, false
         * otherwise.
         */
        containsPoint: function(point, epsilon) {
          epsilon = epsilon || 0;
          var topLeft = this.getTopLeft();
          var topRight = this.getTopRight();
          var bottomLeft = this.getBottomLeft();
          var topDiff = topRight.minus(topLeft);
          var leftDiff = bottomLeft.minus(topLeft);
          return (point.x - topLeft.x) * topDiff.x + (point.y - topLeft.y) * topDiff.y >= -epsilon && (point.x - topRight.x) * topDiff.x + (point.y - topRight.y) * topDiff.y <= epsilon && (point.x - topLeft.x) * leftDiff.x + (point.y - topLeft.y) * leftDiff.y >= -epsilon && (point.x - bottomLeft.x) * leftDiff.x + (point.y - bottomLeft.y) * leftDiff.y <= epsilon;
        },
        /**
         * Provides a string representation of the rectangle which is useful for
         * debugging.
         * @function
         * @returns {String} A string representation of the rectangle.
         */
        toString: function() {
          return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
        }
      };
    })(OpenSeadragon);
    (function($) {
      var THIS = {};
      $.ReferenceStrip = function(options) {
        var _this = this, viewer = options.viewer, viewerSize = $.getElementSize(viewer.element), element, style, i;
        if (!options.id) {
          options.id = "referencestrip-" + $.now();
          this.element = $.makeNeutralElement("div");
          this.element.id = options.id;
          this.element.className = "referencestrip";
        }
        options = $.extend(true, {
          sizeRatio: $.DEFAULT_SETTINGS.referenceStripSizeRatio,
          position: $.DEFAULT_SETTINGS.referenceStripPosition,
          scroll: $.DEFAULT_SETTINGS.referenceStripScroll,
          clickTimeThreshold: $.DEFAULT_SETTINGS.clickTimeThreshold
        }, options, {
          element: this.element
        });
        $.extend(this, options);
        THIS[this.id] = {
          animating: false
        };
        this.minPixelRatio = this.viewer.minPixelRatio;
        this.element.tabIndex = 0;
        style = this.element.style;
        style.marginTop = "0px";
        style.marginRight = "0px";
        style.marginBottom = "0px";
        style.marginLeft = "0px";
        style.left = "0px";
        style.bottom = "0px";
        style.border = "0px";
        style.background = "#000";
        style.position = "relative";
        $.setElementTouchActionNone(this.element);
        $.setElementOpacity(this.element, 0.8);
        this.viewer = viewer;
        this.tracker = new $.MouseTracker({
          userData: "ReferenceStrip.tracker",
          element: this.element,
          clickHandler: $.delegate(this, onStripClick),
          dragHandler: $.delegate(this, onStripDrag),
          scrollHandler: $.delegate(this, onStripScroll),
          enterHandler: $.delegate(this, onStripEnter),
          leaveHandler: $.delegate(this, onStripLeave),
          keyDownHandler: $.delegate(this, onKeyDown),
          keyHandler: $.delegate(this, onKeyPress),
          preProcessEventHandler: function(eventInfo) {
            if (eventInfo.eventType === "wheel") {
              eventInfo.preventDefault = true;
            }
          }
        });
        if (options.width && options.height) {
          this.element.style.width = options.width + "px";
          this.element.style.height = options.height + "px";
          viewer.addControl(
            this.element,
            { anchor: $.ControlAnchor.BOTTOM_LEFT }
          );
        } else {
          if ("horizontal" === options.scroll) {
            this.element.style.width = viewerSize.x * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
            this.element.style.height = viewerSize.y * options.sizeRatio + "px";
            viewer.addControl(
              this.element,
              { anchor: $.ControlAnchor.BOTTOM_LEFT }
            );
          } else {
            this.element.style.height = viewerSize.y * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
            this.element.style.width = viewerSize.x * options.sizeRatio + "px";
            viewer.addControl(
              this.element,
              { anchor: $.ControlAnchor.TOP_LEFT }
            );
          }
        }
        this.panelWidth = viewerSize.x * this.sizeRatio + 8;
        this.panelHeight = viewerSize.y * this.sizeRatio + 8;
        this.panels = [];
        this.miniViewers = {};
        for (i = 0; i < viewer.tileSources.length; i++) {
          element = $.makeNeutralElement("div");
          element.id = this.element.id + "-" + i;
          element.style.width = _this.panelWidth + "px";
          element.style.height = _this.panelHeight + "px";
          element.style.display = "inline";
          element.style["float"] = "left";
          element.style.cssFloat = "left";
          element.style.styleFloat = "left";
          element.style.padding = "2px";
          $.setElementTouchActionNone(element);
          $.setElementPointerEventsNone(element);
          this.element.appendChild(element);
          element.activePanel = false;
          this.panels.push(element);
        }
        loadPanels(this, this.scroll === "vertical" ? viewerSize.y : viewerSize.x, 0);
        this.setFocus(0);
      };
      $.ReferenceStrip.prototype = {
        /**
         * @function
         */
        setFocus: function(page) {
          var element = this.element.querySelector("#" + this.element.id + "-" + page), viewerSize = $.getElementSize(this.viewer.canvas), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), offsetLeft = -Number(this.element.style.marginLeft.replace("px", "")), offsetTop = -Number(this.element.style.marginTop.replace("px", "")), offset;
          if (this.currentSelected !== element) {
            if (this.currentSelected) {
              this.currentSelected.style.background = "#000";
            }
            this.currentSelected = element;
            this.currentSelected.style.background = "#999";
            if ("horizontal" === this.scroll) {
              offset = Number(page) * (this.panelWidth + 3);
              if (offset > offsetLeft + viewerSize.x - this.panelWidth) {
                offset = Math.min(offset, scrollWidth - viewerSize.x);
                this.element.style.marginLeft = -offset + "px";
                loadPanels(this, viewerSize.x, -offset);
              } else if (offset < offsetLeft) {
                offset = Math.max(0, offset - viewerSize.x / 2);
                this.element.style.marginLeft = -offset + "px";
                loadPanels(this, viewerSize.x, -offset);
              }
            } else {
              offset = Number(page) * (this.panelHeight + 3);
              if (offset > offsetTop + viewerSize.y - this.panelHeight) {
                offset = Math.min(offset, scrollHeight - viewerSize.y);
                this.element.style.marginTop = -offset + "px";
                loadPanels(this, viewerSize.y, -offset);
              } else if (offset < offsetTop) {
                offset = Math.max(0, offset - viewerSize.y / 2);
                this.element.style.marginTop = -offset + "px";
                loadPanels(this, viewerSize.y, -offset);
              }
            }
            this.currentPage = page;
            onStripEnter.call(this, { eventSource: this.tracker });
          }
        },
        /**
         * @function
         */
        update: function() {
          if (THIS[this.id].animating) {
            return true;
          }
          return false;
        },
        destroy: function() {
          if (this.miniViewers) {
            for (var key in this.miniViewers) {
              this.miniViewers[key].destroy();
            }
          }
          this.tracker.destroy();
          if (this.element) {
            this.viewer.removeControl(this.element);
          }
        }
      };
      function onStripClick(event) {
        if (event.quick) {
          var page;
          if ("horizontal" === this.scroll) {
            page = Math.floor(event.position.x / (this.panelWidth + 4));
          } else {
            page = Math.floor(event.position.y / this.panelHeight);
          }
          this.viewer.goToPage(page);
        }
        this.element.focus();
      }
      function onStripDrag(event) {
        this.dragging = true;
        if (this.element) {
          var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $.getElementSize(this.viewer.canvas);
          if ("horizontal" === this.scroll) {
            if (-event.delta.x > 0) {
              if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
              }
            } else if (-event.delta.x < 0) {
              if (offsetLeft < 0) {
                this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
              }
            }
          } else {
            if (-event.delta.y > 0) {
              if (offsetTop > -(scrollHeight - viewerSize.y)) {
                this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
              }
            } else if (-event.delta.y < 0) {
              if (offsetTop < 0) {
                this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
              }
            }
          }
        }
      }
      function onStripScroll(event) {
        if (this.element) {
          var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $.getElementSize(this.viewer.canvas);
          if ("horizontal" === this.scroll) {
            if (event.scroll > 0) {
              if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
              }
            } else if (event.scroll < 0) {
              if (offsetLeft < 0) {
                this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
              }
            }
          } else {
            if (event.scroll < 0) {
              if (offsetTop > viewerSize.y - scrollHeight) {
                this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
              }
            } else if (event.scroll > 0) {
              if (offsetTop < 0) {
                this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
              }
            }
          }
          event.preventDefault = true;
        }
      }
      function loadPanels(strip, viewerSize, scroll) {
        var panelSize, activePanelsStart, activePanelsEnd, miniViewer, i, element;
        if ("horizontal" === strip.scroll) {
          panelSize = strip.panelWidth;
        } else {
          panelSize = strip.panelHeight;
        }
        activePanelsStart = Math.ceil(viewerSize / panelSize) + 5;
        activePanelsEnd = Math.ceil((Math.abs(scroll) + viewerSize) / panelSize) + 1;
        activePanelsStart = activePanelsEnd - activePanelsStart;
        activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
        for (i = activePanelsStart; i < activePanelsEnd && i < strip.panels.length; i++) {
          element = strip.panels[i];
          if (!element.activePanel) {
            var miniTileSource;
            var originalTileSource = strip.viewer.tileSources[i];
            if (originalTileSource.referenceStripThumbnailUrl) {
              miniTileSource = {
                type: "image",
                url: originalTileSource.referenceStripThumbnailUrl
              };
            } else {
              miniTileSource = originalTileSource;
            }
            miniViewer = new $.Viewer({
              id: element.id,
              tileSources: [miniTileSource],
              element,
              navigatorSizeRatio: strip.sizeRatio,
              showNavigator: false,
              mouseNavEnabled: false,
              showNavigationControl: false,
              showSequenceControl: false,
              immediateRender: true,
              blendTime: 0,
              animationTime: 0,
              loadTilesWithAjax: strip.viewer.loadTilesWithAjax,
              ajaxHeaders: strip.viewer.ajaxHeaders,
              useCanvas: strip.useCanvas
            });
            $.setElementPointerEventsNone(miniViewer.canvas);
            $.setElementPointerEventsNone(miniViewer.container);
            miniViewer.innerTracker.setTracking(false);
            miniViewer.outerTracker.setTracking(false);
            strip.miniViewers[element.id] = miniViewer;
            element.activePanel = true;
          }
        }
      }
      function onStripEnter(event) {
        var element = event.eventSource.element;
        if ("horizontal" === this.scroll) {
          element.style.marginBottom = "0px";
        } else {
          element.style.marginLeft = "0px";
        }
      }
      function onStripLeave(event) {
        var element = event.eventSource.element;
        if ("horizontal" === this.scroll) {
          element.style.marginBottom = "-" + $.getElementSize(element).y / 2 + "px";
        } else {
          element.style.marginLeft = "-" + $.getElementSize(element).x / 2 + "px";
        }
      }
      function onKeyDown(event) {
        if (!event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 38:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              event.preventDefault = true;
              break;
            case 40:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              event.preventDefault = true;
              break;
            case 37:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              event.preventDefault = true;
              break;
            case 39:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              event.preventDefault = true;
              break;
            default:
              event.preventDefault = false;
              break;
          }
        } else {
          event.preventDefault = false;
        }
      }
      function onKeyPress(event) {
        if (!event.ctrl && !event.alt && !event.meta) {
          switch (event.keyCode) {
            case 61:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              event.preventDefault = true;
              break;
            case 45:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              event.preventDefault = true;
              break;
            case 48:
            case 119:
            case 87:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              event.preventDefault = true;
              break;
            case 115:
            case 83:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              event.preventDefault = true;
              break;
            case 97:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
              event.preventDefault = true;
              break;
            case 100:
              onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
              event.preventDefault = true;
              break;
            default:
              event.preventDefault = false;
              break;
          }
        } else {
          event.preventDefault = false;
        }
      }
    })(OpenSeadragon);
    (function($) {
      $.DisplayRect = function(x, y, width, height, minLevel, maxLevel) {
        $.Rect.apply(this, [x, y, width, height]);
        this.minLevel = minLevel;
        this.maxLevel = maxLevel;
      };
      $.extend($.DisplayRect.prototype, $.Rect.prototype);
    })(OpenSeadragon);
    (function($) {
      $.Spring = function(options) {
        var args = arguments;
        if (typeof options !== "object") {
          options = {
            initial: args.length && typeof args[0] === "number" ? args[0] : void 0,
            /**
             * Spring stiffness.
             * @member {Number} springStiffness
             * @memberof OpenSeadragon.Spring#
             */
            springStiffness: args.length > 1 ? args[1].springStiffness : 5,
            /**
             * Animation duration per spring.
             * @member {Number} animationTime
             * @memberof OpenSeadragon.Spring#
             */
            animationTime: args.length > 1 ? args[1].animationTime : 1.5
          };
        }
        $.console.assert(
          typeof options.springStiffness === "number" && options.springStiffness !== 0,
          "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
        );
        $.console.assert(
          typeof options.animationTime === "number" && options.animationTime >= 0,
          "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
        );
        if (options.exponential) {
          this._exponential = true;
          delete options.exponential;
        }
        $.extend(true, this, options);
        this.current = {
          value: typeof this.initial === "number" ? this.initial : this._exponential ? 0 : 1,
          time: $.now()
          // always work in milliseconds
        };
        $.console.assert(
          !this._exponential || this.current.value !== 0,
          "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
        );
        this.start = {
          value: this.current.value,
          time: this.current.time
        };
        this.target = {
          value: this.current.value,
          time: this.current.time
        };
        if (this._exponential) {
          this.start._logValue = Math.log(this.start.value);
          this.target._logValue = Math.log(this.target.value);
          this.current._logValue = Math.log(this.current.value);
        }
      };
      $.Spring.prototype = {
        /**
         * @function
         * @param {Number} target
         */
        resetTo: function(target) {
          $.console.assert(
            !this._exponential || target !== 0,
            "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
          );
          this.start.value = this.target.value = this.current.value = target;
          this.start.time = this.target.time = this.current.time = $.now();
          if (this._exponential) {
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
            this.current._logValue = Math.log(this.current.value);
          }
        },
        /**
         * @function
         * @param {Number} target
         */
        springTo: function(target) {
          $.console.assert(
            !this._exponential || target !== 0,
            "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
          );
          this.start.value = this.current.value;
          this.start.time = this.current.time;
          this.target.value = target;
          this.target.time = this.start.time + 1e3 * this.animationTime;
          if (this._exponential) {
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
          }
        },
        /**
         * @function
         * @param {Number} delta
         */
        shiftBy: function(delta) {
          this.start.value += delta;
          this.target.value += delta;
          if (this._exponential) {
            $.console.assert(
              this.target.value !== 0 && this.start.value !== 0,
              "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
            );
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
          }
        },
        setExponential: function(value) {
          this._exponential = value;
          if (this._exponential) {
            $.console.assert(
              this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
              "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
            );
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
            this.current._logValue = Math.log(this.current.value);
          }
        },
        /**
         * @function
         * @returns true if the value got updated, false otherwise
         */
        update: function() {
          this.current.time = $.now();
          var startValue, targetValue;
          if (this._exponential) {
            startValue = this.start._logValue;
            targetValue = this.target._logValue;
          } else {
            startValue = this.start.value;
            targetValue = this.target.value;
          }
          var currentValue = this.current.time >= this.target.time ? targetValue : startValue + (targetValue - startValue) * transform(
            this.springStiffness,
            (this.current.time - this.start.time) / (this.target.time - this.start.time)
          );
          var oldValue = this.current.value;
          if (this._exponential) {
            this.current.value = Math.exp(currentValue);
          } else {
            this.current.value = currentValue;
          }
          return oldValue !== this.current.value;
        },
        /**
         * Returns whether the spring is at the target value
         * @function
         * @returns {Boolean} True if at target value, false otherwise
         */
        isAtTargetValue: function() {
          return this.current.value === this.target.value;
        }
      };
      function transform(stiffness, x) {
        return (1 - Math.exp(stiffness * -x)) / (1 - Math.exp(-stiffness));
      }
    })(OpenSeadragon);
    (function($) {
      $.ImageJob = function(options) {
        $.extend(true, this, {
          timeout: $.DEFAULT_SETTINGS.timeout,
          jobId: null,
          tries: 0
        }, options);
        this.data = null;
        this.userData = {};
        this.errorMsg = null;
      };
      $.ImageJob.prototype = {
        /**
         * Starts the image job.
         * @method
         */
        start: function() {
          this.tries++;
          var self = this;
          var selfAbort = this.abort;
          this.jobId = window.setTimeout(function() {
            self.finish(null, null, "Image load exceeded timeout (" + self.timeout + " ms)");
          }, this.timeout);
          this.abort = function() {
            self.source.downloadTileAbort(self);
            if (typeof selfAbort === "function") {
              selfAbort();
            }
          };
          this.source.downloadTileStart(this);
        },
        /**
         * Finish this job.
         * @param {*} data data that has been downloaded
         * @param {XMLHttpRequest} request reference to the request if used
         * @param {string} errorMessage description upon failure
         */
        finish: function(data, request, errorMessage) {
          this.data = data;
          this.request = request;
          this.errorMsg = errorMessage;
          if (this.jobId) {
            window.clearTimeout(this.jobId);
          }
          this.callback(this);
        }
      };
      $.ImageLoader = function(options) {
        $.extend(true, this, {
          jobLimit: $.DEFAULT_SETTINGS.imageLoaderLimit,
          timeout: $.DEFAULT_SETTINGS.timeout,
          jobQueue: [],
          failedTiles: [],
          jobsInProgress: 0
        }, options);
      };
      $.ImageLoader.prototype = {
        /**
         * Add an unloaded image to the loader queue.
         * @method
         * @param {Object} options - Options for this job.
         * @param {String} [options.src] - URL of image to download.
         * @param {Tile} [options.tile] - Tile that belongs the data to. The tile instance
         *      is not internally used and serves for custom TileSources implementations.
         * @param {TileSource} [options.source] - Image loading strategy
         * @param {String} [options.loadWithAjax] - Whether to load this image with AJAX.
         * @param {String} [options.ajaxHeaders] - Headers to add to the image request if using AJAX.
         * @param {String|Boolean} [options.crossOriginPolicy] - CORS policy to use for downloads
         * @param {String} [options.postData] - POST parameters (usually but not necessarily in k=v&k2=v2... form,
         *      see TileSource::getPostData) or null
         * @param {Boolean} [options.ajaxWithCredentials] - Whether to set withCredentials on AJAX
         *      requests.
         * @param {Function} [options.callback] - Called once image has been downloaded.
         * @param {Function} [options.abort] - Called when this image job is aborted.
         */
        addJob: function(options) {
          if (!options.source) {
            $.console.error("ImageLoader.prototype.addJob() requires [options.source]. TileSource since new API defines how images are fetched. Creating a dummy TileSource.");
            var implementation = $.TileSource.prototype;
            options.source = {
              downloadTileStart: implementation.downloadTileStart,
              downloadTileAbort: implementation.downloadTileAbort
            };
          }
          var _this = this, complete = function(job) {
            completeJob(_this, job, options.callback);
          }, jobOptions = {
            src: options.src,
            tile: options.tile || {},
            source: options.source,
            loadWithAjax: options.loadWithAjax,
            ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
            crossOriginPolicy: options.crossOriginPolicy,
            ajaxWithCredentials: options.ajaxWithCredentials,
            postData: options.postData,
            callback: complete,
            abort: options.abort,
            timeout: this.timeout
          }, newJob = new $.ImageJob(jobOptions);
          if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {
            newJob.start();
            this.jobsInProgress++;
          } else {
            this.jobQueue.push(newJob);
          }
        },
        /**
         * Clear any unstarted image loading jobs from the queue.
         * @method
         */
        clear: function() {
          for (var i = 0; i < this.jobQueue.length; i++) {
            var job = this.jobQueue[i];
            if (typeof job.abort === "function") {
              job.abort();
            }
          }
          this.jobQueue = [];
        }
      };
      function completeJob(loader, job, callback) {
        if (job.errorMsg !== "" && (job.data === null || job.data === void 0) && job.tries < 1 + loader.tileRetryMax) {
          loader.failedTiles.push(job);
        }
        var nextJob;
        loader.jobsInProgress--;
        if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
          nextJob = loader.jobQueue.shift();
          nextJob.start();
          loader.jobsInProgress++;
        }
        if (loader.tileRetryMax > 0 && loader.jobQueue.length === 0) {
          if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.failedTiles.length > 0) {
            nextJob = loader.failedTiles.shift();
            setTimeout(function() {
              nextJob.start();
            }, loader.tileRetryDelay);
            loader.jobsInProgress++;
          }
        }
        callback(job.data, job.errorMsg, job.request);
      }
    })(OpenSeadragon);
    (function($) {
      $.Tile = function(level, x, y, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds, postData, cacheKey) {
        this.level = level;
        this.x = x;
        this.y = y;
        this.bounds = bounds;
        this.sourceBounds = sourceBounds;
        this.exists = exists;
        this._url = url;
        this.postData = postData;
        this.context2D = context2D;
        this.loadWithAjax = loadWithAjax;
        this.ajaxHeaders = ajaxHeaders;
        if (cacheKey === void 0) {
          $.console.warn("Tile constructor needs 'cacheKey' variable: creation tile cache in Tile class is deprecated. TileSource.prototype.getTileHashKey will be used.");
          cacheKey = $.TileSource.prototype.getTileHashKey(level, x, y, url, ajaxHeaders, postData);
        }
        this.cacheKey = cacheKey;
        this.loaded = false;
        this.loading = false;
        this.element = null;
        this.imgElement = null;
        this.style = null;
        this.position = null;
        this.size = null;
        this.flipped = false;
        this.blendStart = null;
        this.opacity = null;
        this.squaredDistance = null;
        this.visibility = null;
        this.hasTransparency = false;
        this.beingDrawn = false;
        this.lastTouchTime = 0;
        this.isRightMost = false;
        this.isBottomMost = false;
      };
      $.Tile.prototype = {
        /**
         * Provides a string representation of this tiles level and (x,y)
         * components.
         * @function
         * @returns {String}
         */
        toString: function() {
          return this.level + "/" + this.x + "_" + this.y;
        },
        // private
        _hasTransparencyChannel: function() {
          console.warn("Tile.prototype._hasTransparencyChannel() has been deprecated and will be removed in the future. Use TileSource.prototype.hasTransparency() instead.");
          return !!this.context2D || this.getUrl().match(".png");
        },
        /**
         * Renders the tile in an html container.
         * @function
         * @param {Element} container
         */
        drawHTML: function(container) {
          if (!this.cacheImageRecord) {
            $.console.warn(
              "[Tile.drawHTML] attempting to draw tile %s when it's not cached",
              this.toString()
            );
            return;
          }
          if (!this.loaded) {
            $.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              this.toString()
            );
            return;
          }
          if (!this.element) {
            var image = this.getImage();
            if (!image) {
              return;
            }
            this.element = $.makeNeutralElement("div");
            this.imgElement = image.cloneNode();
            this.imgElement.style.msInterpolationMode = "nearest-neighbor";
            this.imgElement.style.width = "100%";
            this.imgElement.style.height = "100%";
            this.style = this.element.style;
            this.style.position = "absolute";
          }
          if (this.element.parentNode !== container) {
            container.appendChild(this.element);
          }
          if (this.imgElement.parentNode !== this.element) {
            this.element.appendChild(this.imgElement);
          }
          this.style.top = this.position.y + "px";
          this.style.left = this.position.x + "px";
          this.style.height = this.size.y + "px";
          this.style.width = this.size.x + "px";
          if (this.flipped) {
            this.style.transform = "scaleX(-1)";
          }
          $.setElementOpacity(this.element, this.opacity);
        },
        /**
         * The Image object for this tile.
         * @member {Object} image
         * @memberof OpenSeadragon.Tile#
         * @deprecated
         * @returns {Image}
         */
        get image() {
          $.console.error("[Tile.image] property has been deprecated. Use [Tile.prototype.getImage] instead.");
          return this.getImage();
        },
        /**
         * The URL of this tile's image.
         * @member {String} url
         * @memberof OpenSeadragon.Tile#
         * @deprecated
         * @returns {String}
         */
        get url() {
          $.console.error("[Tile.url] property has been deprecated. Use [Tile.prototype.getUrl] instead.");
          return this.getUrl();
        },
        /**
         * Get the Image object for this tile.
         * @returns {Image}
         */
        getImage: function() {
          return this.cacheImageRecord.getImage();
        },
        /**
         * Get the url string for this tile.
         * @returns {String}
         */
        getUrl: function() {
          if (typeof this._url === "function") {
            return this._url();
          }
          return this._url;
        },
        /**
         * Get the CanvasRenderingContext2D instance for tile image data drawn
         * onto Canvas if enabled and available
         * @returns {CanvasRenderingContext2D}
         */
        getCanvasContext: function() {
          return this.context2D || this.cacheImageRecord.getRenderedContext();
        },
        /**
         * Renders the tile in a canvas-based context.
         * @function
         * @param {Canvas} context
         * @param {Function} drawingHandler - Method for firing the drawing event.
         * drawingHandler({context, tile, rendered})
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Number} [scale=1] - Apply a scale to position and size
         * @param {OpenSeadragon.Point} [translate] - A translation vector
         * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
         * position and size of tiles supporting alpha channel in non-transparency
         * context.
         * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
         */
        drawCanvas: function(context, drawingHandler, scale, translate, shouldRoundPositionAndSize, source) {
          var position = this.position.times($.pixelDensityRatio), size = this.size.times($.pixelDensityRatio), rendered;
          if (!this.context2D && !this.cacheImageRecord) {
            $.console.warn(
              "[Tile.drawCanvas] attempting to draw tile %s when it's not cached",
              this.toString()
            );
            return;
          }
          rendered = this.getCanvasContext();
          if (!this.loaded || !rendered) {
            $.console.warn(
              "Attempting to draw tile %s when it's not yet loaded.",
              this.toString()
            );
            return;
          }
          context.save();
          context.globalAlpha = this.opacity;
          if (typeof scale === "number" && scale !== 1) {
            position = position.times(scale);
            size = size.times(scale);
          }
          if (translate instanceof $.Point) {
            position = position.plus(translate);
          }
          if (context.globalAlpha === 1 && this.hasTransparency) {
            if (shouldRoundPositionAndSize) {
              position.x = Math.round(position.x);
              position.y = Math.round(position.y);
              size.x = Math.round(size.x);
              size.y = Math.round(size.y);
            }
            context.clearRect(
              position.x,
              position.y,
              size.x,
              size.y
            );
          }
          drawingHandler({ context, tile: this, rendered });
          var sourceWidth, sourceHeight;
          if (this.sourceBounds) {
            sourceWidth = Math.min(this.sourceBounds.width, rendered.canvas.width);
            sourceHeight = Math.min(this.sourceBounds.height, rendered.canvas.height);
          } else {
            sourceWidth = rendered.canvas.width;
            sourceHeight = rendered.canvas.height;
          }
          context.translate(position.x + size.x / 2, 0);
          if (this.flipped) {
            context.scale(-1, 1);
          }
          context.drawImage(
            rendered.canvas,
            0,
            0,
            sourceWidth,
            sourceHeight,
            -size.x / 2,
            position.y,
            size.x,
            size.y
          );
          context.restore();
        },
        /**
         * Get the ratio between current and original size.
         * @function
         * @returns {Float}
         */
        getScaleForEdgeSmoothing: function() {
          var context;
          if (this.cacheImageRecord) {
            context = this.cacheImageRecord.getRenderedContext();
          } else if (this.context2D) {
            context = this.context2D;
          } else {
            $.console.warn(
              "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
              this.toString()
            );
            return 1;
          }
          return context.canvas.width / (this.size.x * $.pixelDensityRatio);
        },
        /**
         * Get a translation vector that when applied to the tile position produces integer coordinates.
         * Needed to avoid swimming and twitching.
         * @function
         * @param {Number} [scale=1] - Scale to be applied to position.
         * @returns {OpenSeadragon.Point}
         */
        getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
          var x = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
          var y = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
          return new $.Point(x, y).minus(
            this.position.times($.pixelDensityRatio).times(scale || 1).apply(function(x2) {
              return x2 % 1;
            })
          );
        },
        /**
         * Removes tile from its container.
         * @function
         */
        unload: function() {
          if (this.imgElement && this.imgElement.parentNode) {
            this.imgElement.parentNode.removeChild(this.imgElement);
          }
          if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
          }
          this.element = null;
          this.imgElement = null;
          this.loaded = false;
          this.loading = false;
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.OverlayPlacement = $.Placement;
      $.OverlayRotationMode = $.freezeObject({
        NO_ROTATION: 1,
        EXACT: 2,
        BOUNDING_BOX: 3
      });
      $.Overlay = function(element, location, placement) {
        var options;
        if ($.isPlainObject(element)) {
          options = element;
        } else {
          options = {
            element,
            location,
            placement
          };
        }
        this.element = options.element;
        this.style = options.element.style;
        this._init(options);
      };
      $.Overlay.prototype = {
        // private
        _init: function(options) {
          this.location = options.location;
          this.placement = options.placement === void 0 ? $.Placement.TOP_LEFT : options.placement;
          this.onDraw = options.onDraw;
          this.checkResize = options.checkResize === void 0 ? true : options.checkResize;
          this.width = options.width === void 0 ? null : options.width;
          this.height = options.height === void 0 ? null : options.height;
          this.rotationMode = options.rotationMode || $.OverlayRotationMode.EXACT;
          if (this.location instanceof $.Rect) {
            this.width = this.location.width;
            this.height = this.location.height;
            this.location = this.location.getTopLeft();
            this.placement = $.Placement.TOP_LEFT;
          }
          this.scales = this.width !== null && this.height !== null;
          this.bounds = new $.Rect(
            this.location.x,
            this.location.y,
            this.width,
            this.height
          );
          this.position = this.location;
        },
        /**
         * Internal function to adjust the position of an overlay
         * depending on it size and placement.
         * @function
         * @param {OpenSeadragon.Point} position
         * @param {OpenSeadragon.Point} size
         */
        adjust: function(position, size) {
          var properties = $.Placement.properties[this.placement];
          if (!properties) {
            return;
          }
          if (properties.isHorizontallyCentered) {
            position.x -= size.x / 2;
          } else if (properties.isRight) {
            position.x -= size.x;
          }
          if (properties.isVerticallyCentered) {
            position.y -= size.y / 2;
          } else if (properties.isBottom) {
            position.y -= size.y;
          }
        },
        /**
         * @function
         */
        destroy: function() {
          var element = this.element;
          var style = this.style;
          if (element.parentNode) {
            element.parentNode.removeChild(element);
            if (element.prevElementParent) {
              style.display = "none";
              document.body.appendChild(element);
            }
          }
          this.onDraw = null;
          style.top = "";
          style.left = "";
          style.position = "";
          if (this.width !== null) {
            style.width = "";
          }
          if (this.height !== null) {
            style.height = "";
          }
          var transformOriginProp = $.getCssPropertyWithVendorPrefix(
            "transformOrigin"
          );
          var transformProp = $.getCssPropertyWithVendorPrefix(
            "transform"
          );
          if (transformOriginProp && transformProp) {
            style[transformOriginProp] = "";
            style[transformProp] = "";
          }
        },
        /**
         * @function
         * @param {Element} container
         */
        drawHTML: function(container, viewport) {
          var element = this.element;
          if (element.parentNode !== container) {
            element.prevElementParent = element.parentNode;
            element.prevNextSibling = element.nextSibling;
            container.appendChild(element);
            this.style.position = "absolute";
            this.size = $.getElementSize(element);
          }
          var positionAndSize = this._getOverlayPositionAndSize(viewport);
          var position = positionAndSize.position;
          var size = this.size = positionAndSize.size;
          var rotate = positionAndSize.rotate;
          if (this.onDraw) {
            this.onDraw(position, size, this.element);
          } else {
            var style = this.style;
            style.left = position.x + "px";
            style.top = position.y + "px";
            if (this.width !== null) {
              style.width = size.x + "px";
            }
            if (this.height !== null) {
              style.height = size.y + "px";
            }
            var transformOriginProp = $.getCssPropertyWithVendorPrefix(
              "transformOrigin"
            );
            var transformProp = $.getCssPropertyWithVendorPrefix(
              "transform"
            );
            if (transformOriginProp && transformProp) {
              if (rotate) {
                style[transformOriginProp] = this._getTransformOrigin();
                style[transformProp] = "rotate(" + rotate + "deg)";
              } else {
                style[transformOriginProp] = "";
                style[transformProp] = "";
              }
            }
            style.display = "block";
          }
        },
        // private
        _getOverlayPositionAndSize: function(viewport) {
          var position = viewport.pixelFromPoint(this.location, true);
          var size = this._getSizeInPixels(viewport);
          this.adjust(position, size);
          var rotate = 0;
          if (viewport.getRotation(true) && this.rotationMode !== $.OverlayRotationMode.NO_ROTATION) {
            if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
              var rect = new $.Rect(position.x, position.y, size.x, size.y);
              var boundingBox = this._getBoundingBox(rect, viewport.getRotation(true));
              position = boundingBox.getTopLeft();
              size = boundingBox.getSize();
            } else {
              rotate = viewport.getRotation(true);
            }
          }
          return {
            position,
            size,
            rotate
          };
        },
        // private
        _getSizeInPixels: function(viewport) {
          var width = this.size.x;
          var height = this.size.y;
          if (this.width !== null || this.height !== null) {
            var scaledSize = viewport.deltaPixelsFromPointsNoRotate(
              new $.Point(this.width || 0, this.height || 0),
              true
            );
            if (this.width !== null) {
              width = scaledSize.x;
            }
            if (this.height !== null) {
              height = scaledSize.y;
            }
          }
          if (this.checkResize && (this.width === null || this.height === null)) {
            var eltSize = this.size = $.getElementSize(this.element);
            if (this.width === null) {
              width = eltSize.x;
            }
            if (this.height === null) {
              height = eltSize.y;
            }
          }
          return new $.Point(width, height);
        },
        // private
        _getBoundingBox: function(rect, degrees) {
          var refPoint = this._getPlacementPoint(rect);
          return rect.rotate(degrees, refPoint).getBoundingBox();
        },
        // private
        _getPlacementPoint: function(rect) {
          var result = new $.Point(rect.x, rect.y);
          var properties = $.Placement.properties[this.placement];
          if (properties) {
            if (properties.isHorizontallyCentered) {
              result.x += rect.width / 2;
            } else if (properties.isRight) {
              result.x += rect.width;
            }
            if (properties.isVerticallyCentered) {
              result.y += rect.height / 2;
            } else if (properties.isBottom) {
              result.y += rect.height;
            }
          }
          return result;
        },
        // private
        _getTransformOrigin: function() {
          var result = "";
          var properties = $.Placement.properties[this.placement];
          if (!properties) {
            return result;
          }
          if (properties.isLeft) {
            result = "left";
          } else if (properties.isRight) {
            result = "right";
          }
          if (properties.isTop) {
            result += " top";
          } else if (properties.isBottom) {
            result += " bottom";
          }
          return result;
        },
        /**
         * Changes the overlay settings.
         * @function
         * @param {OpenSeadragon.Point|OpenSeadragon.Rect|Object} location
         * If an object is specified, the options are the same than the constructor
         * except for the element which can not be changed.
         * @param {OpenSeadragon.Placement} placement
         */
        update: function(location, placement) {
          var options = $.isPlainObject(location) ? location : {
            location,
            placement
          };
          this._init({
            location: options.location || this.location,
            placement: options.placement !== void 0 ? options.placement : this.placement,
            onDraw: options.onDraw || this.onDraw,
            checkResize: options.checkResize || this.checkResize,
            width: options.width !== void 0 ? options.width : this.width,
            height: options.height !== void 0 ? options.height : this.height,
            rotationMode: options.rotationMode || this.rotationMode
          });
        },
        /**
         * Returns the current bounds of the overlay in viewport coordinates
         * @function
         * @param {OpenSeadragon.Viewport} viewport the viewport
         * @returns {OpenSeadragon.Rect} overlay bounds
         */
        getBounds: function(viewport) {
          $.console.assert(
            viewport,
            "A viewport must now be passed to Overlay.getBounds."
          );
          var width = this.width;
          var height = this.height;
          if (width === null || height === null) {
            var size = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
            if (width === null) {
              width = size.x;
            }
            if (height === null) {
              height = size.y;
            }
          }
          var location = this.location.clone();
          this.adjust(location, new $.Point(width, height));
          return this._adjustBoundsForRotation(
            viewport,
            new $.Rect(location.x, location.y, width, height)
          );
        },
        // private
        _adjustBoundsForRotation: function(viewport, bounds) {
          if (!viewport || viewport.getRotation(true) === 0 || this.rotationMode === $.OverlayRotationMode.EXACT) {
            return bounds;
          }
          if (this.rotationMode === $.OverlayRotationMode.BOUNDING_BOX) {
            if (this.width === null || this.height === null) {
              return bounds;
            }
            var positionAndSize = this._getOverlayPositionAndSize(viewport);
            return viewport.viewerElementToViewportRectangle(new $.Rect(
              positionAndSize.position.x,
              positionAndSize.position.y,
              positionAndSize.size.x,
              positionAndSize.size.y
            ));
          }
          return bounds.rotate(
            -viewport.getRotation(true),
            this._getPlacementPoint(bounds)
          );
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.Drawer = function(options) {
        $.console.assert(options.viewer, "[Drawer] options.viewer is required");
        var args = arguments;
        if (!$.isPlainObject(options)) {
          options = {
            source: args[0],
            // Reference to Viewer tile source.
            viewport: args[1],
            // Reference to Viewer viewport.
            element: args[2]
            // Parent element.
          };
        }
        $.console.assert(options.viewport, "[Drawer] options.viewport is required");
        $.console.assert(options.element, "[Drawer] options.element is required");
        if (options.source) {
          $.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead");
        }
        this.viewer = options.viewer;
        this.viewport = options.viewport;
        this.debugGridColor = typeof options.debugGridColor === "string" ? [options.debugGridColor] : options.debugGridColor || $.DEFAULT_SETTINGS.debugGridColor;
        if (options.opacity) {
          $.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead");
        }
        this.useCanvas = $.supportsCanvas && (this.viewer ? this.viewer.useCanvas : true);
        this.container = $.getElement(options.element);
        this.canvas = $.makeNeutralElement(this.useCanvas ? "canvas" : "div");
        this.context = this.useCanvas ? this.canvas.getContext("2d") : null;
        this.sketchCanvas = null;
        this.sketchContext = null;
        this.element = this.container;
        this.container.dir = "ltr";
        if (this.useCanvas) {
          var viewportSize = this._calculateCanvasSize();
          this.canvas.width = viewportSize.x;
          this.canvas.height = viewportSize.y;
        }
        this.canvas.style.width = "100%";
        this.canvas.style.height = "100%";
        this.canvas.style.position = "absolute";
        $.setElementOpacity(this.canvas, this.opacity, true);
        $.setElementPointerEventsNone(this.canvas);
        $.setElementTouchActionNone(this.canvas);
        this.container.style.textAlign = "left";
        this.container.appendChild(this.canvas);
        this._imageSmoothingEnabled = true;
      };
      $.Drawer.prototype = {
        // deprecated
        addOverlay: function(element, location, placement, onDraw) {
          $.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");
          this.viewer.addOverlay(element, location, placement, onDraw);
          return this;
        },
        // deprecated
        updateOverlay: function(element, location, placement) {
          $.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");
          this.viewer.updateOverlay(element, location, placement);
          return this;
        },
        // deprecated
        removeOverlay: function(element) {
          $.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");
          this.viewer.removeOverlay(element);
          return this;
        },
        // deprecated
        clearOverlays: function() {
          $.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");
          this.viewer.clearOverlays();
          return this;
        },
        /**
         * This function converts the given point from to the drawer coordinate by
         * multiplying it with the pixel density.
         * This function does not take rotation into account, thus assuming provided
         * point is at 0 degree.
         * @param {OpenSeadragon.Point} point - the pixel point to convert
         * @returns {OpenSeadragon.Point} Point in drawer coordinate system.
         */
        viewportCoordToDrawerCoord: function(point) {
          var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
          return new $.Point(
            vpPoint.x * $.pixelDensityRatio,
            vpPoint.y * $.pixelDensityRatio
          );
        },
        /**
         * This function will create multiple polygon paths on the drawing context by provided polygons,
         * then clip the context to the paths.
         * @param {OpenSeadragon.Point[][]} polygons - an array of polygons. A polygon is an array of OpenSeadragon.Point
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         */
        clipWithPolygons: function(polygons, useSketch) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          context.beginPath();
          polygons.forEach(function(polygon) {
            polygon.forEach(function(coord, i) {
              context[i === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
            });
          });
          context.clip();
        },
        /**
         * Set the opacity of the drawer.
         * @param {Number} opacity
         * @returns {OpenSeadragon.Drawer} Chainable.
         */
        setOpacity: function(opacity) {
          $.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
          var world = this.viewer.world;
          for (var i = 0; i < world.getItemCount(); i++) {
            world.getItemAt(i).setOpacity(opacity);
          }
          return this;
        },
        /**
         * Get the opacity of the drawer.
         * @returns {Number}
         */
        getOpacity: function() {
          $.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
          var world = this.viewer.world;
          var maxOpacity = 0;
          for (var i = 0; i < world.getItemCount(); i++) {
            var opacity = world.getItemAt(i).getOpacity();
            if (opacity > maxOpacity) {
              maxOpacity = opacity;
            }
          }
          return maxOpacity;
        },
        // deprecated
        needsUpdate: function() {
          $.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead.");
          return this.viewer.world.needsDraw();
        },
        // deprecated
        numTilesLoaded: function() {
          $.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead.");
          return this.viewer.tileCache.numTilesLoaded();
        },
        // deprecated
        reset: function() {
          $.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead.");
          this.viewer.world.resetItems();
          return this;
        },
        // deprecated
        update: function() {
          $.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead.");
          this.clear();
          this.viewer.world.draw();
          return this;
        },
        /**
         * @returns {Boolean} True if rotation is supported.
         */
        canRotate: function() {
          return this.useCanvas;
        },
        /**
         * Destroy the drawer (unload current loaded tiles)
         */
        destroy: function() {
          this.canvas.width = 1;
          this.canvas.height = 1;
          this.sketchCanvas = null;
          this.sketchContext = null;
        },
        /**
         * Clears the Drawer so it's ready to draw another frame.
         */
        clear: function() {
          this.canvas.innerHTML = "";
          if (this.useCanvas) {
            var viewportSize = this._calculateCanvasSize();
            if (this.canvas.width !== viewportSize.x || this.canvas.height !== viewportSize.y) {
              this.canvas.width = viewportSize.x;
              this.canvas.height = viewportSize.y;
              this._updateImageSmoothingEnabled(this.context);
              if (this.sketchCanvas !== null) {
                var sketchCanvasSize = this._calculateSketchCanvasSize();
                this.sketchCanvas.width = sketchCanvasSize.x;
                this.sketchCanvas.height = sketchCanvasSize.y;
                this._updateImageSmoothingEnabled(this.sketchContext);
              }
            }
            this._clear();
          }
        },
        _clear: function(useSketch, bounds) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          if (bounds) {
            context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
          } else {
            var canvas = context.canvas;
            context.clearRect(0, 0, canvas.width, canvas.height);
          }
        },
        /**
         * Scale from OpenSeadragon viewer rectangle to drawer rectangle
         * (ignoring rotation)
         * @param {OpenSeadragon.Rect} rectangle - The rectangle in viewport coordinate system.
         * @returns {OpenSeadragon.Rect} Rectangle in drawer coordinate system.
         */
        viewportToDrawerRectangle: function(rectangle) {
          var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
          var size = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
          return new $.Rect(
            topLeft.x * $.pixelDensityRatio,
            topLeft.y * $.pixelDensityRatio,
            size.x * $.pixelDensityRatio,
            size.y * $.pixelDensityRatio
          );
        },
        /**
         * Draws the given tile.
         * @param {OpenSeadragon.Tile} tile - The tile to draw.
         * @param {Function} drawingHandler - Method for firing the drawing event if using canvas.
         * drawingHandler({context, tile, rendered})
         * @param {Boolean} useSketch - Whether to use the sketch canvas or not.
         * where <code>rendered</code> is the context with the pre-drawn image.
         * @param {Float} [scale=1] - Apply a scale to tile position and size. Defaults to 1.
         * @param {OpenSeadragon.Point} [translate] A translation vector to offset tile position
         * @param {Boolean} [shouldRoundPositionAndSize] - Tells whether to round
         * position and size of tiles supporting alpha channel in non-transparency
         * context.
         * @param {OpenSeadragon.TileSource} source - The source specification of the tile.
         */
        drawTile: function(tile, drawingHandler, useSketch, scale, translate, shouldRoundPositionAndSize, source) {
          $.console.assert(tile, "[Drawer.drawTile] tile is required");
          $.console.assert(drawingHandler, "[Drawer.drawTile] drawingHandler is required");
          if (this.useCanvas) {
            var context = this._getContext(useSketch);
            scale = scale || 1;
            tile.drawCanvas(context, drawingHandler, scale, translate, shouldRoundPositionAndSize, source);
          } else {
            tile.drawHTML(this.canvas);
          }
        },
        _getContext: function(useSketch) {
          var context = this.context;
          if (useSketch) {
            if (this.sketchCanvas === null) {
              this.sketchCanvas = document.createElement("canvas");
              var sketchCanvasSize = this._calculateSketchCanvasSize();
              this.sketchCanvas.width = sketchCanvasSize.x;
              this.sketchCanvas.height = sketchCanvasSize.y;
              this.sketchContext = this.sketchCanvas.getContext("2d");
              if (this.viewport.getRotation() === 0) {
                var self = this;
                this.viewer.addHandler("rotate", function resizeSketchCanvas() {
                  if (self.viewport.getRotation() === 0) {
                    return;
                  }
                  self.viewer.removeHandler("rotate", resizeSketchCanvas);
                  var sketchCanvasSize2 = self._calculateSketchCanvasSize();
                  self.sketchCanvas.width = sketchCanvasSize2.x;
                  self.sketchCanvas.height = sketchCanvasSize2.y;
                });
              }
              this._updateImageSmoothingEnabled(this.sketchContext);
            }
            context = this.sketchContext;
          }
          return context;
        },
        // private
        saveContext: function(useSketch) {
          if (!this.useCanvas) {
            return;
          }
          this._getContext(useSketch).save();
        },
        // private
        restoreContext: function(useSketch) {
          if (!this.useCanvas) {
            return;
          }
          this._getContext(useSketch).restore();
        },
        // private
        setClip: function(rect, useSketch) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          context.beginPath();
          context.rect(rect.x, rect.y, rect.width, rect.height);
          context.clip();
        },
        // private
        drawRectangle: function(rect, fillStyle, useSketch) {
          if (!this.useCanvas) {
            return;
          }
          var context = this._getContext(useSketch);
          context.save();
          context.fillStyle = fillStyle;
          context.fillRect(rect.x, rect.y, rect.width, rect.height);
          context.restore();
        },
        /**
         * Blends the sketch canvas in the main canvas.
         * @param {Object} options The options
         * @param {Float} options.opacity The opacity of the blending.
         * @param {Float} [options.scale=1] The scale at which tiles were drawn on
         * the sketch. Default is 1.
         * Use scale to draw at a lower scale and then enlarge onto the main canvas.
         * @param {OpenSeadragon.Point} [options.translate] A translation vector
         * that was used to draw the tiles
         * @param {String} [options.compositeOperation] - How the image is
         * composited onto other images; see compositeOperation in
         * {@link OpenSeadragon.Options} for possible values.
         * @param {OpenSeadragon.Rect} [options.bounds] The part of the sketch
         * canvas to blend in the main canvas. If specified, options.scale and
         * options.translate get ignored.
         */
        blendSketch: function(opacity, scale, translate, compositeOperation) {
          var options = opacity;
          if (!$.isPlainObject(options)) {
            options = {
              opacity,
              scale,
              translate,
              compositeOperation
            };
          }
          if (!this.useCanvas || !this.sketchCanvas) {
            return;
          }
          opacity = options.opacity;
          compositeOperation = options.compositeOperation;
          var bounds = options.bounds;
          this.context.save();
          this.context.globalAlpha = opacity;
          if (compositeOperation) {
            this.context.globalCompositeOperation = compositeOperation;
          }
          if (bounds) {
            if (bounds.x < 0) {
              bounds.width += bounds.x;
              bounds.x = 0;
            }
            if (bounds.x + bounds.width > this.canvas.width) {
              bounds.width = this.canvas.width - bounds.x;
            }
            if (bounds.y < 0) {
              bounds.height += bounds.y;
              bounds.y = 0;
            }
            if (bounds.y + bounds.height > this.canvas.height) {
              bounds.height = this.canvas.height - bounds.y;
            }
            this.context.drawImage(
              this.sketchCanvas,
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height,
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height
            );
          } else {
            scale = options.scale || 1;
            translate = options.translate;
            var position = translate instanceof $.Point ? translate : new $.Point(0, 0);
            var widthExt = 0;
            var heightExt = 0;
            if (translate) {
              var widthDiff = this.sketchCanvas.width - this.canvas.width;
              var heightDiff = this.sketchCanvas.height - this.canvas.height;
              widthExt = Math.round(widthDiff / 2);
              heightExt = Math.round(heightDiff / 2);
            }
            this.context.drawImage(
              this.sketchCanvas,
              position.x - widthExt * scale,
              position.y - heightExt * scale,
              (this.canvas.width + 2 * widthExt) * scale,
              (this.canvas.height + 2 * heightExt) * scale,
              -widthExt,
              -heightExt,
              this.canvas.width + 2 * widthExt,
              this.canvas.height + 2 * heightExt
            );
          }
          this.context.restore();
        },
        // private
        drawDebugInfo: function(tile, count, i, tiledImage) {
          if (!this.useCanvas) {
            return;
          }
          var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
          var context = this.context;
          context.save();
          context.lineWidth = 2 * $.pixelDensityRatio;
          context.font = "small-caps bold " + 13 * $.pixelDensityRatio + "px arial";
          context.strokeStyle = this.debugGridColor[colorIndex];
          context.fillStyle = this.debugGridColor[colorIndex];
          if (this.viewport.getRotation(true) % 360 !== 0) {
            this._offsetForRotation({ degrees: this.viewport.getRotation(true) });
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
            this._offsetForRotation({
              degrees: tiledImage.getRotation(true),
              point: tiledImage.viewport.pixelFromPointNoRotate(
                tiledImage._getRotationPoint(true),
                true
              )
            });
          }
          if (tiledImage.viewport.getRotation(true) % 360 === 0 && tiledImage.getRotation(true) % 360 === 0) {
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
            }
          }
          context.strokeRect(
            tile.position.x * $.pixelDensityRatio,
            tile.position.y * $.pixelDensityRatio,
            tile.size.x * $.pixelDensityRatio,
            tile.size.y * $.pixelDensityRatio
          );
          var tileCenterX = (tile.position.x + tile.size.x / 2) * $.pixelDensityRatio;
          var tileCenterY = (tile.position.y + tile.size.y / 2) * $.pixelDensityRatio;
          context.translate(tileCenterX, tileCenterY);
          context.rotate(Math.PI / 180 * -this.viewport.getRotation(true));
          context.translate(-tileCenterX, -tileCenterY);
          if (tile.x === 0 && tile.y === 0) {
            context.fillText(
              "Zoom: " + this.viewport.getZoom(),
              tile.position.x * $.pixelDensityRatio,
              (tile.position.y - 30) * $.pixelDensityRatio
            );
            context.fillText(
              "Pan: " + this.viewport.getBounds().toString(),
              tile.position.x * $.pixelDensityRatio,
              (tile.position.y - 20) * $.pixelDensityRatio
            );
          }
          context.fillText(
            "Level: " + tile.level,
            (tile.position.x + 10) * $.pixelDensityRatio,
            (tile.position.y + 20) * $.pixelDensityRatio
          );
          context.fillText(
            "Column: " + tile.x,
            (tile.position.x + 10) * $.pixelDensityRatio,
            (tile.position.y + 30) * $.pixelDensityRatio
          );
          context.fillText(
            "Row: " + tile.y,
            (tile.position.x + 10) * $.pixelDensityRatio,
            (tile.position.y + 40) * $.pixelDensityRatio
          );
          context.fillText(
            "Order: " + i + " of " + count,
            (tile.position.x + 10) * $.pixelDensityRatio,
            (tile.position.y + 50) * $.pixelDensityRatio
          );
          context.fillText(
            "Size: " + tile.size.toString(),
            (tile.position.x + 10) * $.pixelDensityRatio,
            (tile.position.y + 60) * $.pixelDensityRatio
          );
          context.fillText(
            "Position: " + tile.position.toString(),
            (tile.position.x + 10) * $.pixelDensityRatio,
            (tile.position.y + 70) * $.pixelDensityRatio
          );
          if (this.viewport.getRotation(true) % 360 !== 0) {
            this._restoreRotationChanges();
          }
          if (tiledImage.getRotation(true) % 360 !== 0) {
            this._restoreRotationChanges();
          }
          if (tiledImage.viewport.getRotation(true) % 360 === 0 && tiledImage.getRotation(true) % 360 === 0) {
            if (tiledImage._drawer.viewer.viewport.getFlip()) {
              tiledImage._drawer._flip();
            }
          }
          context.restore();
        },
        // private
        debugRect: function(rect) {
          if (this.useCanvas) {
            var context = this.context;
            context.save();
            context.lineWidth = 2 * $.pixelDensityRatio;
            context.strokeStyle = this.debugGridColor[0];
            context.fillStyle = this.debugGridColor[0];
            context.strokeRect(
              rect.x * $.pixelDensityRatio,
              rect.y * $.pixelDensityRatio,
              rect.width * $.pixelDensityRatio,
              rect.height * $.pixelDensityRatio
            );
            context.restore();
          }
        },
        /**
         * Turns image smoothing on or off for this viewer. Note: Ignored in some (especially older) browsers that do not support this property.
         *
         * @function
         * @param {Boolean} [imageSmoothingEnabled] - Whether or not the image is
         * drawn smoothly on the canvas; see imageSmoothingEnabled in
         * {@link OpenSeadragon.Options} for more explanation.
         */
        setImageSmoothingEnabled: function(imageSmoothingEnabled) {
          if (this.useCanvas) {
            this._imageSmoothingEnabled = imageSmoothingEnabled;
            this._updateImageSmoothingEnabled(this.context);
            this.viewer.forceRedraw();
          }
        },
        // private
        _updateImageSmoothingEnabled: function(context) {
          context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
          context.imageSmoothingEnabled = this._imageSmoothingEnabled;
        },
        /**
         * Get the canvas size
         * @param {Boolean} sketch If set to true return the size of the sketch canvas
         * @returns {OpenSeadragon.Point} The size of the canvas
         */
        getCanvasSize: function(sketch) {
          var canvas = this._getContext(sketch).canvas;
          return new $.Point(canvas.width, canvas.height);
        },
        getCanvasCenter: function() {
          return new $.Point(this.canvas.width / 2, this.canvas.height / 2);
        },
        // private
        _offsetForRotation: function(options) {
          var point = options.point ? options.point.times($.pixelDensityRatio) : this.getCanvasCenter();
          var context = this._getContext(options.useSketch);
          context.save();
          context.translate(point.x, point.y);
          if (this.viewer.viewport.flipped) {
            context.rotate(Math.PI / 180 * -options.degrees);
            context.scale(-1, 1);
          } else {
            context.rotate(Math.PI / 180 * options.degrees);
          }
          context.translate(-point.x, -point.y);
        },
        // private
        _flip: function(options) {
          options = options || {};
          var point = options.point ? options.point.times($.pixelDensityRatio) : this.getCanvasCenter();
          var context = this._getContext(options.useSketch);
          context.translate(point.x, 0);
          context.scale(-1, 1);
          context.translate(-point.x, 0);
        },
        // private
        _restoreRotationChanges: function(useSketch) {
          var context = this._getContext(useSketch);
          context.restore();
        },
        // private
        _calculateCanvasSize: function() {
          var pixelDensityRatio = $.pixelDensityRatio;
          var viewportSize = this.viewport.getContainerSize();
          return {
            // canvas width and height are integers
            x: Math.round(viewportSize.x * pixelDensityRatio),
            y: Math.round(viewportSize.y * pixelDensityRatio)
          };
        },
        // private
        _calculateSketchCanvasSize: function() {
          var canvasSize = this._calculateCanvasSize();
          if (this.viewport.getRotation() === 0) {
            return canvasSize;
          }
          var sketchCanvasSize = Math.ceil(Math.sqrt(
            canvasSize.x * canvasSize.x + canvasSize.y * canvasSize.y
          ));
          return {
            x: sketchCanvasSize,
            y: sketchCanvasSize
          };
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.Viewport = function(options) {
        var args = arguments;
        if (args.length && args[0] instanceof $.Point) {
          options = {
            containerSize: args[0],
            contentSize: args[1],
            config: args[2]
          };
        }
        if (options.config) {
          $.extend(true, options, options.config);
          delete options.config;
        }
        this._margins = $.extend({
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        }, options.margins || {});
        delete options.margins;
        options.initialDegrees = options.degrees;
        delete options.degrees;
        $.extend(true, this, {
          //required settings
          containerSize: null,
          contentSize: null,
          //internal state properties
          zoomPoint: null,
          rotationPivot: null,
          viewer: null,
          //configurable options
          springStiffness: $.DEFAULT_SETTINGS.springStiffness,
          animationTime: $.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: $.DEFAULT_SETTINGS.minZoomImageRatio,
          maxZoomPixelRatio: $.DEFAULT_SETTINGS.maxZoomPixelRatio,
          visibilityRatio: $.DEFAULT_SETTINGS.visibilityRatio,
          wrapHorizontal: $.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: $.DEFAULT_SETTINGS.wrapVertical,
          defaultZoomLevel: $.DEFAULT_SETTINGS.defaultZoomLevel,
          minZoomLevel: $.DEFAULT_SETTINGS.minZoomLevel,
          maxZoomLevel: $.DEFAULT_SETTINGS.maxZoomLevel,
          initialDegrees: $.DEFAULT_SETTINGS.degrees,
          flipped: $.DEFAULT_SETTINGS.flipped,
          homeFillsViewer: $.DEFAULT_SETTINGS.homeFillsViewer,
          silenceMultiImageWarnings: $.DEFAULT_SETTINGS.silenceMultiImageWarnings
        }, options);
        this._updateContainerInnerSize();
        this.centerSpringX = new $.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this.centerSpringY = new $.Spring({
          initial: 0,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this.zoomSpring = new $.Spring({
          exponential: true,
          initial: 1,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this.degreesSpring = new $.Spring({
          initial: options.initialDegrees,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._oldCenterX = this.centerSpringX.current.value;
        this._oldCenterY = this.centerSpringY.current.value;
        this._oldZoom = this.zoomSpring.current.value;
        this._oldDegrees = this.degreesSpring.current.value;
        this._setContentBounds(new $.Rect(0, 0, 1, 1), 1);
        this.goHome(true);
        this.update();
      };
      $.Viewport.prototype = {
        // deprecated
        get degrees() {
          $.console.warn("Accessing [Viewport.degrees] is deprecated. Use viewport.getRotation instead.");
          return this.getRotation();
        },
        // deprecated
        set degrees(degrees) {
          $.console.warn("Setting [Viewport.degrees] is deprecated. Use viewport.rotateTo, viewport.rotateBy, or viewport.setRotation instead.");
          this.rotateTo(degrees);
        },
        /**
         * Updates the viewport's home bounds and constraints for the given content size.
         * @function
         * @param {OpenSeadragon.Point} contentSize - size of the content in content units
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:reset-size
         */
        resetContentSize: function(contentSize) {
          $.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
          $.console.assert(contentSize instanceof $.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
          $.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
          $.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
          this._setContentBounds(new $.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
          return this;
        },
        // deprecated
        setHomeBounds: function(bounds, contentFactor) {
          $.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
          this._setContentBounds(bounds, contentFactor);
        },
        // Set the viewport's content bounds
        // @param {OpenSeadragon.Rect} bounds - the new bounds in viewport coordinates
        // without rotation
        // @param {Number} contentFactor - how many content units per viewport unit
        // @fires OpenSeadragon.Viewer.event:reset-size
        // @private
        _setContentBounds: function(bounds, contentFactor) {
          $.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
          $.console.assert(bounds instanceof $.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
          $.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
          $.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
          this._contentBoundsNoRotate = bounds.clone();
          this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
            contentFactor
          );
          this._contentBounds = bounds.rotate(this.getRotation()).getBoundingBox();
          this._contentSize = this._contentBounds.getSize().times(contentFactor);
          this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
          if (this.viewer) {
            this.viewer.raiseEvent("reset-size", {
              contentSize: this._contentSizeNoRotate.clone(),
              contentFactor,
              homeBounds: this._contentBoundsNoRotate.clone(),
              contentBounds: this._contentBounds.clone()
            });
          }
        },
        /**
         * Returns the home zoom in "viewport zoom" value.
         * @function
         * @returns {Number} The home zoom in "viewport zoom".
         */
        getHomeZoom: function() {
          if (this.defaultZoomLevel) {
            return this.defaultZoomLevel;
          }
          var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
          var output;
          if (this.homeFillsViewer) {
            output = aspectFactor >= 1 ? aspectFactor : 1;
          } else {
            output = aspectFactor >= 1 ? 1 : aspectFactor;
          }
          return output / this._contentBounds.width;
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBounds: function() {
          return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
        },
        /**
         * Returns the home bounds in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getHomeBounds} to take it into account.
         * @function
         * @returns {OpenSeadragon.Rect} The home bounds in vewport coordinates.
         */
        getHomeBoundsNoRotate: function() {
          var center = this._contentBounds.getCenter();
          var width = 1 / this.getHomeZoom();
          var height = width / this.getAspectRatio();
          return new $.Rect(
            center.x - width / 2,
            center.y - height / 2,
            width,
            height
          );
        },
        /**
         * @function
         * @param {Boolean} immediately
         * @fires OpenSeadragon.Viewer.event:home
         */
        goHome: function(immediately) {
          if (this.viewer) {
            this.viewer.raiseEvent("home", {
              immediately
            });
          }
          return this.fitBounds(this.getHomeBounds(), immediately);
        },
        /**
         * @function
         */
        getMinZoom: function() {
          var homeZoom = this.getHomeZoom(), zoom = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * homeZoom;
          return zoom;
        },
        /**
         * @function
         */
        getMaxZoom: function() {
          var zoom = this.maxZoomLevel;
          if (!zoom) {
            zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
            zoom /= this._contentBounds.width;
          }
          return Math.max(zoom, this.getHomeZoom());
        },
        /**
         * @function
         */
        getAspectRatio: function() {
          return this._containerInnerSize.x / this._containerInnerSize.y;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Point} The size of the container, in screen coordinates.
         */
        getContainerSize: function() {
          return new $.Point(
            this.containerSize.x,
            this.containerSize.y
          );
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @returns {Object} Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        getMargins: function() {
          return $.extend({}, this._margins);
        },
        /**
         * The margins push the "home" region in from the sides by the specified amounts.
         * @function
         * @param {Object} margins - Properties (Numbers, in screen coordinates): left, top, right, bottom.
         */
        setMargins: function(margins) {
          $.console.assert($.type(margins) === "object", "[Viewport.setMargins] margins must be an object");
          this._margins = $.extend({
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          }, margins);
          this._updateContainerInnerSize();
          if (this.viewer) {
            this.viewer.forceRedraw();
          }
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBounds: function(current) {
          return this.getBoundsNoRotate(current).rotate(-this.getRotation(current));
        },
        /**
         * Returns the bounds of the visible area in viewport coordinates.
         * This method ignores the viewport rotation. Use
         * {@link OpenSeadragon.Viewport#getBounds} to take it into account.
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to, in viewport coordinates.
         */
        getBoundsNoRotate: function(current) {
          var center = this.getCenter(current);
          var width = 1 / this.getZoom(current);
          var height = width / this.getAspectRatio();
          return new $.Rect(
            center.x - width / 2,
            center.y - height / 2,
            width,
            height
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsWithMargins: function(current) {
          return this.getBoundsNoRotateWithMargins(current).rotate(
            -this.getRotation(current),
            this.getCenter(current)
          );
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The location you are zoomed/panned to,
         * including the space taken by margins, in viewport coordinates.
         */
        getBoundsNoRotateWithMargins: function(current) {
          var bounds = this.getBoundsNoRotate(current);
          var factor = this._containerInnerSize.x * this.getZoom(current);
          bounds.x -= this._margins.left / factor;
          bounds.y -= this._margins.top / factor;
          bounds.width += (this._margins.left + this._margins.right) / factor;
          bounds.height += (this._margins.top + this._margins.bottom) / factor;
          return bounds;
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getCenter: function(current) {
          var centerCurrent = new $.Point(
            this.centerSpringX.current.value,
            this.centerSpringY.current.value
          ), centerTarget = new $.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          ), oldZoomPixel, zoom, width, height, bounds, newZoomPixel, deltaZoomPixels, deltaZoomPoints;
          if (current) {
            return centerCurrent;
          } else if (!this.zoomPoint) {
            return centerTarget;
          }
          oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
          zoom = this.getZoom();
          width = 1 / zoom;
          height = width / this.getAspectRatio();
          bounds = new $.Rect(
            centerCurrent.x - width / 2,
            centerCurrent.y - height / 2,
            width,
            height
          );
          newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
          deltaZoomPixels = newZoomPixel.minus(oldZoomPixel).rotate(-this.getRotation(true));
          deltaZoomPoints = deltaZoomPixels.divide(this._containerInnerSize.x * zoom);
          return centerTarget.plus(deltaZoomPoints);
        },
        /**
         * @function
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         */
        getZoom: function(current) {
          if (current) {
            return this.zoomSpring.current.value;
          } else {
            return this.zoomSpring.target.value;
          }
        },
        // private
        _applyZoomConstraints: function(zoom) {
          return Math.max(
            Math.min(zoom, this.getMaxZoom()),
            this.getMinZoom()
          );
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @returns {OpenSeadragon.Rect} constrained bounds.
         */
        _applyBoundaryConstraints: function(bounds) {
          var newBounds = this.viewportToViewerElementRectangle(bounds).getBoundingBox();
          var cb = this.viewportToViewerElementRectangle(this._contentBoundsNoRotate).getBoundingBox();
          var xConstrained = false;
          var yConstrained = false;
          if (this.wrapHorizontal) {
          } else {
            var boundsRight = newBounds.x + newBounds.width;
            var contentRight = cb.x + cb.width;
            var horizontalThreshold, leftDx, rightDx;
            if (newBounds.width > cb.width) {
              horizontalThreshold = this.visibilityRatio * cb.width;
            } else {
              horizontalThreshold = this.visibilityRatio * newBounds.width;
            }
            leftDx = cb.x - boundsRight + horizontalThreshold;
            rightDx = contentRight - newBounds.x - horizontalThreshold;
            if (horizontalThreshold > cb.width) {
              newBounds.x += (leftDx + rightDx) / 2;
              xConstrained = true;
            } else if (rightDx < 0) {
              newBounds.x += rightDx;
              xConstrained = true;
            } else if (leftDx > 0) {
              newBounds.x += leftDx;
              xConstrained = true;
            }
          }
          if (this.wrapVertical) {
          } else {
            var boundsBottom = newBounds.y + newBounds.height;
            var contentBottom = cb.y + cb.height;
            var verticalThreshold, topDy, bottomDy;
            if (newBounds.height > cb.height) {
              verticalThreshold = this.visibilityRatio * cb.height;
            } else {
              verticalThreshold = this.visibilityRatio * newBounds.height;
            }
            topDy = cb.y - boundsBottom + verticalThreshold;
            bottomDy = contentBottom - newBounds.y - verticalThreshold;
            if (verticalThreshold > cb.height) {
              newBounds.y += (topDy + bottomDy) / 2;
              yConstrained = true;
            } else if (bottomDy < 0) {
              newBounds.y += bottomDy;
              yConstrained = true;
            } else if (topDy > 0) {
              newBounds.y += topDy;
              yConstrained = true;
            }
          }
          var constraintApplied = xConstrained || yConstrained;
          var newViewportBounds = constraintApplied ? this.viewerElementToViewportRectangle(newBounds) : bounds.clone();
          newViewportBounds.xConstrained = xConstrained;
          newViewportBounds.yConstrained = yConstrained;
          newViewportBounds.constraintApplied = constraintApplied;
          return newViewportBounds;
        },
        /**
         * @function
         * @private
         * @param {Boolean} [immediately=false] - whether the function that triggered this event was
         * called with the "immediately" flag
         */
        _raiseConstraintsEvent: function(immediately) {
          if (this.viewer) {
            this.viewer.raiseEvent("constrain", {
              immediately
            });
          }
        },
        /**
         * Enforces the minZoom, maxZoom and visibilityRatio constraints by
         * zooming and panning to the closest acceptable zoom and location.
         * @function
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain if constraints were applied
         */
        applyConstraints: function(immediately) {
          var actualZoom = this.getZoom();
          var constrainedZoom = this._applyZoomConstraints(actualZoom);
          if (actualZoom !== constrainedZoom) {
            this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
          }
          var constrainedBounds = this.getConstrainedBounds(false);
          if (constrainedBounds.constraintApplied) {
            this.fitBounds(constrainedBounds, immediately);
            this._raiseConstraintsEvent(immediately);
          }
          return this;
        },
        /**
         * Equivalent to {@link OpenSeadragon.Viewport#applyConstraints}
         * @function
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:constrain
         */
        ensureVisible: function(immediately) {
          return this.applyConstraints(immediately);
        },
        /**
         * @function
         * @private
         * @param {OpenSeadragon.Rect} bounds
         * @param {Object} options (immediately=false, constraints=false)
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        _fitBounds: function(bounds, options) {
          options = options || {};
          var immediately = options.immediately || false;
          var constraints = options.constraints || false;
          var aspect = this.getAspectRatio();
          var center = bounds.getCenter();
          var newBounds = new $.Rect(
            bounds.x,
            bounds.y,
            bounds.width,
            bounds.height,
            bounds.degrees + this.getRotation()
          ).getBoundingBox();
          if (newBounds.getAspectRatio() >= aspect) {
            newBounds.height = newBounds.width / aspect;
          } else {
            newBounds.width = newBounds.height * aspect;
          }
          newBounds.x = center.x - newBounds.width / 2;
          newBounds.y = center.y - newBounds.height / 2;
          var newZoom = 1 / newBounds.width;
          if (immediately) {
            this.panTo(center, true);
            this.zoomTo(newZoom, null, true);
            if (constraints) {
              this.applyConstraints(true);
            }
            return this;
          }
          var currentCenter = this.getCenter(true);
          var currentZoom = this.getZoom(true);
          this.panTo(currentCenter, true);
          this.zoomTo(currentZoom, null, true);
          var oldBounds = this.getBounds();
          var oldZoom = this.getZoom();
          if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 1e-8) {
            this.zoomTo(newZoom, null, true);
            this.panTo(center, immediately);
            if (constraints) {
              this.applyConstraints(false);
            }
            return this;
          }
          if (constraints) {
            this.panTo(center, false);
            newZoom = this._applyZoomConstraints(newZoom);
            this.zoomTo(newZoom, null, false);
            var constrainedBounds = this.getConstrainedBounds();
            this.panTo(currentCenter, true);
            this.zoomTo(currentZoom, null, true);
            this.fitBounds(constrainedBounds);
          } else {
            var rotatedNewBounds = newBounds.rotate(-this.getRotation());
            var referencePoint = rotatedNewBounds.getTopLeft().times(newZoom).minus(oldBounds.getTopLeft().times(oldZoom)).divide(newZoom - oldZoom);
            this.zoomTo(newZoom, referencePoint, immediately);
          }
          return this;
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport.
         * Note: this method ignores the constraints (minZoom, maxZoom and
         * visibilityRatio).
         * Use {@link OpenSeadragon.Viewport#fitBoundsWithConstraints} to enforce
         * them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitBounds: function(bounds, immediately) {
          return this._fitBounds(bounds, {
            immediately,
            constraints: false
          });
        },
        /**
         * Makes the viewport zoom and pan so that the specified bounds take
         * as much space as possible in the viewport while enforcing the constraints
         * (minZoom, maxZoom and visibilityRatio).
         * Note: because this method enforces the constraints, part of the
         * provided bounds may end up outside of the viewport.
         * Use {@link OpenSeadragon.Viewport#fitBounds} to ignore them.
         * @function
         * @param {OpenSeadragon.Rect} bounds
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitBoundsWithConstraints: function(bounds, immediately) {
          return this._fitBounds(bounds, {
            immediately,
            constraints: true
          });
        },
        /**
         * Zooms so the image just fills the viewer vertically.
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitVertically: function(immediately) {
          var box = new $.Rect(
            this._contentBounds.x + this._contentBounds.width / 2,
            this._contentBounds.y,
            0,
            this._contentBounds.height
          );
          return this.fitBounds(box, immediately);
        },
        /**
         * Zooms so the image just fills the viewer horizontally.
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        fitHorizontally: function(immediately) {
          var box = new $.Rect(
            this._contentBounds.x,
            this._contentBounds.y + this._contentBounds.height / 2,
            this._contentBounds.width,
            0
          );
          return this.fitBounds(box, immediately);
        },
        /**
         * Returns bounds taking constraints into account
         * Added to improve constrained panning
         * @param {Boolean} current - Pass true for the current location; defaults to false (target location).
         * @returns {OpenSeadragon.Rect} The bounds in viewport coordinates after applying constraints. The returned $.Rect
         *                               contains additional properties constraintsApplied, xConstrained and yConstrained.
         *                               These flags indicate whether the viewport bounds were modified by the constraints
         *                               of the viewer rectangle, and in which dimension(s).
         */
        getConstrainedBounds: function(current) {
          var bounds, constrainedBounds;
          bounds = this.getBounds(current);
          constrainedBounds = this._applyBoundaryConstraints(bounds);
          return constrainedBounds;
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} delta
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panBy: function(delta, immediately) {
          var center = new $.Point(
            this.centerSpringX.target.value,
            this.centerSpringY.target.value
          );
          return this.panTo(center.plus(delta), immediately);
        },
        /**
         * @function
         * @param {OpenSeadragon.Point} center
         * @param {Boolean} immediately
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:pan
         */
        panTo: function(center, immediately) {
          if (immediately) {
            this.centerSpringX.resetTo(center.x);
            this.centerSpringY.resetTo(center.y);
          } else {
            this.centerSpringX.springTo(center.x);
            this.centerSpringY.springTo(center.y);
          }
          if (this.viewer) {
            this.viewer.raiseEvent("pan", {
              center,
              immediately
            });
          }
          return this;
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomBy: function(factor, refPoint, immediately) {
          return this.zoomTo(
            this.zoomSpring.target.value * factor,
            refPoint,
            immediately
          );
        },
        /**
         * Zooms to the specified zoom level
         * @function
         * @param {Number} zoom The zoom level to zoom to.
         * @param {OpenSeadragon.Point} [refPoint] The point which will stay at
         * the same screen location. Defaults to the viewport center.
         * @param {Boolean} [immediately=false]
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:zoom
         */
        zoomTo: function(zoom, refPoint, immediately) {
          var _this = this;
          this.zoomPoint = refPoint instanceof $.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y) ? refPoint : null;
          if (immediately) {
            this._adjustCenterSpringsForZoomPoint(function() {
              _this.zoomSpring.resetTo(zoom);
            });
          } else {
            this.zoomSpring.springTo(zoom);
          }
          if (this.viewer) {
            this.viewer.raiseEvent("zoom", {
              zoom,
              refPoint,
              immediately
            });
          }
          return this;
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setRotation: function(degrees, immediately) {
          return this.rotateTo(degrees, null, immediately);
        },
        /**
         * Gets the current rotation in degrees.
         * @function
         * @param {Boolean} [current=false] True for current rotation, false for target.
         * @returns {Number} The current rotation in degrees.
         */
        getRotation: function(current) {
          return current ? this.degreesSpring.current.value : this.degreesSpring.target.value;
        },
        /**
         * Rotates this viewport to the angle specified around a pivot point. Alias for rotateTo.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setRotationWithPivot: function(degrees, pivot, immediately) {
          return this.rotateTo(degrees, pivot, immediately);
        },
        /**
         * Rotates this viewport to the angle specified.
         * @function
         * @param {Number} degrees The degrees to set the rotation to.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        rotateTo: function(degrees, pivot, immediately) {
          if (!this.viewer || !this.viewer.drawer.canRotate()) {
            return this;
          }
          if (this.degreesSpring.target.value === degrees && this.degreesSpring.isAtTargetValue()) {
            return this;
          }
          this.rotationPivot = pivot instanceof $.Point && !isNaN(pivot.x) && !isNaN(pivot.y) ? pivot : null;
          if (immediately) {
            if (this.rotationPivot) {
              var changeInDegrees = degrees - this._oldDegrees;
              if (!changeInDegrees) {
                this.rotationPivot = null;
                return this;
              }
              this._rotateAboutPivot(degrees);
            } else {
              this.degreesSpring.resetTo(degrees);
            }
          } else {
            var normalizedFrom = $.positiveModulo(this.degreesSpring.current.value, 360);
            var normalizedTo = $.positiveModulo(degrees, 360);
            var diff = normalizedTo - normalizedFrom;
            if (diff > 180) {
              normalizedTo -= 360;
            } else if (diff < -180) {
              normalizedTo += 360;
            }
            var reverseDiff = normalizedFrom - normalizedTo;
            this.degreesSpring.resetTo(degrees + reverseDiff);
            this.degreesSpring.springTo(degrees);
          }
          this._setContentBounds(
            this.viewer.world.getHomeBounds(),
            this.viewer.world.getContentFactor()
          );
          this.viewer.forceRedraw();
          this.viewer.raiseEvent("rotate", { degrees, immediately: !!immediately, pivot: this.rotationPivot || this.getCenter() });
          return this;
        },
        /**
         * Rotates this viewport by the angle specified.
         * @function
         * @param {Number} degrees The degrees by which to rotate the viewport.
         * @param {OpenSeadragon.Point} [pivot] (Optional) point in viewport coordinates
         * around which the rotation should be performed. Defaults to the center of the viewport.
         * * @param {Boolean} [immediately=false] Whether to animate to the new angle
         * or rotate immediately.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        rotateBy: function(degrees, pivot, immediately) {
          return this.rotateTo(this.degreesSpring.target.value + degrees, pivot, immediately);
        },
        /**
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         * @fires OpenSeadragon.Viewer.event:resize
         */
        resize: function(newContainerSize, maintain) {
          var oldBounds = this.getBoundsNoRotate(), newBounds = oldBounds, widthDeltaFactor;
          this.containerSize.x = newContainerSize.x;
          this.containerSize.y = newContainerSize.y;
          this._updateContainerInnerSize();
          if (maintain) {
            widthDeltaFactor = newContainerSize.x / this.containerSize.x;
            newBounds.width = oldBounds.width * widthDeltaFactor;
            newBounds.height = newBounds.width / this.getAspectRatio();
          }
          if (this.viewer) {
            this.viewer.raiseEvent("resize", {
              newContainerSize,
              maintain
            });
          }
          var output = this.fitBounds(newBounds, true);
          if (this.viewer) {
            this.viewer.raiseEvent("after-resize", {
              newContainerSize,
              maintain
            });
          }
          return output;
        },
        // private
        _updateContainerInnerSize: function() {
          this._containerInnerSize = new $.Point(
            Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
            Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
          );
        },
        /**
         * Update the zoom, degrees, and center (X and Y) springs.
         * @function
         * @returns {Boolean} True if any change has been made, false otherwise.
         */
        update: function() {
          var _this = this;
          this._adjustCenterSpringsForZoomPoint(function() {
            _this.zoomSpring.update();
          });
          if (this.degreesSpring.isAtTargetValue()) {
            this.rotationPivot = null;
          }
          this.centerSpringX.update();
          this.centerSpringY.update();
          if (this.rotationPivot) {
            this._rotateAboutPivot(true);
          } else {
            this.degreesSpring.update();
          }
          var changed = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom || this.degreesSpring.current.value !== this._oldDegrees;
          this._oldCenterX = this.centerSpringX.current.value;
          this._oldCenterY = this.centerSpringY.current.value;
          this._oldZoom = this.zoomSpring.current.value;
          this._oldDegrees = this.degreesSpring.current.value;
          return changed;
        },
        // private - pass true to use spring, or a number for degrees for immediate rotation
        _rotateAboutPivot: function(degreesOrUseSpring) {
          var useSpring = degreesOrUseSpring === true;
          var delta = this.rotationPivot.minus(this.getCenter());
          this.centerSpringX.shiftBy(delta.x);
          this.centerSpringY.shiftBy(delta.y);
          if (useSpring) {
            this.degreesSpring.update();
          } else {
            this.degreesSpring.resetTo(degreesOrUseSpring);
          }
          var changeInDegrees = this.degreesSpring.current.value - this._oldDegrees;
          var rdelta = delta.rotate(changeInDegrees * -1).times(-1);
          this.centerSpringX.shiftBy(rdelta.x);
          this.centerSpringY.shiftBy(rdelta.y);
        },
        // private
        _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
          if (this.zoomPoint) {
            var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            zoomSpringHandler();
            var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
            var deltaZoomPoints = this.deltaPointsFromPixels(
              deltaZoomPixels,
              true
            );
            this.centerSpringX.shiftBy(deltaZoomPoints.x);
            this.centerSpringY.shiftBy(deltaZoomPoints.y);
            if (this.zoomSpring.isAtTargetValue()) {
              this.zoomPoint = null;
            }
          } else {
            zoomSpringHandler();
          }
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPixelsFromPoints if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
          return deltaPoints.times(
            this._containerInnerSize.x * this.getZoom(current)
          );
        },
        /**
         * Convert a delta (translation vector) from viewport coordinates to pixels
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPoints - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPixelsFromPoints: function(deltaPoints, current) {
          return this.deltaPixelsFromPointsNoRotate(
            deltaPoints.rotate(this.getRotation(current)),
            current
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates. This method does not take rotation into account.
         * Consider using deltaPointsFromPixels if you need to account for rotation.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
          return deltaPixels.divide(
            this._containerInnerSize.x * this.getZoom(current)
          );
        },
        /**
         * Convert a delta (translation vector) from pixels coordinates to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} deltaPixels - The translation vector to convert.
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        deltaPointsFromPixels: function(deltaPixels, current) {
          return this.deltaPointsFromPixelsNoRotate(deltaPixels, current).rotate(-this.getRotation(current));
        },
        /**
         * Convert viewport coordinates to pixels coordinates.
         * This method does not take rotation into account.
         * Consider using pixelFromPoint if you need to account for rotation.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPointNoRotate: function(point, current) {
          return this._pixelFromPointNoRotate(
            point,
            this.getBoundsNoRotate(current)
          );
        },
        /**
         * Convert viewport coordinates to pixel coordinates.
         * @param {OpenSeadragon.Point} point the viewport coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pixelFromPoint: function(point, current) {
          return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
        },
        // private
        _pixelFromPointNoRotate: function(point, bounds) {
          return point.minus(
            bounds.getTopLeft()
          ).times(
            this._containerInnerSize.x / bounds.width
          ).plus(
            new $.Point(this._margins.left, this._margins.top)
          );
        },
        // private
        _pixelFromPoint: function(point, bounds) {
          return this._pixelFromPointNoRotate(
            point.rotate(this.getRotation(true), this.getCenter(true)),
            bounds
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * This method does not take rotation into account.
         * Consider using pointFromPixel if you need to account for rotation.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixelNoRotate: function(pixel, current) {
          var bounds = this.getBoundsNoRotate(current);
          return pixel.minus(
            new $.Point(this._margins.left, this._margins.top)
          ).divide(
            this._containerInnerSize.x / bounds.width
          ).plus(
            bounds.getTopLeft()
          );
        },
        /**
         * Convert pixel coordinates to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel Pixel coordinates
         * @param {Boolean} [current=false] - Pass true for the current location;
         * defaults to false (target location).
         * @returns {OpenSeadragon.Point}
         */
        pointFromPixel: function(pixel, current) {
          return this.pointFromPixelNoRotate(pixel, current).rotate(
            -this.getRotation(current),
            this.getCenter(current)
          );
        },
        // private
        _viewportToImageDelta: function(viewerX, viewerY) {
          var scale = this._contentBoundsNoRotate.width;
          return new $.Point(
            viewerX * this._contentSizeNoRotate.x / scale,
            viewerY * this._contentSizeNoRotate.x / scale
          );
        },
        /**
         * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point|Number)} viewerX either a point or the X
         * coordinate in viewport coordinate system.
         * @param {Number} [viewerY] Y coordinate in viewport coordinate system.
         * @returns {OpenSeadragon.Point} a point representing the coordinates in the image.
         */
        viewportToImageCoordinates: function(viewerX, viewerY) {
          if (viewerX instanceof $.Point) {
            return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              if (!this.silenceMultiImageWarnings) {
                $.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
              }
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.viewportToImageCoordinates(viewerX, viewerY, true);
            }
          }
          return this._viewportToImageDelta(
            viewerX - this._contentBoundsNoRotate.x,
            viewerY - this._contentBoundsNoRotate.y
          );
        },
        // private
        _imageToViewportDelta: function(imageX, imageY) {
          var scale = this._contentBoundsNoRotate.width;
          return new $.Point(
            imageX / this._contentSizeNoRotate.x * scale,
            imageY / this._contentSizeNoRotate.x * scale
          );
        },
        /**
         * Translates from image coordinate system to OpenSeadragon viewer coordinate system
         * This method can be called either by passing X,Y coordinates or an
         * OpenSeadragon.Point
         * Note: not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.
         * @function
         * @param {(OpenSeadragon.Point | Number)} imageX the point or the
         * X coordinate in image coordinate system.
         * @param {Number} [imageY] Y coordinate in image coordinate system.
         * @returns {OpenSeadragon.Point} a point representing the coordinates in the viewport.
         */
        imageToViewportCoordinates: function(imageX, imageY) {
          if (imageX instanceof $.Point) {
            return this.imageToViewportCoordinates(imageX.x, imageX.y);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              if (!this.silenceMultiImageWarnings) {
                $.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
              }
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.imageToViewportCoordinates(imageX, imageY, true);
            }
          }
          var point = this._imageToViewportDelta(imageX, imageY);
          point.x += this._contentBoundsNoRotate.x;
          point.y += this._contentBoundsNoRotate.y;
          return point;
        },
        /**
         * Translates from a rectangle which describes a portion of the image in
         * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} imageX the rectangle or the X
         * coordinate of the top left corner of the rectangle in image coordinate system.
         * @param {Number} [imageY] the Y coordinate of the top left corner of the rectangle
         * in image coordinate system.
         * @param {Number} [pixelWidth] the width in pixel of the rectangle.
         * @param {Number} [pixelHeight] the height in pixel of the rectangle.
         * @returns {OpenSeadragon.Rect} This image's bounds in viewport coordinates
         */
        imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
          var rect = imageX;
          if (!(rect instanceof $.Rect)) {
            rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              if (!this.silenceMultiImageWarnings) {
                $.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
              }
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.imageToViewportRectangle(
                imageX,
                imageY,
                pixelWidth,
                pixelHeight,
                true
              );
            }
          }
          var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
          var coordB = this._imageToViewportDelta(rect.width, rect.height);
          return new $.Rect(
            coordA.x,
            coordA.y,
            coordB.x,
            coordB.y,
            rect.degrees
          );
        },
        /**
         * Translates from a rectangle which describes a portion of
         * the viewport in point coordinates to image rectangle coordinates.
         * This method can be called either by passing X,Y,width,height or an
         * OpenSeadragon.Rect
         * Note: not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.
         * @function
         * @param {(OpenSeadragon.Rect | Number)} viewerX either a rectangle or
         * the X coordinate of the top left corner of the rectangle in viewport
         * coordinate system.
         * @param {Number} [viewerY] the Y coordinate of the top left corner of the rectangle
         * in viewport coordinate system.
         * @param {Number} [pointWidth] the width of the rectangle in viewport coordinate system.
         * @param {Number} [pointHeight] the height of the rectangle in viewport coordinate system.
         */
        viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
          var rect = viewerX;
          if (!(rect instanceof $.Rect)) {
            rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
          }
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              if (!this.silenceMultiImageWarnings) {
                $.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
              }
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.viewportToImageRectangle(
                viewerX,
                viewerY,
                pointWidth,
                pointHeight,
                true
              );
            }
          }
          var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
          var coordB = this._viewportToImageDelta(rect.width, rect.height);
          return new $.Rect(
            coordA.x,
            coordA.y,
            coordB.x,
            coordB.y,
            rect.degrees
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to image
         * coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToImageCoordinates: function(pixel) {
          var point = this.pointFromPixel(pixel, true);
          return this.viewportToImageCoordinates(point);
        },
        /**
         * Convert pixel coordinates relative to the image to
         * viewer element coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToViewerElementCoordinates: function(pixel) {
          var point = this.imageToViewportCoordinates(pixel);
          return this.pixelFromPoint(point, true);
        },
        /**
         * Convert pixel coordinates relative to the window to image coordinates.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToImageCoordinates: function(pixel) {
          $.console.assert(
            this.viewer,
            "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = pixel.minus(
            $.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToImageCoordinates(viewerCoordinates);
        },
        /**
         * Convert image coordinates to pixel coordinates relative to the window.
         * Note: not accurate with multi-image.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        imageToWindowCoordinates: function(pixel) {
          $.console.assert(
            this.viewer,
            "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
          return viewerCoordinates.plus(
            $.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert pixel coordinates relative to the viewer element to viewport
         * coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        viewerElementToViewportCoordinates: function(pixel) {
          return this.pointFromPixel(pixel, true);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the
         * viewer element.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToViewerElementCoordinates: function(point) {
          return this.pixelFromPoint(point, true);
        },
        /**
         * Convert a rectangle in pixel coordinates relative to the viewer element
         * to viewport coordinates.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewerElementToViewportRectangle: function(rectangle) {
          return $.Rect.fromSummits(
            this.pointFromPixel(rectangle.getTopLeft(), true),
            this.pointFromPixel(rectangle.getTopRight(), true),
            this.pointFromPixel(rectangle.getBottomLeft(), true)
          );
        },
        /**
         * Convert a rectangle in viewport coordinates to pixel coordinates relative
         * to the viewer element.
         * @param {OpenSeadragon.Rect} rectangle the rectangle to convert
         * @returns {OpenSeadragon.Rect} the converted rectangle
         */
        viewportToViewerElementRectangle: function(rectangle) {
          return $.Rect.fromSummits(
            this.pixelFromPoint(rectangle.getTopLeft(), true),
            this.pixelFromPoint(rectangle.getTopRight(), true),
            this.pixelFromPoint(rectangle.getBottomLeft(), true)
          );
        },
        /**
         * Convert pixel coordinates relative to the window to viewport coordinates.
         * @param {OpenSeadragon.Point} pixel
         * @returns {OpenSeadragon.Point}
         */
        windowToViewportCoordinates: function(pixel) {
          $.console.assert(
            this.viewer,
            "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = pixel.minus(
            $.getElementPosition(this.viewer.element)
          );
          return this.viewerElementToViewportCoordinates(viewerCoordinates);
        },
        /**
         * Convert viewport coordinates to pixel coordinates relative to the window.
         * @param {OpenSeadragon.Point} point
         * @returns {OpenSeadragon.Point}
         */
        viewportToWindowCoordinates: function(point) {
          $.console.assert(
            this.viewer,
            "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
          );
          var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
          return viewerCoordinates.plus(
            $.getElementPosition(this.viewer.element)
          );
        },
        /**
         * Convert a viewport zoom to an image zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} viewportZoom The viewport zoom
         * target zoom.
         * @returns {Number} imageZoom The image zoom
         */
        viewportToImageZoom: function(viewportZoom) {
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              if (!this.silenceMultiImageWarnings) {
                $.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
              }
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.viewportToImageZoom(viewportZoom);
            }
          }
          var imageWidth = this._contentSizeNoRotate.x;
          var containerWidth = this._containerInnerSize.x;
          var scale = this._contentBoundsNoRotate.width;
          var viewportToImageZoomRatio = containerWidth / imageWidth * scale;
          return viewportZoom * viewportToImageZoomRatio;
        },
        /**
         * Convert an image zoom to a viewport zoom.
         * Image zoom: ratio of the original image size to displayed image size.
         * 1 means original image size, 0.5 half size...
         * Viewport zoom: ratio of the displayed image's width to viewport's width.
         * 1 means identical width, 2 means image's width is twice the viewport's width...
         * Note: not accurate with multi-image.
         * @function
         * @param {Number} imageZoom The image zoom
         * target zoom.
         * @returns {Number} viewportZoom The viewport zoom
         */
        imageToViewportZoom: function(imageZoom) {
          if (this.viewer) {
            var count = this.viewer.world.getItemCount();
            if (count > 1) {
              if (!this.silenceMultiImageWarnings) {
                $.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
              }
            } else if (count === 1) {
              var item = this.viewer.world.getItemAt(0);
              return item.imageToViewportZoom(imageZoom);
            }
          }
          var imageWidth = this._contentSizeNoRotate.x;
          var containerWidth = this._containerInnerSize.x;
          var scale = this._contentBoundsNoRotate.width;
          var viewportToImageZoomRatio = imageWidth / containerWidth / scale;
          return imageZoom * viewportToImageZoomRatio;
        },
        /**
         * Toggles flip state and demands a new drawing on navigator and viewer objects.
         * @function
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        toggleFlip: function() {
          this.setFlip(!this.getFlip());
          return this;
        },
        /**
         * Get flip state stored on viewport.
         * @function
         * @returns {Boolean} Flip state.
         */
        getFlip: function() {
          return this.flipped;
        },
        /**
         * Sets flip state according to the state input argument.
         * @function
         * @param {Boolean} state - Flip state to set.
         * @returns {OpenSeadragon.Viewport} Chainable.
         */
        setFlip: function(state) {
          if (this.flipped === state) {
            return this;
          }
          this.flipped = state;
          if (this.viewer.navigator) {
            this.viewer.navigator.setFlip(this.getFlip());
          }
          this.viewer.forceRedraw();
          this.viewer.raiseEvent("flip", { flipped: state });
          return this;
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.TiledImage = function(options) {
        var _this = this;
        $.console.assert(options.tileCache, "[TiledImage] options.tileCache is required");
        $.console.assert(options.drawer, "[TiledImage] options.drawer is required");
        $.console.assert(options.viewer, "[TiledImage] options.viewer is required");
        $.console.assert(options.imageLoader, "[TiledImage] options.imageLoader is required");
        $.console.assert(options.source, "[TiledImage] options.source is required");
        $.console.assert(
          !options.clip || options.clip instanceof $.Rect,
          "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
        );
        $.EventSource.call(this);
        this._tileCache = options.tileCache;
        delete options.tileCache;
        this._drawer = options.drawer;
        delete options.drawer;
        this._imageLoader = options.imageLoader;
        delete options.imageLoader;
        if (options.clip instanceof $.Rect) {
          this._clip = options.clip.clone();
        }
        delete options.clip;
        var x = options.x || 0;
        delete options.x;
        var y = options.y || 0;
        delete options.y;
        this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
        this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
        var scale = 1;
        if (options.width) {
          scale = options.width;
          delete options.width;
          if (options.height) {
            $.console.error("specifying both width and height to a tiledImage is not supported");
            delete options.height;
          }
        } else if (options.height) {
          scale = options.height / this.normHeight;
          delete options.height;
        }
        var fitBounds = options.fitBounds;
        delete options.fitBounds;
        var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
        delete options.fitBoundsPlacement;
        var degrees = options.degrees || 0;
        delete options.degrees;
        var ajaxHeaders = options.ajaxHeaders;
        delete options.ajaxHeaders;
        $.extend(true, this, {
          //internal state properties
          viewer: null,
          tilesMatrix: {},
          // A '3d' dictionary [level][x][y] --> Tile.
          coverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas have been drawn.
          loadingCoverage: {},
          // A '3d' dictionary [level][x][y] --> Boolean; shows what areas are loaded or are being loaded/blended.
          lastDrawn: [],
          // An unordered list of Tiles drawn last frame.
          lastResetTime: 0,
          // Last time for which the tiledImage was reset.
          _midDraw: false,
          // Is the tiledImage currently updating the viewport?
          _needsDraw: true,
          // Does the tiledImage need to update the viewport again?
          _hasOpaqueTile: false,
          // Do we have even one fully opaque tile?
          _tilesLoading: 0,
          // The number of pending tile requests.
          //configurable settings
          springStiffness: $.DEFAULT_SETTINGS.springStiffness,
          animationTime: $.DEFAULT_SETTINGS.animationTime,
          minZoomImageRatio: $.DEFAULT_SETTINGS.minZoomImageRatio,
          wrapHorizontal: $.DEFAULT_SETTINGS.wrapHorizontal,
          wrapVertical: $.DEFAULT_SETTINGS.wrapVertical,
          immediateRender: $.DEFAULT_SETTINGS.immediateRender,
          blendTime: $.DEFAULT_SETTINGS.blendTime,
          alwaysBlend: $.DEFAULT_SETTINGS.alwaysBlend,
          minPixelRatio: $.DEFAULT_SETTINGS.minPixelRatio,
          smoothTileEdgesMinZoom: $.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
          iOSDevice: $.DEFAULT_SETTINGS.iOSDevice,
          debugMode: $.DEFAULT_SETTINGS.debugMode,
          crossOriginPolicy: $.DEFAULT_SETTINGS.crossOriginPolicy,
          ajaxWithCredentials: $.DEFAULT_SETTINGS.ajaxWithCredentials,
          placeholderFillStyle: $.DEFAULT_SETTINGS.placeholderFillStyle,
          opacity: $.DEFAULT_SETTINGS.opacity,
          preload: $.DEFAULT_SETTINGS.preload,
          compositeOperation: $.DEFAULT_SETTINGS.compositeOperation,
          subPixelRoundingForTransparency: $.DEFAULT_SETTINGS.subPixelRoundingForTransparency
        }, options);
        this._preload = this.preload;
        delete this.preload;
        this._fullyLoaded = false;
        this._xSpring = new $.Spring({
          initial: x,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._ySpring = new $.Spring({
          initial: y,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._scaleSpring = new $.Spring({
          initial: scale,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._degreesSpring = new $.Spring({
          initial: degrees,
          springStiffness: this.springStiffness,
          animationTime: this.animationTime
        });
        this._updateForScale();
        if (fitBounds) {
          this.fitBounds(fitBounds, fitBoundsPlacement, true);
        }
        this._drawingHandler = function(args) {
          _this.viewer.raiseEvent("tile-drawing", $.extend({
            tiledImage: _this
          }, args));
        };
        this._ownAjaxHeaders = {};
        this.setAjaxHeaders(ajaxHeaders, false);
      };
      $.extend(
        $.TiledImage.prototype,
        $.EventSource.prototype,
        /** @lends OpenSeadragon.TiledImage.prototype */
        {
          /**
           * @returns {Boolean} Whether the TiledImage needs to be drawn.
           */
          needsDraw: function() {
            return this._needsDraw;
          },
          /**
           * @returns {Boolean} Whether all tiles necessary for this TiledImage to draw at the current view have been loaded.
           */
          getFullyLoaded: function() {
            return this._fullyLoaded;
          },
          // private
          _setFullyLoaded: function(flag) {
            if (flag === this._fullyLoaded) {
              return;
            }
            this._fullyLoaded = flag;
            this.raiseEvent("fully-loaded-change", {
              fullyLoaded: this._fullyLoaded
            });
          },
          /**
           * Clears all tiles and triggers an update on the next call to
           * {@link OpenSeadragon.TiledImage#update}.
           */
          reset: function() {
            this._tileCache.clearTilesFor(this);
            this.lastResetTime = $.now();
            this._needsDraw = true;
          },
          /**
           * Updates the TiledImage's bounds, animating if needed.
           * @returns {Boolean} Whether the TiledImage animated.
           */
          update: function() {
            var xUpdated = this._xSpring.update();
            var yUpdated = this._ySpring.update();
            var scaleUpdated = this._scaleSpring.update();
            var degreesUpdated = this._degreesSpring.update();
            if (xUpdated || yUpdated || scaleUpdated || degreesUpdated) {
              this._updateForScale();
              this._needsDraw = true;
              return true;
            }
            return false;
          },
          /**
           * Draws the TiledImage to its Drawer.
           */
          draw: function() {
            if (this.opacity !== 0 || this._preload) {
              this._midDraw = true;
              this._updateViewport();
              this._midDraw = false;
            } else {
              this._needsDraw = false;
            }
          },
          /**
           * Destroy the TiledImage (unload current loaded tiles).
           */
          destroy: function() {
            this.reset();
            if (this.source.destroy) {
              this.source.destroy();
            }
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBounds: function(current) {
            return this.getBoundsNoRotate(current).rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          /**
           * Get this TiledImage's bounds in viewport coordinates without taking
           * rotation into account.
           * @param {Boolean} [current=false] - Pass true for the current location;
           * false for target location.
           * @returns {OpenSeadragon.Rect} This TiledImage's bounds in viewport coordinates.
           */
          getBoundsNoRotate: function(current) {
            return current ? new $.Rect(
              this._xSpring.current.value,
              this._ySpring.current.value,
              this._worldWidthCurrent,
              this._worldHeightCurrent
            ) : new $.Rect(
              this._xSpring.target.value,
              this._ySpring.target.value,
              this._worldWidthTarget,
              this._worldHeightTarget
            );
          },
          // deprecated
          getWorldBounds: function() {
            $.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead");
            return this.getBounds();
          },
          /**
           * Get the bounds of the displayed part of the tiled image.
           * @param {Boolean} [current=false] Pass true for the current location,
           * false for the target location.
           * @returns {$.Rect} The clipped bounds in viewport coordinates.
           */
          getClippedBounds: function(current) {
            var bounds = this.getBoundsNoRotate(current);
            if (this._clip) {
              var worldWidth = current ? this._worldWidthCurrent : this._worldWidthTarget;
              var ratio = worldWidth / this.source.dimensions.x;
              var clip = this._clip.times(ratio);
              bounds = new $.Rect(
                bounds.x + clip.x,
                bounds.y + clip.y,
                clip.width,
                clip.height
              );
            }
            return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          /**
           * @function
           * @param {Number} level
           * @param {Number} x
           * @param {Number} y
           * @returns {OpenSeadragon.Rect} Where this tile fits (in normalized coordinates).
           */
          getTileBounds: function(level, x, y) {
            var numTiles = this.source.getNumTiles(level);
            var xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
            var yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
            var bounds = this.source.getTileBounds(level, xMod, yMod);
            if (this.getFlip()) {
              bounds.x = 1 - bounds.x - bounds.width;
            }
            bounds.x += (x - xMod) / numTiles.x;
            bounds.y += this._worldHeightCurrent / this._worldWidthCurrent * ((y - yMod) / numTiles.y);
            return bounds;
          },
          /**
           * @returns {OpenSeadragon.Point} This TiledImage's content size, in original pixels.
           */
          getContentSize: function() {
            return new $.Point(this.source.dimensions.x, this.source.dimensions.y);
          },
          /**
           * @returns {OpenSeadragon.Point} The TiledImage's content size, in window coordinates.
           */
          getSizeInWindowCoordinates: function() {
            var topLeft = this.imageToWindowCoordinates(new $.Point(0, 0));
            var bottomRight = this.imageToWindowCoordinates(this.getContentSize());
            return new $.Point(bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
          },
          // private
          _viewportToImageDelta: function(viewerX, viewerY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $.Point(
              viewerX * (this.source.dimensions.x / scale),
              viewerY * (this.source.dimensions.y * this.contentAspectX / scale)
            );
          },
          /**
           * Translates from OpenSeadragon viewer coordinate system to image coordinate system.
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} viewerX - The X coordinate or point in viewport coordinate system.
           * @param {Number} [viewerY] - The Y coordinate in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Point} A point representing the coordinates in the image.
           */
          viewportToImageCoordinates: function(viewerX, viewerY, current) {
            var point;
            if (viewerX instanceof $.Point) {
              current = viewerY;
              point = viewerX;
            } else {
              point = new $.Point(viewerX, viewerY);
            }
            point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
            return current ? this._viewportToImageDelta(
              point.x - this._xSpring.current.value,
              point.y - this._ySpring.current.value
            ) : this._viewportToImageDelta(
              point.x - this._xSpring.target.value,
              point.y - this._ySpring.target.value
            );
          },
          // private
          _imageToViewportDelta: function(imageX, imageY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $.Point(
              imageX / this.source.dimensions.x * scale,
              imageY / this.source.dimensions.y / this.contentAspectX * scale
            );
          },
          /**
           * Translates from image coordinate system to OpenSeadragon viewer coordinate system
           * This method can be called either by passing X,Y coordinates or an {@link OpenSeadragon.Point}.
           * @param {Number|OpenSeadragon.Point} imageX - The X coordinate or point in image coordinate system.
           * @param {Number} [imageY] - The Y coordinate in image coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Point} A point representing the coordinates in the viewport.
           */
          imageToViewportCoordinates: function(imageX, imageY, current) {
            if (imageX instanceof $.Point) {
              current = imageY;
              imageY = imageX.y;
              imageX = imageX.x;
            }
            var point = this._imageToViewportDelta(imageX, imageY);
            if (current) {
              point.x += this._xSpring.current.value;
              point.y += this._ySpring.current.value;
            } else {
              point.x += this._xSpring.target.value;
              point.y += this._ySpring.target.value;
            }
            return point.rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          /**
           * Translates from a rectangle which describes a portion of the image in
           * pixel coordinates to OpenSeadragon viewport rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} imageX - The left coordinate or rectangle in image coordinate system.
           * @param {Number} [imageY] - The top coordinate in image coordinate system.
           * @param {Number} [pixelWidth] - The width in pixel of the rectangle.
           * @param {Number} [pixelHeight] - The height in pixel of the rectangle.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the viewport.
           */
          imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
            var rect = imageX;
            if (rect instanceof $.Rect) {
              current = imageY;
            } else {
              rect = new $.Rect(imageX, imageY, pixelWidth, pixelHeight);
            }
            var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
            var coordB = this._imageToViewportDelta(rect.width, rect.height, current);
            return new $.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees + this.getRotation(current)
            );
          },
          /**
           * Translates from a rectangle which describes a portion of
           * the viewport in point coordinates to image rectangle coordinates.
           * This method can be called either by passing X,Y,width,height or an {@link OpenSeadragon.Rect}.
           * @param {Number|OpenSeadragon.Rect} viewerX - The left coordinate or rectangle in viewport coordinate system.
           * @param {Number} [viewerY] - The top coordinate in viewport coordinate system.
           * @param {Number} [pointWidth] - The width in viewport coordinate system.
           * @param {Number} [pointHeight] - The height in viewport coordinate system.
           * @param {Boolean} [current=false] - Pass true to use the current location; false for target location.
           * @returns {OpenSeadragon.Rect} A rect representing the coordinates in the image.
           */
          viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight, current) {
            var rect = viewerX;
            if (viewerX instanceof $.Rect) {
              current = viewerY;
            } else {
              rect = new $.Rect(viewerX, viewerY, pointWidth, pointHeight);
            }
            var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
            var coordB = this._viewportToImageDelta(rect.width, rect.height, current);
            return new $.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees - this.getRotation(current)
            );
          },
          /**
           * Convert pixel coordinates relative to the viewer element to image
           * coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          viewerElementToImageCoordinates: function(pixel) {
            var point = this.viewport.pointFromPixel(pixel, true);
            return this.viewportToImageCoordinates(point);
          },
          /**
           * Convert pixel coordinates relative to the image to
           * viewer element coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToViewerElementCoordinates: function(pixel) {
            var point = this.imageToViewportCoordinates(pixel);
            return this.viewport.pixelFromPoint(point, true);
          },
          /**
           * Convert pixel coordinates relative to the window to image coordinates.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          windowToImageCoordinates: function(pixel) {
            var viewerCoordinates = pixel.minus(
              OpenSeadragon.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToImageCoordinates(viewerCoordinates);
          },
          /**
           * Convert image coordinates to pixel coordinates relative to the window.
           * @param {OpenSeadragon.Point} pixel
           * @returns {OpenSeadragon.Point}
           */
          imageToWindowCoordinates: function(pixel) {
            var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
            return viewerCoordinates.plus(
              OpenSeadragon.getElementPosition(this.viewer.element)
            );
          },
          // private
          // Convert rectangle in viewport coordinates to this tiled image point
          // coordinates (x in [0, 1] and y in [0, aspectRatio])
          _viewportToTiledImageRectangle: function(rect) {
            var scale = this._scaleSpring.current.value;
            rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
            return new $.Rect(
              (rect.x - this._xSpring.current.value) / scale,
              (rect.y - this._ySpring.current.value) / scale,
              rect.width / scale,
              rect.height / scale,
              rect.degrees
            );
          },
          /**
           * Convert a viewport zoom to an image zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * @function
           * @param {Number} viewportZoom The viewport zoom
           * @returns {Number} imageZoom The image zoom
           */
          viewportToImageZoom: function(viewportZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return ratio * viewportZoom;
          },
          /**
           * Convert an image zoom to a viewport zoom.
           * Image zoom: ratio of the original image size to displayed image size.
           * 1 means original image size, 0.5 half size...
           * Viewport zoom: ratio of the displayed image's width to viewport's width.
           * 1 means identical width, 2 means image's width is twice the viewport's width...
           * Note: not accurate with multi-image.
           * @function
           * @param {Number} imageZoom The image zoom
           * @returns {Number} viewportZoom The viewport zoom
           */
          imageToViewportZoom: function(imageZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return imageZoom / ratio;
          },
          /**
           * Sets the TiledImage's position in the world.
           * @param {OpenSeadragon.Point} position - The new position, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new position or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setPosition: function(position, immediately) {
            var sameTarget = this._xSpring.target.value === position.x && this._ySpring.target.value === position.y;
            if (immediately) {
              if (sameTarget && this._xSpring.current.value === position.x && this._ySpring.current.value === position.y) {
                return;
              }
              this._xSpring.resetTo(position.x);
              this._ySpring.resetTo(position.y);
              this._needsDraw = true;
            } else {
              if (sameTarget) {
                return;
              }
              this._xSpring.springTo(position.x);
              this._ySpring.springTo(position.y);
              this._needsDraw = true;
            }
            if (!sameTarget) {
              this._raiseBoundsChange();
            }
          },
          /**
           * Sets the TiledImage's width in the world, adjusting the height to match based on aspect ratio.
           * @param {Number} width - The new width, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setWidth: function(width, immediately) {
            this._setScale(width, immediately);
          },
          /**
           * Sets the TiledImage's height in the world, adjusting the width to match based on aspect ratio.
           * @param {Number} height - The new height, in viewport coordinates.
           * @param {Boolean} [immediately=false] - Whether to animate to the new size or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setHeight: function(height, immediately) {
            this._setScale(height / this.normHeight, immediately);
          },
          /**
           * Sets an array of polygons to crop the TiledImage during draw tiles.
           * The render function will use the default non-zero winding rule.
           * @param {OpenSeadragon.Point[][]} polygons - represented in an array of point object in image coordinates.
           * Example format: [
           *  [{x: 197, y:172}, {x: 226, y:172}, {x: 226, y:198}, {x: 197, y:198}], // First polygon
           *  [{x: 328, y:200}, {x: 330, y:199}, {x: 332, y:201}, {x: 329, y:202}]  // Second polygon
           *  [{x: 321, y:201}, {x: 356, y:205}, {x: 341, y:250}] // Third polygon
           * ]
           */
          setCroppingPolygons: function(polygons) {
            var isXYObject = function(obj) {
              return obj instanceof $.Point || typeof obj.x === "number" && typeof obj.y === "number";
            };
            var objectToSimpleXYObject = function(objs) {
              return objs.map(function(obj) {
                try {
                  if (isXYObject(obj)) {
                    return { x: obj.x, y: obj.y };
                  } else {
                    throw new Error();
                  }
                } catch (e) {
                  throw new Error("A Provided cropping polygon point is not supported");
                }
              });
            };
            try {
              if (!$.isArray(polygons)) {
                throw new Error("Provided cropping polygon is not an array");
              }
              this._croppingPolygons = polygons.map(function(polygon) {
                return objectToSimpleXYObject(polygon);
              });
            } catch (e) {
              $.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported");
              $.console.error(e);
              this._croppingPolygons = null;
            }
          },
          /**
           * Resets the cropping polygons, thus next render will remove all cropping
           * polygon effects.
           */
          resetCroppingPolygons: function() {
            this._croppingPolygons = null;
          },
          /**
           * Positions and scales the TiledImage to fit in the specified bounds.
           * Note: this method fires OpenSeadragon.TiledImage.event:bounds-change
           * twice
           * @param {OpenSeadragon.Rect} bounds The bounds to fit the image into.
           * @param {OpenSeadragon.Placement} [anchor=OpenSeadragon.Placement.CENTER]
           * How to anchor the image in the bounds.
           * @param {Boolean} [immediately=false] Whether to animate to the new size
           * or snap immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          fitBounds: function(bounds, anchor, immediately) {
            anchor = anchor || $.Placement.CENTER;
            var anchorProperties = $.Placement.properties[anchor];
            var aspectRatio = this.contentAspectX;
            var xOffset = 0;
            var yOffset = 0;
            var displayedWidthRatio = 1;
            var displayedHeightRatio = 1;
            if (this._clip) {
              aspectRatio = this._clip.getAspectRatio();
              displayedWidthRatio = this._clip.width / this.source.dimensions.x;
              displayedHeightRatio = this._clip.height / this.source.dimensions.y;
              if (bounds.getAspectRatio() > aspectRatio) {
                xOffset = this._clip.x / this._clip.height * bounds.height;
                yOffset = this._clip.y / this._clip.height * bounds.height;
              } else {
                xOffset = this._clip.x / this._clip.width * bounds.width;
                yOffset = this._clip.y / this._clip.width * bounds.width;
              }
            }
            if (bounds.getAspectRatio() > aspectRatio) {
              var height = bounds.height / displayedHeightRatio;
              var marginLeft = 0;
              if (anchorProperties.isHorizontallyCentered) {
                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
              } else if (anchorProperties.isRight) {
                marginLeft = bounds.width - bounds.height * aspectRatio;
              }
              this.setPosition(
                new $.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
                immediately
              );
              this.setHeight(height, immediately);
            } else {
              var width = bounds.width / displayedWidthRatio;
              var marginTop = 0;
              if (anchorProperties.isVerticallyCentered) {
                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
              } else if (anchorProperties.isBottom) {
                marginTop = bounds.height - bounds.width / aspectRatio;
              }
              this.setPosition(
                new $.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
                immediately
              );
              this.setWidth(width, immediately);
            }
          },
          /**
           * @returns {OpenSeadragon.Rect|null} The TiledImage's current clip rectangle,
           * in image pixels, or null if none.
           */
          getClip: function() {
            if (this._clip) {
              return this._clip.clone();
            }
            return null;
          },
          /**
           * @param {OpenSeadragon.Rect|null} newClip - An area, in image pixels, to clip to
           * (portions of the image outside of this area will not be visible). Only works on
           * browsers that support the HTML5 canvas.
           * @fires OpenSeadragon.TiledImage.event:clip-change
           */
          setClip: function(newClip) {
            $.console.assert(
              !newClip || newClip instanceof $.Rect,
              "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
            );
            if (newClip instanceof $.Rect) {
              this._clip = newClip.clone();
            } else {
              this._clip = null;
            }
            this._needsDraw = true;
            this.raiseEvent("clip-change");
          },
          /**
           * @returns {Boolean} Whether the TiledImage should be flipped before rendering.
           */
          getFlip: function() {
            return !!this.flipped;
          },
          /**
           * @param {Boolean} flip Whether the TiledImage should be flipped before rendering.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setFlip: function(flip) {
            this.flipped = !!flip;
            this._needsDraw = true;
            this._raiseBoundsChange();
          },
          /**
           * @returns {Number} The TiledImage's current opacity.
           */
          getOpacity: function() {
            return this.opacity;
          },
          /**
           * @param {Number} opacity Opacity the tiled image should be drawn at.
           * @fires OpenSeadragon.TiledImage.event:opacity-change
           */
          setOpacity: function(opacity) {
            if (opacity === this.opacity) {
              return;
            }
            this.opacity = opacity;
            this._needsDraw = true;
            this.raiseEvent("opacity-change", {
              opacity: this.opacity
            });
          },
          /**
           * @returns {Boolean} whether the tiledImage can load its tiles even when it has zero opacity.
           */
          getPreload: function() {
            return this._preload;
          },
          /**
           * Set true to load even when hidden. Set false to block loading when hidden.
           */
          setPreload: function(preload) {
            this._preload = !!preload;
            this._needsDraw = true;
          },
          /**
           * Get the rotation of this tiled image in degrees.
           * @param {Boolean} [current=false] True for current rotation, false for target.
           * @returns {Number} the rotation of this tiled image in degrees.
           */
          getRotation: function(current) {
            return current ? this._degreesSpring.current.value : this._degreesSpring.target.value;
          },
          /**
           * Set the current rotation of this tiled image in degrees.
           * @param {Number} degrees the rotation in degrees.
           * @param {Boolean} [immediately=false] Whether to animate to the new angle
           * or rotate immediately.
           * @fires OpenSeadragon.TiledImage.event:bounds-change
           */
          setRotation: function(degrees, immediately) {
            if (this._degreesSpring.target.value === degrees && this._degreesSpring.isAtTargetValue()) {
              return;
            }
            if (immediately) {
              this._degreesSpring.resetTo(degrees);
            } else {
              this._degreesSpring.springTo(degrees);
            }
            this._needsDraw = true;
            this._raiseBoundsChange();
          },
          /**
           * Get the point around which this tiled image is rotated
           * @private
           * @param {Boolean} current True for current rotation point, false for target.
           * @returns {OpenSeadragon.Point}
           */
          _getRotationPoint: function(current) {
            return this.getBoundsNoRotate(current).getCenter();
          },
          /**
           * @returns {String} The TiledImage's current compositeOperation.
           */
          getCompositeOperation: function() {
            return this.compositeOperation;
          },
          /**
           * @param {String} compositeOperation the tiled image should be drawn with this globalCompositeOperation.
           * @fires OpenSeadragon.TiledImage.event:composite-operation-change
           */
          setCompositeOperation: function(compositeOperation) {
            if (compositeOperation === this.compositeOperation) {
              return;
            }
            this.compositeOperation = compositeOperation;
            this._needsDraw = true;
            this.raiseEvent("composite-operation-change", {
              compositeOperation: this.compositeOperation
            });
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * Unless `propagate` is set to false (which is likely only useful in rare circumstances),
           * the updated headers are propagated to all tiles and queued image loader jobs.
           *
           * Note that the rules for merging headers still apply, i.e. headers returned by
           * {@link OpenSeadragon.TileSource#getTileAjaxHeaders} take precedence over
           * the headers here in the tiled image (`TiledImage.ajaxHeaders`).
           *
           * @function
           * @param {Object} ajaxHeaders Updated AJAX headers, which will be merged over any headers specified in {@link OpenSeadragon.Options}.
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
           */
          setAjaxHeaders: function(ajaxHeaders, propagate) {
            if (ajaxHeaders === null) {
              ajaxHeaders = {};
            }
            if (!$.isPlainObject(ajaxHeaders)) {
              console.error("[TiledImage.setAjaxHeaders] Ignoring invalid headers, must be a plain object");
              return;
            }
            this._ownAjaxHeaders = ajaxHeaders;
            this._updateAjaxHeaders(propagate);
          },
          /**
           * Update headers to include when making AJAX requests.
           *
           * This function has the same effect as calling {@link OpenSeadragon.TiledImage#setAjaxHeaders},
           * except that the headers for this tiled image do not change. This is especially useful
           * for propagating updated headers from {@link OpenSeadragon.TileSource#getTileAjaxHeaders}
           * to existing tiles.
           *
           * @private
           * @function
           * @param {Boolean} [propagate=true] Whether to propagate updated headers to existing tiles and queued image loader jobs.
           */
          _updateAjaxHeaders: function(propagate) {
            if (propagate === void 0) {
              propagate = true;
            }
            if ($.isPlainObject(this.viewer.ajaxHeaders)) {
              this.ajaxHeaders = $.extend({}, this.viewer.ajaxHeaders, this._ownAjaxHeaders);
            } else {
              this.ajaxHeaders = this._ownAjaxHeaders;
            }
            if (propagate) {
              var numTiles, xMod, yMod, tile;
              for (var level in this.tilesMatrix) {
                numTiles = this.source.getNumTiles(level);
                for (var x in this.tilesMatrix[level]) {
                  xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
                  for (var y in this.tilesMatrix[level][x]) {
                    yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
                    tile = this.tilesMatrix[level][x][y];
                    tile.loadWithAjax = this.loadTilesWithAjax;
                    if (tile.loadWithAjax) {
                      var tileAjaxHeaders = this.source.getTileAjaxHeaders(level, xMod, yMod);
                      tile.ajaxHeaders = $.extend({}, this.ajaxHeaders, tileAjaxHeaders);
                    } else {
                      tile.ajaxHeaders = null;
                    }
                  }
                }
              }
              for (var i = 0; i < this._imageLoader.jobQueue.length; i++) {
                var job = this._imageLoader.jobQueue[i];
                job.loadWithAjax = job.tile.loadWithAjax;
                job.ajaxHeaders = job.tile.loadWithAjax ? job.tile.ajaxHeaders : null;
              }
            }
          },
          // private
          _setScale: function(scale, immediately) {
            var sameTarget = this._scaleSpring.target.value === scale;
            if (immediately) {
              if (sameTarget && this._scaleSpring.current.value === scale) {
                return;
              }
              this._scaleSpring.resetTo(scale);
              this._updateForScale();
              this._needsDraw = true;
            } else {
              if (sameTarget) {
                return;
              }
              this._scaleSpring.springTo(scale);
              this._updateForScale();
              this._needsDraw = true;
            }
            if (!sameTarget) {
              this._raiseBoundsChange();
            }
          },
          // private
          _updateForScale: function() {
            this._worldWidthTarget = this._scaleSpring.target.value;
            this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
            this._worldWidthCurrent = this._scaleSpring.current.value;
            this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
          },
          // private
          _raiseBoundsChange: function() {
            this.raiseEvent("bounds-change");
          },
          // private
          _isBottomItem: function() {
            return this.viewer.world.getItemAt(0) === this;
          },
          // private
          _getLevelsInterval: function() {
            var lowestLevel = Math.max(
              this.source.minLevel,
              Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
            );
            var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(0),
              true
            ).x * this._scaleSpring.current.value;
            var highestLevel = Math.min(
              Math.abs(this.source.maxLevel),
              Math.abs(Math.floor(
                Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
              ))
            );
            highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
            lowestLevel = Math.min(lowestLevel, highestLevel);
            return {
              lowestLevel,
              highestLevel
            };
          },
          /**
           * @private
           * @inner
           * Pretty much every other line in this needs to be documented so it's clear
           * how each piece of this routine contributes to the drawing process.  That's
           * why there are so many TODO's inside this function.
           */
          _updateViewport: function() {
            this._needsDraw = false;
            this._tilesLoading = 0;
            this.loadingCoverage = {};
            while (this.lastDrawn.length > 0) {
              var tile = this.lastDrawn.pop();
              tile.beingDrawn = false;
            }
            var viewport = this.viewport;
            var drawArea = this._viewportToTiledImageRectangle(
              viewport.getBoundsWithMargins(true)
            );
            if (!this.wrapHorizontal && !this.wrapVertical) {
              var tiledImageBounds = this._viewportToTiledImageRectangle(
                this.getClippedBounds(true)
              );
              drawArea = drawArea.intersection(tiledImageBounds);
              if (drawArea === null) {
                return;
              }
            }
            var levelsInterval = this._getLevelsInterval();
            var lowestLevel = levelsInterval.lowestLevel;
            var highestLevel = levelsInterval.highestLevel;
            var bestTile = null;
            var haveDrawn = false;
            var currentTime = $.now();
            for (var level = highestLevel; level >= lowestLevel; level--) {
              var drawLevel = false;
              var currentRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(level),
                true
              ).x * this._scaleSpring.current.value;
              if (level === lowestLevel || !haveDrawn && currentRenderPixelRatio >= this.minPixelRatio) {
                drawLevel = true;
                haveDrawn = true;
              } else if (!haveDrawn) {
                continue;
              }
              var targetRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(level),
                false
              ).x * this._scaleSpring.current.value;
              var targetZeroRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(
                  Math.max(
                    this.source.getClosestLevel(),
                    0
                  )
                ),
                false
              ).x * this._scaleSpring.current.value;
              var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
              var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
              var levelVisibility = optimalRatio / Math.abs(
                optimalRatio - targetRenderPixelRatio
              );
              bestTile = this._updateLevel(
                haveDrawn,
                drawLevel,
                level,
                levelOpacity,
                levelVisibility,
                drawArea,
                currentTime,
                bestTile
              );
              if (this._providesCoverage(this.coverage, level)) {
                break;
              }
            }
            this._drawTiles(this.lastDrawn);
            if (bestTile && !bestTile.context2D) {
              this._loadTile(bestTile, currentTime);
              this._needsDraw = true;
              this._setFullyLoaded(false);
            } else {
              this._setFullyLoaded(this._tilesLoading === 0);
            }
          },
          // private
          _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
            var leftX;
            var rightX;
            if (this.wrapHorizontal) {
              leftX = $.positiveModulo(topLeftBound.x, 1);
              rightX = $.positiveModulo(bottomRightBound.x, 1);
            } else {
              leftX = Math.max(0, topLeftBound.x);
              rightX = Math.min(1, bottomRightBound.x);
            }
            var topY;
            var bottomY;
            var aspectRatio = 1 / this.source.aspectRatio;
            if (this.wrapVertical) {
              topY = $.positiveModulo(topLeftBound.y, aspectRatio);
              bottomY = $.positiveModulo(bottomRightBound.y, aspectRatio);
            } else {
              topY = Math.max(0, topLeftBound.y);
              bottomY = Math.min(aspectRatio, bottomRightBound.y);
            }
            var topLeftTile = this.source.getTileAtPoint(level, new $.Point(leftX, topY));
            var bottomRightTile = this.source.getTileAtPoint(level, new $.Point(rightX, bottomY));
            var numTiles = this.source.getNumTiles(level);
            if (this.wrapHorizontal) {
              topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
              bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
            }
            if (this.wrapVertical) {
              topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
              bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
            }
            return {
              topLeft: topLeftTile,
              bottomRight: bottomRightTile
            };
          },
          /**
           * Updates all tiles at a given resolution level.
           * @private
           * @param {Boolean} haveDrawn
           * @param {Boolean} drawLevel
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} levelVisibility
           * @param {OpenSeadragon.Rect} drawArea
           * @param {Number} currentTime
           * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
           */
          _updateLevel: function(haveDrawn, drawLevel, level, levelOpacity, levelVisibility, drawArea, currentTime, best) {
            var topLeftBound = drawArea.getBoundingBox().getTopLeft();
            var bottomRightBound = drawArea.getBoundingBox().getBottomRight();
            if (this.viewer) {
              this.viewer.raiseEvent("update-level", {
                tiledImage: this,
                havedrawn: haveDrawn,
                level,
                opacity: levelOpacity,
                visibility: levelVisibility,
                drawArea,
                topleft: topLeftBound,
                bottomright: bottomRightBound,
                currenttime: currentTime,
                best
              });
            }
            this._resetCoverage(this.coverage, level);
            this._resetCoverage(this.loadingCoverage, level);
            var cornerTiles = this._getCornerTiles(level, topLeftBound, bottomRightBound);
            var topLeftTile = cornerTiles.topLeft;
            var bottomRightTile = cornerTiles.bottomRight;
            var numberOfTiles = this.source.getNumTiles(level);
            var viewportCenter = this.viewport.pixelFromPoint(this.viewport.getCenter());
            if (this.getFlip()) {
              bottomRightTile.x += 1;
              if (!this.wrapHorizontal) {
                bottomRightTile.x = Math.min(bottomRightTile.x, numberOfTiles.x - 1);
              }
            }
            for (var x = topLeftTile.x; x <= bottomRightTile.x; x++) {
              for (var y = topLeftTile.y; y <= bottomRightTile.y; y++) {
                var flippedX;
                if (this.getFlip()) {
                  var xMod = (numberOfTiles.x + x % numberOfTiles.x) % numberOfTiles.x;
                  flippedX = x + numberOfTiles.x - xMod - xMod - 1;
                } else {
                  flippedX = x;
                }
                if (drawArea.intersection(this.getTileBounds(level, flippedX, y)) === null) {
                  continue;
                }
                best = this._updateTile(
                  drawLevel,
                  haveDrawn,
                  flippedX,
                  y,
                  level,
                  levelOpacity,
                  levelVisibility,
                  viewportCenter,
                  numberOfTiles,
                  currentTime,
                  best
                );
              }
            }
            return best;
          },
          /**
           * @private
           * @inner
           * Update a single tile at a particular resolution level.
           * @param {Boolean} haveDrawn
           * @param {Boolean} drawLevel
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} levelVisibility
           * @param {OpenSeadragon.Point} viewportCenter
           * @param {Number} numberOfTiles
           * @param {Number} currentTime
           * @param {OpenSeadragon.Tile} best - The current "best" tile to draw.
           */
          _updateTile: function(haveDrawn, drawLevel, x, y, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best) {
            var tile = this._getTile(
              x,
              y,
              level,
              currentTime,
              numberOfTiles,
              this._worldWidthCurrent,
              this._worldHeightCurrent
            ), drawTile = drawLevel;
            if (this.viewer) {
              this.viewer.raiseEvent("update-tile", {
                tiledImage: this,
                tile
              });
            }
            this._setCoverage(this.coverage, level, x, y, false);
            var loadingCoverage = tile.loaded || tile.loading || this._isCovered(this.loadingCoverage, level, x, y);
            this._setCoverage(this.loadingCoverage, level, x, y, loadingCoverage);
            if (!tile.exists) {
              return best;
            }
            if (haveDrawn && !drawTile) {
              if (this._isCovered(this.coverage, level, x, y)) {
                this._setCoverage(this.coverage, level, x, y, true);
              } else {
                drawTile = true;
              }
            }
            if (!drawTile) {
              return best;
            }
            this._positionTile(
              tile,
              this.source.tileOverlap,
              this.viewport,
              viewportCenter,
              levelVisibility
            );
            if (!tile.loaded) {
              if (tile.context2D) {
                this._setTileLoaded(tile);
              } else {
                var imageRecord = this._tileCache.getImageRecord(tile.cacheKey);
                if (imageRecord) {
                  this._setTileLoaded(tile, imageRecord.getData());
                }
              }
            }
            if (tile.loaded) {
              var needsDraw = this._blendTile(
                tile,
                x,
                y,
                level,
                levelOpacity,
                currentTime
              );
              if (needsDraw) {
                this._needsDraw = true;
              }
            } else if (tile.loading) {
              this._tilesLoading++;
            } else if (!loadingCoverage) {
              best = this._compareTiles(best, tile);
            }
            return best;
          },
          /**
           * @private
           * @inner
           * Obtains a tile at the given location.
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} time
           * @param {Number} numTiles
           * @param {Number} worldWidth
           * @param {Number} worldHeight
           * @returns {OpenSeadragon.Tile}
           */
          _getTile: function(x, y, level, time, numTiles, worldWidth, worldHeight) {
            var xMod, yMod, bounds, sourceBounds, exists, urlOrGetter, post, ajaxHeaders, context2D, tile, tilesMatrix = this.tilesMatrix, tileSource = this.source;
            if (!tilesMatrix[level]) {
              tilesMatrix[level] = {};
            }
            if (!tilesMatrix[level][x]) {
              tilesMatrix[level][x] = {};
            }
            if (!tilesMatrix[level][x][y] || !tilesMatrix[level][x][y].flipped !== !this.flipped) {
              xMod = (numTiles.x + x % numTiles.x) % numTiles.x;
              yMod = (numTiles.y + y % numTiles.y) % numTiles.y;
              bounds = this.getTileBounds(level, x, y);
              sourceBounds = tileSource.getTileBounds(level, xMod, yMod, true);
              exists = tileSource.tileExists(level, xMod, yMod);
              urlOrGetter = tileSource.getTileUrl(level, xMod, yMod);
              post = tileSource.getTilePostData(level, xMod, yMod);
              if (this.loadTilesWithAjax) {
                ajaxHeaders = tileSource.getTileAjaxHeaders(level, xMod, yMod);
                if ($.isPlainObject(this.ajaxHeaders)) {
                  ajaxHeaders = $.extend({}, this.ajaxHeaders, ajaxHeaders);
                }
              } else {
                ajaxHeaders = null;
              }
              context2D = tileSource.getContext2D ? tileSource.getContext2D(level, xMod, yMod) : void 0;
              tile = new $.Tile(
                level,
                x,
                y,
                bounds,
                exists,
                urlOrGetter,
                context2D,
                this.loadTilesWithAjax,
                ajaxHeaders,
                sourceBounds,
                post,
                tileSource.getTileHashKey(level, xMod, yMod, urlOrGetter, ajaxHeaders, post)
              );
              if (this.getFlip()) {
                if (xMod === 0) {
                  tile.isRightMost = true;
                }
              } else {
                if (xMod === numTiles.x - 1) {
                  tile.isRightMost = true;
                }
              }
              if (yMod === numTiles.y - 1) {
                tile.isBottomMost = true;
              }
              tile.flipped = this.flipped;
              tilesMatrix[level][x][y] = tile;
            }
            tile = tilesMatrix[level][x][y];
            tile.lastTouchTime = time;
            return tile;
          },
          /**
           * @private
           * @inner
           * Dispatch a job to the ImageLoader to load the Image for a Tile.
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} time
           */
          _loadTile: function(tile, time) {
            var _this = this;
            tile.loading = true;
            this._imageLoader.addJob({
              src: tile.getUrl(),
              tile,
              source: this.source,
              postData: tile.postData,
              loadWithAjax: tile.loadWithAjax,
              ajaxHeaders: tile.ajaxHeaders,
              crossOriginPolicy: this.crossOriginPolicy,
              ajaxWithCredentials: this.ajaxWithCredentials,
              callback: function(data, errorMsg, tileRequest) {
                _this._onTileLoad(tile, time, data, errorMsg, tileRequest);
              },
              abort: function() {
                tile.loading = false;
              }
            });
          },
          /**
           * @private
           * @inner
           * Callback fired when a Tile's Image finished downloading.
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} time
           * @param {*} data image data
           * @param {String} errorMsg
           * @param {XMLHttpRequest} tileRequest
           */
          _onTileLoad: function(tile, time, data, errorMsg, tileRequest) {
            if (!data) {
              $.console.error("Tile %s failed to load: %s - error: %s", tile, tile.getUrl(), errorMsg);
              this.viewer.raiseEvent("tile-load-failed", {
                tile,
                tiledImage: this,
                time,
                message: errorMsg,
                tileRequest
              });
              tile.loading = false;
              tile.exists = false;
              return;
            } else {
              tile.exists = true;
            }
            if (time < this.lastResetTime) {
              $.console.warn("Ignoring tile %s loaded before reset: %s", tile, tile.getUrl());
              tile.loading = false;
              return;
            }
            var _this = this, finish = function() {
              var ccc = _this.source;
              var cutoff = ccc.getClosestLevel();
              _this._setTileLoaded(tile, data, cutoff, tileRequest);
            };
            if (!this._midDraw) {
              finish();
            } else {
              window.setTimeout(finish, 1);
            }
          },
          /**
           * @private
           * @inner
           * @param {OpenSeadragon.Tile} tile
           * @param {*} data image data, the data sent to ImageJob.prototype.finish(), by default an Image object
           * @param {Number|undefined} cutoff
           * @param {XMLHttpRequest|undefined} tileRequest
           */
          _setTileLoaded: function(tile, data, cutoff, tileRequest) {
            var increment = 0, eventFinished = false, _this = this;
            function getCompletionCallback() {
              if (eventFinished) {
                $.console.error("Event 'tile-loaded' argument getCompletionCallback must be called synchronously. Its return value should be called asynchronously.");
              }
              increment++;
              return completionCallback;
            }
            function completionCallback() {
              increment--;
              if (increment === 0) {
                tile.loading = false;
                tile.loaded = true;
                tile.hasTransparency = _this.source.hasTransparency(
                  tile.context2D,
                  tile.getUrl(),
                  tile.ajaxHeaders,
                  tile.postData
                );
                if (!tile.context2D) {
                  _this._tileCache.cacheTile({
                    data,
                    tile,
                    cutoff,
                    tiledImage: _this
                  });
                }
                _this._needsDraw = true;
              }
            }
            var fallbackCompletion = getCompletionCallback();
            this.viewer.raiseEvent("tile-loaded", {
              tile,
              tiledImage: this,
              tileRequest,
              get image() {
                $.console.error("[tile-loaded] event 'image' has been deprecated. Use 'data' property instead.");
                return data;
              },
              data,
              getCompletionCallback
            });
            eventFinished = true;
            fallbackCompletion();
          },
          /**
           * @private
           * @inner
           * @param {OpenSeadragon.Tile} tile
           * @param {Boolean} overlap
           * @param {OpenSeadragon.Viewport} viewport
           * @param {OpenSeadragon.Point} viewportCenter
           * @param {Number} levelVisibility
           */
          _positionTile: function(tile, overlap, viewport, viewportCenter, levelVisibility) {
            var boundsTL = tile.bounds.getTopLeft();
            boundsTL.x *= this._scaleSpring.current.value;
            boundsTL.y *= this._scaleSpring.current.value;
            boundsTL.x += this._xSpring.current.value;
            boundsTL.y += this._ySpring.current.value;
            var boundsSize = tile.bounds.getSize();
            boundsSize.x *= this._scaleSpring.current.value;
            boundsSize.y *= this._scaleSpring.current.value;
            var positionC = viewport.pixelFromPointNoRotate(boundsTL, true), positionT = viewport.pixelFromPointNoRotate(boundsTL, false), sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true), sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false), tileCenter = positionT.plus(sizeT.divide(2)), tileSquaredDistance = viewportCenter.squaredDistanceTo(tileCenter);
            if (!overlap) {
              sizeC = sizeC.plus(new $.Point(1, 1));
            }
            if (tile.isRightMost && this.wrapHorizontal) {
              sizeC.x += 0.75;
            }
            if (tile.isBottomMost && this.wrapVertical) {
              sizeC.y += 0.75;
            }
            tile.position = positionC;
            tile.size = sizeC;
            tile.squaredDistance = tileSquaredDistance;
            tile.visibility = levelVisibility;
          },
          /**
           * @private
           * @inner
           * Updates the opacity of a tile according to the time it has been on screen
           * to perform a fade-in.
           * Updates coverage once a tile is fully opaque.
           * Returns whether the fade-in has completed.
           *
           * @param {OpenSeadragon.Tile} tile
           * @param {Number} x
           * @param {Number} y
           * @param {Number} level
           * @param {Number} levelOpacity
           * @param {Number} currentTime
           * @returns {Boolean}
           */
          _blendTile: function(tile, x, y, level, levelOpacity, currentTime) {
            var blendTimeMillis = 1e3 * this.blendTime, deltaTime, opacity;
            if (!tile.blendStart) {
              tile.blendStart = currentTime;
            }
            deltaTime = currentTime - tile.blendStart;
            opacity = blendTimeMillis ? Math.min(1, deltaTime / blendTimeMillis) : 1;
            if (this.alwaysBlend) {
              opacity *= levelOpacity;
            }
            tile.opacity = opacity;
            this.lastDrawn.push(tile);
            if (opacity === 1) {
              this._setCoverage(this.coverage, level, x, y, true);
              this._hasOpaqueTile = true;
            } else if (deltaTime < blendTimeMillis) {
              return true;
            }
            return false;
          },
          /**
           * @private
           * @inner
           * Determines whether the 'last best' tile for the area is better than the
           * tile in question.
           *
           * @param {OpenSeadragon.Tile} previousBest
           * @param {OpenSeadragon.Tile} tile
           * @returns {OpenSeadragon.Tile} The new best tile.
           */
          _compareTiles: function(previousBest, tile) {
            if (!previousBest) {
              return tile;
            }
            if (tile.visibility > previousBest.visibility) {
              return tile;
            } else if (tile.visibility === previousBest.visibility) {
              if (tile.squaredDistance < previousBest.squaredDistance) {
                return tile;
              }
            }
            return previousBest;
          },
          /**
           * @private
           * @inner
           * Draws a TiledImage.
           * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
           */
          _drawTiles: function(lastDrawn) {
            if (this.opacity === 0 || lastDrawn.length === 0 && !this.placeholderFillStyle) {
              return;
            }
            var tile = lastDrawn[0];
            var useSketch;
            if (tile) {
              useSketch = this.opacity < 1 || this.compositeOperation && this.compositeOperation !== "source-over" || !this._isBottomItem() && this.source.hasTransparency(tile.context2D, tile.getUrl(), tile.ajaxHeaders, tile.postData);
            }
            var sketchScale;
            var sketchTranslate;
            var zoom = this.viewport.getZoom(true);
            var imageZoom = this.viewportToImageZoom(zoom);
            if (lastDrawn.length > 1 && imageZoom > this.smoothTileEdgesMinZoom && !this.iOSDevice && this.getRotation(true) % 360 === 0 && // TODO: support tile edge smoothing with tiled image rotation.
            $.supportsCanvas && this.viewer.useCanvas) {
              useSketch = true;
              sketchScale = tile.getScaleForEdgeSmoothing();
              sketchTranslate = tile.getTranslationForEdgeSmoothing(
                sketchScale,
                this._drawer.getCanvasSize(false),
                this._drawer.getCanvasSize(true)
              );
            }
            var bounds;
            if (useSketch) {
              if (!sketchScale) {
                bounds = this.viewport.viewportToViewerElementRectangle(
                  this.getClippedBounds(true)
                ).getIntegerBoundingBox();
                if (this._drawer.viewer.viewport.getFlip()) {
                  if (this.viewport.getRotation(true) % 360 !== 0 || this.getRotation(true) % 360 !== 0) {
                    bounds.x = this._drawer.viewer.container.clientWidth - (bounds.x + bounds.width);
                  }
                }
                bounds = bounds.times($.pixelDensityRatio);
              }
              this._drawer._clear(true, bounds);
            }
            if (!sketchScale) {
              if (this.viewport.getRotation(true) % 360 !== 0) {
                this._drawer._offsetForRotation({
                  degrees: this.viewport.getRotation(true),
                  useSketch
                });
              }
              if (this.getRotation(true) % 360 !== 0) {
                this._drawer._offsetForRotation({
                  degrees: this.getRotation(true),
                  point: this.viewport.pixelFromPointNoRotate(
                    this._getRotationPoint(true),
                    true
                  ),
                  useSketch
                });
              }
              if (this.viewport.getRotation(true) % 360 === 0 && this.getRotation(true) % 360 === 0) {
                if (this._drawer.viewer.viewport.getFlip()) {
                  this._drawer._flip();
                }
              }
            }
            var usedClip = false;
            if (this._clip) {
              this._drawer.saveContext(useSketch);
              var box = this.imageToViewportRectangle(this._clip, true);
              box = box.rotate(-this.getRotation(true), this._getRotationPoint(true));
              var clipRect = this._drawer.viewportToDrawerRectangle(box);
              if (sketchScale) {
                clipRect = clipRect.times(sketchScale);
              }
              if (sketchTranslate) {
                clipRect = clipRect.translate(sketchTranslate);
              }
              this._drawer.setClip(clipRect, useSketch);
              usedClip = true;
            }
            if (this._croppingPolygons) {
              var self = this;
              this._drawer.saveContext(useSketch);
              try {
                var polygons = this._croppingPolygons.map(function(polygon) {
                  return polygon.map(function(coord) {
                    var point = self.imageToViewportCoordinates(coord.x, coord.y, true).rotate(-self.getRotation(true), self._getRotationPoint(true));
                    var clipPoint = self._drawer.viewportCoordToDrawerCoord(point);
                    if (sketchScale) {
                      clipPoint = clipPoint.times(sketchScale);
                    }
                    if (sketchTranslate) {
                      clipPoint = clipPoint.plus(sketchTranslate);
                    }
                    return clipPoint;
                  });
                });
                this._drawer.clipWithPolygons(polygons, useSketch);
              } catch (e) {
                $.console.error(e);
              }
              usedClip = true;
            }
            if (this.placeholderFillStyle && this._hasOpaqueTile === false) {
              var placeholderRect = this._drawer.viewportToDrawerRectangle(this.getBounds(true));
              if (sketchScale) {
                placeholderRect = placeholderRect.times(sketchScale);
              }
              if (sketchTranslate) {
                placeholderRect = placeholderRect.translate(sketchTranslate);
              }
              var fillStyle = null;
              if (typeof this.placeholderFillStyle === "function") {
                fillStyle = this.placeholderFillStyle(this, this._drawer.context);
              } else {
                fillStyle = this.placeholderFillStyle;
              }
              this._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);
            }
            var subPixelRoundingRule = determineSubPixelRoundingRule(this.subPixelRoundingForTransparency);
            var shouldRoundPositionAndSize = false;
            if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS) {
              shouldRoundPositionAndSize = true;
            } else if (subPixelRoundingRule === $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST) {
              var isAnimating = this.viewer && this.viewer.isAnimating();
              shouldRoundPositionAndSize = !isAnimating;
            }
            for (var i = lastDrawn.length - 1; i >= 0; i--) {
              tile = lastDrawn[i];
              this._drawer.drawTile(
                tile,
                this._drawingHandler,
                useSketch,
                sketchScale,
                sketchTranslate,
                shouldRoundPositionAndSize,
                this.source
              );
              tile.beingDrawn = true;
              if (this.viewer) {
                this.viewer.raiseEvent("tile-drawn", {
                  tiledImage: this,
                  tile
                });
              }
            }
            if (usedClip) {
              this._drawer.restoreContext(useSketch);
            }
            if (!sketchScale) {
              if (this.getRotation(true) % 360 !== 0) {
                this._drawer._restoreRotationChanges(useSketch);
              }
              if (this.viewport.getRotation(true) % 360 !== 0) {
                this._drawer._restoreRotationChanges(useSketch);
              }
            }
            if (useSketch) {
              if (sketchScale) {
                if (this.viewport.getRotation(true) % 360 !== 0) {
                  this._drawer._offsetForRotation({
                    degrees: this.viewport.getRotation(true),
                    useSketch: false
                  });
                }
                if (this.getRotation(true) % 360 !== 0) {
                  this._drawer._offsetForRotation({
                    degrees: this.getRotation(true),
                    point: this.viewport.pixelFromPointNoRotate(
                      this._getRotationPoint(true),
                      true
                    ),
                    useSketch: false
                  });
                }
              }
              this._drawer.blendSketch({
                opacity: this.opacity,
                scale: sketchScale,
                translate: sketchTranslate,
                compositeOperation: this.compositeOperation,
                bounds
              });
              if (sketchScale) {
                if (this.getRotation(true) % 360 !== 0) {
                  this._drawer._restoreRotationChanges(false);
                }
                if (this.viewport.getRotation(true) % 360 !== 0) {
                  this._drawer._restoreRotationChanges(false);
                }
              }
            }
            if (!sketchScale) {
              if (this.viewport.getRotation(true) % 360 === 0 && this.getRotation(true) % 360 === 0) {
                if (this._drawer.viewer.viewport.getFlip()) {
                  this._drawer._flip();
                }
              }
            }
            this._drawDebugInfo(lastDrawn);
          },
          /**
           * @private
           * @inner
           * Draws special debug information for a TiledImage if in debug mode.
           * @param {OpenSeadragon.Tile[]} lastDrawn - An unordered list of Tiles drawn last frame.
           */
          _drawDebugInfo: function(lastDrawn) {
            if (this.debugMode) {
              for (var i = lastDrawn.length - 1; i >= 0; i--) {
                var tile = lastDrawn[i];
                try {
                  this._drawer.drawDebugInfo(tile, lastDrawn.length, i, this);
                } catch (e) {
                  $.console.error(e);
                }
              }
            }
          },
          /**
           * @private
           * @inner
           * Returns true if the given tile provides coverage to lower-level tiles of
           * lower resolution representing the same content. If neither x nor y is
           * given, returns true if the entire visible level provides coverage.
           *
           * Note that out-of-bounds tiles provide coverage in this sense, since
           * there's no content that they would need to cover. Tiles at non-existent
           * levels that are within the image bounds, however, do not.
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @returns {Boolean}
           */
          _providesCoverage: function(coverage, level, x, y) {
            var rows, cols, i, j;
            if (!coverage[level]) {
              return false;
            }
            if (x === void 0 || y === void 0) {
              rows = coverage[level];
              for (i in rows) {
                if (Object.prototype.hasOwnProperty.call(rows, i)) {
                  cols = rows[i];
                  for (j in cols) {
                    if (Object.prototype.hasOwnProperty.call(cols, j) && !cols[j]) {
                      return false;
                    }
                  }
                }
              }
              return true;
            }
            return coverage[level][x] === void 0 || coverage[level][x][y] === void 0 || coverage[level][x][y] === true;
          },
          /**
           * @private
           * @inner
           * Returns true if the given tile is completely covered by higher-level
           * tiles of higher resolution representing the same content. If neither x
           * nor y is given, returns true if the entire visible level is covered.
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @returns {Boolean}
           */
          _isCovered: function(coverage, level, x, y) {
            if (x === void 0 || y === void 0) {
              return this._providesCoverage(coverage, level + 1);
            } else {
              return this._providesCoverage(coverage, level + 1, 2 * x, 2 * y) && this._providesCoverage(coverage, level + 1, 2 * x, 2 * y + 1) && this._providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y) && this._providesCoverage(coverage, level + 1, 2 * x + 1, 2 * y + 1);
            }
          },
          /**
           * @private
           * @inner
           * Sets whether the given tile provides coverage or not.
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of the tile.
           * @param {Number} x - The X position of the tile.
           * @param {Number} y - The Y position of the tile.
           * @param {Boolean} covers - Whether the tile provides coverage.
           */
          _setCoverage: function(coverage, level, x, y, covers) {
            if (!coverage[level]) {
              $.console.warn(
                "Setting coverage for a tile before its level's coverage has been reset: %s",
                level
              );
              return;
            }
            if (!coverage[level][x]) {
              coverage[level][x] = {};
            }
            coverage[level][x][y] = covers;
          },
          /**
           * @private
           * @inner
           * Resets coverage information for the given level. This should be called
           * after every draw routine. Note that at the beginning of the next draw
           * routine, coverage for every visible tile should be explicitly set.
           *
           * @param {Object} coverage - A '3d' dictionary [level][x][y] --> Boolean.
           * @param {Number} level - The resolution level of tiles to completely reset.
           */
          _resetCoverage: function(coverage, level) {
            coverage[level] = {};
          }
        }
      );
      var DEFAULT_SUBPIXEL_ROUNDING_RULE = $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
      function isSubPixelRoundingRuleUnknown(value) {
        return value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ALWAYS && value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.ONLY_AT_REST && value !== $.SUBPIXEL_ROUNDING_OCCURRENCES.NEVER;
      }
      function normalizeSubPixelRoundingRule(value) {
        if (isSubPixelRoundingRuleUnknown(value)) {
          return DEFAULT_SUBPIXEL_ROUNDING_RULE;
        }
        return value;
      }
      function determineSubPixelRoundingRule(subPixelRoundingRules) {
        if (typeof subPixelRoundingRules === "number") {
          return normalizeSubPixelRoundingRule(subPixelRoundingRules);
        }
        if (!subPixelRoundingRules || !$.Browser) {
          return DEFAULT_SUBPIXEL_ROUNDING_RULE;
        }
        var subPixelRoundingRule = subPixelRoundingRules[$.Browser.vendor];
        if (isSubPixelRoundingRuleUnknown(subPixelRoundingRule)) {
          subPixelRoundingRule = subPixelRoundingRules["*"];
        }
        return normalizeSubPixelRoundingRule(subPixelRoundingRule);
      }
    })(OpenSeadragon);
    (function($) {
      var TileRecord = function(options) {
        $.console.assert(options, "[TileCache.cacheTile] options is required");
        $.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
        $.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
        this.tile = options.tile;
        this.tiledImage = options.tiledImage;
      };
      var ImageRecord = function(options) {
        $.console.assert(options, "[ImageRecord] options is required");
        $.console.assert(options.data, "[ImageRecord] options.data is required");
        this._tiles = [];
        options.create.apply(null, [this, options.data, options.ownerTile]);
        this._destroyImplementation = options.destroy.bind(null, this);
        this.getImage = options.getImage.bind(null, this);
        this.getData = options.getData.bind(null, this);
        this.getRenderedContext = options.getRenderedContext.bind(null, this);
      };
      ImageRecord.prototype = {
        destroy: function() {
          this._destroyImplementation();
          this._tiles = null;
        },
        addTile: function(tile) {
          $.console.assert(tile, "[ImageRecord.addTile] tile is required");
          this._tiles.push(tile);
        },
        removeTile: function(tile) {
          for (var i = 0; i < this._tiles.length; i++) {
            if (this._tiles[i] === tile) {
              this._tiles.splice(i, 1);
              return;
            }
          }
          $.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", tile);
        },
        getTileCount: function() {
          return this._tiles.length;
        }
      };
      $.TileCache = function(options) {
        options = options || {};
        this._maxImageCacheCount = options.maxImageCacheCount || $.DEFAULT_SETTINGS.maxImageCacheCount;
        this._tilesLoaded = [];
        this._imagesLoaded = [];
        this._imagesLoadedCount = 0;
      };
      $.TileCache.prototype = {
        /**
         * @returns {Number} The total number of tiles that have been loaded by
         * this TileCache.
         */
        numTilesLoaded: function() {
          return this._tilesLoaded.length;
        },
        /**
         * Caches the specified tile, removing an old tile if necessary to stay under the
         * maxImageCacheCount specified on construction. Note that if multiple tiles reference
         * the same image, there may be more tiles than maxImageCacheCount; the goal is to keep
         * the number of images below that number. Note, as well, that even the number of images
         * may temporarily surpass that number, but should eventually come back down to the max specified.
         * @param {Object} options - Tile info.
         * @param {OpenSeadragon.Tile} options.tile - The tile to cache.
         * @param {String} options.tile.cacheKey - The unique key used to identify this tile in the cache.
         * @param {Image} options.image - The image of the tile to cache.
         * @param {OpenSeadragon.TiledImage} options.tiledImage - The TiledImage that owns that tile.
         * @param {Number} [options.cutoff=0] - If adding this tile goes over the cache max count, this
         * function will release an old tile. The cutoff option specifies a tile level at or below which
         * tiles will not be released.
         */
        cacheTile: function(options) {
          $.console.assert(options, "[TileCache.cacheTile] options is required");
          $.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
          $.console.assert(options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required");
          $.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
          var cutoff = options.cutoff || 0;
          var insertionIndex = this._tilesLoaded.length;
          var imageRecord = this._imagesLoaded[options.tile.cacheKey];
          if (!imageRecord) {
            if (!options.data) {
              $.console.error("[TileCache.cacheTile] options.image was renamed to options.data. '.image' attribute has been deprecated and will be removed in the future.");
              options.data = options.image;
            }
            $.console.assert(options.data, "[TileCache.cacheTile] options.data is required to create an ImageRecord");
            imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
              data: options.data,
              ownerTile: options.tile,
              create: options.tiledImage.source.createTileCache,
              destroy: options.tiledImage.source.destroyTileCache,
              getImage: options.tiledImage.source.getTileCacheDataAsImage,
              getData: options.tiledImage.source.getTileCacheData,
              getRenderedContext: options.tiledImage.source.getTileCacheDataAsContext2D
            });
            this._imagesLoadedCount++;
          }
          imageRecord.addTile(options.tile);
          options.tile.cacheImageRecord = imageRecord;
          if (this._imagesLoadedCount > this._maxImageCacheCount) {
            var worstTile = null;
            var worstTileIndex = -1;
            var worstTileRecord = null;
            var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
            for (var i = this._tilesLoaded.length - 1; i >= 0; i--) {
              prevTileRecord = this._tilesLoaded[i];
              prevTile = prevTileRecord.tile;
              if (prevTile.level <= cutoff || prevTile.beingDrawn) {
                continue;
              } else if (!worstTile) {
                worstTile = prevTile;
                worstTileIndex = i;
                worstTileRecord = prevTileRecord;
                continue;
              }
              prevTime = prevTile.lastTouchTime;
              worstTime = worstTile.lastTouchTime;
              prevLevel = prevTile.level;
              worstLevel = worstTile.level;
              if (prevTime < worstTime || prevTime === worstTime && prevLevel > worstLevel) {
                worstTile = prevTile;
                worstTileIndex = i;
                worstTileRecord = prevTileRecord;
              }
            }
            if (worstTile && worstTileIndex >= 0) {
              this._unloadTile(worstTileRecord);
              insertionIndex = worstTileIndex;
            }
          }
          this._tilesLoaded[insertionIndex] = new TileRecord({
            tile: options.tile,
            tiledImage: options.tiledImage
          });
        },
        /**
         * Clears all tiles associated with the specified tiledImage.
         * @param {OpenSeadragon.TiledImage} tiledImage
         */
        clearTilesFor: function(tiledImage) {
          $.console.assert(tiledImage, "[TileCache.clearTilesFor] tiledImage is required");
          var tileRecord;
          for (var i = 0; i < this._tilesLoaded.length; ++i) {
            tileRecord = this._tilesLoaded[i];
            if (tileRecord.tiledImage === tiledImage) {
              this._unloadTile(tileRecord);
              this._tilesLoaded.splice(i, 1);
              i--;
            }
          }
        },
        // private
        getImageRecord: function(cacheKey) {
          $.console.assert(cacheKey, "[TileCache.getImageRecord] cacheKey is required");
          return this._imagesLoaded[cacheKey];
        },
        // private
        _unloadTile: function(tileRecord) {
          $.console.assert(tileRecord, "[TileCache._unloadTile] tileRecord is required");
          var tile = tileRecord.tile;
          var tiledImage = tileRecord.tiledImage;
          tile.unload();
          tile.cacheImageRecord = null;
          var imageRecord = this._imagesLoaded[tile.cacheKey];
          imageRecord.removeTile(tile);
          if (!imageRecord.getTileCount()) {
            imageRecord.destroy();
            delete this._imagesLoaded[tile.cacheKey];
            this._imagesLoadedCount--;
          }
          tiledImage.viewer.raiseEvent("tile-unloaded", {
            tile,
            tiledImage
          });
        }
      };
    })(OpenSeadragon);
    (function($) {
      $.World = function(options) {
        var _this = this;
        $.console.assert(options.viewer, "[World] options.viewer is required");
        $.EventSource.call(this);
        this.viewer = options.viewer;
        this._items = [];
        this._needsDraw = false;
        this._autoRefigureSizes = true;
        this._needsSizesFigured = false;
        this._delegatedFigureSizes = function(event) {
          if (_this._autoRefigureSizes) {
            _this._figureSizes();
          } else {
            _this._needsSizesFigured = true;
          }
        };
        this._figureSizes();
      };
      $.extend(
        $.World.prototype,
        $.EventSource.prototype,
        /** @lends OpenSeadragon.World.prototype */
        {
          /**
           * Add the specified item.
           * @param {OpenSeadragon.TiledImage} item - The item to add.
           * @param {Number} [options.index] - Index for the item. If not specified, goes at the top.
           * @fires OpenSeadragon.World.event:add-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          addItem: function(item, options) {
            $.console.assert(item, "[World.addItem] item is required");
            $.console.assert(item instanceof $.TiledImage, "[World.addItem] only TiledImages supported at this time");
            options = options || {};
            if (options.index !== void 0) {
              var index = Math.max(0, Math.min(this._items.length, options.index));
              this._items.splice(index, 0, item);
            } else {
              this._items.push(item);
            }
            if (this._autoRefigureSizes) {
              this._figureSizes();
            } else {
              this._needsSizesFigured = true;
            }
            this._needsDraw = true;
            item.addHandler("bounds-change", this._delegatedFigureSizes);
            item.addHandler("clip-change", this._delegatedFigureSizes);
            this.raiseEvent("add-item", {
              item
            });
          },
          /**
           * Get the item at the specified index.
           * @param {Number} index - The item's index.
           * @returns {OpenSeadragon.TiledImage} The item at the specified index.
           */
          getItemAt: function(index) {
            $.console.assert(index !== void 0, "[World.getItemAt] index is required");
            return this._items[index];
          },
          /**
           * Get the index of the given item or -1 if not present.
           * @param {OpenSeadragon.TiledImage} item - The item.
           * @returns {Number} The index of the item or -1 if not present.
           */
          getIndexOfItem: function(item) {
            $.console.assert(item, "[World.getIndexOfItem] item is required");
            return $.indexOf(this._items, item);
          },
          /**
           * @returns {Number} The number of items used.
           */
          getItemCount: function() {
            return this._items.length;
          },
          /**
           * Change the index of a item so that it appears over or under others.
           * @param {OpenSeadragon.TiledImage} item - The item to move.
           * @param {Number} index - The new index.
           * @fires OpenSeadragon.World.event:item-index-change
           */
          setItemIndex: function(item, index) {
            $.console.assert(item, "[World.setItemIndex] item is required");
            $.console.assert(index !== void 0, "[World.setItemIndex] index is required");
            var oldIndex = this.getIndexOfItem(item);
            if (index >= this._items.length) {
              throw new Error("Index bigger than number of layers.");
            }
            if (index === oldIndex || oldIndex === -1) {
              return;
            }
            this._items.splice(oldIndex, 1);
            this._items.splice(index, 0, item);
            this._needsDraw = true;
            this.raiseEvent("item-index-change", {
              item,
              previousIndex: oldIndex,
              newIndex: index
            });
          },
          /**
           * Remove an item.
           * @param {OpenSeadragon.TiledImage} item - The item to remove.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeItem: function(item) {
            $.console.assert(item, "[World.removeItem] item is required");
            var index = $.indexOf(this._items, item);
            if (index === -1) {
              return;
            }
            item.removeHandler("bounds-change", this._delegatedFigureSizes);
            item.removeHandler("clip-change", this._delegatedFigureSizes);
            item.destroy();
            this._items.splice(index, 1);
            this._figureSizes();
            this._needsDraw = true;
            this._raiseRemoveItem(item);
          },
          /**
           * Remove all items.
           * @fires OpenSeadragon.World.event:remove-item
           * @fires OpenSeadragon.World.event:metrics-change
           */
          removeAll: function() {
            this.viewer._cancelPendingImages();
            var item;
            var i;
            for (i = 0; i < this._items.length; i++) {
              item = this._items[i];
              item.removeHandler("bounds-change", this._delegatedFigureSizes);
              item.removeHandler("clip-change", this._delegatedFigureSizes);
              item.destroy();
            }
            var removedItems = this._items;
            this._items = [];
            this._figureSizes();
            this._needsDraw = true;
            for (i = 0; i < removedItems.length; i++) {
              item = removedItems[i];
              this._raiseRemoveItem(item);
            }
          },
          /**
           * Clears all tiles and triggers updates for all items.
           */
          resetItems: function() {
            for (var i = 0; i < this._items.length; i++) {
              this._items[i].reset();
            }
          },
          /**
           * Updates (i.e. animates bounds of) all items.
           */
          update: function() {
            var animated = false;
            for (var i = 0; i < this._items.length; i++) {
              animated = this._items[i].update() || animated;
            }
            return animated;
          },
          /**
           * Draws all items.
           */
          draw: function() {
            for (var i = 0; i < this._items.length; i++) {
              this._items[i].draw();
            }
            this._needsDraw = false;
          },
          /**
           * @returns {Boolean} true if any items need updating.
           */
          needsDraw: function() {
            for (var i = 0; i < this._items.length; i++) {
              if (this._items[i].needsDraw()) {
                return true;
              }
            }
            return this._needsDraw;
          },
          /**
           * @returns {OpenSeadragon.Rect} The smallest rectangle that encloses all items, in viewport coordinates.
           */
          getHomeBounds: function() {
            return this._homeBounds.clone();
          },
          /**
           * To facilitate zoom constraints, we keep track of the pixel density of the
           * densest item in the World (i.e. the item whose content size to viewport size
           * ratio is the highest) and save it as this "content factor".
           * @returns {Number} the number of content units per viewport unit.
           */
          getContentFactor: function() {
            return this._contentFactor;
          },
          /**
           * As a performance optimization, setting this flag to false allows the bounds-change event handler
           * on tiledImages to skip calculations on the world bounds. If a lot of images are going to be positioned in
           * rapid succession, this is a good idea. When finished, setAutoRefigureSizes should be called with true
           * or the system may behave oddly.
           * @param {Boolean} [value] The value to which to set the flag.
           */
          setAutoRefigureSizes: function(value) {
            this._autoRefigureSizes = value;
            if (value & this._needsSizesFigured) {
              this._figureSizes();
              this._needsSizesFigured = false;
            }
          },
          /**
           * Arranges all of the TiledImages with the specified settings.
           * @param {Object} options - Specifies how to arrange.
           * @param {Boolean} [options.immediately=false] - Whether to animate to the new arrangement.
           * @param {String} [options.layout] - See collectionLayout in {@link OpenSeadragon.Options}.
           * @param {Number} [options.rows] - See collectionRows in {@link OpenSeadragon.Options}.
           * @param {Number} [options.columns] - See collectionColumns in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileSize] - See collectionTileSize in {@link OpenSeadragon.Options}.
           * @param {Number} [options.tileMargin] - See collectionTileMargin in {@link OpenSeadragon.Options}.
           * @fires OpenSeadragon.World.event:metrics-change
           */
          arrange: function(options) {
            options = options || {};
            var immediately = options.immediately || false;
            var layout = options.layout || $.DEFAULT_SETTINGS.collectionLayout;
            var rows = options.rows || $.DEFAULT_SETTINGS.collectionRows;
            var columns = options.columns || $.DEFAULT_SETTINGS.collectionColumns;
            var tileSize = options.tileSize || $.DEFAULT_SETTINGS.collectionTileSize;
            var tileMargin = options.tileMargin || $.DEFAULT_SETTINGS.collectionTileMargin;
            var increment = tileSize + tileMargin;
            var wrap;
            if (!options.rows && columns) {
              wrap = columns;
            } else {
              wrap = Math.ceil(this._items.length / rows);
            }
            var x = 0;
            var y = 0;
            var item, box, width, height, position;
            this.setAutoRefigureSizes(false);
            for (var i = 0; i < this._items.length; i++) {
              if (i && i % wrap === 0) {
                if (layout === "horizontal") {
                  y += increment;
                  x = 0;
                } else {
                  x += increment;
                  y = 0;
                }
              }
              item = this._items[i];
              box = item.getBounds();
              if (box.width > box.height) {
                width = tileSize;
              } else {
                width = tileSize * (box.width / box.height);
              }
              height = width * (box.height / box.width);
              position = new $.Point(
                x + (tileSize - width) / 2,
                y + (tileSize - height) / 2
              );
              item.setPosition(position, immediately);
              item.setWidth(width, immediately);
              if (layout === "horizontal") {
                x += increment;
              } else {
                y += increment;
              }
            }
            this.setAutoRefigureSizes(true);
          },
          // private
          _figureSizes: function() {
            var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
            var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
            var oldContentFactor = this._contentFactor || 0;
            if (!this._items.length) {
              this._homeBounds = new $.Rect(0, 0, 1, 1);
              this._contentSize = new $.Point(1, 1);
              this._contentFactor = 1;
            } else {
              var item = this._items[0];
              var bounds = item.getBounds();
              this._contentFactor = item.getContentSize().x / bounds.width;
              var clippedBounds = item.getClippedBounds().getBoundingBox();
              var left = clippedBounds.x;
              var top = clippedBounds.y;
              var right = clippedBounds.x + clippedBounds.width;
              var bottom = clippedBounds.y + clippedBounds.height;
              for (var i = 1; i < this._items.length; i++) {
                item = this._items[i];
                bounds = item.getBounds();
                this._contentFactor = Math.max(
                  this._contentFactor,
                  item.getContentSize().x / bounds.width
                );
                clippedBounds = item.getClippedBounds().getBoundingBox();
                left = Math.min(left, clippedBounds.x);
                top = Math.min(top, clippedBounds.y);
                right = Math.max(right, clippedBounds.x + clippedBounds.width);
                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
              }
              this._homeBounds = new $.Rect(left, top, right - left, bottom - top);
              this._contentSize = new $.Point(
                this._homeBounds.width * this._contentFactor,
                this._homeBounds.height * this._contentFactor
              );
            }
            if (this._contentFactor !== oldContentFactor || !this._homeBounds.equals(oldHomeBounds) || !this._contentSize.equals(oldContentSize)) {
              this.raiseEvent("metrics-change", {});
            }
          },
          // private
          _raiseRemoveItem: function(item) {
            this.raiseEvent("remove-item", { item });
          }
        }
      );
    })(OpenSeadragon);
  }
});
export default require_openseadragon();
/*! Bundled license information:

openseadragon/build/openseadragon/openseadragon.js:
  (*! openseadragon 4.1.0 *)
  (*! Built on 2023-05-25 *)
  (*! Git commit: v4.1.0-0-8849681 *)
  (*! http://openseadragon.github.io *)
  (*! License: http://openseadragon.github.io/license/ *)
*/
//# sourceMappingURL=openseadragon.js.map
