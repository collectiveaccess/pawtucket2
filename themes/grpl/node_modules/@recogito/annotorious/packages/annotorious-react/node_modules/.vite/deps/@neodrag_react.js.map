{
  "version": 3,
  "sources": ["../../../../../node_modules/@neodrag/react/dist/index.js"],
  "sourcesContent": ["import { useRef, useState, useEffect } from 'react';\n\n// ../core/dist/index.js\nvar DEFAULT_RECOMPUTE_BOUNDS = {\n  dragStart: true\n};\nvar draggable = (node, options = {}) => {\n  let {\n    bounds,\n    axis = \"both\",\n    gpuAcceleration = true,\n    legacyTranslate = true,\n    transform,\n    applyUserSelectHack = true,\n    disabled = false,\n    ignoreMultitouch = false,\n    recomputeBounds = DEFAULT_RECOMPUTE_BOUNDS,\n    grid,\n    position,\n    cancel,\n    handle,\n    defaultClass = \"neodrag\",\n    defaultClassDragging = \"neodrag-dragging\",\n    defaultClassDragged = \"neodrag-dragged\",\n    defaultPosition = { x: 0, y: 0 },\n    onDragStart,\n    onDrag,\n    onDragEnd\n  } = options;\n  let active = false;\n  let translateX = 0, translateY = 0;\n  let initialX = 0, initialY = 0;\n  let clientToNodeOffsetX = 0, clientToNodeOffsetY = 0;\n  let { x: xOffset, y: yOffset } = position ? { x: position?.x ?? 0, y: position?.y ?? 0 } : defaultPosition;\n  setTranslate(xOffset, yOffset);\n  let canMoveInX;\n  let canMoveInY;\n  let bodyOriginalUserSelectVal = \"\";\n  let computedBounds;\n  let nodeRect;\n  let dragEls;\n  let cancelEls;\n  let currentlyDraggedEl;\n  let isControlled = !!position;\n  recomputeBounds = { ...DEFAULT_RECOMPUTE_BOUNDS, ...recomputeBounds };\n  const bodyStyle = document.body.style;\n  const nodeClassList = node.classList;\n  function setTranslate(xPos = translateX, yPos = translateY) {\n    if (!transform) {\n      if (legacyTranslate) {\n        let common = `${+xPos}px, ${+yPos}px`;\n        return setStyle(\n          node,\n          \"transform\",\n          gpuAcceleration ? `translate3d(${common}, 0)` : `translate(${common})`\n        );\n      }\n      return setStyle(node, \"translate\", `${+xPos}px ${+yPos}px ${gpuAcceleration ? \"1px\" : \"\"}`);\n    }\n    const transformCalled = transform({ offsetX: xPos, offsetY: yPos, rootNode: node });\n    if (isString(transformCalled)) {\n      setStyle(node, \"transform\", transformCalled);\n    }\n  }\n  const getEventData = () => ({\n    offsetX: translateX,\n    offsetY: translateY,\n    rootNode: node,\n    currentNode: currentlyDraggedEl\n  });\n  const callEvent = (eventName, fn) => {\n    const data = getEventData();\n    node.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    fn?.(data);\n  };\n  function fireSvelteDragStartEvent() {\n    callEvent(\"neodrag:start\", onDragStart);\n  }\n  function fireSvelteDragEndEvent() {\n    callEvent(\"neodrag:end\", onDragEnd);\n  }\n  function fireSvelteDragEvent() {\n    callEvent(\"neodrag\", onDrag);\n  }\n  const listen = addEventListener;\n  listen(\"pointerdown\", dragStart, false);\n  listen(\"pointerup\", dragEnd, false);\n  listen(\"pointermove\", drag, false);\n  setStyle(node, \"touch-action\", \"none\");\n  const calculateInverseScale = () => {\n    let inverseScale = node.offsetWidth / nodeRect.width;\n    if (isNaN(inverseScale))\n      inverseScale = 1;\n    return inverseScale;\n  };\n  function dragStart(e) {\n    if (disabled)\n      return;\n    if (e.button === 2)\n      return;\n    if (ignoreMultitouch && !e.isPrimary)\n      return;\n    if (recomputeBounds.dragStart)\n      computedBounds = computeBoundRect(bounds, node);\n    if (isString(handle) && isString(cancel) && handle === cancel)\n      throw new Error(\"`handle` selector can't be same as `cancel` selector\");\n    nodeClassList.add(defaultClass);\n    dragEls = getHandleEls(handle, node);\n    cancelEls = getCancelElements(cancel, node);\n    canMoveInX = /(both|x)/.test(axis);\n    canMoveInY = /(both|y)/.test(axis);\n    if (cancelElementContains(cancelEls, dragEls))\n      throw new Error(\n        \"Element being dragged can't be a child of the element on which `cancel` is applied\"\n      );\n    const eventTarget = e.composedPath()[0];\n    if (dragEls.some((el) => el.contains(eventTarget) || el.shadowRoot?.contains(eventTarget)) && !cancelElementContains(cancelEls, [eventTarget])) {\n      currentlyDraggedEl = dragEls.length === 1 ? node : dragEls.find((el) => el.contains(eventTarget));\n      active = true;\n    } else\n      return;\n    nodeRect = node.getBoundingClientRect();\n    if (applyUserSelectHack) {\n      bodyOriginalUserSelectVal = bodyStyle.userSelect;\n      bodyStyle.userSelect = \"none\";\n    }\n    fireSvelteDragStartEvent();\n    const { clientX, clientY } = e;\n    const inverseScale = calculateInverseScale();\n    if (canMoveInX)\n      initialX = clientX - xOffset / inverseScale;\n    if (canMoveInY)\n      initialY = clientY - yOffset / inverseScale;\n    if (computedBounds) {\n      clientToNodeOffsetX = clientX - nodeRect.left;\n      clientToNodeOffsetY = clientY - nodeRect.top;\n    }\n  }\n  function dragEnd() {\n    if (!active)\n      return;\n    if (recomputeBounds.dragEnd)\n      computedBounds = computeBoundRect(bounds, node);\n    nodeClassList.remove(defaultClassDragging);\n    nodeClassList.add(defaultClassDragged);\n    if (applyUserSelectHack)\n      bodyStyle.userSelect = bodyOriginalUserSelectVal;\n    fireSvelteDragEndEvent();\n    if (canMoveInX)\n      initialX = translateX;\n    if (canMoveInY)\n      initialY = translateY;\n    active = false;\n  }\n  function drag(e) {\n    if (!active)\n      return;\n    if (recomputeBounds.drag)\n      computedBounds = computeBoundRect(bounds, node);\n    nodeClassList.add(defaultClassDragging);\n    e.preventDefault();\n    nodeRect = node.getBoundingClientRect();\n    let finalX = e.clientX, finalY = e.clientY;\n    const inverseScale = calculateInverseScale();\n    if (computedBounds) {\n      const virtualClientBounds = {\n        left: computedBounds.left + clientToNodeOffsetX,\n        top: computedBounds.top + clientToNodeOffsetY,\n        right: computedBounds.right + clientToNodeOffsetX - nodeRect.width,\n        bottom: computedBounds.bottom + clientToNodeOffsetY - nodeRect.height\n      };\n      finalX = clamp(finalX, virtualClientBounds.left, virtualClientBounds.right);\n      finalY = clamp(finalY, virtualClientBounds.top, virtualClientBounds.bottom);\n    }\n    if (Array.isArray(grid)) {\n      let [xSnap, ySnap] = grid;\n      if (isNaN(+xSnap) || xSnap < 0)\n        throw new Error(\"1st argument of `grid` must be a valid positive number\");\n      if (isNaN(+ySnap) || ySnap < 0)\n        throw new Error(\"2nd argument of `grid` must be a valid positive number\");\n      let deltaX = finalX - initialX, deltaY = finalY - initialY;\n      [deltaX, deltaY] = snapToGrid([xSnap / inverseScale, ySnap / inverseScale], deltaX, deltaY);\n      finalX = initialX + deltaX;\n      finalY = initialY + deltaY;\n    }\n    if (canMoveInX)\n      translateX = Math.round((finalX - initialX) * inverseScale);\n    if (canMoveInY)\n      translateY = Math.round((finalY - initialY) * inverseScale);\n    xOffset = translateX;\n    yOffset = translateY;\n    fireSvelteDragEvent();\n    setTranslate();\n  }\n  return {\n    destroy: () => {\n      const unlisten = removeEventListener;\n      unlisten(\"pointerdown\", dragStart, false);\n      unlisten(\"pointerup\", dragEnd, false);\n      unlisten(\"pointermove\", drag, false);\n    },\n    update: (options2) => {\n      axis = options2.axis || \"both\";\n      disabled = options2.disabled ?? false;\n      ignoreMultitouch = options2.ignoreMultitouch ?? false;\n      handle = options2.handle;\n      bounds = options2.bounds;\n      recomputeBounds = options2.recomputeBounds ?? DEFAULT_RECOMPUTE_BOUNDS;\n      cancel = options2.cancel;\n      applyUserSelectHack = options2.applyUserSelectHack ?? true;\n      grid = options2.grid;\n      gpuAcceleration = options2.gpuAcceleration ?? true;\n      legacyTranslate = options2.legacyTranslate ?? true;\n      transform = options2.transform;\n      const dragged = nodeClassList.contains(defaultClassDragged);\n      nodeClassList.remove(defaultClass, defaultClassDragged);\n      defaultClass = options2.defaultClass ?? \"neodrag\";\n      defaultClassDragging = options2.defaultClassDragging ?? \"neodrag-dragging\";\n      defaultClassDragged = options2.defaultClassDragged ?? \"neodrag-dragged\";\n      nodeClassList.add(defaultClass);\n      if (dragged)\n        nodeClassList.add(defaultClassDragged);\n      if (isControlled) {\n        xOffset = translateX = options2.position?.x ?? translateX;\n        yOffset = translateY = options2.position?.y ?? translateY;\n        setTranslate();\n      }\n    }\n  };\n};\nvar clamp = (val, min, max) => Math.min(Math.max(val, min), max);\nvar isString = (val) => typeof val === \"string\";\nvar snapToGrid = ([xSnap, ySnap], pendingX, pendingY) => {\n  const calc = (val, snap) => snap === 0 ? 0 : Math.ceil(val / snap) * snap;\n  const x = calc(pendingX, xSnap);\n  const y = calc(pendingY, ySnap);\n  return [x, y];\n};\nfunction getHandleEls(handle, node) {\n  if (!handle)\n    return [node];\n  if (isHTMLElement(handle))\n    return [handle];\n  if (Array.isArray(handle))\n    return handle;\n  const handleEls = node.querySelectorAll(handle);\n  if (handleEls === null)\n    throw new Error(\n      \"Selector passed for `handle` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(handleEls.values());\n}\nfunction getCancelElements(cancel, node) {\n  if (!cancel)\n    return [];\n  if (isHTMLElement(cancel))\n    return [cancel];\n  if (Array.isArray(cancel))\n    return cancel;\n  const cancelEls = node.querySelectorAll(cancel);\n  if (cancelEls === null)\n    throw new Error(\n      \"Selector passed for `cancel` option should be child of the element on which the action is applied\"\n    );\n  return Array.from(cancelEls.values());\n}\nvar cancelElementContains = (cancelElements, dragElements) => cancelElements.some((cancelEl) => dragElements.some((el) => cancelEl.contains(el)));\nfunction computeBoundRect(bounds, rootNode) {\n  if (bounds === void 0)\n    return;\n  if (isHTMLElement(bounds))\n    return bounds.getBoundingClientRect();\n  if (typeof bounds === \"object\") {\n    const { top = 0, left = 0, right = 0, bottom = 0 } = bounds;\n    const computedRight = window.innerWidth - right;\n    const computedBottom = window.innerHeight - bottom;\n    return { top, right: computedRight, bottom: computedBottom, left };\n  }\n  if (bounds === \"parent\")\n    return rootNode.parentNode.getBoundingClientRect();\n  const node = document.querySelector(bounds);\n  if (node === null)\n    throw new Error(\"The selector provided for bound doesn't exists in the document.\");\n  return node.getBoundingClientRect();\n}\nvar setStyle = (el, style, value) => el.style.setProperty(style, value);\nvar isHTMLElement = (obj) => obj instanceof HTMLElement;\nfunction unwrapHandleCancel(val) {\n  if (val == void 0 || typeof val === \"string\" || val instanceof HTMLElement)\n    return val;\n  if (\"current\" in val)\n    return val.current;\n  if (Array.isArray(val)) {\n    return val.map((v) => v instanceof HTMLElement ? v : v.current);\n  }\n}\nfunction useDraggable(nodeRef, options = {}) {\n  const updateRef = useRef();\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragState, setDragState] = useState();\n  let { onDragStart, onDrag, onDragEnd, handle, cancel } = options;\n  let newHandle = unwrapHandleCancel(handle);\n  let newCancel = unwrapHandleCancel(cancel);\n  function callEvent(arg, cb) {\n    setDragState(arg);\n    cb?.(arg);\n  }\n  function customOnDragStart(arg) {\n    setIsDragging(true);\n    callEvent(arg, onDragStart);\n  }\n  function customOnDrag(arg) {\n    callEvent(arg, onDrag);\n  }\n  function customOnDragEnd(arg) {\n    setIsDragging(false);\n    callEvent(arg, onDragEnd);\n  }\n  useEffect(() => {\n    if (typeof window === \"undefined\")\n      return;\n    const node = nodeRef.current;\n    if (!node)\n      return;\n    ({ onDragStart, onDrag, onDragEnd } = options);\n    const { update, destroy } = draggable(node, {\n      ...options,\n      handle: newHandle,\n      cancel: newCancel,\n      onDragStart: customOnDragStart,\n      onDrag: customOnDrag,\n      onDragEnd: customOnDragEnd\n    });\n    updateRef.current = update;\n    return destroy;\n  }, []);\n  useEffect(() => {\n    updateRef.current?.({\n      ...options,\n      handle: unwrapHandleCancel(handle),\n      cancel: unwrapHandleCancel(cancel),\n      onDragStart: customOnDragStart,\n      onDrag: customOnDrag,\n      onDragEnd: customOnDragEnd\n    });\n  }, [options]);\n  return { isDragging, dragState };\n}\n\nexport { useDraggable };\n"],
  "mappings": "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",
  "names": []
}
