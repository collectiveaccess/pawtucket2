function g() {
}
function B(t, n) {
  for (const e in n)
    t[e] = n[e];
  return t;
}
function S(t) {
  return t();
}
function N() {
  return /* @__PURE__ */ Object.create(null);
}
function p(t) {
  t.forEach(S);
}
function E(t) {
  return typeof t == "function";
}
function V(t, n) {
  return t != t ? n == n : t !== n || t && typeof t == "object" || typeof t == "function";
}
function F(t) {
  return Object.keys(t).length === 0;
}
function P(t, ...n) {
  if (t == null)
    return g;
  const e = t.subscribe(...n);
  return e.unsubscribe ? () => e.unsubscribe() : e;
}
function W(t, n, e) {
  t.$$.on_destroy.push(P(n, e));
}
function X(t, n, e, r) {
  if (t) {
    const o = L(t, n, e, r);
    return t[0](o);
  }
}
function L(t, n, e, r) {
  return t[1] && r ? B(e.ctx.slice(), t[1](r(n))) : e.ctx;
}
function Y(t, n, e, r) {
  if (t[2] && r) {
    const o = t[2](r(e));
    if (n.dirty === void 0)
      return o;
    if (typeof o == "object") {
      const c = [], i = Math.max(n.dirty.length, o.length);
      for (let s = 0; s < i; s += 1)
        c[s] = n.dirty[s] | o[s];
      return c;
    }
    return n.dirty | o;
  }
  return n.dirty;
}
function Z(t, n, e, r, o, c) {
  if (o) {
    const i = L(n, e, r, c);
    t.p(i, o);
  }
}
function tt(t) {
  if (t.ctx.length > 32) {
    const n = [], e = t.ctx.length / 32;
    for (let r = 0; r < e; r++)
      n[r] = -1;
    return n;
  }
  return -1;
}
function nt(t) {
  return t && E(t.destroy) ? t.destroy : g;
}
function et(t, n) {
  t.appendChild(n);
}
function rt(t, n, e) {
  t.insertBefore(n, e || null);
}
function T(t) {
  t.parentNode && t.parentNode.removeChild(t);
}
function ot(t) {
  return document.createElement(t);
}
function q(t) {
  return document.createTextNode(t);
}
function ut() {
  return q("");
}
function it(t, n, e, r) {
  return t.addEventListener(n, e, r), () => t.removeEventListener(n, e, r);
}
function ct(t, n, e) {
  e == null ? t.removeAttribute(n) : t.getAttribute(n) !== e && t.setAttribute(n, e);
}
function D(t) {
  return Array.from(t.childNodes);
}
function ft(t, n) {
  n = "" + n, t.data !== n && (t.data = n);
}
let m;
function h(t) {
  m = t;
}
function v() {
  if (!m)
    throw new Error("Function called outside component initialization");
  return m;
}
function st(t) {
  v().$$.on_mount.push(t);
}
function lt(t, n) {
  return v().$$.context.set(t, n), n;
}
function at(t) {
  return v().$$.context.get(t);
}
const d = [], O = [];
let _ = [];
const M = [], G = /* @__PURE__ */ Promise.resolve();
let b = !1;
function H() {
  b || (b = !0, G.then(z));
}
function w(t) {
  _.push(t);
}
const $ = /* @__PURE__ */ new Set();
let a = 0;
function z() {
  if (a !== 0)
    return;
  const t = m;
  do {
    try {
      for (; a < d.length; ) {
        const n = d[a];
        a++, h(n), I(n.$$);
      }
    } catch (n) {
      throw d.length = 0, a = 0, n;
    }
    for (h(null), d.length = 0, a = 0; O.length; )
      O.pop()();
    for (let n = 0; n < _.length; n += 1) {
      const e = _[n];
      $.has(e) || ($.add(e), e());
    }
    _.length = 0;
  } while (d.length);
  for (; M.length; )
    M.pop()();
  b = !1, $.clear(), h(t);
}
function I(t) {
  if (t.fragment !== null) {
    t.update(), p(t.before_update);
    const n = t.dirty;
    t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, n), t.after_update.forEach(w);
  }
}
function J(t) {
  const n = [], e = [];
  _.forEach((r) => t.indexOf(r) === -1 ? n.push(r) : e.push(r)), e.forEach((r) => r()), _ = n;
}
const x = /* @__PURE__ */ new Set();
let l;
function dt() {
  l = {
    r: 0,
    c: [],
    p: l
    // parent group
  };
}
function _t() {
  l.r || p(l.c), l = l.p;
}
function K(t, n) {
  t && t.i && (x.delete(t), t.i(n));
}
function ht(t, n, e, r) {
  if (t && t.o) {
    if (x.has(t))
      return;
    x.add(t), l.c.push(() => {
      x.delete(t), r && (e && t.d(1), r());
    }), t.o(n);
  } else
    r && r();
}
function Q(t, n, e, r) {
  const { fragment: o, after_update: c } = t.$$;
  o && o.m(n, e), r || w(() => {
    const i = t.$$.on_mount.map(S).filter(E);
    t.$$.on_destroy ? t.$$.on_destroy.push(...i) : p(i), t.$$.on_mount = [];
  }), c.forEach(w);
}
function R(t, n) {
  const e = t.$$;
  e.fragment !== null && (J(e.after_update), p(e.on_destroy), e.fragment && e.fragment.d(n), e.on_destroy = e.fragment = null, e.ctx = []);
}
function U(t, n) {
  t.$$.dirty[0] === -1 && (d.push(t), H(), t.$$.dirty.fill(0)), t.$$.dirty[n / 31 | 0] |= 1 << n % 31;
}
function gt(t, n, e, r, o, c, i, s = [-1]) {
  const y = m;
  h(t);
  const u = t.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: c,
    update: g,
    not_equal: o,
    bound: N(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(n.context || (y ? y.$$.context : [])),
    // everything else
    callbacks: N(),
    dirty: s,
    skip_bound: !1,
    root: n.target || y.$$.root
  };
  i && i(u.root);
  let k = !1;
  if (u.ctx = e ? e(t, n.props || {}, (f, j, ...C) => {
    const A = C.length ? C[0] : j;
    return u.ctx && o(u.ctx[f], u.ctx[f] = A) && (!u.skip_bound && u.bound[f] && u.bound[f](A), k && U(t, f)), j;
  }) : [], u.update(), k = !0, p(u.before_update), u.fragment = r ? r(u.ctx) : !1, n.target) {
    if (n.hydrate) {
      const f = D(n.target);
      u.fragment && u.fragment.l(f), f.forEach(T);
    } else
      u.fragment && u.fragment.c();
    n.intro && K(t.$$.fragment), Q(t, n.target, n.anchor, n.customElement), z();
  }
  h(y);
}
class mt {
  $destroy() {
    R(this, 1), this.$destroy = g;
  }
  $on(n, e) {
    if (!E(e))
      return g;
    const r = this.$$.callbacks[n] || (this.$$.callbacks[n] = []);
    return r.push(e), () => {
      const o = r.indexOf(e);
      o !== -1 && r.splice(o, 1);
    };
  }
  $set(n) {
    this.$$set && !F(n) && (this.$$.skip_bound = !0, this.$$set(n), this.$$.skip_bound = !1);
  }
}
export {
  mt as SvelteComponent,
  nt as action_destroyer,
  w as add_render_callback,
  et as append,
  B as assign,
  ct as attr,
  O as binding_callbacks,
  N as blank_object,
  _t as check_outros,
  D as children,
  W as component_subscribe,
  X as create_slot,
  m as current_component,
  R as destroy_component,
  T as detach,
  d as dirty_components,
  ot as element,
  ut as empty,
  z as flush,
  J as flush_render_callbacks,
  at as getContext,
  tt as get_all_dirty_from_scope,
  v as get_current_component,
  Y as get_slot_changes,
  dt as group_outros,
  gt as init,
  rt as insert,
  F as is_empty,
  E as is_function,
  it as listen,
  Q as mount_component,
  g as noop,
  st as onMount,
  S as run,
  p as run_all,
  V as safe_not_equal,
  H as schedule_update,
  lt as setContext,
  h as set_current_component,
  ft as set_data,
  P as subscribe,
  q as text,
  K as transition_in,
  ht as transition_out,
  Z as update_slot_base
};
//# sourceMappingURL=annotorious-svelte.es5.js.map
