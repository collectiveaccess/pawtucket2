var F = { dragStart: !0 }, rt = (e, s, i) => Math.min(Math.max(e, s), i), G = (e) => typeof e == "string", dt = ([e, s], i, d) => {
  const u = (y, f) => f === 0 ? 0 : Math.ceil(y / f) * f;
  return [u(i, e), u(d, s)];
}, ot = (e, s) => e.some((i) => s.some((d) => i.contains(d)));
function I(e, s) {
  if (e === void 0)
    return;
  if (J(e))
    return e.getBoundingClientRect();
  if (typeof e == "object") {
    const { top: d = 0, left: u = 0, right: y = 0, bottom: f = 0 } = e;
    return { top: d, right: window.innerWidth - y, bottom: window.innerHeight - f, left: u };
  }
  if (e === "parent")
    return s.parentNode.getBoundingClientRect();
  const i = document.querySelector(e);
  if (i === null)
    throw new Error("The selector provided for bound doesn't exists in the document.");
  return i.getBoundingClientRect();
}
var H = (e, s, i) => e.style.setProperty(s, i), J = (e) => e instanceof HTMLElement, ut = (e, s = {}) => {
  let i, d, { bounds: u, axis: y = "both", gpuAcceleration: f = !0, legacyTranslate: K = !0, transform: L, applyUserSelectHack: P = !0, disabled: O = !1, ignoreMultitouch: Q = !1, recomputeBounds: x = F, grid: T, position: p, cancel: N, handle: D, defaultClass: M = "neodrag", defaultClassDragging: X = "neodrag-dragging", defaultClassDragged: S = "neodrag-dragged", defaultPosition: it = { x: 0, y: 0 }, onDragStart: at, onDrag: st, onDragEnd: lt } = s, B = !1, b = 0, w = 0, A = 0, C = 0, Y = 0, q = 0, { x: $, y: R } = p ? { x: (p == null ? void 0 : p.x) ?? 0, y: (p == null ? void 0 : p.y) ?? 0 } : it;
  W($, R);
  let g, v, E, k, V, Z = "", ct = !!p;
  x = { ...F, ...x };
  const U = document.body.style, m = e.classList;
  function W(t = b, r = w) {
    if (!L) {
      if (K) {
        let a = `${+t}px, ${+r}px`;
        return H(e, "transform", f ? `translate3d(${a}, 0)` : `translate(${a})`);
      }
      return H(e, "translate", `${+t}px ${+r}px ${f ? "1px" : ""}`);
    }
    const o = L({ offsetX: t, offsetY: r, rootNode: e });
    G(o) && H(e, "transform", o);
  }
  const j = (t, r) => {
    const o = { offsetX: b, offsetY: w, rootNode: e, currentNode: V };
    e.dispatchEvent(new CustomEvent(t, { detail: o })), r == null || r(o);
  }, z = addEventListener;
  z("pointerdown", tt, !1), z("pointerup", et, !1), z("pointermove", nt, !1), H(e, "touch-action", "none");
  const _ = () => {
    let t = e.offsetWidth / v.width;
    return isNaN(t) && (t = 1), t;
  };
  function tt(t) {
    if (O || t.button === 2 || Q && !t.isPrimary)
      return;
    if (x.dragStart && (g = I(u, e)), G(D) && G(N) && D === N)
      throw new Error("`handle` selector can't be same as `cancel` selector");
    if (m.add(M), E = function(n, c) {
      if (!n)
        return [c];
      if (J(n))
        return [n];
      if (Array.isArray(n))
        return n;
      const h = c.querySelectorAll(n);
      if (h === null)
        throw new Error("Selector passed for `handle` option should be child of the element on which the action is applied");
      return Array.from(h.values());
    }(D, e), k = function(n, c) {
      if (!n)
        return [];
      if (J(n))
        return [n];
      if (Array.isArray(n))
        return n;
      const h = c.querySelectorAll(n);
      if (h === null)
        throw new Error("Selector passed for `cancel` option should be child of the element on which the action is applied");
      return Array.from(h.values());
    }(N, e), i = /(both|x)/.test(y), d = /(both|y)/.test(y), ot(k, E))
      throw new Error("Element being dragged can't be a child of the element on which `cancel` is applied");
    const r = t.composedPath()[0];
    if (!E.some((n) => {
      var c;
      return n.contains(r) || ((c = n.shadowRoot) == null ? void 0 : c.contains(r));
    }) || ot(k, [r]))
      return;
    V = E.length === 1 ? e : E.find((n) => n.contains(r)), B = !0, v = e.getBoundingClientRect(), P && (Z = U.userSelect, U.userSelect = "none"), j("neodrag:start", at);
    const { clientX: o, clientY: a } = t, l = _();
    i && (A = o - $ / l), d && (C = a - R / l), g && (Y = o - v.left, q = a - v.top);
  }
  function et() {
    B && (x.dragEnd && (g = I(u, e)), m.remove(X), m.add(S), P && (U.userSelect = Z), j("neodrag:end", lt), i && (A = b), d && (C = w), B = !1);
  }
  function nt(t) {
    if (!B)
      return;
    x.drag && (g = I(u, e)), m.add(X), t.preventDefault(), v = e.getBoundingClientRect();
    let r = t.clientX, o = t.clientY;
    const a = _();
    if (g) {
      const l = { left: g.left + Y, top: g.top + q, right: g.right + Y - v.width, bottom: g.bottom + q - v.height };
      r = rt(r, l.left, l.right), o = rt(o, l.top, l.bottom);
    }
    if (Array.isArray(T)) {
      let [l, n] = T;
      if (isNaN(+l) || l < 0)
        throw new Error("1st argument of `grid` must be a valid positive number");
      if (isNaN(+n) || n < 0)
        throw new Error("2nd argument of `grid` must be a valid positive number");
      let c = r - A, h = o - C;
      [c, h] = dt([l / a, n / a], c, h), r = A + c, o = C + h;
    }
    i && (b = Math.round((r - A) * a)), d && (w = Math.round((o - C) * a)), $ = b, R = w, j("neodrag", st), W();
  }
  return { destroy: () => {
    const t = removeEventListener;
    t("pointerdown", tt, !1), t("pointerup", et, !1), t("pointermove", nt, !1);
  }, update: (t) => {
    var o, a;
    y = t.axis || "both", O = t.disabled ?? !1, Q = t.ignoreMultitouch ?? !1, D = t.handle, u = t.bounds, x = t.recomputeBounds ?? F, N = t.cancel, P = t.applyUserSelectHack ?? !0, T = t.grid, f = t.gpuAcceleration ?? !0, K = t.legacyTranslate ?? !0, L = t.transform;
    const r = m.contains(S);
    m.remove(M, S), M = t.defaultClass ?? "neodrag", X = t.defaultClassDragging ?? "neodrag-dragging", S = t.defaultClassDragged ?? "neodrag-dragged", m.add(M), r && m.add(S), ct && ($ = b = ((o = t.position) == null ? void 0 : o.x) ?? b, R = w = ((a = t.position) == null ? void 0 : a.y) ?? w, W());
  } };
};
export {
  ut as draggable
};
//# sourceMappingURL=annotorious-svelte.es9.js.map
