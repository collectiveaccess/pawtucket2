(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.IIIFVault = {}));
})(this, (function (exports) { 'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  const EMPTY = [];
  Object.freeze(EMPTY);
  const emptyAnnotationPage = {
    id: "https://iiif-parser/annotation-page",
    type: "AnnotationPage",
    behavior: EMPTY,
    motivation: null,
    label: null,
    thumbnail: EMPTY,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    provider: EMPTY,
    items: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    rendering: EMPTY,
    service: EMPTY
  };
  const emptyCanvas = {
    id: "https://iiif-parser/empty-canvas",
    type: "Canvas",
    label: null,
    behavior: EMPTY,
    motivation: null,
    thumbnail: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    navDate: null,
    provider: EMPTY,
    items: EMPTY,
    annotations: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    partOf: EMPTY,
    rendering: EMPTY,
    service: EMPTY,
    duration: 0,
    height: 0,
    width: 0
  };
  const emptyCollection = {
    id: "https://iiif-parser/empty-collection",
    type: "Collection",
    label: null,
    viewingDirection: "left-to-right",
    behavior: EMPTY,
    motivation: null,
    thumbnail: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    navDate: null,
    provider: EMPTY,
    items: EMPTY,
    annotations: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    partOf: EMPTY,
    rendering: EMPTY,
    service: EMPTY,
    services: EMPTY
  };
  const emptyManifest = {
    id: "https://iiif-parser/empty-manifest",
    type: "Manifest",
    annotations: EMPTY,
    behavior: EMPTY,
    homepage: EMPTY,
    items: EMPTY,
    label: null,
    logo: EMPTY,
    metadata: EMPTY,
    motivation: null,
    navDate: null,
    provider: EMPTY,
    partOf: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    rendering: EMPTY,
    requiredStatement: null,
    rights: null,
    seeAlso: EMPTY,
    service: EMPTY,
    services: EMPTY,
    start: null,
    structures: EMPTY,
    summary: null,
    thumbnail: EMPTY,
    viewingDirection: "left-to-right"
  };
  const emptyRange = {
    id: "https://iiif-parser/empty-canvas",
    type: "Range",
    label: null,
    behavior: EMPTY,
    motivation: null,
    thumbnail: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    navDate: null,
    provider: EMPTY,
    items: EMPTY,
    annotations: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    partOf: EMPTY,
    rendering: EMPTY,
    service: EMPTY,
    start: null,
    supplementary: null,
    viewingDirection: "left-to-right"
  };
  const emptyAgent = {
    id: "https://iiif-parser/empty-agent",
    type: "Agent",
    label: {},
    logo: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY
  };
  function ensureArray$1(maybeArray) {
    if (Array.isArray(maybeArray)) {
      return maybeArray;
    }
    return [maybeArray];
  }
  const types$1 = [
    "Collection",
    "Manifest",
    "Canvas",
    "AnnotationPage",
    "AnnotationCollection",
    "Annotation",
    "ContentResource",
    "Range",
    "Service",
    "Selector",
    "Agent"
  ];
  function identifyResource$1(resource) {
    if (typeof resource === "undefined" || resource === null) {
      throw new Error("Null or undefined is not a valid entity.");
    }
    if (Array.isArray(resource)) {
      throw new Error("Array is not a valid entity");
    }
    if (typeof resource !== "object") {
      throw new Error(`${typeof resource} is not a valid entity`);
    }
    if (typeof resource.type === "string") {
      const hasType = types$1.indexOf(resource.type);
      if (hasType !== -1) {
        return types$1[hasType];
      }
    }
    if (resource.profile) {
      return "Service";
    }
    throw new Error("Resource type is not known");
  }
  class Traverse$1 {
    constructor(traversals, options = {}) {
      __publicField(this, "traversals");
      __publicField(this, "options");
      this.traversals = {
        collection: [],
        manifest: [],
        canvas: [],
        annotationCollection: [],
        annotationPage: [],
        annotation: [],
        contentResource: [],
        choice: [],
        range: [],
        service: [],
        agent: [],
        ...traversals
      };
      this.options = {
        allowUndefinedReturn: false,
        ...options
      };
    }
    static all(traversal) {
      return new Traverse$1({
        collection: [traversal],
        manifest: [traversal],
        canvas: [traversal],
        annotationCollection: [traversal],
        annotationPage: [traversal],
        annotation: [traversal],
        contentResource: [traversal],
        choice: [traversal],
        range: [traversal],
        service: [traversal]
      });
    }
    traverseDescriptive(resource) {
      if (resource.thumbnail) {
        resource.thumbnail = resource.thumbnail.map(
          (thumbnail) => this.traverseType(thumbnail, this.traversals.contentResource)
        );
      }
      if (resource.provider) {
        resource.provider = resource.provider.map((agent) => this.traverseAgent(agent));
      }
      return resource;
    }
    traverseLinking(resource) {
      if (resource.seeAlso) {
        resource.seeAlso = resource.seeAlso.map((content) => this.traverseType(content, this.traversals.contentResource));
      }
      if (resource.service) {
        resource.service = ensureArray$1(resource.service).map(
          (service) => this.traverseType(service, this.traversals.service)
        );
      }
      if (resource.services) {
        resource.services = resource.services.map((service) => this.traverseType(service, this.traversals.service));
      }
      if (resource.logo) {
        resource.logo = resource.logo.map((content) => this.traverseType(content, this.traversals.contentResource));
      }
      if (resource.homepage) {
        resource.homepage = resource.homepage.map(
          (homepage) => this.traverseType(homepage, this.traversals.contentResource)
        );
      }
      if (resource.partOf) {
        resource.partOf = resource.partOf.map((partOf) => {
          if (typeof partOf === "string" || !partOf.type) {
            return this.traverseType(partOf, this.traversals.contentResource);
          }
          if (partOf.type === "Canvas") {
            return this.traverseType(partOf, this.traversals.canvas);
          }
          if (partOf.type === "AnnotationCollection") {
            return this.traverseType(partOf, this.traversals.annotationCollection);
          }
          if (partOf.type === "Collection") {
            return this.traverseType(partOf, this.traversals.collection);
          }
          return this.traverseType(partOf, this.traversals.contentResource);
        });
      }
      if (resource.start) {
        resource.start = resource.start ? this.traverseType(resource.start, this.traversals.canvas) : null;
      }
      if (resource.rendering) {
        resource.rendering = resource.rendering.map(
          (content) => this.traverseType(content, this.traversals.contentResource)
        );
      }
      if (resource.supplementary) {
        resource.supplementary = resource.supplementary.map(
          (content) => this.traverseType(content, this.traversals.contentResource)
        );
      }
      return resource;
    }
    traverseCollectionItems(collection) {
      if (collection.items) {
        collection.items.map((collectionOrManifest) => {
          if (collectionOrManifest.type === "Collection") {
            return this.traverseCollection(collectionOrManifest);
          }
          return this.traverseManifest(collectionOrManifest);
        });
      }
      return collection;
    }
    traverseCollection(collection) {
      return this.traverseType(
        this.traverseDescriptive(
          this.traverseInlineAnnotationPages(
            this.traverseLinking(this.traversePosterCanvas(this.traverseCollectionItems(collection)))
          )
        ),
        this.traversals.collection
      );
    }
    traverseManifestItems(manifest) {
      if (manifest.items) {
        manifest.items = manifest.items.map((canvas) => this.traverseCanvas(canvas));
      }
      return manifest;
    }
    traverseManifestStructures(manifest) {
      if (manifest.structures) {
        manifest.structures = manifest.structures.map((range) => this.traverseRange(range));
      }
      return manifest;
    }
    traverseManifest(manifest) {
      return this.traverseType(
        this.traverseInlineAnnotationPages(
          this.traverseManifestStructures(
            this.traversePosterCanvas(
              this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(manifest)))
            )
          )
        ),
        this.traversals.manifest
      );
    }
    traverseCanvasItems(canvas) {
      canvas.items = (canvas.items || []).map((annotationPage) => {
        return this.traverseAnnotationPage(annotationPage);
      });
      return canvas;
    }
    traverseInlineAnnotationPages(resource) {
      if (typeof resource === "string" || !resource) {
        return resource;
      }
      if (resource.annotations) {
        resource.annotations = resource.annotations.map((annotationPage) => {
          return this.traverseAnnotationPage(annotationPage);
        });
      }
      return resource;
    }
    traverseCanvas(canvas) {
      return this.traverseType(
        this.traverseInlineAnnotationPages(
          this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(canvas))))
        ),
        this.traversals.canvas
      );
    }
    traverseAnnotationPageItems(annotationPage) {
      if (annotationPage.items) {
        annotationPage.items = annotationPage.items.map((annotation) => {
          return this.traverseAnnotation(annotation);
        });
      }
      return annotationPage;
    }
    traverseAnnotationPage(annotationPageJson) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationPageItems(annotationPageJson))),
        this.traversals.annotationPage
      );
    }
    traverseAnnotationBody(annotation) {
      if (Array.isArray(annotation.body)) {
        annotation.body = annotation.body.map((annotationBody) => {
          return this.traverseContentResource(annotationBody);
        });
      } else if (annotation.body) {
        annotation.body = this.traverseContentResource(annotation.body);
      }
      return annotation;
    }
    traversePosterCanvas(json) {
      if (json.posterCanvas) {
        json.posterCanvas = this.traverseCanvas(json.posterCanvas);
      }
      if (json.placeholderCanvas) {
        json.placeholderCanvas = this.traverseCanvas(json.placeholderCanvas);
      }
      if (json.accompanyingCanvas) {
        json.accompanyingCanvas = this.traverseCanvas(json.accompanyingCanvas);
      }
      return json;
    }
    traverseAnnotation(annotationJson) {
      return this.traverseType(
        this.traverseLinking(this.traverseAnnotationBody(annotationJson)),
        this.traversals.annotation
      );
    }
    traverseContentResourceLinking(contentResourceJson) {
      if (typeof contentResourceJson === "string" || !contentResourceJson) {
        return contentResourceJson;
      }
      if (contentResourceJson && contentResourceJson.service) {
        contentResourceJson.service = ensureArray$1(
          contentResourceJson.service || []
        ).map((service) => this.traverseType(service, this.traversals.service));
      }
      return contentResourceJson;
    }
    traverseContentResource(contentResourceJson) {
      if (contentResourceJson.type === "Choice") {
        contentResourceJson.items = contentResourceJson.items.map((choiceItem) => {
          return this.traverseContentResource(choiceItem);
        });
      }
      return this.traverseType(
        this.traverseInlineAnnotationPages(this.traverseContentResourceLinking(contentResourceJson)),
        this.traversals.contentResource
      );
    }
    traverseRangeRanges(range) {
      if (range.items) {
        range.items = range.items.map((rangeOrManifest) => {
          if (typeof rangeOrManifest === "string") {
            return this.traverseCanvas({ id: rangeOrManifest, type: "Canvas" });
          }
          if (rangeOrManifest.type === "Manifest") {
            return this.traverseManifest(rangeOrManifest);
          }
          return this.traverseRange(rangeOrManifest);
        });
      }
      return range;
    }
    traverseRange(range) {
      return this.traverseType(
        this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseRangeRanges(range)))),
        this.traversals.range
      );
    }
    traverseAgent(agent) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(agent)),
        this.traversals.agent
      );
    }
    traverseType(object, traversals) {
      return traversals.reduce((acc, traversal) => {
        const returnValue = traversal(acc);
        if (typeof returnValue === "undefined" && !this.options.allowUndefinedReturn) {
          return acc;
        }
        return returnValue;
      }, object);
    }
    traverseService(service) {
      return this.traverseType(service, this.traversals.service);
    }
    traverseUnknown(resource) {
      const type = identifyResource$1(resource);
      switch (type) {
        case "Collection":
          return this.traverseCollection(resource);
        case "Manifest":
          return this.traverseManifest(resource);
        case "Canvas":
          return this.traverseCanvas(resource);
        case "AnnotationPage":
          return this.traverseAnnotationPage(resource);
        case "Annotation":
          return this.traverseAnnotation(resource);
        case "ContentResource":
          return this.traverseContentResource(resource);
        case "Range":
          return this.traverseRange(resource);
        case "Service":
          return this.traverseService(resource);
        case "Agent":
          return this.traverseAgent(resource);
        default:
          throw new Error(`Unknown or unsupported resource type of ${type}`);
      }
    }
  }
  const types = [
    "sc:Collection",
    "sc:Manifest",
    "sc:Canvas",
    "sc:AnnotationList",
    "oa:Annotation",
    "sc:Range",
    "sc:Layer",
    "sc:Sequence",
    "oa:Choice",
    "Service",
    "ContentResource"
  ];
  function identifyResource(resource) {
    if (typeof resource === "undefined" || resource === null) {
      throw new Error("Null or undefined is not a valid entity.");
    }
    if (Array.isArray(resource)) {
      throw new Error("Array is not a valid entity");
    }
    if (typeof resource !== "object") {
      throw new Error(`${typeof resource} is not a valid entity`);
    }
    if (typeof resource["@type"] === "string") {
      const hasType = types.indexOf(resource["@type"]);
      if (hasType !== -1) {
        return types[hasType];
      }
    }
    if (resource.profile) {
      return "Service";
    }
    if (resource.format) {
      return "ContentResource";
    }
    if (resource["@type"]) {
      return "ContentResource";
    }
    throw new Error("Resource type is not known");
  }
  class Traverse {
    constructor(traversals, options = {}) {
      __publicField(this, "traversals");
      __publicField(this, "options");
      this.traversals = {
        collection: [],
        manifest: [],
        canvas: [],
        annotationList: [],
        sequence: [],
        annotation: [],
        contentResource: [],
        choice: [],
        range: [],
        service: [],
        layer: [],
        ...traversals
      };
      this.options = {
        convertPropsToArray: true,
        mergeMemberProperties: true,
        allowUndefinedReturn: false,
        ...options
      };
    }
    static all(traversal) {
      return new Traverse({
        collection: [traversal],
        manifest: [traversal],
        canvas: [traversal],
        annotationList: [traversal],
        sequence: [traversal],
        annotation: [traversal],
        contentResource: [traversal],
        choice: [traversal],
        range: [traversal],
        service: [traversal],
        layer: [traversal]
      });
    }
    traverseCollection(collection) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseCollectionItems(collection))),
        this.traversals.collection
      );
    }
    traverseCollectionItems(collection) {
      if (this.options.mergeMemberProperties) {
        const members = [
          ...(collection.manifests || []).map((manifest) => {
            if (typeof manifest === "string") {
              return { "@id": manifest, "@type": "sc:Manifest" };
            }
            return manifest;
          }),
          ...(collection.collections || []).map((subCollection) => {
            if (typeof subCollection === "string") {
              return { "@id": subCollection, "@type": "sc:Collection" };
            }
            return subCollection;
          }),
          ...collection.members || []
        ];
        delete collection.collections;
        delete collection.manifests;
        collection.members = members;
      }
      if (collection.manifests) {
        collection.manifests = collection.manifests.map(
          (manifest) => this.traverseManifest(
            typeof manifest === "string" ? { "@id": manifest, "@type": "sc:Manifest" } : manifest
          )
        );
      }
      if (collection.collections) {
        collection.collections = collection.collections.map(
          (subCollection) => this.traverseCollection(
            typeof subCollection === "string" ? { "@id": subCollection, "@type": "sc:Collection" } : subCollection
          )
        );
      }
      if (collection.members) {
        collection.members = collection.members.map((member) => {
          if (typeof member === "string") {
            return member;
          }
          return this.traverseUnknown(member);
        });
      }
      return collection;
    }
    traverseManifest(manifest) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(manifest))),
        this.traversals.manifest
      );
    }
    traverseManifestItems(manifest) {
      if (manifest.sequences) {
        manifest.sequences = manifest.sequences.map((sequence) => this.traverseSequence(sequence));
      }
      if (manifest.structures) {
        manifest.structures = manifest.structures.map((structure) => this.traverseRange(structure));
      }
      return manifest;
    }
    traverseSequence(sequence) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseSequenceItems(sequence))),
        this.traversals.sequence
      );
    }
    traverseSequenceItems(sequence) {
      if (sequence.canvases) {
        sequence.canvases = sequence.canvases.map((canvas) => this.traverseCanvas(canvas));
      }
      return sequence;
    }
    traverseCanvas(canvas) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(canvas))),
        this.traversals.canvas
      );
    }
    traverseCanvasItems(canvas) {
      if (canvas.images) {
        canvas.images = canvas.images.map((image) => this.traverseAnnotation(image));
      }
      if (canvas.otherContent) {
        canvas.otherContent = canvas.otherContent.map((annotationList) => this.traverseAnnotationList(annotationList));
      }
      return canvas;
    }
    traverseRange(range) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseRangeItems(range))),
        this.traversals.range
      );
    }
    traverseRangeItems(range) {
      if (this.options.mergeMemberProperties) {
        const members = [
          ...(range.ranges || []).map((innerRange) => {
            if (typeof innerRange === "string") {
              return { "@id": innerRange, "@type": "sc:Range" };
            }
            return innerRange;
          }),
          ...(range.canvases || []).map((canvas) => {
            if (typeof canvas === "string") {
              return { "@id": canvas, "@type": "sc:Canvas" };
            }
            return canvas;
          }),
          ...range.members || []
        ];
        delete range.ranges;
        delete range.canvases;
        range.members = members.length ? members.map((member) => this.traverseUnknown(member)) : void 0;
      }
      return range;
    }
    traverseAnnotationList(annotationList) {
      const list = typeof annotationList === "string" ? { "@id": annotationList, "@type": "sc:AnnotationList" } : annotationList;
      return this.traverseType(
        this.traverseDescriptive(this.traverseAnnotationListItems(list)),
        this.traversals.annotationList
      );
    }
    traverseAnnotationListItems(annotationList) {
      if (annotationList.resources) {
        annotationList.resources = annotationList.resources.map((annotation) => this.traverseAnnotation(annotation));
      }
      return annotationList;
    }
    traverseAnnotation(annotation) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationItems(annotation))),
        this.traversals.annotation
      );
    }
    traverseAnnotationItems(annotation) {
      if (annotation.resource) {
        if (Array.isArray(annotation.resource)) {
          annotation.resource = annotation.resource.map(
            (res) => this.traverseContentResource(res)
          );
        } else {
          annotation.resource = this.traverseContentResource(annotation.resource);
        }
      }
      if (annotation.on)
        ;
      return annotation;
    }
    traverseLayer(layer) {
      return this.traverseType(this.traverseLinking(this.traverseLayerItems(layer)), this.traversals.layer);
    }
    traverseLayerItems(layer) {
      if (layer.otherContent) {
        layer.otherContent = layer.otherContent.map((annotationList) => this.traverseAnnotationList(annotationList));
      }
      return layer;
    }
    traverseChoice(choice) {
      return this.traverseType(this.traverseChoiceItems(choice), this.traversals.choice);
    }
    traverseChoiceItems(choice) {
      if (choice.default && choice.default !== "rdf:nil") {
        choice.default = this.traverseContentResource(choice.default);
      }
      if (choice.item && choice.item !== "rdf:nil") {
        choice.item = choice.item.map((item) => this.traverseContentResource(item));
      }
      return choice;
    }
    traverseService(service) {
      return this.traverseType(this.traverseLinking(service), this.traversals.service);
    }
    traverseContentResource(contentResource) {
      if (contentResource["@type"] === "oa:Choice") {
        return this.traverseChoice(contentResource);
      }
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(contentResource)),
        this.traversals.contentResource
      );
    }
    traverseUnknown(item) {
      if (!item["@type"] || typeof item === "string") {
        return item;
      }
      switch (identifyResource(item)) {
        case "sc:Collection":
          return this.traverseCollection(item);
        case "sc:Manifest":
          return this.traverseManifest(item);
        case "sc:Canvas":
          return this.traverseCanvas(item);
        case "sc:Sequence":
          return this.traverseSequence(item);
        case "sc:Range":
          return this.traverseRange(item);
        case "oa:Annotation":
          return this.traverseAnnotation(item);
        case "sc:AnnotationList":
          return this.traverseAnnotationList(item);
        case "sc:Layer":
          return this.traverseLayer(item);
        case "Service":
          return this.traverseService(item);
        case "oa:Choice":
          return this.traverseChoice(item);
        case "ContentResource":
          return this.traverseContentResource(item);
      }
      if (item.profile) {
        return this.traverseService(item);
      }
      return item;
    }
    traverseImageResource(contentResource) {
      const wasArray = Array.isArray(contentResource);
      const resourceList = Array.isArray(contentResource) ? contentResource : [contentResource];
      const newResourceList = [];
      for (const singleResource of resourceList) {
        if (typeof singleResource === "string") {
          newResourceList.push(
            this.traverseContentResource({
              "@id": singleResource,
              "@type": "dctypes:Image"
            })
          );
        } else {
          newResourceList.push(this.traverseContentResource(singleResource));
        }
      }
      if (!wasArray && !this.options.convertPropsToArray) {
        return newResourceList[0];
      }
      return newResourceList;
    }
    traverseDescriptive(resource) {
      if (resource.thumbnail) {
        resource.thumbnail = this.traverseImageResource(resource.thumbnail);
      }
      if (resource.logo) {
        resource.logo = this.traverseImageResource(resource.logo);
      }
      return resource;
    }
    traverseOneOrMoreServices(allServices) {
      const wasArray = Array.isArray(allServices);
      const services = Array.isArray(allServices) ? allServices : [allServices];
      const newServices = [];
      for (const service of services) {
        newServices.push(this.traverseService(service));
      }
      if (!wasArray && !this.options.convertPropsToArray) {
        return newServices[0];
      }
      return newServices;
    }
    traverseLinking(resource) {
      if (resource.related) {
        resource.related = this.traverseOneOrManyType(resource.related, this.traversals.contentResource);
      }
      if (resource.rendering) {
        resource.rendering = this.traverseOneOrManyType(resource.rendering, this.traversals.contentResource);
      }
      if (resource.service) {
        resource.service = this.traverseOneOrMoreServices(resource.service);
      }
      if (resource.seeAlso) {
        resource.seeAlso = this.traverseOneOrManyType(resource.seeAlso, this.traversals.contentResource);
      }
      if (resource.within) {
        if (typeof resource.within === "string")
          ;
        else {
          resource.within = this.traverseOneOrManyType(
            resource.within,
            this.traversals.contentResource
          );
        }
      }
      if (resource.startCanvas) {
        if (typeof resource.startCanvas === "string") {
          resource.startCanvas = this.traverseType(
            { "@id": resource.startCanvas, "@type": "sc:Canvas" },
            this.traversals.canvas
          );
        } else if (resource.startCanvas) {
          this.traverseType(resource.startCanvas, this.traversals.canvas);
        }
      }
      if (resource.contentLayer) {
        if (typeof resource.contentLayer === "string") {
          resource.contentLayer = this.traverseLayer({
            "@id": resource.contentLayer,
            "@type": "sc:Layer"
          });
        } else {
          resource.contentLayer = this.traverseLayer(resource.contentLayer);
        }
      }
      return resource;
    }
    traverseOneOrManyType(object, traversals) {
      if (!Array.isArray(object)) {
        if (this.options.convertPropsToArray) {
          object = [object];
        } else {
          return this.traverseType(object, traversals);
        }
      }
      return object.map((singleObj) => this.traverseType(singleObj, traversals));
    }
    traverseType(object, traversals) {
      return traversals.reduce((acc, traversal) => {
        const returnValue = traversal(acc);
        if (typeof returnValue === "undefined" && !this.options.allowUndefinedReturn) {
          return acc;
        }
        return returnValue;
      }, object);
    }
  }
  const STANFORD_IIIF_IMAGE_COMPLIANCE_0 = "http://library.stanford.edu/iiif/image-api/compliance.html#level0";
  const STANFORD_IIIF_IMAGE_COMPLIANCE_1 = "http://library.stanford.edu/iiif/image-api/compliance.html#level1";
  const STANFORD_IIIF_IMAGE_COMPLIANCE_2 = "http://library.stanford.edu/iiif/image-api/compliance.html#level2";
  const STANFORD_IIIF_IMAGE_CONFORMANCE_0 = "http://library.stanford.edu/iiif/image-api/conformance.html#level0";
  const STANFORD_IIIF_IMAGE_CONFORMANCE_1 = "http://library.stanford.edu/iiif/image-api/conformance.html#level1";
  const STANFORD_IIIF_IMAGE_CONFORMANCE_2 = "http://library.stanford.edu/iiif/image-api/conformance.html#level2";
  const STANFORD_IIIF_1_IMAGE_COMPLIANCE_0 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0";
  const STANFORD_IIIF_1_IMAGE_COMPLIANCE_1 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1";
  const STANFORD_IIIF_1_IMAGE_COMPLIANCE_2 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2";
  const STANFORD_IIIF_1_IMAGE_CONFORMANCE_0 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0";
  const STANFORD_IIIF_1_IMAGE_CONFORMANCE_1 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1";
  const STANFORD_IIIF_1_IMAGE_CONFORMANCE_2 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2";
  const IIIF_1_IMAGE_LEVEL_0 = "http://iiif.io/api/image/1/level0.json";
  const IIIF_1_IMAGE_LEVEL_0_PROFILE = "http://iiif.io/api/image/1/profiles/level0.json";
  const IIIF_1_IMAGE_LEVEL_1 = "http://iiif.io/api/image/1/level1.json";
  const IIIF_1_IMAGE_LEVEL_1_PROFILE = "http://iiif.io/api/image/1/profiles/level1.json";
  const IIIF_1_IMAGE_LEVEL_2 = "http://iiif.io/api/image/1/level2.json";
  const IIIF_1_IMAGE_LEVEL_2_PROFILE = "http://iiif.io/api/image/1/profiles/level2.json";
  const IIIF_2_IMAGE_LEVEL_0 = "http://iiif.io/api/image/2/level0.json";
  const IIIF_2_IMAGE_LEVEL_0_PROFILE = "http://iiif.io/api/image/2/profiles/level0.json";
  const IIIF_2_IMAGE_LEVEL_1 = "http://iiif.io/api/image/2/level1.json";
  const IIIF_2_IMAGE_LEVEL_1_PROFILE = "http://iiif.io/api/image/2/profiles/level1.json";
  const IIIF_2_IMAGE_LEVEL_2 = "http://iiif.io/api/image/2/level2.json";
  const IIIF_2_IMAGE_LEVEL_2_PROFILE = "http://iiif.io/api/image/2/profiles/level2.json";
  const IIIF_3_IMAGE_LEVEL_0 = "level0";
  const IIIF_3_IMAGE_LEVEL_1 = "level1";
  const IIIF_3_IMAGE_LEVEL_2 = "level2";
  const IIIF_2_IMAGE_LEVEL_0_NO_JSON = "http://iiif.io/api/image/2/level0";
  const IIIF_2_IMAGE_LEVEL_1_NO_JSON = "http://iiif.io/api/image/2/level1";
  const IIIF_2_IMAGE_LEVEL_2_NO_JSON = "http://iiif.io/api/image/2/level2";
  const level1Support = [
    IIIF_2_IMAGE_LEVEL_1_NO_JSON,
    IIIF_2_IMAGE_LEVEL_2_NO_JSON,
    STANFORD_IIIF_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_IMAGE_CONFORMANCE_2,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,
    IIIF_1_IMAGE_LEVEL_1,
    IIIF_1_IMAGE_LEVEL_1_PROFILE,
    IIIF_1_IMAGE_LEVEL_2,
    IIIF_1_IMAGE_LEVEL_2_PROFILE,
    IIIF_2_IMAGE_LEVEL_1,
    IIIF_2_IMAGE_LEVEL_1_PROFILE,
    IIIF_2_IMAGE_LEVEL_2,
    IIIF_2_IMAGE_LEVEL_2_PROFILE,
    IIIF_3_IMAGE_LEVEL_1,
    IIIF_3_IMAGE_LEVEL_2
  ];
  const imageServiceProfiles = [
    IIIF_2_IMAGE_LEVEL_0_NO_JSON,
    IIIF_2_IMAGE_LEVEL_1_NO_JSON,
    IIIF_2_IMAGE_LEVEL_2_NO_JSON,
    STANFORD_IIIF_IMAGE_COMPLIANCE_0,
    STANFORD_IIIF_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_IMAGE_CONFORMANCE_0,
    STANFORD_IIIF_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_IMAGE_CONFORMANCE_2,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_0,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_0,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,
    IIIF_1_IMAGE_LEVEL_0,
    IIIF_1_IMAGE_LEVEL_0_PROFILE,
    IIIF_1_IMAGE_LEVEL_1,
    IIIF_1_IMAGE_LEVEL_1_PROFILE,
    IIIF_1_IMAGE_LEVEL_2,
    IIIF_1_IMAGE_LEVEL_2_PROFILE,
    IIIF_2_IMAGE_LEVEL_0,
    IIIF_2_IMAGE_LEVEL_0_PROFILE,
    IIIF_2_IMAGE_LEVEL_1,
    IIIF_2_IMAGE_LEVEL_1_PROFILE,
    IIIF_2_IMAGE_LEVEL_2,
    IIIF_2_IMAGE_LEVEL_2_PROFILE,
    IIIF_3_IMAGE_LEVEL_0,
    IIIF_3_IMAGE_LEVEL_1,
    IIIF_3_IMAGE_LEVEL_2
  ];
  const configuration = {
    attributionLabel: "Attribution",
    lang: "none",
    providerId: "http://example.org/provider",
    providerName: "Unknown"
  };
  function convertLanguageMapping(inputLangProperty, defaultLang = "none") {
    if (!inputLangProperty) {
      return {};
    }
    const arrayOfValues = Array.isArray(inputLangProperty) ? inputLangProperty : [inputLangProperty];
    const languageMap = {};
    for (const language of arrayOfValues) {
      if (typeof language === "string") {
        languageMap[defaultLang] = languageMap[defaultLang] ? languageMap[defaultLang] : [];
        languageMap[defaultLang].push(language || "");
        continue;
      }
      if (!language["@language"]) {
        languageMap[defaultLang] = languageMap[defaultLang] ? languageMap[defaultLang] : [];
        languageMap[defaultLang].push(language["@value"] || "");
        continue;
      }
      const lang = language["@language"];
      languageMap[lang] = languageMap[lang] ? languageMap[lang] : [];
      languageMap[lang].push(language["@value"] || "");
    }
    return languageMap;
  }
  function getProfile(profile) {
    if (Array.isArray(profile)) {
      return getProfile(profile.find((s) => typeof s === "string"));
    }
    if (imageServiceProfiles.indexOf(profile) !== -1) {
      return "level2";
    }
    if (level1Support.indexOf(profile) !== -1) {
      return "level1";
    }
    if (typeof profile !== "string") {
      return void 0;
    }
    return profile;
  }
  function getTypeFromContext(inputContexts) {
    const contexts = Array.isArray(inputContexts) ? inputContexts : [inputContexts];
    for (const context of contexts) {
      switch (context) {
        case "http://iiif.io/api/image/2/context.json":
        case "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2":
          return "ImageService2";
        case "http://iiif.io/api/image/1/context.json":
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
          return "ImageService1";
        case "http://iiif.io/api/annex/openannotation/context.json":
          return "ImageApiSelector";
      }
    }
    return void 0;
  }
  function getTypeFromProfile(inputProfile) {
    switch (inputProfile) {
      case "http://iiif.io/api/image/2/level0.json":
      case "http://iiif.io/api/image/2/level1.json":
      case "http://iiif.io/api/image/2/level2.json":
        return "ImageService2";
      case "http://iiif.io/api/auth/1/kiosk":
      case "http://iiif.io/api/auth/1/login":
      case "http://iiif.io/api/auth/1/clickthrough":
      case "http://iiif.io/api/auth/1/external":
      case "http://iiif.io/api/auth/0/kiosk":
      case "http://iiif.io/api/auth/0/login":
      case "http://iiif.io/api/auth/0/clickthrough":
      case "http://iiif.io/api/auth/0/external":
        return "AuthCookieService1";
      case "http://iiif.io/api/auth/1/token":
      case "http://iiif.io/api/auth/0/token":
        return "AuthTokenService1";
      case "http://iiif.io/api/auth/1/logout":
      case "http://iiif.io/api/auth/0/logout":
        return "AuthLogoutService1";
      case "http://iiif.io/api/search/1/search":
      case "http://iiif.io/api/search/0/search":
        return "SearchService1";
      case "http://iiif.io/api/search/1/autocomplete":
      case "http://iiif.io/api/search/0/autocomplete":
        return "AutoCompleteService1";
    }
    return void 0;
  }
  function removePrefix(str) {
    for (const prefix of ["sc", "oa", "dcterms", "dctypes", "iiif"]) {
      if (str.startsWith(`${prefix}:`)) {
        return str.slice(prefix.length + 1);
      }
    }
    return str;
  }
  const knownTypes = ["Collection", "Manifest", "Annotation", "AnnotationPage", "Range", "Service"];
  function getNewType(resource) {
    const id = resource["@id"] || resource.id;
    let oldType = resource["@type"] || resource.type;
    const profile = resource.profile || void 0;
    const context = resource["@context"] || void 0;
    if (profile) {
      const possibleType = getTypeFromProfile(profile);
      if (possibleType) {
        return possibleType;
      }
    }
    if (context) {
      const possibleType = getTypeFromContext(context);
      if (possibleType) {
        return possibleType;
      }
    }
    if (oldType) {
      if (Array.isArray(oldType)) {
        if (oldType.indexOf("oa:CssStylesheet") !== -1) {
          return "CssStylesheet";
        }
        if (oldType.indexOf("cnt:ContentAsText") !== -1) {
          return "TextualBody";
        }
        oldType = oldType[0];
      }
      for (const prefix of ["sc", "oa", "dcterms", "dctypes", "iiif"]) {
        if (oldType.startsWith(`${prefix}:`)) {
          oldType = oldType.slice(prefix.length + 1);
          break;
        }
      }
      switch (oldType) {
        case "Layer":
          return "AnnotationCollection";
        case "AnnotationList":
          return "AnnotationPage";
        case "cnt:ContentAsText":
          return "TextualBody";
      }
    }
    if (oldType && knownTypes.indexOf(oldType) !== -1) {
      return oldType;
    }
    if (resource.format) {
      if (resource.format.startsWith("image/")) {
        return "Image";
      }
      if (resource.format.startsWith("text/")) {
        return "Text";
      }
      if (resource.format === "application/pdf") {
        return "Text";
      }
      if (resource.format.startsWith("application/")) {
        return "Dataset";
      }
    }
    if (id && (id.endsWith(".jpg") || id.endsWith(".png") || id.endsWith(".jpeg"))) {
      return "Image";
    }
    if (!oldType) {
      return "unknown";
    }
    return oldType;
  }
  const licenseRegex = /http(s)?:\/\/(creativecommons.org|rightsstatements.org)[^"'\\<\n]+/gm;
  function extractLicense(license) {
    const matches = license.match(licenseRegex);
    if (matches) {
      return matches[0];
    }
    return license;
  }
  function fixLicense(license, licenseLabel = "Rights/License", lang = "none") {
    let rights = null;
    const metadata = [];
    const licenseList = Array.isArray(license) ? license : [license];
    for (const rawLicense of licenseList) {
      const singleLicense = rawLicense ? extractLicense(rawLicense) : void 0;
      if (singleLicense && (singleLicense.indexOf("creativecommons.org") !== -1 || singleLicense.indexOf("rightsstatements.org") !== -1)) {
        if (singleLicense.startsWith("https://")) {
          rights = `http://${singleLicense.slice(8)}`;
        } else {
          rights = singleLicense;
        }
        continue;
      }
      if (singleLicense) {
        metadata.push({
          label: { [lang]: [licenseLabel] },
          value: { [lang]: [singleLicense] }
        });
      }
    }
    return [rights, metadata];
  }
  const removeContexts = [
    "http://iiif.io/api/presentation/2/context.json",
    "http://iiif.io/api/image/2/context.json",
    "http://iiif.io/api/image/1/context.json",
    "http://library.stanford.edu/iiif/image-api/1.1/context.json",
    "http://iiif.io/api/search/1/context.json",
    "http://iiif.io/api/search/0/context.json",
    "http://iiif.io/api/auth/1/context.json",
    "http://iiif.io/api/auth/0/context.json",
    "http://iiif.io/api/annex/openannotation/context.json"
  ];
  function fixContext(inputContext) {
    if (inputContext) {
      const contexts = Array.isArray(inputContext) ? inputContext : [inputContext];
      const newContexts = [];
      for (const context of contexts) {
        if (context === "http://iiif.io/api/presentation/2/context.json") {
          newContexts.push("http://iiif.io/api/presentation/3/context.json");
        }
        if (removeContexts.indexOf(context) !== -1) {
          continue;
        }
        newContexts.push(context);
      }
      if (contexts.length) {
        return newContexts.length === 1 ? newContexts[0] : newContexts;
      }
    }
    return void 0;
  }
  function convertMetadata(metadata) {
    if (!metadata) {
      return [];
    }
    return metadata.map((item) => {
      return {
        label: convertLanguageMapping(item.label),
        value: convertLanguageMapping(item.value)
      };
    });
  }
  function removeUndefinedProperties(obj) {
    for (const prop in obj) {
      if (typeof obj[prop] === "undefined" || obj[prop] === null) {
        delete obj[prop];
      }
    }
    return obj;
  }
  let mintedIdCounter = 0;
  function mintNewIdFromResource(resource, subresource) {
    const origId = encodeURI(resource.id || resource["@id"] || "").trim();
    if (origId && subresource) {
      return `${origId}/${subresource}`;
    }
    if (origId) {
      return origId;
    }
    mintedIdCounter++;
    return `http://example.org/${resource["@type"]}${subresource ? `/${subresource}` : ""}/${mintedIdCounter}`;
  }
  function technicalProperties$2(resource) {
    const allBehaviours = [...resource.behavior || []];
    if (resource.viewingHint) {
      allBehaviours.push(resource.viewingHint);
    }
    let motivation;
    if (Array.isArray(resource.motivation)) {
      motivation = resource.motivation.map(removePrefix);
    } else if (resource.motivation) {
      motivation = removePrefix(resource.motivation);
    }
    return {
      "@context": resource["@context"] ? fixContext(resource["@context"]) : void 0,
      id: (resource["@id"] || mintNewIdFromResource(resource)).trim(),
      type: getNewType(resource),
      behavior: allBehaviours.length ? allBehaviours : void 0,
      height: resource.height ? resource.height : void 0,
      width: resource.width ? resource.width : void 0,
      motivation,
      viewingDirection: resource.viewingDirection,
      profile: resource.profile,
      format: resource.format ? resource.format : void 0,
      duration: void 0,
      timeMode: void 0
    };
  }
  function descriptiveProperties$2(resource) {
    const [rights, extraMetadata] = fixLicense(resource.license);
    const allMetadata = [...resource.metadata ? convertMetadata(resource.metadata) : [], ...extraMetadata];
    return {
      rights,
      metadata: allMetadata.length ? allMetadata : void 0,
      label: resource.label ? convertLanguageMapping(resource.label) : void 0,
      requiredStatement: resource.attribution ? {
        label: convertLanguageMapping(configuration.attributionLabel),
        value: convertLanguageMapping(resource.attribution)
      } : void 0,
      navDate: resource.navDate,
      summary: resource.description ? convertLanguageMapping(resource.description) : void 0,
      thumbnail: resource.thumbnail
    };
  }
  function parseWithin(resource) {
    if (!resource.within) {
      return void 0;
    }
    const withinProperties = Array.isArray(resource.within) ? resource.within : [resource.within];
    const returnPartOf = [];
    for (const within of withinProperties) {
      if (typeof within === "string") {
        if (within) {
          switch (resource["@type"]) {
            case "sc:Manifest":
              returnPartOf.push({ id: within, type: "Collection" });
              break;
          }
        }
      } else if (within["@id"]) {
        returnPartOf.push({
          id: within["@id"],
          type: getNewType(within)
        });
      } else
        ;
    }
    return returnPartOf.length ? returnPartOf : void 0;
  }
  function linkingProperties$2(resource) {
    const related = resource.related ? Array.isArray(resource.related) ? resource.related : [resource.related] : [];
    const layer = resource.contentLayer;
    return {
      provider: resource.logo || related.length ? [
        {
          id: configuration.providerId,
          type: "Agent",
          homepage: related.length ? [related[0]] : void 0,
          logo: resource.logo ? Array.isArray(resource.logo) ? resource.logo : [resource.logo] : void 0,
          label: convertLanguageMapping(configuration.providerName)
        }
      ] : void 0,
      partOf: parseWithin(resource),
      rendering: resource.rendering,
      seeAlso: resource.seeAlso,
      start: resource.startCanvas,
      service: resource.service ? ensureArray$1(resource.service) : void 0,
      supplementary: layer ? [layer] : void 0
    };
  }
  function embeddedContentProperties(resource) {
    return {
      chars: resource.chars,
      format: resource.format ? resource.format : void 0,
      language: resource.language
    };
  }
  function upgradeCollection(collection) {
    return removeUndefinedProperties({
      ...technicalProperties$2(collection),
      ...descriptiveProperties$2(collection),
      ...linkingProperties$2(collection),
      items: collection.members
    });
  }
  function upgradeManifest(manifest) {
    const allCanvases = [];
    const behavior = [];
    for (const sequence of manifest.sequences || []) {
      if (sequence.canvases.length) {
        allCanvases.push(...sequence.canvases);
      }
      if (sequence.behavior) {
        behavior.push(...sequence.behavior);
      }
    }
    const technical = technicalProperties$2(manifest);
    if (behavior.length) {
      if (technical.behavior) {
        technical.behavior.push(...behavior);
      } else {
        technical.behavior = behavior;
      }
    }
    return removeUndefinedProperties({
      ...technical,
      ...descriptiveProperties$2(manifest),
      ...linkingProperties$2(manifest),
      items: allCanvases,
      structures: manifest.structures
    });
  }
  function upgradeCanvas(canvas) {
    return removeUndefinedProperties({
      ...technicalProperties$2(canvas),
      ...descriptiveProperties$2(canvas),
      ...linkingProperties$2(canvas),
      annotations: canvas.otherContent && canvas.otherContent.length ? canvas.otherContent : void 0,
      items: canvas.images && canvas.images.length ? [
        {
          id: mintNewIdFromResource(canvas, "annotation-page"),
          type: "AnnotationPage",
          items: canvas.images
        }
      ] : void 0
    });
  }
  function upgradeAnnotationList(annotationPage) {
    return removeUndefinedProperties({
      ...technicalProperties$2(annotationPage),
      ...descriptiveProperties$2(annotationPage),
      ...linkingProperties$2(annotationPage),
      items: annotationPage.resources && annotationPage.resources.length ? annotationPage.resources : void 0
    });
  }
  function upgradeSequence(sequence) {
    if (!sequence.canvases || sequence.canvases.length === 0) {
      return {
        canvases: [],
        behavior: []
      };
    }
    return {
      canvases: sequence.canvases,
      behavior: sequence.viewingHint ? [sequence.viewingHint] : []
    };
  }
  function upgradeAnnotation(annotation) {
    function upgradeTarget(target) {
      if (Array.isArray(target)) {
        if (target.length > 1) {
          return { type: "List", items: target.map(upgradeTarget) };
        }
        target = target[0];
      }
      if (typeof target === "string") {
        return encodeURI(target).trim();
      } else if ("@type" in target) {
        let source;
        if (typeof target.full === "string") {
          source = target.full;
        } else if (target.full["@type"] === "dctypes:Image") {
          source = { id: target.full["@id"], type: "Image" };
        } else if (target.full["@type"] === "sc:Canvas") {
          source = { id: target.full["@id"], type: "Canvas" };
        } else {
          throw new Error(`Unsupported source type on annotation: ${target.full["@type"]}`);
        }
        return {
          type: "SpecificResource",
          source,
          selector: upgradeSelector(target.selector)
        };
      } else {
        return encodeURI(target["@id"]).trim();
      }
    }
    return removeUndefinedProperties({
      ...technicalProperties$2(annotation),
      ...descriptiveProperties$2(annotation),
      ...linkingProperties$2(annotation),
      target: upgradeTarget(annotation.on),
      body: Array.isArray(annotation.resource) ? annotation.resource.map(upgradeContentResource) : upgradeContentResource(annotation.resource)
    });
  }
  function upgradeContentResource(inputContentResource) {
    const contentResource = inputContentResource;
    return removeUndefinedProperties({
      ...technicalProperties$2(contentResource),
      ...descriptiveProperties$2(contentResource),
      ...linkingProperties$2(contentResource),
      ...embeddedContentProperties(contentResource)
    });
  }
  function upgradeChoice(choice) {
    const items = [];
    if (choice.default && choice.default !== "rdf:nil") {
      items.push(choice.default);
    }
    if (choice.item && choice.item !== "rdf:nil") {
      items.push(...choice.item);
    }
    return {
      ...technicalProperties$2(choice),
      ...descriptiveProperties$2(choice),
      items
    };
  }
  function upgradeRange(range) {
    return removeUndefinedProperties({
      ...technicalProperties$2(range),
      ...descriptiveProperties$2(range),
      ...linkingProperties$2(range),
      items: range.members
    });
  }
  function upgradeService(service) {
    const { "@id": id, "@type": type, "@context": context, profile, ...additionalProps } = service;
    const newService = {};
    if (id) {
      newService["@id"] = id;
    }
    newService["@type"] = getNewType(service);
    if (newService["@type"] === "unknown") {
      if (context && context.length) {
        newService["@context"] = context;
      }
      newService["@type"] = "Service";
    }
    if (profile) {
      newService.profile = getProfile(profile);
    }
    return removeUndefinedProperties({
      ...newService,
      ...additionalProps
    });
  }
  function upgradeLayer(layer) {
    return removeUndefinedProperties({
      ...technicalProperties$2(layer),
      ...descriptiveProperties$2(layer),
      ...linkingProperties$2(layer)
    });
  }
  const presentation2to3 = new Traverse({
    collection: [upgradeCollection],
    manifest: [upgradeManifest],
    canvas: [upgradeCanvas],
    annotationList: [upgradeAnnotationList],
    sequence: [upgradeSequence],
    annotation: [upgradeAnnotation],
    contentResource: [upgradeContentResource],
    choice: [upgradeChoice],
    range: [upgradeRange],
    service: [upgradeService],
    layer: [upgradeLayer]
  });
  function convertPresentation2(entity) {
    if (entity && entity["@context"] && (entity["@context"] === "http://iiif.io/api/presentation/2/context.json" || entity["@context"].indexOf("http://iiif.io/api/presentation/2/context.json") !== -1 || entity["@context"] === "http://www.shared-canvas.org/ns/context.json") || entity["@context"] === "http://iiif.io/api/image/2/context.json") {
      return presentation2to3.traverseUnknown(entity);
    }
    return entity;
  }
  function upgradeSelector(selector) {
    const isSvgSelector = (Array.isArray(selector["@type"]) && selector["@type"].includes("oa:SvgSelector") || selector["@type"] == "oa:SvgSelector") && ("chars" in selector || "value" in selector);
    if (isSvgSelector) {
      return {
        type: "SvgSelector",
        value: "chars" in selector ? selector.chars : selector.value
      };
    }
    if (selector["@type"] === "oa:FragmentSelector") {
      return {
        type: "FragmentSelector",
        value: selector.value
      };
    }
    if (selector["@type"] === "oa:Choice") {
      return [
        upgradeSelector(selector.default),
        ...(Array.isArray(selector.item) ? selector.item : [selector.item]).map(
          upgradeSelector
        )
      ];
    }
    if (selector["@type"] == "iiif:ImageApiSelector") {
      return {
        type: "ImageApiSelector",
        region: "region" in selector ? selector.region : void 0,
        rotation: "rotation" in selector ? selector.rotation : void 0
      };
    }
    throw new Error(`Unsupported selector type: ${selector["@type"]}`);
  }
  function getDefaultEntities$1() {
    return {
      Collection: {},
      Manifest: {},
      Canvas: {},
      AnnotationPage: {},
      AnnotationCollection: {},
      Annotation: {},
      ContentResource: {},
      Range: {},
      Service: {},
      Selector: {},
      Agent: {}
    };
  }
  function getResource(entityOrString, type) {
    if (typeof entityOrString === "string") {
      return { id: entityOrString, type };
    }
    if (!entityOrString.id) {
      throw new Error(`Invalid resource does not have an ID (${type})`);
    }
    return entityOrString;
  }
  function mapToEntities(entities) {
    return (type, defaultStringType) => {
      const storeType = entities[type] ? entities[type] : {};
      return (r) => {
        const resource = getResource(r, defaultStringType || type);
        if (resource && resource.id && type) {
          storeType[resource.id] = storeType[resource.id] ? mergeEntities(storeType[resource.id], resource) : Object.assign({}, resource);
          return {
            id: resource.id,
            type: type === "ContentResource" ? type : resource.type
          };
        }
        return resource;
      };
    };
  }
  function merge(existing, incoming) {
    if (!incoming) {
      return existing;
    }
    if (Array.isArray(existing)) {
      if (!Array.isArray(incoming)) {
        throw new Error("Cannot merge array with non-array");
      }
      const merged = [...existing];
      for (const item of incoming) {
        if (item === null || item === void 0) {
          continue;
        }
        if (Array.isArray(item)) {
          merged.push(item);
        } else if (typeof item === "object" && item.id && item.type) {
          const existingIdx = merged.findIndex((e) => e.id === item.id && e.type === item.type);
          if (existingIdx >= 0) {
            merged[existingIdx] = merge(merged[existingIdx], item);
          }
        } else if (existing.indexOf(item) === -1) {
          merged.push(item);
        }
      }
      return merged;
    } else if (typeof existing === "object") {
      if (Array.isArray(incoming) || typeof incoming !== "object") {
        throw new Error("Cannot merge object with non-object");
      }
      const merged = { ...existing };
      for (const [key, val] of Object.entries(incoming)) {
        const currentVal = merged[key];
        if (currentVal === EMPTY || !currentVal) {
          merged[key] = val;
        } else {
          merged[key] = merge(currentVal, val);
        }
      }
      return merged;
    } else if (existing) {
      return existing;
    }
    return incoming;
  }
  function mergeEntities(existing, incoming) {
    if (typeof existing === "string") {
      return existing;
    }
    if (incoming.id !== existing.id || incoming.type !== existing.type) {
      throw new Error("Can only merge entities with identical identifiers and type!");
    }
    return merge({ ...existing }, incoming);
  }
  function recordTypeInMapping(mapping) {
    return (type, defaultStringType) => {
      return (r) => {
        const { id, type: foundType } = getResource(r, defaultStringType || type);
        if (typeof id === "undefined") {
          throw new Error("Found invalid entity without an ID.");
        }
        if (type === "ContentResource") {
          mapping[id] = type;
        } else {
          mapping[id] = foundType;
        }
        return r;
      };
    };
  }
  function hash(object) {
    const text = JSON.stringify(object);
    let numHash = 5381, index = text.length;
    while (index) {
      numHash = numHash * 33 ^ text.charCodeAt(--index);
    }
    const num = numHash >>> 0;
    const hexString = num.toString(16);
    if (hexString.length % 2) {
      return "0" + hexString;
    }
    return hexString;
  }
  function addMissingIdToContentResource(type) {
    return (resource) => {
      if (typeof resource === "string") {
        return { id: resource, type };
      }
      if (!resource.id) {
        return { id: `vault://${hash(resource)}`, type, ...resource };
      }
      if (!resource.type) {
        return { type, ...resource };
      }
      return resource;
    };
  }
  function ensureDefaultFields(defaultResource) {
    return (resource) => {
      return {
        ...defaultResource,
        ...resource
      };
    };
  }
  function ensureArray(maybeArray) {
    if (Array.isArray(maybeArray)) {
      return maybeArray;
    }
    return [maybeArray];
  }
  function ensureArrayOnAnnotation(annotation) {
    if (annotation.body) {
      annotation.body = ensureArray(annotation.body);
    }
    if (annotation.seeAlso) {
      annotation.seeAlso = ensureArray(annotation.seeAlso);
    }
    if (annotation.body) {
      annotation.body = ensureArray(annotation.body);
    }
    if (annotation.audience) {
      annotation.audience = ensureArray(annotation.audience);
    }
    if (annotation.accessibility) {
      annotation.accessibility = ensureArray(annotation.accessibility);
    }
    if (annotation.motivation) {
      annotation.motivation = ensureArray(annotation.motivation);
    }
    return annotation;
  }
  function normalize(unknownEntity) {
    const entity = convertPresentation2(unknownEntity);
    const entities = getDefaultEntities$1();
    const mapping = {};
    const addToEntities = mapToEntities(entities);
    const addToMapping = recordTypeInMapping(mapping);
    const traversal = new Traverse$1({
      collection: [
        ensureDefaultFields(emptyCollection),
        addToMapping("Collection"),
        addToEntities("Collection")
      ],
      manifest: [
        ensureDefaultFields(emptyManifest),
        addToMapping("Manifest"),
        addToEntities("Manifest")
      ],
      canvas: [
        ensureDefaultFields(emptyCanvas),
        addToMapping("Canvas"),
        addToEntities("Canvas")
      ],
      annotationPage: [
        addMissingIdToContentResource("AnnotationPage"),
        ensureDefaultFields(emptyAnnotationPage),
        addToMapping("AnnotationPage"),
        addToEntities("AnnotationPage")
      ],
      annotation: [
        addMissingIdToContentResource("Annotation"),
        ensureArrayOnAnnotation,
        addToMapping("Annotation"),
        addToEntities("Annotation")
      ],
      contentResource: [
        addMissingIdToContentResource("ContentResource"),
        addToMapping("ContentResource"),
        addToEntities("ContentResource")
      ],
      range: [
        ensureDefaultFields(emptyRange),
        addToMapping("Range", "Canvas"),
        addToEntities("Range", "Canvas")
      ],
      agent: [
        ensureDefaultFields(emptyAgent),
        addToMapping("Agent"),
        addToEntities("Agent")
      ]
    });
    const resource = traversal.traverseUnknown(entity);
    return { entities, resource, mapping };
  }
  const UNSET = "__$UNSET$__";
  const UNWRAP = "__$UNWRAP$__";
  function resolveIfExists$1(state, url) {
    const request = state.requests[url];
    const resourceType = state.mapping[url];
    if (!resourceType || request && request.resourceUri && !state.entities[resourceType][request.resourceUri]) {
      return void 0;
    }
    return state.entities[resourceType][request ? request.resourceUri : url];
  }
  function serializedFieldsToObject(fields) {
    const object = {};
    for (const [key, value] of fields) {
      if (key === UNWRAP && value !== UNSET) {
        return value;
      }
      if (value !== UNSET && typeof value !== "undefined" && value !== null) {
        object[key] = value;
      }
    }
    return object;
  }
  function serialize(state, subject, config) {
    if (!subject.type || !subject.id) {
      throw new Error("Unknown entity");
    }
    if (!config[subject.type]) {
      throw new Error(`Serializer not found for ${subject.type}`);
    }
    function flatten(sub) {
      const generator = config[sub.type];
      if (!generator) {
        return UNSET;
      }
      const resource = resolveIfExists$1(state, sub.id) || (sub.id && sub.type ? sub : null);
      if (!resource) {
        return UNSET;
      }
      const iterator = generator(resource, state, { isTopLevel: subject.id === sub.id });
      let current = iterator.next();
      while (!current.done) {
        const requestToHydrate = current.value;
        let next = UNSET;
        if (requestToHydrate) {
          if (Array.isArray(requestToHydrate)) {
            const nextList = [];
            for (const req of requestToHydrate) {
              nextList.push(flatten(req));
            }
            next = nextList;
          } else {
            next = flatten(requestToHydrate);
          }
        }
        current = iterator.next(next);
      }
      if (current.value === UNSET) {
        return UNSET;
      }
      return serializedFieldsToObject(current.value);
    }
    return flatten(subject);
  }
  function languageString2to3(value) {
    if (!value) {
      return void 0;
    }
    const languages = Object.keys(value);
    if (languages.length === 0) {
      return void 0;
    }
    if (languages.length === 1) {
      const language = languages[0];
      if (!language) {
        return "";
      }
      const singleValue = (value[language] || []).join("");
      if (language === "@none" || language === "none" || language === "en") {
        return singleValue;
      }
      return {
        "@language": language,
        "@value": singleValue
      };
    }
    return languages.map((language) => {
      return {
        "@language": language,
        "@value": (value[language] || []).join("")
      };
    });
  }
  function parseCanvasTarget(target) {
    if (Array.isArray(target)) {
      return target.map((t) => parseCanvasTarget(t));
    }
    if (typeof target === "string") {
      return target;
    }
    if (target.type && target.type === "Canvas") {
      return target.id;
    }
    return target;
  }
  function unNestArray(oneOrArray, onlyOne = false) {
    if (!oneOrArray) {
      return void 0;
    }
    if (oneOrArray.length > 1 && !onlyOne) {
      return oneOrArray;
    }
    return oneOrArray[0] || void 0;
  }
  function convertService(service) {
    if (!service) {
      return void 0;
    }
    if (typeof service === "string") {
      return {
        "@id": service
      };
    }
    if ("@id" in service) {
      const newService = { ...service };
      delete newService["@type"];
      return newService;
    }
    return {
      "@context": "http://iiif.io/api/image/2/context.json",
      "@id": service.id,
      profile: `http://iiif.io/api/image/2/profiles/${service.profile}.json`
    };
  }
  function technicalProperties$1(props, type) {
    return [
      ["@id", props.id],
      ["@type", type],
      ["format", props.format],
      ["height", props.height],
      ["width", props.width],
      ["viewingDirection", props.viewingDirection !== "left-to-right" ? props.viewingDirection : void 0]
    ];
  }
  function* descriptiveProperties$1(prop) {
    const provider = prop.provider ? yield prop.provider[0] : void 0;
    return [
      ["label", languageString2to3(prop.label)],
      [
        "metadata",
        prop.metadata && prop.metadata.length ? prop.metadata.map((item) => ({
          label: languageString2to3(item.label) || "",
          value: languageString2to3(item.value) || ""
        })) : void 0
      ],
      ["description", languageString2to3(prop.summary)],
      ["thumbnail", unNestArray(yield prop.thumbnail)],
      ["navDate", prop.navDate],
      ["logo", provider ? unNestArray(provider.logo) : void 0],
      ["homepage", provider ? provider.homepage : void 0],
      ["attribution", prop.requiredStatement ? languageString2to3(prop.requiredStatement.value) : void 0]
    ];
  }
  function* linkingProperties$1(prop) {
    return [
      ["seeAlso", unNestArray(yield prop.seeAlso)],
      ["service", unNestArray((prop.service || []).map(convertService))],
      ["rendering", unNestArray(yield prop.rendering)],
      ["startCanvas", prop.start ? prop.start.id : void 0]
    ];
  }
  const serializeConfigPresentation2 = {
    Manifest: function* (entity) {
      return [
        ...technicalProperties$1(entity, "sc:Manifest"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        [
          "sequences",
          [
            {
              "@id": `${entity.id}/sequence0`,
              "@type": "sc:Sequence",
              canvases: yield entity.items
            }
          ]
        ],
        ["structures", yield entity.structures]
      ];
    },
    Canvas: function* (entity) {
      const paintingPage = yield entity.items;
      const resources = paintingPage[0];
      return [
        ...technicalProperties$1(entity, "sc:Canvas"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        ["images", resources ? [resources.resources] : void 0],
        [
          "annotations",
          entity.annotations && entity.annotations.length ? unNestArray(yield entity.annotations) : void 0
        ]
      ];
    },
    AnnotationPage: function* (entity) {
      return [
        ...technicalProperties$1(entity, "sc:AnnotationList"),
        ...yield* descriptiveProperties$1(entity),
        ["resources", entity.items && entity.items.length ? unNestArray(yield entity.items) : void 0]
      ];
    },
    Annotation: function* (entity) {
      return [
        ["@id", entity.id],
        ["@type", "oa:Annotation"],
        ["motivation", "sc:painting"],
        ["on", parseCanvasTarget(entity.target)],
        ["resource", unNestArray(yield entity.body, true)]
      ];
    },
    ContentResource: function* (entity) {
      switch (entity.type) {
        case "Image":
          return [
            ...technicalProperties$1(entity, "dctypes:Image"),
            ...yield* descriptiveProperties$1(entity),
            ...yield* linkingProperties$1(entity)
          ];
        case "Text":
        case "Dataset":
        default:
          return [...technicalProperties$1(entity, void 0), ...yield* descriptiveProperties$1(entity)];
      }
    },
    AnnotationCollection: function* (entity) {
      return [
        ["@id", entity.id],
        ["@type", "sc:Layer"],
        ["label", languageString2to3(entity.label)]
      ];
    },
    Collection: function* (entity) {
      return [
        ...technicalProperties$1(entity, "sc:Collection"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        ["members", yield* entity.items]
      ];
    },
    Range: function* (entity) {
      const members = [];
      const canvases = [];
      if (entity.items) {
        for (const item of entity.items) {
          const canvas = yield item;
          members.push({
            "@id": item.id,
            "@type": item.type,
            label: canvas ? canvas.label : void 0,
            within: entity.id
          });
          if (item.type === "Canvas") {
            canvases.push(item.id);
          }
        }
      }
      return [
        ...technicalProperties$1(entity, "sc:Range"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        ["canvases", canvases.length === members.length ? canvases : void 0],
        ["members", canvases.length !== members.length ? members : void 0]
      ];
    }
  };
  function technicalProperties(entity) {
    var _a;
    return [
      ["id", !((_a = entity.id) == null ? void 0 : _a.startsWith("vault://")) ? entity.id : void 0],
      ["type", entity.type],
      ["format", entity.format],
      ["profile", entity.profile],
      ["height", entity.height],
      ["width", entity.width],
      ["duration", entity.duration || void 0],
      ["viewingDirection", entity.viewingDirection !== "left-to-right" ? entity.viewingDirection : void 0],
      ["behavior", entity.behavior && entity.behavior.length ? entity.behavior : void 0],
      ["timeMode", entity.timeMode],
      ["motivation", Array.isArray(entity.motivation) ? entity.motivation[0] : entity.motivation]
    ];
  }
  function filterEmpty(item) {
    if (!item || item.length === 0) {
      return void 0;
    }
    return item;
  }
  function service2compat(service) {
    if (service && service.type && service.type === "ImageService2") {
      const { id, type, profile: _profile, ..._service } = service;
      const profile = typeof _profile === "string" ? _profile : Array.isArray(_profile) ? _profile.find((p) => typeof p === "string") : "";
      return {
        "@id": id,
        "@type": type,
        profile: profile ? profile.startsWith("http") ? profile : `http://iiif.io/api/image/2/${profile}.json` : "http://iiif.io/api/image/2/level0.json",
        ..._service
      };
    }
    return service;
  }
  function filterService2Compat(services) {
    if (!services || services.length === 0) {
      return void 0;
    }
    return services.map(service2compat);
  }
  function* descriptiveProperties(entity) {
    return [
      ["label", entity.label],
      ["metadata", filterEmpty(entity.metadata)],
      ["summary", entity.summary],
      ["requiredStatement", entity.requiredStatement],
      ["rights", entity.rights],
      ["navDate", entity.navDate],
      ["language", entity.language],
      ["thumbnail", filterEmpty(yield entity.thumbnail)],
      ["placeholderCanvas", yield entity.placeholderCanvas],
      ["accompanyingCanvas", yield entity.accompanyingCanvas],
      ["provider", filterEmpty(yield entity.provider)]
    ];
  }
  function* linkingProperties(entity) {
    return [
      ["seeAlso", filterEmpty(yield entity.seeAlso)],
      ["service", filterService2Compat(entity.service)],
      ["services", filterService2Compat(entity.services)],
      ["rendering", filterEmpty(yield entity.rendering)],
      ["supplementary", filterEmpty(yield entity.supplementary)],
      ["homepage", filterEmpty(yield entity.homepage)],
      ["logo", filterEmpty(yield entity.logo)],
      ["partOf", filterEmpty(yield entity.partOf)],
      ["start", entity.start]
    ];
  }
  const serializeConfigPresentation3 = {
    Manifest: function* (entity, state, { isTopLevel }) {
      if (!isTopLevel) {
        return [
          ...technicalProperties(entity),
          ...yield* descriptiveProperties(entity)
        ];
      }
      return [
        ["@context", "http://iiif.io/api/presentation/3/context.json"],
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["items", yield entity.items],
        ["structures", filterEmpty(yield entity.structures)],
        ["annotations", filterEmpty(yield entity.annotations)]
      ];
    },
    Canvas: function* (entity) {
      return [
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["items", yield entity.items],
        ["annotations", filterEmpty(yield entity.annotations)]
      ];
    },
    Agent: function* (entity) {
      return [
        ["id", entity.id],
        ["type", "Agent"],
        ["label", entity.label],
        ...yield* linkingProperties(entity)
      ];
    },
    AnnotationPage: function* (entity) {
      const entries = Object.entries(entity).map(([key, item]) => {
        return [key, Array.isArray(item) ? filterEmpty(item) : item];
      }).filter(([key, value]) => {
        return key !== "items";
      });
      return [
        ...entries,
        ...yield* linkingProperties(entity),
        ["items", yield entity.items]
      ];
    },
    Service: function* (entity) {
      return [[UNWRAP, service2compat(entity)]];
    },
    Annotation: function* (entity) {
      const entries = Object.entries(entity).map(([key, item]) => {
        if (key === "motivation") {
          return [key, Array.isArray(item) ? item[0] : item];
        }
        return [key, Array.isArray(item) ? filterEmpty(item) : item];
      }).filter(([key]) => {
        return key !== "body";
      });
      const resolvedBody = yield entity.body;
      return [...entries, ["body", resolvedBody.length === 1 ? resolvedBody[0] : resolvedBody]];
    },
    ContentResource: function* (entity) {
      return [
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["annotations", filterEmpty(yield entity.annotations)],
        ["items", filterEmpty(yield entity.items)]
      ];
    },
    AnnotationCollection: function* (entity) {
      return [
        ["id", entity.id],
        ["type", "AnnotationCollection"],
        ["label", entity.label]
      ];
    },
    Collection: function* (entity, state, { isTopLevel }) {
      if (isTopLevel) {
        return [
          ["@context", "http://iiif.io/api/presentation/3/context.json"],
          ...technicalProperties(entity),
          ...yield* descriptiveProperties(entity),
          ...yield* linkingProperties(entity),
          ["items", filterEmpty(yield entity.items)]
        ];
      }
      return [...technicalProperties(entity), ...yield* descriptiveProperties(entity)];
    },
    Range: function* (entity) {
      const rangeItems = [];
      for (const item of entity.items) {
        if (item.type === "Range") {
          rangeItems.push(yield item);
        } else {
          rangeItems.push(item);
        }
      }
      return [
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["items", rangeItems],
        ["annotations", filterEmpty(yield entity.annotations)]
      ];
    }
  };

  function n(n){return null==n}function t(n){throw new Error("Argument "+n+" is empty.")}function o(n){return "string"==typeof n||"symbol"==typeof n}function u(n){return !o(n)}function a(n){throw new Error("Argument "+n+" is invalid, it should be an action type of type: string | symbol")}function s(r,e){n(r)&&t(1),u(r)&&a(1);return Object.assign((function(){var n=null!=e?e.apply(void 0,arguments):void 0;return Object.assign({type:r},n)}),{getType:function(){return r},toString:function(){return r}})}function y(r,e,i){return n(r)&&t(1),u(r)&&a(1),function(){return s(r,(function(){var n=arguments.length<=0?void 0:arguments[0],t=arguments.length<=1?void 0:arguments[1];return null==e&&null==i||(n=null!=e?e.apply(void 0,arguments):void 0,t=null!=i?i.apply(void 0,arguments):void 0),Object.assign({},void 0!==n&&{payload:n},{},void 0!==t&&{meta:t})}))}}

  const IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
  const MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
  const REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
  const ADD_REFERENCE = "@iiif/ADD_REFERENCE";
  const REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
  const importEntities = y(IMPORT_ENTITIES)();
  const modifyEntityField = y(MODIFY_ENTITY_FIELD)();
  const reorderEntityField = y(REORDER_ENTITY_FIELD)();
  const addReference = y(ADD_REFERENCE)();
  const removeReference = y(REMOVE_REFERENCE)();
  const entityActions = { importEntities, modifyEntityField, reorderEntityField, addReference, removeReference };

  const ADD_MAPPING = "@iiif/ADD_MAPPING";
  const ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
  const addMapping = y(ADD_MAPPING)();
  const addMappings = y(ADD_MAPPINGS)();

  const SET_META_VALUE = "@iiif/SET_META_VALUE";
  const SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
  const UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
  const setMetaValue = y(SET_META_VALUE)();
  const setMetaValueDynamic = y(SET_META_VALUE_DYNAMIC)();
  const unsetMetaValue = y(UNSET_META_VALUE)();
  const metaActions = {
    setMetaValue,
    setMetaValueDynamic,
    unsetMetaValue
  };

  const RESOURCE_ERROR = "RESOURCE_ERROR";
  const RESOURCE_LOADING = "RESOURCE_LOADING";
  const RESOURCE_READY = "RESOURCE_READY";
  const REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
  const REQUEST_ERROR = "@iiif/REQUEST_ERROR";
  const REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
  const REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
  const REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
  const requestResource = y(REQUEST_RESOURCE)();
  const requestError = y(REQUEST_ERROR)();
  const requestMismatch = y(REQUEST_MISMATCH)();
  const requestComplete = y(REQUEST_COMPLETE)();
  y(REQUEST_OFFLINE_RESOURCE)();

  const BATCH_ACTIONS = "@iiif/BATCH";
  const BATCH_IMPORT = "@iiif/BATCH_IMPORT";
  const batchActions = y(BATCH_ACTIONS)();
  y(BATCH_IMPORT)();

  const actionListFromResource = (id, response) => {
    const { entities, resource, mapping } = normalize(response);
    if (resource.id === void 0) {
      return [requestError({ id, message: "ID is not defined in resource." })];
    }
    const actions = [importEntities({ entities }), addMappings({ mapping })];
    if (resource.id !== id) {
      actions.push(addMapping({ id, type: resource.type }));
      actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
    }
    actions.push(requestComplete({ id }));
    return actions;
  };

  const safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
      return newInputs === lastInputs;
    }
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (let i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }

  function resolveIfExists(state, url) {
    const request = state.iiif.requests[url];
    const resourceType = state.iiif.mapping[url];
    if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
      return void 0;
    }
    return state.iiif.entities[resourceType][request.resourceUri];
  }

  function createFetchHelper(store, fetcher, { waitTimeout = 30 } = {}) {
    return async (url, options) => {
      const state = store.getState();
      const request = state.iiif.requests[url];
      if (request) {
        switch (request.loadingState) {
          case RESOURCE_ERROR:
            break;
          case RESOURCE_LOADING: {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise((resolve, reject) => setTimeout(() => {
                  didContinue = true;
                  reject();
                }, waitTimeout * 60))
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              break;
            }
            break;
          }
          case RESOURCE_READY: {
            const resolvedEntity = resolveIfExists(state, url);
            if (resolvedEntity) {
              return resolvedEntity;
            }
            break;
          }
        }
      }
      store.dispatch(requestResource({ id: url }));
      try {
        const resource = await fetcher(url, options);
        if (!resource.id && !resource["@id"]) {
          if (resource["@type"]) {
            resource["@id"] = url;
            resource.id = url;
          } else {
            resource.id = url;
          }
        }
        const toDispatch = actionListFromResource(url, resource);
        store.dispatch(batchActions({ actions: toDispatch }));
        return resolveIfExists(store.getState(), url);
      } catch (err) {
        store.dispatch(requestError({ id: url, message: err.toString() }));
        throw err;
      }
    };
  }

  function getDefaultEntities() {
    return {
      Collection: {},
      Manifest: {},
      Canvas: {},
      AnnotationPage: {},
      AnnotationCollection: {},
      Annotation: {},
      ContentResource: {},
      Range: {},
      Service: {},
      Selector: {},
      Agent: {}
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  // Inlined version of the `symbol-observable` polyfill
  var $$observable = (function () {
    return typeof Symbol === 'function' && Symbol.observable || '@@observable';
  })();

  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */
  var randomString = function randomString() {
    return Math.random().toString(36).substring(7).split('').join('.');
  };

  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };

  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */
  function isPlainObject(obj) {
    if (typeof obj !== 'object' || obj === null) return false;
    var proto = obj;

    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(obj) === proto;
  }

  // Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
  function miniKindOf(val) {
    if (val === void 0) return 'undefined';
    if (val === null) return 'null';
    var type = typeof val;

    switch (type) {
      case 'boolean':
      case 'string':
      case 'number':
      case 'symbol':
      case 'function':
        {
          return type;
        }
    }

    if (Array.isArray(val)) return 'array';
    if (isDate(val)) return 'date';
    if (isError(val)) return 'error';
    var constructorName = ctorName(val);

    switch (constructorName) {
      case 'Symbol':
      case 'Promise':
      case 'WeakMap':
      case 'WeakSet':
      case 'Map':
      case 'Set':
        return constructorName;
    } // other


    return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
  }

  function ctorName(val) {
    return typeof val.constructor === 'function' ? val.constructor.name : null;
  }

  function isError(val) {
    return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
  }

  function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
  }

  function kindOf(val) {
    var typeOfVal = typeof val;

    {
      typeOfVal = miniKindOf(val);
    }

    return typeOfVal;
  }

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */

  function createStore$1(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
      throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');
    }

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error("Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
      }

      return enhancer(createStore$1)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error("Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    /**
     * This makes a shallow copy of currentListeners so we can use
     * nextListeners as a temporary list while dispatching.
     *
     * This prevents any bugs around consumers calling
     * subscribe/unsubscribe in the middle of a dispatch.
     */

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */


    function getState() {
      if (isDispatching) {
        throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
      }

      return currentState;
    }
    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */


    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error("Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
      }

      if (isDispatching) {
        throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
      }

      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        if (isDispatching) {
          throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
        }

        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
        currentListeners = null;
      };
    }
    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */


    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error("Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;

      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }
    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */


    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error("Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
      }

      currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
      // Any reducers that existed in both the new and old rootReducer
      // will receive the previous state. This effectively populates
      // the new state tree with any relevant data from the old one.

      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */


    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            throw new Error("Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe
          };
        }
      }, _ref[$$observable] = function () {
        return this;
      }, _ref;
    } // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.


    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }

  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */
  function warning(message) {
    /* eslint-disable no-console */
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    /* eslint-enable no-console */


    try {
      // This error was thrown as a convenience so that if you enable
      // "break on all exceptions" in your console,
      // it would pause the execution at this line.
      throw new Error(message);
    } catch (e) {} // eslint-disable-line no-empty

  }

  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }

    if (!isPlainObject(inputState)) {
      return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
    }

    var unexpectedKeys = Object.keys(inputState).filter(function (key) {
      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });
    unexpectedKeys.forEach(function (key) {
      unexpectedKeyCache[key] = true;
    });
    if (action && action.type === ActionTypes.REPLACE) return;

    if (unexpectedKeys.length > 0) {
      return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
    }
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {
        type: ActionTypes.INIT
      });

      if (typeof initialState === 'undefined') {
        throw new Error("The slice reducer for key \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
      }

      if (typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined') {
        throw new Error("The slice reducer for key \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle '" + ActionTypes.INIT + "' or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
      }
    });
  }
  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */


  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      {
        if (typeof reducers[key] === 'undefined') {
          warning("No reducer provided for key \"" + key + "\"");
        }
      }

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }

    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
    // keys multiple times.

    var unexpectedKeyCache;

    {
      unexpectedKeyCache = {};
    }

    var shapeAssertionError;

    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

        if (warningMessage) {
          warning(warningMessage);
        }
      }

      var hasChanged = false;
      var nextState = {};

      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);

        if (typeof nextStateForKey === 'undefined') {
          var actionType = action && action.type;
          throw new Error("When called with an action of type " + (actionType ? "\"" + String(actionType) + "\"" : '(unknown type)') + ", the slice reducer for key \"" + _key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.");
        }

        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }

      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }

  /**
   * Composes single-argument functions from right to left. The rightmost
   * function can take multiple arguments as it provides the signature for
   * the resulting composite function.
   *
   * @param {...Function} funcs The functions to compose.
   * @returns {Function} A function obtained by composing the argument functions
   * from right to left. For example, compose(f, g, h) is identical to doing
   * (...args) => f(g(h(...args))).
   */
  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(void 0, arguments));
      };
    });
  }

  /**
   * Creates a store enhancer that applies middleware to the dispatch method
   * of the Redux store. This is handy for a variety of tasks, such as expressing
   * asynchronous actions in a concise manner, or logging every action payload.
   *
   * See `redux-thunk` package as an example of the Redux middleware.
   *
   * Because middleware is potentially asynchronous, this should be the first
   * store enhancer in the composition chain.
   *
   * Note that each middleware will be given the `dispatch` and `getState` functions
   * as named arguments.
   *
   * @param {...Function} middlewares The middleware chain to be applied.
   * @returns {Function} A store enhancer applying the middleware.
   */

  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function () {
        var store = createStore.apply(void 0, arguments);

        var _dispatch = function dispatch() {
          throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
        };

        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose.apply(void 0, chain)(store.dispatch);
        return _objectSpread2(_objectSpread2({}, store), {}, {
          dispatch: _dispatch
        });
      };
    };
  }

  /*
   * This is a dummy function to check if the function name has been altered by minification.
   * If the function has been minified and NODE_ENV !== 'production', warn the user.
   */

  function isCrushed() {}

  if (typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
  }

  const mappingReducer = (state = {}, action) => {
    switch (action.type) {
      case ADD_MAPPING:
        return {
          ...state,
          [action.payload.id]: action.payload.type
        };
      case ADD_MAPPINGS:
        return {
          ...state,
          ...action.payload.mapping
        };
      default:
        return state;
    }
  };

  function isReferenceList(state, id, type, key) {
    return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
  }

  function quickMerge(a, b) {
    const newResource = {};
    const added = [];
    for (const [key, value] of Object.entries(a || {})) {
      added.push(key);
      const bValue = (b || {})[key];
      if (!bValue || bValue.length === 0) {
        newResource[key] = value;
        continue;
      }
      newResource[key] = bValue;
    }
    for (const [key, value] of Object.entries(b || {})) {
      if (added.indexOf(key) !== -1) {
        continue;
      }
      newResource[key] = value;
    }
    return newResource;
  }

  const entitiesReducer = (state = getDefaultEntities(), action) => {
    switch (action.type) {
      case MODIFY_ENTITY_FIELD: {
        if (!state[action.payload.type] || !state[action.payload.type][action.payload.id]) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        if (typeof entity === "string") {
          return state;
        }
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: action.payload.value
            }
          }
        };
      }
      case REORDER_ENTITY_FIELD: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        if (typeof entity === "string") {
          return state;
        }
        const result = Array.from(entity[action.payload.key]);
        const [removed] = result.splice(action.payload.startIndex, 1);
        result.splice(action.payload.endIndex, 0, removed);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      case IMPORT_ENTITIES: {
        const keys = Object.keys(action.payload.entities);
        const toReturn = { ...state };
        for (const key of keys) {
          const entities = action.payload.entities[key];
          const newEntities = { ...state[key] || {} };
          let changed = false;
          const ids = Object.keys(entities || {}) || [];
          if (entities && ids) {
            for (const id of ids) {
              changed = true;
              newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
            }
            if (changed) {
              toReturn[key] = newEntities;
            }
          }
        }
        return toReturn;
      }
      case ADD_REFERENCE: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        const result = Array.from(entity[action.payload.key]);
        result.splice(action.payload.index || result.length + 1, 0, action.payload.reference);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      case REMOVE_REFERENCE: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        const result = Array.from(entity[action.payload.key]);
        const indexToRemove = action.payload.index || result.findIndex((e) => e && e.id === action.payload.reference.id);
        if (indexToRemove === -1) {
          return state;
        }
        if (result[indexToRemove]?.id !== action.payload.reference.id) {
          return state;
        }
        result.splice(indexToRemove, 1);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      default:
        return state;
    }
  };

  const requestReducer = (state = {}, action) => {
    switch (action.type) {
      case REQUEST_RESOURCE:
      case REQUEST_OFFLINE_RESOURCE:
        return {
          ...state,
          [action.payload.id]: {
            requestUri: action.payload.id,
            loadingState: RESOURCE_LOADING,
            uriMismatch: false,
            resourceUri: action.payload.id
          }
        };
      case REQUEST_MISMATCH:
        return {
          ...state,
          [action.payload.requestId]: {
            ...state[action.payload.requestId] || {},
            uriMismatch: true,
            resourceUri: action.payload.actualId
          },
          [action.payload.actualId]: {
            requestUri: action.payload.requestId,
            loadingState: state[action.payload.requestId].loadingState,
            uriMismatch: true,
            resourceUri: action.payload.actualId
          }
        };
      case REQUEST_ERROR:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_ERROR,
            error: action.payload.message
          }
        };
      case REQUEST_COMPLETE:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_READY,
            error: void 0
          }
        };
    }
    return state;
  };

  const metaReducer = (state = {}, action) => {
    const { id, updateValue, value, meta, key } = action && action.payload || {};
    switch (action.type) {
      case SET_META_VALUE: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: value
            }
          }
        };
      }
      case SET_META_VALUE_DYNAMIC: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
            }
          }
        };
      }
      case UNSET_META_VALUE: {
        if (state[id] && state[id][meta] && state[id][meta][key]) {
          return {
            ...state,
            [id]: {
              ...state[id] || {},
              [meta]: {
                ...state[id] ? state[id][meta] || {} : {},
                [key]: void 0
              }
            }
          };
        }
        return state;
      }
      default:
        return state;
    }
  };

  function createBatchReducer(rootReducer) {
    return (state, action) => {
      if (action && action.type === BATCH_ACTIONS) {
        return action.payload.actions.reduce(rootReducer, state);
      }
      if (action && action.type === BATCH_IMPORT) {
        return action.payload.state;
      }
      return rootReducer(state, action);
    };
  }

  const reducers = combineReducers({
    mapping: mappingReducer,
    entities: entitiesReducer,
    requests: requestReducer,
    meta: metaReducer
  });
  const composeEnhancers = typeof window !== "undefined" ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose : compose;
  function createStore(options = {}) {
    const {
      enableDevtools = true,
      iiifStoreName = "iiif",
      defaultState = {},
      extraMiddleware = [],
      customReducers = {}
    } = options;
    const rootReducer = combineReducers({ [iiifStoreName]: reducers, ...customReducers });
    const store = createStore$1(createBatchReducer(rootReducer), defaultState, enableDevtools ? composeEnhancers(applyMiddleware(...extraMiddleware)) : compose(applyMiddleware(...extraMiddleware)));
    return store;
  }

  function mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]));},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e);}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e);});}}}

  class Vault {
    options;
    store;
    emitter;
    isBatching = false;
    batchQueue = [];
    remoteFetcher;
    staticFetcher;
    constructor(options, store) {
      this.options = Object.assign({
        reducers: {},
        middleware: [],
        defaultState: {},
        customFetcher: this.defaultFetcher,
        enableDevtools: true
      }, options || {});
      this.store = store || createStore({
        customReducers: this.options.reducers,
        extraMiddleware: [...this.options.middleware, this.middleware],
        defaultState: this.options.defaultState,
        enableDevtools: this.options.enableDevtools
      });
      this.emitter = mitt();
      this.remoteFetcher = createFetchHelper(this.store, this.options.customFetcher);
      this.staticFetcher = createFetchHelper(this.store, (id, json) => json);
    }
    defaultFetcher = (url) => {
      return fetch(url).then((r) => r.json());
    };
    batch(cb) {
      this.isBatching = true;
      try {
        cb(this);
        this.store.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e;
      }
      this.batchQueue = [];
      this.isBatching = false;
    }
    async asyncBatch(cb) {
      this.isBatching = true;
      try {
        await cb(this);
        this.store.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e;
      }
      this.batchQueue = [];
      this.isBatching = false;
    }
    modifyEntityField(entity, key, value) {
      this.dispatch(entityActions.modifyEntityField({
        id: entity.id,
        type: entity.type,
        key,
        value
      }));
    }
    dispatch(action) {
      if (!this.isBatching) {
        this.store.dispatch(action);
      } else {
        this.batchQueue.push(action);
      }
    }
    middleware = (store) => (next) => (action) => {
      if (action.type === BATCH_ACTIONS) {
        for (const realAction of action.payload.actions) {
          this.emitter.emit(realAction.type, { realAction, state: store.getState() });
        }
        const state2 = next(action);
        for (const realAction of action.payload.actions) {
          this.emitter.emit(`after:${action.type}`, { action, state: state2 });
        }
        return state2;
      }
      this.emitter.emit(action.type, { action, state: store.getState() });
      const state = next(action);
      this.emitter.emit(`after:${action.type}`, { action, state });
      return state;
    };
    serialize(entity, config) {
      return serialize(this.getState().iiif, entity, config);
    }
    toPresentation2(entity) {
      return this.serialize(entity, serializeConfigPresentation2);
    }
    toPresentation3(entity) {
      return this.serialize(entity, serializeConfigPresentation3);
    }
    hydrate(reference, type) {
      return this.get(reference, type, { skipSelfReturn: false });
    }
    get(reference, type, options = {}) {
      if (typeof type !== "string") {
        options = type || {};
        type = void 0;
      }
      const { skipSelfReturn = true } = options || {};
      if (Array.isArray(reference)) {
        return reference.map((i) => this.get(i, options));
      }
      const state = this.getState();
      if (typeof reference === "string") {
        const _type2 = type ? type : state.iiif.mapping[reference];
        if (!_type2) {
          if (skipSelfReturn) {
            return null;
          }
          return { id: reference, type: "unknown" };
        }
        reference = { id: reference, type: _type2 };
      }
      const _type = type ? type : reference.type;
      const _id = reference.id;
      const entities = state.iiif.entities[_type];
      if (!entities) {
        const request = state.iiif.requests[_id];
        if (request && request.resourceUri !== _id) {
          return this.get(request.resourceUri, options);
        }
        if (skipSelfReturn) {
          return null;
        }
        return reference;
      }
      return entities[reference.id] || (skipSelfReturn ? null : reference);
    }
    select(selector) {
      return selector(this.getState());
    }
    getStore() {
      return this.store;
    }
    getState() {
      return this.store.getState();
    }
    loadManifest(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json);
    }
    loadCollection(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json);
    }
    load(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      if (json) {
        return this.staticFetcher(_id, json);
      }
      return this.remoteFetcher(_id);
    }
    areInputsEqual(newInputs, lastInputs) {
      return areInputsEqual(newInputs, lastInputs);
    }
    subscribe(selector, subscription, skipInitial) {
      if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
        skipInitial = subscription;
        subscription = selector;
        selector = (a) => a;
      }
      let lastState = skipInitial ? null : selector(this.store.getState());
      if (!skipInitial) {
        subscription(lastState, this);
      }
      return this.store.subscribe(() => {
        const state = this.store.getState();
        const selectedState = selector(state);
        if (lastState !== selectedState && !areInputsEqual(lastState, selectedState)) {
          subscription(selectedState, this);
        }
        lastState = selectedState;
      });
    }
    async ensureLoaded(_id) {
      const id = typeof _id === "string" ? _id : _id.id;
      if (!this.requestStatus(id)) {
        await this.load(id);
      }
    }
    requestStatus(id) {
      return this.select((state) => {
        return state.iiif.requests[id];
      });
    }
    getResourceMeta(resource, metaKey) {
      const resourceMeta = this.getState().iiif.meta[resource];
      if (!resourceMeta) {
        return void 0;
      }
      if (!metaKey) {
        return resourceMeta;
      }
      return resourceMeta[metaKey];
    }
    setMetaValue([id, meta, key], newValueOrUpdate) {
      this.dispatch(typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
        id,
        meta,
        key,
        updateValue: newValueOrUpdate
      }) : metaActions.setMetaValue({
        id,
        meta,
        key,
        value: newValueOrUpdate
      }));
    }
  }

  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    return {};
  }

  function globalVault(options) {
    const g = getGlobal();
    try {
      const gv = g["IIIF_VAULT"];
      if (gv) {
        return gv;
      }
    } catch (e) {
    }
    const newVault = new Vault(options);
    try {
      g["IIIF_VAULT"] = newVault;
    } catch (e) {
    }
    return newVault;
  }

  exports.Vault = Vault;
  exports.globalVault = globalVault;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
