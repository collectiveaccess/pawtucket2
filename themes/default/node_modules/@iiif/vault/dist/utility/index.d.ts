import { CollectionNormalized, ManifestNormalized, CanvasNormalized, AnnotationPageNormalized, AnnotationCollection, AnnotationNormalized, ContentResource, RangeNormalized, ServiceNormalized, ResourceProviderNormalized, Selector, Reference } from '@iiif/presentation-3';
import * as typesafe_actions from 'typesafe-actions';
import { ActionType } from 'typesafe-actions';
import { Store } from 'redux';

declare const mappingActions: {
    addMapping: typesafe_actions.PayloadActionCreator<"@iiif/ADD_MAPPING", {
        id: string;
        type: string;
    }>;
    addMappings: typesafe_actions.PayloadActionCreator<"@iiif/ADD_MAPPINGS", {
        mapping: {
            [id: string]: string;
        };
    }>;
};
declare type MappingActions = ActionType<typeof mappingActions>;

declare const entityActions: {
    importEntities: typesafe_actions.PayloadActionCreator<"@iiif/IMPORT_ENTITIES", {
        entities: Partial<Entities>;
    }>;
    modifyEntityField: typesafe_actions.PayloadActionCreator<"@iiif/MODIFY_ENTITY_FIELD", {
        type: keyof Entities;
        id: string;
        key: string;
        value: any;
    }>;
    reorderEntityField: typesafe_actions.PayloadActionCreator<"@iiif/REORDER_ENTITY_FIELD", {
        type: keyof Entities;
        id: string;
        key: string;
        startIndex: number;
        endIndex: number;
    }>;
    addReference: typesafe_actions.PayloadActionCreator<"@iiif/ADD_REFERENCE", {
        type: keyof Entities;
        id: string;
        key: string;
        index?: number | undefined;
        reference: {
            id: string;
            type: string;
        } & any;
    }>;
    removeReference: typesafe_actions.PayloadActionCreator<"@iiif/REMOVE_REFERENCE", {
        type: keyof Entities;
        id: string;
        key: string;
        index?: number | undefined;
        reference: {
            id: string;
            type: string;
        } & any;
    }>;
};
declare type EntityActions = ActionType<typeof entityActions>;

declare const metaActions: {
    setMetaValue: typesafe_actions.PayloadActionCreator<"@iiif/SET_META_VALUE", {
        id: string;
        meta: string;
        key: string;
        value: any;
    }>;
    setMetaValueDynamic: typesafe_actions.PayloadActionCreator<"@iiif/SET_META_VALUE_DYNAMIC", {
        id: string;
        meta: string;
        key: string;
        updateValue: (oldValue: any) => any;
    }>;
    unsetMetaValue: typesafe_actions.PayloadActionCreator<"@iiif/UNSET_META_VALUE", {
        id: string;
        meta: string;
        key: string;
    }>;
};
declare type MetaActions = ActionType<typeof metaActions>;

declare const requestActions: {
    requestResource: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_RESOURCE", {
        id: string;
    }>;
    requestError: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_ERROR", {
        id: string;
        message: string;
    }>;
    requestMismatch: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_MISMATCH", {
        requestId: string;
        actualId: string;
    }>;
    requestComplete: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_COMPLETE", {
        id: string;
    }>;
    requestOfflineResource: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_OFFLINE_RESOURCE", {
        id: string;
        entity: unknown;
    }>;
};
declare type RequestActions = ActionType<typeof requestActions>;

declare const batchActions: typesafe_actions.PayloadActionCreator<"@iiif/BATCH", {
    actions: AllActions[];
}>;
declare const batchImport: typesafe_actions.PayloadActionCreator<"@iiif/BATCH_IMPORT", {
    state: EntityStore;
}>;
declare type BatchAction = ActionType<typeof batchActions | typeof batchImport>;

declare type MetaState = Record<string, Record<string, Record<string, any>>>;
declare type RequestState = {
    [id: string]: {
        loadingState: 'RESOURCE_ERROR' | 'RESOURCE_LOADING' | 'RESOURCE_READY';
        uriMismatch: boolean;
        requestUri: string;
        resourceUri: string;
        error?: string;
    };
};
declare type NormalizedEntity = CollectionNormalized | ManifestNormalized | CanvasNormalized | AnnotationPageNormalized | AnnotationCollection | AnnotationNormalized | ContentResource | RangeNormalized | ServiceNormalized | ResourceProviderNormalized | Selector;
declare type Entities = {
    Collection: {
        [id: string]: CollectionNormalized;
    };
    Manifest: {
        [id: string]: ManifestNormalized;
    };
    Canvas: {
        [id: string]: CanvasNormalized;
    };
    AnnotationPage: {
        [id: string]: AnnotationPageNormalized;
    };
    AnnotationCollection: {
        [id: string]: AnnotationCollection;
    };
    Annotation: {
        [id: string]: AnnotationNormalized;
    };
    ContentResource: {
        [id: string]: ContentResource;
    };
    Range: {
        [id: string]: RangeNormalized;
    };
    Service: {
        [id: string]: ServiceNormalized;
    };
    Selector: {
        [id: string]: Selector;
    };
    Agent: {
        [id: string]: ResourceProviderNormalized;
    };
};
declare type EntityStore<Meta extends MetaState = MetaState> = {
    entities: Entities;
    mapping: Record<string, string>;
    requests: RequestState;
    meta: Meta;
};
declare type IIIFStore<Meta extends MetaState = MetaState> = {
    iiif: EntityStore<Meta>;
};
declare type AllActions = MappingActions | RequestActions | EntityActions | MetaActions;
declare type ReduxStore = Store<IIIFStore, AllActions | BatchAction>;

declare const actionListFromResource: (id: string, response: unknown) => AllActions[];

declare function areInputsEqual(newInputs: readonly unknown[] | unknown, lastInputs: readonly unknown[] | unknown): boolean;

declare function createFetchHelper<T>(store: ReduxStore, fetcher: (url: string, options?: T) => any | Promise<any>, { waitTimeout }?: {
    waitTimeout?: number;
}): (url: string, options?: T | undefined) => Promise<NormalizedEntity | undefined>;

declare function getDefaultEntities(): Entities;

declare function resolveIfExists<T extends NormalizedEntity>(state: IIIFStore, url: string): T | undefined;

declare function resolveList<T extends NormalizedEntity>(state: IIIFStore, items: Reference<T>[]): Array<NormalizedEntity>;

export { actionListFromResource, areInputsEqual, createFetchHelper, getDefaultEntities, resolveIfExists, resolveList };
