import { CollectionNormalized, ManifestNormalized, CanvasNormalized, AnnotationPageNormalized, AnnotationCollection, AnnotationNormalized, ContentResource, RangeNormalized, ServiceNormalized, ResourceProviderNormalized, Selector, Reference } from '@iiif/presentation-3';
import * as typesafe_actions from 'typesafe-actions';
import { ActionType } from 'typesafe-actions';
import { Store } from 'redux';
import { SerializeConfig } from '@iiif/parser';

declare const mappingActions: {
    addMapping: typesafe_actions.PayloadActionCreator<"@iiif/ADD_MAPPING", {
        id: string;
        type: string;
    }>;
    addMappings: typesafe_actions.PayloadActionCreator<"@iiif/ADD_MAPPINGS", {
        mapping: {
            [id: string]: string;
        };
    }>;
};
declare type MappingActions = ActionType<typeof mappingActions>;

declare const entityActions: {
    importEntities: typesafe_actions.PayloadActionCreator<"@iiif/IMPORT_ENTITIES", {
        entities: Partial<Entities>;
    }>;
    modifyEntityField: typesafe_actions.PayloadActionCreator<"@iiif/MODIFY_ENTITY_FIELD", {
        type: keyof Entities;
        id: string;
        key: string;
        value: any;
    }>;
    reorderEntityField: typesafe_actions.PayloadActionCreator<"@iiif/REORDER_ENTITY_FIELD", {
        type: keyof Entities;
        id: string;
        key: string;
        startIndex: number;
        endIndex: number;
    }>;
    addReference: typesafe_actions.PayloadActionCreator<"@iiif/ADD_REFERENCE", {
        type: keyof Entities;
        id: string;
        key: string;
        index?: number | undefined;
        reference: {
            id: string;
            type: string;
        } & any;
    }>;
    removeReference: typesafe_actions.PayloadActionCreator<"@iiif/REMOVE_REFERENCE", {
        type: keyof Entities;
        id: string;
        key: string;
        index?: number | undefined;
        reference: {
            id: string;
            type: string;
        } & any;
    }>;
};
declare type EntityActions = ActionType<typeof entityActions>;

declare const metaActions: {
    setMetaValue: typesafe_actions.PayloadActionCreator<"@iiif/SET_META_VALUE", {
        id: string;
        meta: string;
        key: string;
        value: any;
    }>;
    setMetaValueDynamic: typesafe_actions.PayloadActionCreator<"@iiif/SET_META_VALUE_DYNAMIC", {
        id: string;
        meta: string;
        key: string;
        updateValue: (oldValue: any) => any;
    }>;
    unsetMetaValue: typesafe_actions.PayloadActionCreator<"@iiif/UNSET_META_VALUE", {
        id: string;
        meta: string;
        key: string;
    }>;
};
declare type MetaActions = ActionType<typeof metaActions>;

declare const requestActions: {
    requestResource: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_RESOURCE", {
        id: string;
    }>;
    requestError: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_ERROR", {
        id: string;
        message: string;
    }>;
    requestMismatch: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_MISMATCH", {
        requestId: string;
        actualId: string;
    }>;
    requestComplete: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_COMPLETE", {
        id: string;
    }>;
    requestOfflineResource: typesafe_actions.PayloadActionCreator<"@iiif/REQUEST_OFFLINE_RESOURCE", {
        id: string;
        entity: unknown;
    }>;
};
declare type RequestActions = ActionType<typeof requestActions>;

declare const batchActions: typesafe_actions.PayloadActionCreator<"@iiif/BATCH", {
    actions: AllActions[];
}>;
declare const batchImport: typesafe_actions.PayloadActionCreator<"@iiif/BATCH_IMPORT", {
    state: EntityStore;
}>;
declare type BatchAction = ActionType<typeof batchActions | typeof batchImport>;

declare type MetaState = Record<string, Record<string, Record<string, any>>>;
declare type RequestState = {
    [id: string]: {
        loadingState: 'RESOURCE_ERROR' | 'RESOURCE_LOADING' | 'RESOURCE_READY';
        uriMismatch: boolean;
        requestUri: string;
        resourceUri: string;
        error?: string;
    };
};
declare type NormalizedEntity = CollectionNormalized | ManifestNormalized | CanvasNormalized | AnnotationPageNormalized | AnnotationCollection | AnnotationNormalized | ContentResource | RangeNormalized | ServiceNormalized | ResourceProviderNormalized | Selector;
declare type Entities = {
    Collection: {
        [id: string]: CollectionNormalized;
    };
    Manifest: {
        [id: string]: ManifestNormalized;
    };
    Canvas: {
        [id: string]: CanvasNormalized;
    };
    AnnotationPage: {
        [id: string]: AnnotationPageNormalized;
    };
    AnnotationCollection: {
        [id: string]: AnnotationCollection;
    };
    Annotation: {
        [id: string]: AnnotationNormalized;
    };
    ContentResource: {
        [id: string]: ContentResource;
    };
    Range: {
        [id: string]: RangeNormalized;
    };
    Service: {
        [id: string]: ServiceNormalized;
    };
    Selector: {
        [id: string]: Selector;
    };
    Agent: {
        [id: string]: ResourceProviderNormalized;
    };
};
declare type EntityStore<Meta extends MetaState = MetaState> = {
    entities: Entities;
    mapping: Record<string, string>;
    requests: RequestState;
    meta: Meta;
};
declare type IIIFStore<Meta extends MetaState = MetaState> = {
    iiif: EntityStore<Meta>;
};
declare type AllActions = MappingActions | RequestActions | EntityActions | MetaActions;
declare type ReduxStore = Store<IIIFStore, AllActions | BatchAction>;

declare type VaultOptions = {
    reducers: Record<string, any>;
    middleware: [];
    defaultState: any;
    customFetcher: <T>(url: string, options: T) => unknown | Promise<unknown>;
    enableDevtools: boolean;
};
declare type GetOptions = {
    skipSelfReturn?: boolean;
};
declare type EntityRef<Ref extends keyof Entities> = IIIFStore['iiif']['entities'][Ref][string];
declare class Vault {
    private readonly options;
    private readonly store;
    private readonly emitter;
    private isBatching;
    private batchQueue;
    remoteFetcher: (str: string, options?: any) => Promise<NormalizedEntity | undefined>;
    staticFetcher: (str: string, json: any) => Promise<NormalizedEntity | undefined>;
    constructor(options?: Partial<VaultOptions>, store?: ReduxStore);
    defaultFetcher: (url: string) => Promise<any>;
    batch(cb: (vault: this) => void): void;
    asyncBatch(cb: (vault: this) => Promise<void> | void): Promise<void>;
    modifyEntityField(entity: Reference<keyof Entities>, key: string, value: any): void;
    dispatch(action: any): void;
    middleware: (store: ReduxStore) => (next: (action: AllActions | BatchAction) => IIIFStore) => (action: AllActions | BatchAction) => IIIFStore;
    serialize<Return>(entity: Reference<keyof Entities>, config: SerializeConfig): Return;
    toPresentation2<Return>(entity: Reference<keyof Entities>): Return;
    toPresentation3<Return>(entity: Reference<keyof Entities>): Return;
    hydrate<Entity extends EntityRef<any>>(reference: string[] | Reference<any>[] | NormalizedEntity[], type?: string): Entity[];
    hydrate<Entity extends EntityRef<any>>(reference: string[] | Reference<any>[] | NormalizedEntity[]): Entity[];
    hydrate<Entity extends EntityRef<any>>(reference: string | Reference<any> | NormalizedEntity, type?: string): Entity;
    hydrate<Entity extends EntityRef<any>>(reference: string | Reference<any> | NormalizedEntity): Entity;
    get<Entity extends EntityRef<any>>(reference: string[] | Reference<any>[] | NormalizedEntity[], type?: string, opt?: GetOptions): Entity[];
    get<Entity extends EntityRef<any>>(reference: string[] | Reference<any>[] | NormalizedEntity[], opt?: GetOptions): Entity[];
    get<Entity extends EntityRef<any>>(reference: string | Reference<any> | NormalizedEntity, type?: string, opt?: GetOptions): Entity;
    get<Entity extends EntityRef<any>>(reference: string | Reference<any> | NormalizedEntity, opt?: GetOptions): Entity;
    select<R>(selector: (state: IIIFStore) => R): R;
    getStore(): ReduxStore;
    getState(): IIIFStore;
    loadManifest(id: string | Reference<any>, json?: unknown): Promise<ManifestNormalized | undefined>;
    loadCollection(id: string | Reference<any>, json?: unknown): Promise<CollectionNormalized | undefined>;
    load<T>(id: string | Reference<any>, json?: unknown): Promise<T | undefined>;
    areInputsEqual(newInputs: readonly unknown[] | unknown, lastInputs: readonly unknown[] | unknown): boolean;
    subscribe<T>(selector: (state: IIIFStore) => T, subscription: (state: T, vault: Vault) => void, skipInitial: boolean): () => void;
    subscribe<T>(subscription: (state: T, vault: Vault) => void, skipInitial?: boolean): () => void;
    ensureLoaded(_id: string | Reference<any>): Promise<void>;
    requestStatus(id: string): RequestState[any] | undefined;
    getResourceMeta<T = any>(resource: string): Partial<T> | undefined;
    getResourceMeta<T = any, Key extends keyof T = keyof T>(resource: string, metaKey: Key): T[Key] | undefined;
    setMetaValue<Value = any>([id, meta, key]: [string, string, string], newValueOrUpdate: Value | ((oldValue: Value | undefined) => Value)): void;
}

type vaultModule_VaultOptions = VaultOptions;
type vaultModule_GetOptions = GetOptions;
type vaultModule_EntityRef<Ref extends keyof Entities> = EntityRef<Ref>;
type vaultModule_Vault = Vault;
declare const vaultModule_Vault: typeof Vault;
declare namespace vaultModule {
  export {
    vaultModule_VaultOptions as VaultOptions,
    vaultModule_GetOptions as GetOptions,
    vaultModule_EntityRef as EntityRef,
    vaultModule_Vault as Vault,
  };
}

declare global {
    const IIIF_VAULT: Vault;
    const IIIFVault: typeof vaultModule;
}
declare function globalVault(options?: VaultOptions): any;

export { AllActions, Entities, EntityRef, EntityStore, GetOptions, IIIFStore, MetaState, NormalizedEntity, ReduxStore, RequestState, Vault, VaultOptions, globalVault };
