function createEventsHelper(vault) {
  return {
    addEventListener(resource, event, listener, scope) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          const callbacks = registeredCallbacks || [];
          for (const registered of callbacks) {
            if (registered.callback === listener) {
              return callbacks;
            }
          }
          return [...callbacks, { callback: listener, scope }];
        }
      );
      return listener;
    },
    removeEventListener(resource, event, listener) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);
        }
      );
    },
    getListenersAsProps(resourceOrId, scope) {
      const resource = typeof resourceOrId === "string" ? { id: resourceOrId } : resourceOrId;
      if (!resource || !resource.id) {
        return {};
      }
      const hooks = vault.getResourceMeta(resource.id, "eventManager");
      const props = {};
      if (hooks && resource) {
        for (const hook of Object.keys(hooks)) {
          props[hook] = (e) => {
            const fullResource = vault.get(resource);
            for (const { callback, scope: _scope } of hooks[hook] || []) {
              if (!_scope || scope && _scope.indexOf(scope) !== -1) {
                callback(e, fullResource);
              }
            }
          };
        }
      }
      return props;
    }
  };
}
function createStylesHelper(vault) {
  return {
    applyStyles(resource, scope, styles) {
      const id = typeof resource === "string" ? resource : resource.id;
      return vault.setMetaValue([id, "styles", scope], styles);
    },
    getAppliedStyles(resource) {
      const id = typeof resource === "string" ? resource : resource.id;
      return vault.getResourceMeta(id, "styles");
    }
  };
}
function p(e) {
  return e.endsWith("info.json") ? e : e.endsWith("/") ? `${e}info.json` : `${e}/info.json`;
}
const Y = "http://library.stanford.edu/iiif/image-api/compliance.html#level0", F = "http://library.stanford.edu/iiif/image-api/compliance.html#level1", v = "http://library.stanford.edu/iiif/image-api/compliance.html#level2", q = "http://library.stanford.edu/iiif/image-api/conformance.html#level0", O = "http://library.stanford.edu/iiif/image-api/conformance.html#level1", z = "http://library.stanford.edu/iiif/image-api/conformance.html#level2", ii = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0", A = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1", E = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2", ei = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0", L = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1", b = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2", ti = "http://iiif.io/api/image/1/level0.json", ri = "http://iiif.io/api/image/1/profiles/level0.json", M = "http://iiif.io/api/image/1/level1.json", j = "http://iiif.io/api/image/1/profiles/level1.json", W = "http://iiif.io/api/image/1/level2.json", P = "http://iiif.io/api/image/1/profiles/level2.json", ni = "http://iiif.io/api/image/2/level0.json", si = "http://iiif.io/api/image/2/profiles/level0.json", C = "http://iiif.io/api/image/2/level1.json", B = "http://iiif.io/api/image/2/profiles/level1.json", N = "http://iiif.io/api/image/2/level2.json", R = "http://iiif.io/api/image/2/profiles/level2.json", ai = "level0", $ = "level1", H = "level2", oi = "http://iiif.io/api/image/2/level0", G = "http://iiif.io/api/image/2/level1", T = "http://iiif.io/api/image/2/level2", k = [T, v, z, E, b, W, P, N, R, H], Q = [...k, G, F, O, A, L, M, j, C, B, $], V = [oi, G, T, Y, F, v, q, O, z, ii, A, E, ei, L, b, ti, ri, M, j, W, P, ni, si, C, B, N, R, ai, $, H], fi = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["sizeByWhListed"] }, li = { extraFormats: ["jpg"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPx", "regionSquare", "sizeByWhListed", "sizeByH", "sizeByW", "sizeByWh"] }, hi = { extraFormats: ["jpg", "png"], extraQualities: ["default"], extraFeatures: ["baseUriRedirect", "cors", "jsonldMediaType", "regionByPct", "regionByPx", "regionSquare", "rotationBy90s", "sizeByWhListed", "sizeByConfinedWh", "sizeByH", "sizeByPct", "sizeByW", "sizeByWh"] };
function ui(e) {
  return k.indexOf(e) !== -1 ? hi : Q.indexOf(e) !== -1 ? li : fi;
}
function U(e) {
  const i = e ? Array.isArray(e.profile) ? e.profile : [e.profile] : [], t = { extraQualities: [], extraFormats: [], extraFeatures: [] };
  for (let r of i)
    if (typeof r == "string" && (r = ui(r)), !!r) {
      if (r.formats)
        for (const n of r.formats)
          t.extraFormats.indexOf(n) === -1 && t.extraFormats.push(n);
      if (r.qualities)
        for (const n of r.qualities)
          t.extraQualities.indexOf(n) === -1 && t.extraQualities.push(n);
      if (r.supports)
        for (const n of r.supports)
          t.extraFeatures.indexOf(n) === -1 && t.extraFeatures.push(n);
      if (r.maxHeight && (t.maxHeight = r.maxHeight), r.maxWidth && (t.maxWidth = r.maxWidth), r.maxArea && (t.maxArea = r.maxArea), r.extraFormats)
        for (const n of r.extraFormats)
          t.extraFormats.indexOf(n) === -1 && t.extraFormats.push(n);
      if (r.extraQualities)
        for (const n of r.extraQualities)
          t.extraQualities.indexOf(n) === -1 && t.extraQualities.push(n);
      if (r.extraFeatures)
        for (const n of r.extraFeatures)
          t.extraFeatures.indexOf(n) === -1 && t.extraFeatures.push(n);
      r.maxHeight && (t.maxHeight = r.maxHeight), r.maxWidth && (t.maxWidth = r.maxWidth), r.maxArea && (t.maxArea = r.maxArea);
    }
  if (e.extraFormats)
    for (const r of e.extraFormats)
      t.extraFormats.indexOf(r) === -1 && t.extraFormats.push(r);
  if (e.extraFeatures)
    for (const r of e.extraFeatures)
      t.extraFeatures.indexOf(r) === -1 && t.extraFeatures.push(r);
  if (e.extraQualities)
    for (const r of e.extraQualities)
      t.extraQualities.indexOf(r) === -1 && t.extraQualities.push(r);
  return t;
}
function ci(e) {
  try {
    if (e === "full")
      return { full: true };
    if (e === "square")
      return { square: true };
    const i = e.startsWith("pct:"), r = e.substr(i ? 4 : 0).split(",").map((n) => parseFloat(n));
    return { x: r[0], y: r[1], w: r[2], h: r[3], percent: i };
  } catch {
    throw new Error("Expected 'full', 'square' or 'x,y,w,h'. Found " + e);
  }
}
function di(e) {
  const i = { upscaled: false, max: false, confined: false };
  if (e[0] === "^" && (i.upscaled = true, e = e.slice(1)), e === "max" || e === "full")
    return i.max = true, i.serialiseAsFull = e === "full", i;
  if (e[0] === "!" && (i.confined = true, e = e.slice(1)), e[0] === "p")
    return i.percentScale = parseFloat(e.slice(4)), i;
  const t = e.split(",").map((r) => r.trim());
  return t.length && (t[0] !== "" && (i.width = parseInt(t[0], 10)), t[1] !== "" && (i.height = parseInt(t[1], 10))), i;
}
function pi(e) {
  const i = { angle: 0 };
  if (e[0] === "!" && (i.mirror = true, e = e.substr(1)), i.angle = parseFloat(e) % 360, Number.isNaN(i.angle))
    throw new Error(`Invalid rotation ${e}`);
  return i;
}
function gi(e, i = "") {
  const t = e.match(/^(([a-zA-Z]+):\/\/([^/]+))?((.*)+)/);
  if (!t)
    throw new Error(`Invalid or unknown input ${e}`);
  const r = t[2], n = t[3];
  let s = t[4];
  if (s[0] === "/" && (s = s.substr(1)), i.length > 0) {
    if (i[0] === "/" && (i = i.substr(1)), i !== s.substr(0, i.length))
      throw new Error(`Path does not start with prefix (path: ${s}, prefix: ${i})`);
    s = s.substr(i.length);
  }
  return { scheme: r, server: n, path: s, prefix: i };
}
function mi(e, i = "") {
  const { path: t, scheme: r, server: n, prefix: s } = gi(e, i), a = t.split("/").reverse(), [o, l, f, u, ...I] = a, d = I.reverse().filter(Boolean).join("/");
  if (a.length === 1 || o === "")
    return { type: "base", scheme: r, server: n, prefix: s, identifier: d };
  if (o === "info.json") {
    const [, ...g] = a;
    return { type: "info", scheme: r, server: n, prefix: s, identifier: g.reverse().filter(Boolean).join("/") };
  }
  const c = o.split(".");
  return { type: "image", scheme: r, server: n, prefix: s, identifier: d, originalPath: t, region: ci(u), size: di(f), rotation: pi(l), quality: c[0], format: c[1] };
}
function xi(e) {
  const i = mi(p(e.id));
  if (i.type !== "info")
    throw new Error("Invalid service URL");
  const t = U(e);
  return { identifier: i.identifier, originalPath: "", server: i.server, prefix: i.prefix, scheme: i.scheme, type: "image", quality: t.extraQualities.indexOf("default") === -1 ? t.extraQualities[0] : "default", region: { full: true }, size: { max: true, upscaled: false, confined: false }, format: "jpg", rotation: { angle: 0 } };
}
function Ii(e, i, t) {
  const r = t.length, n = [];
  for (let s = 0; s < r; s++) {
    const o = t[s].width;
    n.push(e / o);
  }
  return n;
}
function _i(e, i, t) {
  const r = t.length, n = [];
  for (let s = 0; s < r; s++) {
    const a = t[s];
    n.push({ width: Math.floor(e / a), height: Math.floor(i / a) });
  }
  return n;
}
function h(e) {
  if (e["@id"])
    return e["@id"];
  if (e.id)
    return e.id;
}
function _(e) {
  if (!e || !e.profile || !h(e))
    return false;
  const i = Array.isArray(e.profile) ? e.profile : [e.profile];
  for (const t of i)
    if (typeof t == "string" && V.indexOf(t) !== -1)
      return true;
  return false;
}
function yi(e) {
  if (!_(e))
    return false;
  const i = Array.isArray(e.profile) ? e.profile : [e.profile];
  for (const t of i)
    if (typeof t == "string") {
      if (Q.indexOf(t) !== -1)
        return true;
    } else {
      const r = [...t.supports || [], ...t.extraFeatures || []];
      if (r.indexOf("regionByPx") !== -1 && (r.indexOf("sizeByW") !== -1 || r.indexOf("sizeByWh") !== -1))
        return true;
    }
  return false;
}
function wi(e) {
  if (!yi(e))
    return [];
  const i = [], t = Array.isArray(e.profile) ? e.profile : [e.profile], r = t.length;
  for (let n = 0; n < r; n++) {
    const s = t[n];
    if (typeof s != "string" && (s.maxHeight || s.maxWidth))
      return [{ id: h(e), type: "variable", minWidth: 0, minHeight: 0, maxHeight: s.maxHeight || s.maxWidth, maxWidth: s.maxWidth || s.maxHeight }];
  }
  if (e.tiles) {
    const n = e.tiles.length;
    for (let s = 0; s < n; s++) {
      const a = e.tiles[s];
      (a.height || a.width) && i.push({ id: h(e), type: "variable", minHeight: 0, minWidth: 0, maxHeight: a.height || a.width, maxWidth: a.width });
    }
  }
  return i;
}
function J(e) {
  const i = /^.*\/(full)\/(((\d+),(\d+)?)|max)\/(\d+)\/default\.(jpg|png|jpeg)$/, t = e.match(i);
  if (t) {
    const r = t[1], n = parseInt(t[4], 10), s = parseInt(t[5], 10), a = t[7];
    if ((r === "max" || r === "full") && n && s && a)
      return { type: "fixed", id: e, height: s, width: n };
  }
  return { type: "unknown", id: e };
}
function Si(e) {
  if (e["@type"])
    return e["@type"];
  if (e.type)
    return e.type;
}
function Fi(e) {
  if (typeof e == "string")
    return J(e);
  const i = Si(e);
  if (i !== "Image" && i !== "sc:Image")
    return null;
  const t = e, r = h(t);
  return r ? r && t.width && t.height ? { id: r, type: "fixed", width: t.width, height: t.height, unsafe: true } : J(r) : null;
}
function vi(e) {
  return _(e) ? (e && e.sizes ? e.sizes : []).map((i) => ({ id: h(e), type: "fixed-service", height: i.height, width: i.width })) : [];
}
function Z(e) {
  const i = [], t = e.length;
  for (let r = 0; r < t; r++) {
    const n = vi(e[r]);
    n.length && i.push(...n);
    const s = wi(e[r]);
    s.length && i.push(...s);
  }
  return i;
}
function K(e) {
  const i = e.service ? Array.isArray(e.service) ? e.service : [e.service] : [], t = i.length, r = [];
  for (let n = 0; n < t; n++)
    _(i[n]) && r.push(i[n]);
  return r;
}
function Oi(e, i = true, t) {
  const r = [], n = Fi(e);
  if (n === null)
    return r;
  const s = e;
  if (r.push(n), i && s.width && s.height) {
    const a = [], o = K(s);
    for (const l of o) {
      const f = { id: h(l), width: s.width, height: s.height };
      if (t.canLoadSync(f)) {
        const u = t.loadServiceSync(f);
        u && (u.height || (u.height = s.height), u.width || (u.width = s.width), a.push(...Z([u])));
      }
    }
    if (a.length)
      return r.push(...a), r;
  }
  return s.service && r.push(...Z(s.service)), r;
}
function zi({ x: e = 0, y: i = 0, w: t, h: r, full: n, square: s, percent: a }) {
  if (n)
    return "full";
  if (s)
    return "square";
  if (typeof t > "u" || typeof r > "u")
    throw new Error("RegionParameter: invalid region");
  const o = `${e},${i},${t},${r}`;
  return a ? `pct:${o}` : o;
}
function Ai({ max: e, percentScale: i, upscaled: t, confined: r, width: n, height: s, serialiseAsFull: a }) {
  const o = [];
  return t && o.push("^"), e ? (o.push(a ? "full" : "max"), o.join("")) : (r && o.push("!"), i && o.push(`pct:${i}`), n && o.push(`${n}`), o.push(","), s && o.push(`${s}`), o.join(""));
}
function Ei(e) {
  return `${e.mirror ? "!" : ""}${(e.angle || 0) % 360}`;
}
var Gi = Object.defineProperty, Ti = Object.defineProperties, ki = Object.getOwnPropertyDescriptors, Li = Object.getOwnPropertySymbols, Qi = Object.prototype.hasOwnProperty, Vi = Object.prototype.propertyIsEnumerable, bi = (e, i, t) => i in e ? Gi(e, i, { enumerable: true, configurable: true, writable: true, value: t }) : e[i] = t, y = (e, i) => {
  for (var t in i || (i = {}))
    Qi.call(i, t) && bi(e, t, i[t]);
  if (Li)
    for (var t of Li(i))
      Vi.call(i, t) && bi(e, t, i[t]);
  return e;
}, w = (e, i) => Ti(e, ki(i));
function Mi(e, i) {
  const t = e.prefix.startsWith("/") ? e.prefix.substr(1) : e.prefix, r = `${e.scheme}://${e.server}/${t ? `${t}/` : ""}${e.identifier}`;
  if (e.type === "base")
    return r;
  if (e.type === "info")
    return `${r}/info.json`;
  let { region: n, size: s, rotation: a, format: o, quality: l } = e;
  if (i) {
    const f = i["@context"] ? Array.isArray(i["@context"]) ? i["@context"] : [i["@context"]] : [], u = f.indexOf("http://iiif.io/api/image/2/context.json") !== -1, I = f.indexOf("http://iiif.io/api/image/3/context.json") !== -1;
    if ((s.width === i.width && !s.height || s.height === i.height && !s.width || s.width === i.width && s.height === i.height) && (s = w(y({}, s), { max: true })), u && (s.max && !s.serialiseAsFull && (s = w(y({}, s), { serialiseAsFull: true })), !s.max && s.width && s.height && (s = w(y({}, s), { height: void 0 }))), I && (s.max && s.serialiseAsFull && (s = w(y({}, s), { serialiseAsFull: false })), s.width && !s.height && i.width && i.height)) {
      const d = i.height / i.width;
      s = w(y({}, s), { height: Math.ceil(s.width * d) });
    }
  }
  return [r, zi(n), Ai(s), Ei(a), `${l}.${o}`].filter(Boolean).join("/");
}
function S(e, i, t) {
  const r = xi({ id: p(h(e)), profile: "level2", type: "ImageService2" });
  if (r.type !== "image")
    throw new Error("Invalid service");
  return r.size.max = false, r.size.width = i, r.size.height = t, { id: Mi(r), type: "fixed", width: i, height: t || e.height / (e.width || 1) * i, unsafe: e.width > i };
}
function m(e) {
  const i = e.replace(/(https?:\/\/)?(www.)?/i, "");
  return i.indexOf("/") !== -1 ? i.split("/")[0] : i;
}
function ji(e, i, t) {
  const r = e.width ? e.width : e.maxWidth;
  return t.height <= e.maxHeight && t.width <= e.maxWidth && t.height >= e.minHeight && t.width >= e.minWidth && (!i || Math.abs(t.width - r) < Math.abs(i.width - r));
}
function Wi(e, i) {
  const t = [], r = Object.assign({ unsafeImageService: false, atAnyCost: true, fallback: true, minHeight: 64, minWidth: 64, maxHeight: 1 / 0, maxWidth: 1 / 0, returnAllOptions: false, preferFixedSize: false, allowUnsafe: false, explain: false, height: 0, width: 0 }, e), n = [], s = [];
  let a = null;
  const o = (f, u) => {
    if (ji(r, u, f)) {
      if (r.preferFixedSize && f.unsafe) {
        s.push(f);
        return;
      }
      r.returnAllOptions && u && s.push(u), a = f;
    } else
      r.returnAllOptions && s.push(f);
  }, l = i.length;
  for (let f = 0; f < l; f++) {
    const u = i[f](), I = u.length;
    for (let d = 0; d < I; d++) {
      const c = u[d];
      if (c.type === "unknown" && r.atAnyCost && n.push(c), c.type === "fixed" && (c.unsafe ? n.push(c) : o(c, a)), c.type === "fixed-service")
        if (r.unsafeImageService) {
          const g = S(c, r.width, r.height);
          o(g, a);
        } else {
          const g = S(c, c.width, c.height);
          o(g, a);
        }
      if (c.type === "variable" && c.maxWidth) {
        const g = S({ id: c.id, type: "fixed-service", width: c.maxWidth, height: c.maxWidth }, c.maxWidth);
        o(g, a);
      }
    }
    if (a && !r.returnAllOptions) {
      if (a.unsafe || r.allowUnsafe)
        continue;
      break;
    }
  }
  return r.atAnyCost && s.length === 0 ? { best: a || n[0], fallback: n.slice(1), log: t } : r.returnAllOptions ? { best: r.atAnyCost ? a || s[0] || n[0] : a || s[0], fallback: [...s, ...n], log: t } : { best: a || s[0] || null, fallback: a ? s : s.slice(1), log: t };
}
var Zi = Object.defineProperty, Ki = Object.defineProperties, Xi = Object.getOwnPropertyDescriptors, Pi = Object.getOwnPropertySymbols, Yi = Object.prototype.hasOwnProperty, qi = Object.prototype.propertyIsEnumerable, Ci = (e, i, t) => i in e ? Zi(e, i, { enumerable: true, configurable: true, writable: true, value: t }) : e[i] = t, ie = (e, i) => {
  for (var t in i || (i = {}))
    Yi.call(i, t) && Ci(e, t, i[t]);
  if (Pi)
    for (var t of Pi(i))
      qi.call(i, t) && Ci(e, t, i[t]);
  return e;
}, ee = (e, i) => Ki(e, Xi(i));
function Bi(e, i, t) {
  const r = e > i ? e : i, n = t.length, s = [];
  for (let a = 0; a < n; a++) {
    const o = t[a];
    let l = o.scaleFactors[0], f = r / l;
    const u = [l];
    for (; f >= o.width; )
      l = l * 2, u.push(l), f = f / 2;
    s.push(ee(ie({}, o), { scaleFactors: u }));
  }
  return s;
}
function Ni(e, i) {
  if (e.length !== i.length)
    return false;
  if (e.length === 0 && i.length === 0)
    return true;
  const t = e.length;
  let r = true;
  for (let s = 0; s < t; s++) {
    const a = e[s], o = i[s];
    if (a.width !== o.width || a.height !== o.height) {
      r = false;
      break;
    }
  }
  if (r)
    return true;
  let n = 0;
  for (let s = 0; s < t; s++)
    for (let a = 0; a < t; a++)
      if (e[s].width === i[a].width && e[s].height === i[a].height) {
        n++;
        break;
      }
  return n === t;
}
function Ri(e) {
  if (e && e.profile) {
    const i = e.profile;
    if (i) {
      const t = Array.isArray(i) ? i : [i];
      return t.includes("level0") || t.includes("http://iiif.io/api/image/2/level0.json") || t.includes("http://iiif.io/api/image/1/level0.json") || t.includes("http://iiif.io/api/image/1/profiles/level0.json");
    }
  }
  return false;
}
var x = (e, i, t) => new Promise((r, n) => {
  var s = (l) => {
    try {
      o(t.next(l));
    } catch (f) {
      n(f);
    }
  }, a = (l) => {
    try {
      o(t.throw(l));
    } catch (f) {
      n(f);
    }
  }, o = (l) => l.done ? r(l.value) : Promise.resolve(l.value).then(s, a);
  o((t = t.apply(e, i)).next());
});
class $i {
  constructor() {
    this.config = { verificationsRequired: 1, approximateServices: true, enableFetching: true, disableThrottling: false }, this.fetchingCount = 0, this.imageServices = {}, this.knownImageServers = {};
  }
  setConfig(i) {
    Object.assign(this.config, i);
  }
  sample(i, t, r = true) {
    const n = m(h(i)), s = p(h(i)), a = this.knownImageServers[n];
    return this.imageServices[s] = Object.assign(i, { real: true }), !a && i.tiles && !Ri(i) ? (this.knownImageServers[n] = { verifications: 0, malformed: false, root: n, preLoaded: r, sampledId: h(i), verified: false, server: null, result: { context: i["@context"] || [], sampledProfile: i.profile, resourceServiceRatio: t && i.height ? t.height / i.height : 1, sampledSizes: i.sizes || [], sizeRatios: Ii(i.width, i.height, i.sizes || []), sampledTiles: i.tiles || [] } }, true) : this.verify(i);
  }
  preLoad(i, t = true) {
    this.knownImageServers[i.root] = i, t && (this.knownImageServers[i.root].malformed = false, this.knownImageServers[i.root].verifications = this.config.verificationsRequired);
  }
  predict(i, t = false, r = false) {
    const n = i == null ? void 0 : i.source, s = m(h(i)), a = this.knownImageServers[s];
    if (!a || !a.result || !r && (a.malformed || a.verifications < this.config.verificationsRequired) || Ri(i.source))
      return null;
    const o = p(h(i));
    return this.imageServices[o] || (this.imageServices[o] = { "@context": a.result.context, "@id": h(i), id: h(i), protocol: "http://iiif.io/api/image", tiles: (n == null ? void 0 : n.tiles) || Bi(i.width, i.height, a.result.sampledTiles), sizes: (n == null ? void 0 : n.sizes) || _i(Math.round(i.width / a.result.resourceServiceRatio), Math.round(i.height / a.result.resourceServiceRatio), a.result.sizeRatios), profile: (n == null ? void 0 : n.profile) || a.result.sampledProfile, height: (n == null ? void 0 : n.height) || i.height, width: (n == null ? void 0 : n.width) || i.width, real: false }), this.imageServices[o];
  }
  getThumbnailFromResource(i, t) {
    return x(this, arguments, function* (r, n, s = true, a = []) {
      const o = yield this.getImageCandidates(r, s);
      return Wi(n, [() => a, () => o]);
    });
  }
  getImageCandidates(i, t = true) {
    return x(this, null, function* () {
      const r = i;
      if (t && r.height && r.width) {
        const n = K(r);
        for (const s of n) {
          const a = { id: h(s), width: s.width ? s.width : r.width, height: s.height ? s.height : r.height, source: s };
          yield this.loadService(a);
        }
      }
      return Oi(i, t, this);
    });
  }
  verify(i) {
    return x(this, null, function* () {
      const t = this.predict(i, false, true), r = yield this.fetchService(h(i));
      if (!t)
        return false;
      const n = t.height === r.height && t.width === r.width && t["@context"] === r["@context"] && Ni(t.sizes || [], r.sizes || []);
      if (n) {
        const s = m(h(i));
        this.knownImageServers[s].verifications += 1, this.knownImageServers[s].verifications >= this.config.verificationsRequired && (this.knownImageServers[s].verified = true);
      }
      return n;
    });
  }
  canLoadSync(i) {
    const t = typeof i == "string" ? i : h(i), r = p(t);
    if (this.imageServices[r])
      return true;
    const n = this.knownImageServers[m(t)];
    return n && !n.malformed && n.verifications >= this.config.verificationsRequired;
  }
  markAsMalformed(i) {
    return x(this, null, function* () {
      return this.knownImageServers[m(h(i))].malformed = true, this.loadService(i, true);
    });
  }
  fetchService(i, t = false) {
    return x(this, null, function* () {
      const r = p(i);
      if (this.imageServices[r] && (!t || this.imageServices[r].real))
        return this.imageServices[r];
      if (!this.config.enableFetching)
        throw new Error("Fetching is not enabled");
      const n = yield this.fetch(r).then((s) => s.json());
      return !n.id && n["@id"] && (n.id = n["@id"]), n.id !== i && (n.id = i, n["@id"] && (n["@id"] = i)), this.imageServices[r] = Object.assign(n, { real: true }), this.imageServices[r];
    });
  }
  fetch(i, t) {
    return x(this, null, function* () {
      return fetch(i, t);
    });
  }
  loadService(i, t = false) {
    return x(this, null, function* () {
      if (!this.config.disableThrottling) {
        let s = true;
        for (; s; )
          if (this.fetchingCount >= this.config.verificationsRequired)
            yield new Promise((a) => setTimeout(a, 500));
          else {
            s = false;
            break;
          }
      }
      const r = this.knownImageServers[m(h(i))];
      if (r && !r.malformed && !t) {
        yield r.result;
        const s = this.loadServiceSync(i);
        if (s)
          return s;
      }
      this.fetchingCount++;
      const n = yield this.fetchService(h(i), t);
      return this.fetchingCount--, n.real && this.sample(n, i), n;
    });
  }
  loadServiceSync(i) {
    const t = p(h(i));
    return this.imageServices[t] ? this.imageServices[t] : this.predict(i);
  }
}
new $i();
function createThumbnailHelper(vault, dependencies = {}) {
  const imageServiceLoader = dependencies.imageServiceLoader || new $i();
  async function getBestThumbnailAtSize(input, request, dereference, candidates = [], dimensions) {
    if (typeof input === "string") {
      return { best: Fi(input), fallback: [], log: [] };
    }
    const fullInput = vault.get(input);
    if (typeof fullInput === "string") {
      return { best: Fi(fullInput), fallback: [], log: [] };
    }
    switch (fullInput.type) {
      case "Annotation": {
        const contentResources = fullInput.body;
        const firstContentResources = vault.get(contentResources[0]);
        if (dimensions && !firstContentResources.width) {
          firstContentResources.width = dimensions.width;
          firstContentResources.height = dimensions.height;
        }
        return await imageServiceLoader.getThumbnailFromResource(
          firstContentResources,
          request,
          dereference,
          candidates
        );
      }
      case "Canvas": {
        const canvas = fullInput;
        if (canvas.thumbnail && canvas.thumbnail.length) {
          const thumbnail = vault.get(canvas.thumbnail[0]);
          const potentialThumbnails = await imageServiceLoader.getImageCandidates(thumbnail, dereference);
          if (potentialThumbnails && potentialThumbnails.length) {
            candidates.push(...potentialThumbnails);
          }
        }
        return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {
          width: canvas.width,
          height: canvas.height
        });
      }
      case "AnnotationPage": {
        const annotationPage = fullInput;
        return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);
      }
      case "Choice": {
        const choice = fullInput;
        return getBestThumbnailAtSize(choice.items[0], request, dereference, candidates, dimensions);
      }
      case "Collection": {
        const collection = fullInput;
        const firstManifest = collection.items[0];
        return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);
      }
      case "Manifest": {
        const manifest = fullInput;
        const firstCanvas = manifest.items[0];
        return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);
      }
      case "SpecificResource":
      case "Image":
      case "Dataset":
      case "Sound":
      case "Text":
      case "TextualBody":
      case "Video":
        if (dimensions && !fullInput.width) {
          fullInput.width = dimensions.width;
          fullInput.height = dimensions.height;
        }
        return imageServiceLoader.getThumbnailFromResource(fullInput, request, dereference, candidates);
      case "Service":
      case "Range":
      case "AnnotationCollection":
      case "CanvasReference":
      case "ContentResource":
        return { best: void 0, fallback: [], log: [] };
    }
    return { best: void 0, fallback: [], log: [] };
  }
  return {
    getBestThumbnailAtSize
  };
}
function getClosestLanguage(i18nLanguage, languages, i18nLanguages = [], strictFallback = false) {
  if (!i18nLanguage || !languages || languages.length === 0) {
    return void 0;
  }
  if (languages.length === 1) {
    return languages[0];
  }
  if (languages.indexOf(i18nLanguage) !== -1) {
    return i18nLanguage;
  }
  const root = i18nLanguage.indexOf("-") !== -1 ? i18nLanguage.slice(0, i18nLanguage.indexOf("-")) : null;
  if (root && languages.indexOf(root) !== -1) {
    return root;
  }
  for (const lang of i18nLanguages) {
    if (languages.indexOf(lang) !== -1) {
      return lang;
    }
  }
  if (!strictFallback) {
    const inverseRoot = languages.map((l) => l.indexOf("-") !== -1 ? l.slice(0, l.indexOf("-")) : null);
    const inverseIdx = inverseRoot.indexOf(i18nLanguage);
    if (inverseIdx !== -1) {
      return languages[inverseIdx];
    }
    for (const lang of i18nLanguages) {
      const root2 = lang.indexOf("-") !== -1 ? lang.slice(0, lang.indexOf("-")) : null;
      const inverseIdx2 = root2 ? languages.indexOf(root2) : -1;
      if (inverseIdx2 !== -1) {
        return languages[inverseIdx2];
      }
    }
  }
  if (languages.indexOf("none") !== -1) {
    return "none";
  }
  if (languages.indexOf("@none") !== -1) {
    return "@none";
  }
  return languages[0];
}
function buildLocaleString(inputText, i18nLanguage, options = {}) {
  const { strictFallback = false, defaultText = "", separator = "\n", fallbackLanguages = [], closest } = options;
  const languages = Object.keys(inputText || {});
  const language = closest ? i18nLanguage : getClosestLanguage(i18nLanguage, languages, fallbackLanguages, strictFallback);
  if (!inputText) {
    return defaultText;
  }
  if (typeof inputText === "string") {
    return inputText;
  }
  const candidateText = language ? inputText[language] : void 0;
  if (candidateText) {
    if (typeof candidateText === "string") {
      return candidateText;
    }
    return candidateText.join(separator);
  }
  return "";
}
function getValue(inputText, options = {}) {
  return buildLocaleString(inputText, typeof navigator !== "undefined" ? navigator.language : void 0, options);
}
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i2 = arr[Symbol.iterator](), _s; !(_n = (_s = _i2.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i2["return"])
          _i2["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x2 = _ref.x, y2 = _ref.y;
  x2 *= rx;
  y2 *= ry;
  var xp = cosphi * x2 - sinphi * y2;
  var yp = sinphi * x2 + cosphi * y2;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x3 = _mapToEllipse3.x, y3 = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x: x3, y: y3 };
  });
};
var parseSvgPath = parse;
var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function parse(path) {
  var data = [];
  path.replace(segment, function(_2, command, args) {
    var type = command.toLowerCase();
    args = parseValues(args);
    if (type == "m" && args.length > 2) {
      data.push([command].concat(args.splice(0, 2)));
      type = "l";
      command = command == "m" ? "l" : "L";
    }
    while (true) {
      if (args.length == length[type]) {
        args.unshift(command);
        return data.push(args);
      }
      if (args.length < length[type])
        throw new Error("malformed path data");
      data.push([command].concat(args.splice(0, length[type])));
    }
  });
  return data;
}
var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function parseValues(args) {
  var numbers = args.match(number);
  return numbers ? numbers.map(Number) : [];
}
var absSvgPath = absolutize;
function absolutize(path) {
  var startX = 0;
  var startY = 0;
  var x2 = 0;
  var y2 = 0;
  return path.map(function(seg) {
    seg = seg.slice();
    var type = seg[0];
    var command = type.toUpperCase();
    if (type != command) {
      seg[0] = command;
      switch (type) {
        case "a":
          seg[6] += x2;
          seg[7] += y2;
          break;
        case "v":
          seg[1] += y2;
          break;
        case "h":
          seg[1] += x2;
          break;
        default:
          for (var i = 1; i < seg.length; ) {
            seg[i++] += x2;
            seg[i++] += y2;
          }
      }
    }
    switch (command) {
      case "Z":
        x2 = startX;
        y2 = startY;
        break;
      case "H":
        x2 = seg[1];
        break;
      case "V":
        y2 = seg[1];
        break;
      case "M":
        x2 = startX = seg[1];
        y2 = startY = seg[2];
        break;
      default:
        x2 = seg[seg.length - 2];
        y2 = seg[seg.length - 1];
    }
    return seg;
  });
}
function parseAndNormalizeSvgPath(path) {
  const parsed = parseSvgPath(path);
  const absolute = absSvgPath(parsed);
  let prevCmd;
  let startX = 0;
  let startY = 0;
  let bezierX = 0;
  let bezierY = 0;
  let quadX;
  let quadY;
  let x2 = 0;
  let y2 = 0;
  const out = [];
  for (let i = 0; i < absolute.length; i++) {
    let seg = absolute[i];
    const cmd = seg[0];
    switch (cmd) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "H":
        seg = ["L", seg[1], startY];
        break;
      case "V":
        seg = ["L", startX, seg[1]];
        break;
      case "S":
        {
          let cx = x2;
          let cy = y2;
          if (prevCmd === "C" || prevCmd == "S") {
            cx += cx - bezierX;
            cy += cy - bezierY;
          }
          seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
        }
        break;
      case "T":
        if (prevCmd === "Q" || prevCmd == "T") {
          quadX = x2 * 2 - quadX;
          quadY = y2 * 2 - quadY;
        } else {
          quadX = x2;
          quadY = y2;
        }
        seg = ["Q", quadX, quadY, seg[1], seg[2]];
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        break;
      case "A":
        {
          const curves = arcToBezier({
            px: x2,
            py: y2,
            cx: seg[6],
            cy: seg[7],
            rx: seg[1],
            ry: seg[2],
            xAxisRotation: seg[3],
            largeArcFlag: seg[4],
            sweepFlag: seg[5]
          });
          if (!curves.length) {
            continue;
          }
          for (const [j2, curve] of curves.entries()) {
            seg = ["C", curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];
            if (j2 < curves.length - 1) {
              out.push(seg);
            }
          }
          seg = seg;
        }
        break;
      case "Z":
        seg = ["L", startX, startY];
        break;
    }
    prevCmd = cmd;
    x2 = seg[seg.length - 2];
    y2 = seg[seg.length - 1];
    if (["C", "Q", "A"].indexOf(cmd) > -1) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x2;
      bezierY = y2;
    }
    out.push(seg);
  }
  return out;
}
/** Code to "flatten" quadratic and cubic Bézier curves to polylines.
 *
 * All code in this module is based on JavaScript code by Raph Levien, published on his blog at
 * https://raphlinus.github.io/.
 * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.
 *
 * Flattening of quadratic Bézier curves:
 * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html
 * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212
 *
 * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html
 *
 * Note that the code in this module has a different license than the rest of the package,
 * due to the inclusion of Apache-licensed third party code.
 *
 * @license
 * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>
 * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function flattenQuadraticBezier(start, control, end, tolerance = 1) {
  return new QuadraticBezier(start, control, end).subdivide(tolerance);
}
function flattenCubicBezier(start, startControl, end, endControl, tolerance = 1) {
  return new CubicBezier(
    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])
  ).subdivide(tolerance);
}
function hypot2(p2) {
  return p2.x * p2.x + p2.y * p2.y;
}
function approx_myint(x2) {
  const d = 0.67;
  return x2 / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x2 * x2, 0.25));
}
function approx_inv_myint(x2) {
  const b2 = 0.39;
  return x2 * (1 - b2 + Math.sqrt(b2 * b2 + 0.25 * x2 * x2));
}
class QuadraticBezier {
  constructor(start, control, end) {
    this.start = start;
    this.control = control;
    this.end = end;
  }
  eval(t) {
    const mt = 1 - t;
    return {
      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,
      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t
    };
  }
  mapToBasic() {
    const { x: x0, y: y0 } = this.start;
    const { x: x1, y: y1 } = this.control;
    const { x: x2, y: y2 } = this.end;
    const ddx = 2 * x1 - x0 - x2;
    const ddy = 2 * y1 - y0 - y2;
    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;
    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;
    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;
    const paramX0 = u0 / cross;
    const paramX2 = u2 / cross;
    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));
    return { x0, x2, scale, cross };
  }
  subdivide(tolerance) {
    const params = this.mapToBasic();
    const a0 = approx_myint(params.x0);
    const a2 = approx_myint(params.x2);
    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);
    const n = Math.ceil(count);
    const u0 = approx_inv_myint(a0);
    const u2 = approx_inv_myint(a2);
    const tValues = [0];
    for (let i = 1; i < n; i++) {
      const u = approx_inv_myint(a0 + (a2 - a0) * i / n);
      const t = (u - u0) / (u2 - u0);
      tValues.push(t);
    }
    tValues.push(1);
    return tValues.map((t) => this.eval(t));
  }
}
class CubicBezier {
  constructor(coords) {
    this.c = coords;
  }
  weightsum(c0, c1, c2, c3) {
    const x2 = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];
    const y2 = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];
    return { x: x2, y: y2 };
  }
  eval(t) {
    const mt = 1 - t;
    const c0 = mt * mt * mt;
    const c1 = 3 * mt * mt * t;
    const c2 = 3 * mt * t * t;
    const c3 = t * t * t;
    return this.weightsum(c0, c1, c2, c3);
  }
  deriv(t) {
    const mt = 1 - t;
    const c0 = -3 * mt * mt;
    const c3 = 3 * t * t;
    const c1 = -6 * t * mt - c0;
    const c2 = 6 * t * mt - c3;
    return this.weightsum(c0, c1, c2, c3);
  }
  midpoint_quadbez() {
    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);
    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });
  }
  subsegment(t0, t1) {
    const c = new Float64Array(8);
    const p0 = this.eval(t0);
    const p3 = this.eval(t1);
    c[0] = p0.x;
    c[1] = p0.y;
    const scale = (t1 - t0) / 3;
    const d1 = this.deriv(t0);
    c[2] = p0.x + scale * d1.x;
    c[3] = p0.y + scale * d1.y;
    const d2 = this.deriv(t1);
    c[4] = p3.x - scale * d2.x;
    c[5] = p3.y - scale * d2.y;
    c[6] = p3.x;
    c[7] = p3.y;
    return new CubicBezier(c);
  }
  subdivide(tol) {
    const tol1 = 0.1 * tol;
    const tol2 = tol - tol1;
    const sqrt_tol2 = Math.sqrt(tol2);
    const err2 = hypot2(this.weightsum(1, -3, 3, -1));
    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));
    const quads = [];
    let sum = 0;
    for (let i2 = 0; i2 < n_quads; i2++) {
      const t0 = i2 / n_quads;
      const t1 = (i2 + 1) / n_quads;
      const quad = this.subsegment(t0, t1).midpoint_quadbez();
      const params = quad.mapToBasic();
      const a0 = approx_myint(params.x0);
      const a2 = approx_myint(params.x2);
      const scale = Math.sqrt(params.scale);
      let val2 = Math.abs(a2 - a0) * scale;
      if (Math.sign(params.x0) != Math.sign(params.x2)) {
        const xmin = sqrt_tol2 / scale;
        const cusp_val = sqrt_tol2 * Math.abs(a2 - a0) / approx_myint(xmin);
        val2 = Math.max(val2, cusp_val);
      }
      quads.push({
        quad,
        a0,
        a2,
        val: val2
      });
      sum += val2;
    }
    const count = 0.5 * sum / sqrt_tol2;
    const n = Math.ceil(count);
    const result = [{ x: this.c[0], y: this.c[1] }];
    let val = 0;
    let i = 0;
    for (let j2 = 1; j2 < n; j2++) {
      const target = sum * j2 / n;
      while (val + quads[i].val < target) {
        val += quads[i].val;
        i++;
      }
      const a0 = quads[i].a0;
      const a2 = quads[i].a2;
      const u0 = approx_inv_myint(a0);
      const u2 = approx_inv_myint(a2);
      const a = a0 + (a2 - a0) * (target - val) / quads[i].val;
      const u = approx_inv_myint(a);
      const t = (u - u0) / (u2 - u0);
      result.push(quads[i].quad.eval(t));
    }
    result.push({ x: this.c[6], y: this.c[7] });
    return result;
  }
}
const BOX_SELECTOR = /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?)/;
const TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(.[0-9]+)?)?(,([0-9]+(.[0-9]+)?))?/;
const RGBA_COLOR = /^rgba\((\d+),(\d+),(\d+),([0-9.]+)\)$/;
function parseSelector(source, { domParser, svgPreprocessor } = {}) {
  var _a, _b;
  if (Array.isArray(source)) {
    return source.reduce(
      (data, nextSource) => {
        const { selector, selectors } = parseSelector(nextSource);
        if (selector) {
          if (!data.selector) {
            data.selector = selector;
          }
          data.selectors.push(...selectors);
        }
        return data;
      },
      {
        selector: null,
        selectors: []
      }
    );
  }
  if (!source) {
    return {
      selector: null,
      selectors: []
    };
  }
  if (typeof source === "string") {
    const [id, fragment] = source.split("#");
    if (!fragment) {
      return {
        selector: null,
        selectors: []
      };
    }
    return parseSelector({ type: "FragmentSelector", value: fragment });
  }
  if (source.type === "PointSelector" && (source.t || source.t === 0)) {
    const selector = {
      type: "TemporalSelector",
      temporal: {
        startTime: source.t
      }
    };
    return {
      selector,
      selectors: [selector]
    };
  }
  if (source.type === "FragmentSelector") {
    const matchBoxSelector = BOX_SELECTOR.exec(source.value);
    if (matchBoxSelector) {
      const selector = {
        type: "BoxSelector",
        spatial: {
          unit: matchBoxSelector[2] === "percent:" || matchBoxSelector[2] === "pct:" ? "percent" : "pixel",
          x: parseFloat(matchBoxSelector[3]),
          y: parseFloat(matchBoxSelector[4]),
          width: parseFloat(matchBoxSelector[5]),
          height: parseFloat(matchBoxSelector[6])
        }
      };
      return {
        selector,
        selectors: [selector]
      };
    }
    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);
    if (matchTimeSelector) {
      const selector = {
        type: "TemporalSelector",
        temporal: {
          startTime: matchTimeSelector[4] ? parseFloat(matchTimeSelector[4]) : 0,
          endTime: matchTimeSelector[7] ? parseFloat(matchTimeSelector[7]) : void 0
        }
      };
      return {
        selector,
        selectors: [selector]
      };
    }
    return {
      selector: null,
      selectors: []
    };
  }
  if (source.type === "SvgSelector" && "value" in source) {
    if (!domParser) {
      if (typeof window !== "undefined") {
        domParser = new window.DOMParser();
      } else {
        console.warn(
          "No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized."
        );
      }
    }
    let points = [];
    let rect;
    let style;
    let svg = (_a = svgPreprocessor == null ? void 0 : svgPreprocessor(source.value)) != null ? _a : source.value;
    let svgShape;
    if (domParser) {
      const svgElement = domParser.parseFromString(source.value, "image/svg+xml").querySelector("svg");
      if (!svgElement) {
        console.warn(`Illegal SVG selector: ${source.value}`);
        return {
          selector: null,
          selectors: []
        };
      }
      const selectorElem = getSelectorElement(svgElement);
      if (selectorElem) {
        points = selectorElem.points;
        svgShape = selectorElem.shapeType;
        rect = [
          Math.min(...points.map((p2) => p2[0])),
          Math.min(...points.map((p2) => p2[1])),
          Math.max(...points.map((p2) => p2[0])),
          Math.max(...points.map((p2) => p2[1]))
        ];
        ({ style, svg } = (_b = extractStyles(selectorElem.element)) != null ? _b : { svg });
      }
    }
    const sel = {
      type: "SvgSelector",
      svg,
      svgShape,
      style,
      points: points.length ? points : void 0,
      spatial: rect ? { unit: "pixel", x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] } : void 0
    };
    return {
      selector: sel,
      selectors: [sel]
    };
  }
  return {
    selector: null,
    selectors: []
  };
}
function getShapeTypeFromPath(svgPath) {
  const cmdFrequencies = svgPath.map((seg) => seg[0]).reduce(
    (acc, cmd) => {
      acc[cmd] += 1;
      return acc;
    },
    { C: 0, Q: 0, L: 0, M: 0 }
  );
  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));
  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {
    return "path";
  }
  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || cmdTypes.size === 2 && cmdTypes.has("M"))) {
    if (cmdFrequencies.L === 4) {
      return "rect";
    }
    const lastSeg = svgPath.slice(-1)[0];
    if (svgPath[0][0] === "M" && lastSeg[0] === "L" && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2] || lastSeg[1] === 0 && lastSeg[2] === 0) {
      return "polygon";
    } else {
      return "polyline";
    }
  }
  return "path";
}
function getSelectorElement(svgElem) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i2, _j, _k, _l, _m, _n, _o, _p, _q;
  for (const element of Array.from(svgElem.children)) {
    switch (element == null ? void 0 : element.tagName.toLowerCase()) {
      case "g":
        {
          const res = getSelectorElement(element);
          if (res) {
            return res;
          }
        }
        continue;
      case "path": {
        const p2 = element.getAttribute("d");
        if (!p2) {
          continue;
        }
        const normalized = parseAndNormalizeSvgPath(p2);
        return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };
      }
      case "circle": {
        const cx = parseFloat((_a = element.getAttribute("cx")) != null ? _a : "0");
        const cy = parseFloat((_b = element.getAttribute("cy")) != null ? _b : "0");
        const r = parseFloat((_c = element.getAttribute("r")) != null ? _c : "0");
        if (!r) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const rad = angle * Math.PI / 180;
          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);
        }
        return { element, points, shapeType: "circle" };
      }
      case "ellipse": {
        const cx = parseFloat((_d = element.getAttribute("cx")) != null ? _d : "0");
        const cy = parseFloat((_e = element.getAttribute("cy")) != null ? _e : "0");
        const rx = parseFloat((_f = element.getAttribute("rx")) != null ? _f : "0");
        const ry = parseFloat((_g = element.getAttribute("ry")) != null ? _g : "0");
        if (!rx && !ry) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const t = Math.tan(angle / 360 * Math.PI);
          const px = rx * (1 - t ** 2) / (1 + t ** 2);
          const py = ry * 2 * t / (1 + t ** 2);
          points.push([cx + px, cy + py]);
        }
        return { element, points, shapeType: "ellipse" };
      }
      case "line": {
        const x0 = parseFloat((_h = element.getAttribute("x0")) != null ? _h : "0");
        const y0 = parseFloat((_i2 = element.getAttribute("y0")) != null ? _i2 : "0");
        const x1 = parseFloat((_j = element.getAttribute("x1")) != null ? _j : "0");
        const y1 = parseFloat((_k = element.getAttribute("y1")) != null ? _k : "0");
        if (x0 === x1 && y0 === y1) {
          continue;
        }
        return {
          element,
          points: [
            [x0, y0],
            [x1, y1]
          ],
          shapeType: "polyline"
        };
      }
      case "polygon":
      case "polyline": {
        const points = (_m = (_l = element.getAttribute("points")) == null ? void 0 : _l.split(" ").map((ps) => ps.split(",").map(parseFloat))) != null ? _m : [];
        if (!points.length) {
          continue;
        }
        let shapeType = "polyline";
        if (element.tagName.toLowerCase() === "polygon") {
          points.push(points[0]);
          shapeType = "polygon";
        }
        return { element, points, shapeType };
      }
      case "rect": {
        const x2 = parseFloat((_n = element.getAttribute("x")) != null ? _n : "0");
        const y2 = parseFloat((_o = element.getAttribute("y")) != null ? _o : "0");
        const width = parseFloat((_p = element.getAttribute("width")) != null ? _p : "0");
        const height = parseFloat((_q = element.getAttribute("height")) != null ? _q : "0");
        if (!width || !height) {
          continue;
        }
        return {
          element,
          points: [
            [x2, y2],
            [x2 + width, y2],
            [x2 + width, y2 + height],
            [x2, y2 + height],
            [x2, y2]
          ],
          shapeType: "rect"
        };
      }
      default:
        continue;
    }
  }
  return null;
}
function pathToPoints(normalizedPath) {
  var _a;
  const out = [];
  for (let i = 0; i < normalizedPath.length; i++) {
    const startPoint = (_a = out[out.length - 1]) != null ? _a : [0, 0];
    const seg = normalizedPath[i];
    switch (seg[0]) {
      case "M":
      case "L":
        out.push([seg[1], seg[2]]);
        continue;
      case "C":
        out.push(
          ...flattenCubicBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] },
            { x: seg[5], y: seg[6] }
          ).map((p2) => [p2.x, p2.y]).slice(1)
        );
        continue;
      case "Q":
        out.push(
          ...flattenQuadraticBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] }
          ).map((p2) => [p2.x, p2.y]).slice(1)
        );
        continue;
    }
  }
  return out;
}
function extractStyles(selectorElement) {
  const style = {};
  if (selectorElement.hasAttribute("fill")) {
    style.fill = selectorElement.getAttribute("fill");
    selectorElement.removeAttribute("fill");
  } else if (selectorElement.style.fill) {
    style.fill = selectorElement.style.fill;
  }
  if (style.fill) {
    const rgbaMatch = RGBA_COLOR.exec(style.fill);
    if (rgbaMatch) {
      style.fillOpacity = parseFloat(rgbaMatch[4]);
      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("fill-opacity")) {
    style.fillOpacity = parseFloat(selectorElement.getAttribute("fill-opacity"));
    selectorElement.removeAttribute("fill-opacity");
  } else if (selectorElement.style.fillOpacity) {
    style.fillOpacity = parseFloat(selectorElement.style.fillOpacity);
  }
  if (selectorElement.hasAttribute("stroke")) {
    style.stroke = selectorElement.getAttribute("stroke");
    selectorElement.removeAttribute("stroke");
  } else if (selectorElement.style.stroke) {
    style.stroke = selectorElement.style.stroke;
  }
  if (style.stroke) {
    const rgbaMatch = RGBA_COLOR.exec(style.stroke);
    if (rgbaMatch) {
      style.strokeOpacity = parseFloat(rgbaMatch[4]);
      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("stroke-opacity")) {
    style.strokeOpacity = parseFloat(selectorElement.getAttribute("stroke-opacity"));
    selectorElement.removeAttribute("stroke-opacity");
  } else if (selectorElement.style.strokeOpacity) {
    style.strokeOpacity = parseFloat(selectorElement.style.strokeOpacity);
  }
  if (selectorElement.hasAttribute("stroke-width")) {
    style.strokeWidth = selectorElement.getAttribute("stroke-width");
    selectorElement.removeAttribute("stroke-width");
  } else if (selectorElement.style.strokeWidth) {
    style.strokeWidth = selectorElement.style.strokeWidth;
  }
  if (selectorElement.hasAttribute("stroke-dasharray")) {
    style.strokeDasharray = selectorElement.getAttribute("stroke-dasharray");
    selectorElement.removeAttribute("stroke-dasharray");
  } else if (selectorElement.style.strokeDasharray) {
    style.strokeDasharray = selectorElement.style.strokeDasharray;
  }
  let rootElem = selectorElement;
  while (rootElem.tagName.toLowerCase() !== "svg") {
    rootElem = rootElem.parentElement;
    if (rootElem === null) {
      throw new Error("Could not find root SVG element");
    }
  }
  return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : void 0 };
}
function expandTarget(target, options = {}) {
  if (Array.isArray(target)) {
    return expandTarget(target[0]);
  }
  if (typeof target === "string") {
    const [id, fragment] = target.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: { id, type: options.typeMap && options.typeMap[id] || "Unknown" },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: { id, type: "Unknown" },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  if (target.type === "Choice" || target.type === "List" || target.type === "Composite" || target.type === "Independents") {
    return expandTarget(target.items[0]);
  }
  if (target.type === "SpecificResource") {
    if (target.source.type === "Canvas" && target.source.partOf && typeof target.source.partOf === "string") {
      target.source.partOf = [
        {
          id: target.source.partOf,
          type: "Manifest"
        }
      ];
    }
    const { selector, selectors } = target.selector ? parseSelector(target.selector, options) : { selector: null, selectors: [] };
    return {
      type: "SpecificResource",
      source: target.source,
      selector,
      selectors
    };
  }
  if (target.id) {
    if (target.type === "Canvas" && target.partOf && typeof target.partOf === "string") {
      target.partOf = [
        {
          id: target.partOf,
          type: "Manifest"
        }
      ];
    }
    const [id, fragment] = target.id.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: {
          ...target,
          id
        },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: {
        ...target,
        id
      },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  return {
    type: "SpecificResource",
    source: target,
    selector: null,
    selectors: []
  };
}
function validateContentState(annotation, strict = false) {
  if (typeof annotation === "string") {
    if (annotation.startsWith("{")) {
      try {
        const parsed = JSON.parse(annotation);
        return validateContentState(parsed);
      } catch (err) {
        return [false, { reason: "Invalid JSON" }];
      }
    }
    return [true];
  }
  if (Array.isArray(annotation)) {
    for (const anno of annotation) {
      const [valid, reason] = validateContentState(anno);
      if (!valid && reason) {
        return [valid, reason];
      }
    }
    return [true];
  }
  if (annotation.type === "Annotation") {
    return [true];
  }
  if (strict && annotation.type === "Canvas" && !annotation.partOf) {
    return [false, { reason: "Canvas without partOf cannot be loaded" }];
  }
  return [true];
}
function serialiseContentState(annotation) {
  return encodeContentState(typeof annotation === "string" ? annotation : JSON.stringify(annotation));
}
function parseContentState(state, asyncOrFetcher) {
  state = state.trim();
  if (state[0] === "{") {
    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);
  }
  if (state.startsWith("http")) {
    if (!asyncOrFetcher) {
      throw new Error("Cannot fetch remote fetch with async=false in parseContentState");
    }
    return fetch(state).then((r) => r.json());
  }
  return parseContentState(decodeContentState(state), asyncOrFetcher);
}
function encodeContentState(state) {
  const uriEncoded = encodeURIComponent(state);
  const base64 = typeof btoa === "undefined" ? Buffer.from(uriEncoded, "utf-8").toString("base64") : btoa(uriEncoded);
  const base64url = base64.replace(/\+/g, "-").replace(/\//g, "_");
  return base64url.replace(/=/g, "");
}
function decodeContentState(encodedContentState) {
  const base64url = restorePadding(encodedContentState);
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const base64Decoded = typeof atob === "undefined" ? Buffer.from(base64, "base64").toString("utf-8") : atob(base64);
  return decodeURIComponent(base64Decoded).trim();
}
function restorePadding(s) {
  const pad = s.length % 4;
  if (pad === 1) {
    throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");
  }
  return s + (pad ? "====".slice(0, 4 - pad) : "");
}
function normaliseContentState(state) {
  if (!state) {
    throw new Error("Content state is empty");
  }
  if (!Array.isArray(state)) {
    state = [state];
  }
  let annoId = "vault://virtual-annotation/" + new Date().getTime();
  const targets = [];
  for (const source of state) {
    if (typeof source === "string") {
      throw new Error("Content state is a [String] type and cannot be inferred");
    }
    if (source.type === "Annotation") {
      annoId = source.id;
      if (Array.isArray(source.motivation)) {
        for (const singleMotivation of source.motivation) {
        }
      }
      if (Array.isArray(source.target)) {
        for (const target2 of source.target) {
          const expanded = expandTarget(target2);
          targets.push(expanded);
        }
      } else {
        const expanded = expandTarget(source.target);
        targets.push(expanded);
      }
      continue;
    }
    const target = expandTarget(source);
    targets.push(target);
  }
  return {
    id: annoId,
    type: "Annotation",
    motivation: ["contentState", ...state.motivation || []],
    target: targets,
    extensions: {}
  };
}
function parseSpecificResource(resource) {
  if (resource.type === "SpecificResource") {
    return [resource.source, { selector: resource.selector }];
  }
  return [resource, { selector: null }];
}
function createPaintingAnnotationsHelper(vault) {
  function getAllPaintingAnnotations(canvasOrId) {
    const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
    if (!canvas) {
      return [];
    }
    const annotationPages = vault.get(canvas.items);
    const flatAnnotations = [];
    for (const page of annotationPages) {
      flatAnnotations.push(...vault.get(page.items));
    }
    return flatAnnotations;
  }
  function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
    const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
    const types = [];
    let choice = null;
    const items = [];
    for (const annotation of paintingAnnotations) {
      if (annotation.type !== "Annotation") {
        throw new Error(`getPaintables() accept either a canvas or list of annotations`);
      }
      const bodies = vault.get(annotation.body);
      for (const unknownBody of bodies) {
        const [body, { selector }] = parseSpecificResource(unknownBody);
        const type = (body.type || "unknown").toLowerCase();
        if (type === "choice") {
          const nestedBodies = vault.get(body.items);
          const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b2) => b2.id === cid)).filter(Boolean) : [nestedBodies[0]];
          if (selected.length === 0) {
            selected.push(nestedBodies[0]);
          }
          choice = {
            type: "single-choice",
            items: nestedBodies.map((b2) => ({
              id: b2.id,
              label: b2.label,
              selected: selected.indexOf(b2) !== -1
            })),
            label: unknownBody.label
          };
          bodies.push(...selected);
          continue;
        }
        if (types.indexOf(type) === -1) {
          types.push(type);
        }
        items.push({
          type,
          resource: body,
          target: annotation.target,
          selector
        });
      }
    }
    return {
      types,
      items,
      choice
    };
  }
  function extractChoices(paintingAnnotationsOrCanvas) {
    const { choice } = getPaintables(paintingAnnotationsOrCanvas);
    return choice;
  }
  return {
    getAllPaintingAnnotations,
    getPaintables,
    extractChoices
  };
}
function defineProperty(name, prototype, vault) {
  prototype[DEFINED] = prototype[DEFINED] || [];
  prototype[DEFINED].push(name);
  Object.defineProperty(prototype, name, {
    get() {
      if (typeof prototype[REFS][name] === "undefined") {
        return void 0;
      }
      const ref = prototype[REFS][name];
      if (!ref) {
        return ref;
      }
      return wrapObject(vault.get(prototype[REFS][name]), vault);
    },
    set(items) {
      const existing = prototype[REFS][name];
      if (existing !== items) {
        this[REFS][name] = items;
      }
    }
  });
}
const REFS = Symbol.for("_refs_");
const REACTIVE = Symbol.for("_reactive_");
const DEFINED = Symbol.for("_defined_");
function createPrototype(vault, reactive = false) {
  const prototype = {
    id: null,
    [DEFINED]: [],
    [REFS]: {},
    [REACTIVE]: null,
    is(refOrObject) {
      if (typeof refOrObject === "string") {
        return this.id === refOrObject;
      }
      if (refOrObject.id) {
        return refOrObject.id === this.id;
      }
      return false;
    },
    reactive() {
      if (this[REACTIVE]) {
        return;
      }
      this[REACTIVE] = this.subscribe(() => this.refresh(), true);
      return () => {
        this.unreactive();
      };
    },
    refresh() {
      if (this.id) {
        const fresh = this.unwrap();
        for (const key of Object.keys(fresh || {})) {
          if (this[DEFINED].includes(key)) {
            this[REFS][key] = fresh[key];
          } else {
            this[key] = fresh[key];
          }
        }
      }
    },
    unreactive() {
      if (this[REACTIVE]) {
        this[REACTIVE]();
        this[REACTIVE] = null;
      }
    },
    unwrap() {
      if (!this.id) {
        throw new Error("Invalid object");
      }
      return vault.get(this.id);
    },
    toPresentation3() {
      return vault.toPresentation3(this.unwrap());
    },
    toPresentation2() {
      return vault.toPresentation2(this.unwrap());
    },
    toJSON() {
      const that = this;
      return {
        ...that,
        items: that.items,
        annotations: that.annotations,
        structures: that.structures,
        seeAlso: that.seeAlso,
        service: that.service,
        services: that.services,
        rendering: that.rendering,
        partOf: that.partOf,
        start: that.start,
        supplementary: that.supplementary,
        homepage: that.homepage,
        thumbnail: that.thumbnail,
        placeholderCanvas: that.placeholderCanvas,
        accompanyingCanvas: that.accompanyingCanvas,
        provider: that.provider
      };
    },
    subscribe(subscription, skipInitial = true) {
      return vault.subscribe(
        () => {
          return this.id ? vault.get(this.id) : null;
        },
        subscription,
        skipInitial
      );
    }
  };
  defineProperty("items", prototype, vault);
  defineProperty("annotations", prototype, vault);
  defineProperty("structures", prototype, vault);
  defineProperty("seeAlso", prototype, vault);
  defineProperty("service", prototype, vault);
  defineProperty("services", prototype, vault);
  defineProperty("rendering", prototype, vault);
  defineProperty("partOf", prototype, vault);
  defineProperty("start", prototype, vault);
  defineProperty("supplementary", prototype, vault);
  defineProperty("homepage", prototype, vault);
  defineProperty("thumbnail", prototype, vault);
  defineProperty("placeholderCanvas", prototype, vault);
  defineProperty("accompanyingCanvas", prototype, vault);
  defineProperty("provider", prototype, vault);
  defineProperty("body", prototype, vault);
  defineProperty("logo", prototype, vault);
  return prototype;
}
function unwrapObject(object) {
  if (Array.isArray(object)) {
    return object.map((o) => unwrapObject(o));
  }
  if (!object || !object.type) {
    return object;
  }
  return { id: object.id, type: object.type };
}
function wrapObject(object, vault, reactive = false) {
  if (Array.isArray(object)) {
    return object.map((o) => wrapObject(o, vault, reactive));
  }
  if (!object || !object.type || !object.id) {
    return object;
  }
  const prototype = createPrototype(vault, reactive);
  const newObject = Object.create(prototype);
  const wrapped = Object.assign(newObject, object);
  if (reactive) {
    wrapped.reactive();
  }
  return wrapped;
}
function createObjectsHelper(vault) {
  return {
    get(id, reactive = false) {
      return wrapObject(vault.get(id), vault, reactive);
    },
    async load(id, json) {
      return wrapObject(await vault.load(id, json), vault);
    },
    async loadManifest(id, json) {
      return wrapObject(await vault.loadManifest(id, json), vault);
    },
    async loadCollection(id, json) {
      return wrapObject(await vault.loadCollection(id, json), vault);
    },
    wrapObject(objectType) {
      return wrapObject(vault.get(objectType, { skipSelfReturn: false }), vault);
    },
    isWrapped(object) {
      return !!object[DEFINED];
    }
  };
}
function createRangeHelper(vault) {
  return {
    findFirstCanvasFromRange: (range) => findFirstCanvasFromRange(vault, range),
    findAllCanvasesInRange: (range) => findAllCanvasesInRange(vault, range),
    findManifestSelectedRange: (manifest, canvasId) => findManifestSelectedRange(vault, manifest, canvasId),
    findSelectedRange: (range, canvasId) => findSelectedRange(vault, range, canvasId)
  };
}
function findFirstCanvasFromRange(vault, range) {
  for (const inner of range.items) {
    if (inner.type === "Canvas") {
      return inner;
    }
    if (inner.type === "Range") {
      const found = findFirstCanvasFromRange(vault, vault.get(inner));
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function findAllCanvasesInRange(vault, range) {
  const found = [];
  for (const inner of range.items) {
    if (inner.type === "Canvas") {
      if (inner.id.indexOf("#") !== -1) {
        found.push({ id: inner.id.split("#")[0], type: "Canvas" });
      } else {
        found.push(inner);
      }
    }
    if (inner.type === "Range") {
      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));
    }
    if (inner.type === "SpecificResource") {
      const sourceId = typeof inner.source === "string" ? inner.source : inner.source.id;
      found.push({ id: sourceId, type: "Canvas" });
    }
  }
  return found;
}
function findManifestSelectedRange(vault, manifest, canvasId) {
  for (const range of manifest.structures) {
    const found = findSelectedRange(vault, vault.get(range), canvasId);
    if (found) {
      return found;
    }
  }
  return null;
}
function findSelectedRange(vault, range, canvasId) {
  var _a;
  for (const inner of range.items) {
    const parsedId = (_a = inner.id) == null ? void 0 : _a.split("#")[0];
    if (inner.type === "SpecificResource" && inner.source === canvasId) {
      return range;
    }
    if (inner.type === "Canvas" && canvasId === parsedId) {
      return range;
    }
    if (inner.type === "Range") {
      const found = findSelectedRange(vault, vault.get(inner), canvasId);
      if (found) {
        return found;
      }
    }
  }
  return null;
}
function createSequenceHelper(vault) {
  return {
    getVisibleCanvasesFromCanvasId: (manifestOrRange, canvasId, preventPaged = false) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),
    getManifestSequence: (manifestOrRange, options = {}) => getManifestSequence(vault, manifestOrRange, options)
  };
}
function getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged = false) {
  const behavior = manifestOrRange.behavior;
  const fullCanvas = canvasId ? vault.get(canvasId) : null;
  if (!fullCanvas) {
    return [];
  }
  const canvasBehavior = fullCanvas.behavior;
  const isPaged = preventPaged ? false : behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const isCanvasFacingPages = canvasBehavior.includes("facing-pages");
  const isCanvasNonPaged = canvasBehavior.includes("non-paged");
  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {
    return [{ id: fullCanvas.id, type: "Canvas" }];
  }
  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);
  if (isContinuous) {
    return manifestItems;
  }
  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);
  if (canvasIndex === -1) {
    return [];
  }
  for (const indexes of ordering) {
    if (indexes.includes(canvasIndex)) {
      return indexes.map((index) => manifestItems[index]);
    }
  }
  return [{ id: fullCanvas.id, type: "Canvas" }];
}
function getManifestSequence(vault, manifestOrRange, { disablePaging, skipNonPaged } = {}) {
  const behavior = manifestOrRange.behavior;
  const isPaged = behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const manifestItems = manifestOrRange.type === "Manifest" ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);
  if (isContinuous) {
    return [manifestItems, [manifestItems.map((_2, index) => index)]];
  }
  if (isIndividuals || !isPaged || disablePaging) {
    return [manifestItems, manifestItems.map((_2, index) => [index])];
  }
  const ordering = [];
  let currentOrdering = [];
  const flush = () => {
    if (currentOrdering.length) {
      ordering.push([...currentOrdering]);
      currentOrdering = [];
    }
  };
  let offset = 0;
  let flushNextPaged = false;
  for (let i = 0; i < manifestItems.length; i++) {
    const canvas = vault.get(manifestItems[i]);
    if (canvas.behavior.includes("non-paged")) {
      if (i === offset) {
        offset++;
      }
      if (!skipNonPaged) {
        flush();
        ordering.push([i]);
        flush();
      }
      continue;
    }
    if (i === offset || canvas.behavior.includes("facing-pages")) {
      if (currentOrdering.length) {
        flushNextPaged = true;
      }
      flush();
      ordering.push([i]);
      flush();
      continue;
    }
    currentOrdering.push(i);
    if (flushNextPaged) {
      flush();
      flushNextPaged = false;
      continue;
    }
    if (currentOrdering.length > 1) {
      flush();
    }
  }
  if (currentOrdering.length) {
    flush();
  }
  return [manifestItems, ordering];
}
export { buildLocaleString, createEventsHelper, createObjectsHelper, createPaintingAnnotationsHelper, createRangeHelper, createSequenceHelper, createStylesHelper, createThumbnailHelper, decodeContentState, encodeContentState, expandTarget, findAllCanvasesInRange, findFirstCanvasFromRange, findManifestSelectedRange, findSelectedRange, getClosestLanguage, getManifestSequence, getValue, getVisibleCanvasesFromCanvasId, normaliseContentState, parseContentState, parseSelector, parseSpecificResource, serialiseContentState, unwrapObject, validateContentState, wrapObject };
//# sourceMappingURL=index.mjs.map
