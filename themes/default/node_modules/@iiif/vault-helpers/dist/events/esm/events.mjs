function createEventsHelper(vault) {
  return {
    addEventListener(resource, event, listener, scope) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          const callbacks = registeredCallbacks || [];
          for (const registered of callbacks) {
            if (registered.callback === listener) {
              return callbacks;
            }
          }
          return [...callbacks, { callback: listener, scope }];
        }
      );
      return listener;
    },
    removeEventListener(resource, event, listener) {
      if (!resource) {
        return;
      }
      vault.setMetaValue(
        [resource.id, "eventManager", event],
        (registeredCallbacks) => {
          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);
        }
      );
    },
    getListenersAsProps(resourceOrId, scope) {
      const resource = typeof resourceOrId === "string" ? { id: resourceOrId } : resourceOrId;
      if (!resource || !resource.id) {
        return {};
      }
      const hooks = vault.getResourceMeta(resource.id, "eventManager");
      const props = {};
      if (hooks && resource) {
        for (const hook of Object.keys(hooks)) {
          props[hook] = (e) => {
            const fullResource = vault.get(resource);
            for (const { callback, scope: _scope } of hooks[hook] || []) {
              if (!_scope || scope && _scope.indexOf(scope) !== -1) {
                callback(e, fullResource);
              }
            }
          };
        }
      }
      return props;
    }
  };
}
export { createEventsHelper };
//# sourceMappingURL=events.mjs.map
