{"version":3,"file":"events.mjs","sources":["../../../src/events.ts"],"sourcesContent":["import type { Reference } from '@iiif/presentation-3';\nimport type { Vault } from '@iiif/vault';\n\nexport function createEventsHelper(vault: Vault) {\n  return {\n    addEventListener<T>(\n      resource: Reference<any>,\n      event: string,\n      listener: (e: any, resource: T) => void,\n      scope?: string[]\n    ) {\n      if (!resource) {\n        return;\n      }\n\n      vault.setMetaValue<Array<{ callback: any; scope?: string[] }>>(\n        [resource.id, 'eventManager', event],\n        (registeredCallbacks) => {\n          const callbacks = registeredCallbacks || [];\n          for (const registered of callbacks) {\n            if (registered.callback === listener) {\n              // @todo check for scopes matching, very edge-case as scopes should be fixed.\n              return callbacks;\n            }\n          }\n          return [...callbacks, { callback: listener, scope }];\n        }\n      );\n\n      return listener;\n    },\n\n    removeEventListener<T>(resource: Reference<any>, event: string, listener: (e: any, resource: T) => void) {\n      if (!resource) {\n        return;\n      }\n      vault.setMetaValue<Array<{ callback: () => void; scope?: string[] }>>(\n        [resource.id, 'eventManager', event],\n        (registeredCallbacks) => {\n          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);\n        }\n      );\n    },\n\n    getListenersAsProps(resourceOrId: string | Reference<any>, scope?: string[]) {\n      const resource = typeof resourceOrId === 'string' ? { id: resourceOrId } : resourceOrId;\n      if (!resource || !resource.id) {\n        return {};\n      }\n      const hooks = vault.getResourceMeta(resource.id, 'eventManager');\n      const props: any = {};\n      if (hooks && resource) {\n        for (const hook of Object.keys(hooks)) {\n          props[hook] = (e: any) => {\n            const fullResource = vault.get(resource);\n            for (const { callback, scope: _scope } of hooks[hook] || []) {\n              if (!_scope || (scope && _scope.indexOf(scope) !== -1)) {\n                callback(e, fullResource);\n              }\n            }\n          };\n        }\n      }\n      return props;\n    },\n  };\n}\n"],"names":[],"mappings":"AAGO,SAAS,mBAAmB,OAAc;AACxC,SAAA;AAAA,IACL,iBACE,UACA,OACA,UACA,OACA;AACA,UAAI,CAAC,UAAU;AACb;AAAA,MACF;AAEM,YAAA;AAAA,QACJ,CAAC,SAAS,IAAI,gBAAgB,KAAK;AAAA,QACnC,CAAC,wBAAwB;AACjB,gBAAA,YAAY,uBAAuB;AACzC,qBAAW,cAAc,WAAW;AAC9B,gBAAA,WAAW,aAAa,UAAU;AAE7B,qBAAA;AAAA,YACT;AAAA,UACF;AACA,iBAAO,CAAC,GAAG,WAAW,EAAE,UAAU,UAAU,OAAO;AAAA,QACrD;AAAA,MAAA;AAGK,aAAA;AAAA,IACT;AAAA,IAEA,oBAAuB,UAA0B,OAAe,UAAyC;AACvG,UAAI,CAAC,UAAU;AACb;AAAA,MACF;AACM,YAAA;AAAA,QACJ,CAAC,SAAS,IAAI,gBAAgB,KAAK;AAAA,QACnC,CAAC,wBAAwB;AACf,kBAAA,uBAAuB,CAAA,GAAI,OAAO,CAAC,uBAAuB,mBAAmB,aAAa,QAAQ;AAAA,QAC5G;AAAA,MAAA;AAAA,IAEJ;AAAA,IAEA,oBAAoB,cAAuC,OAAkB;AAC3E,YAAM,WAAW,OAAO,iBAAiB,WAAW,EAAE,IAAI,aAAiB,IAAA;AAC3E,UAAI,CAAC,YAAY,CAAC,SAAS,IAAI;AAC7B,eAAO;MACT;AACA,YAAM,QAAQ,MAAM,gBAAgB,SAAS,IAAI,cAAc;AAC/D,YAAM,QAAa,CAAA;AACnB,UAAI,SAAS,UAAU;AACrB,mBAAW,QAAQ,OAAO,KAAK,KAAK,GAAG;AAC/B,gBAAA,QAAQ,CAAC,MAAW;AAClB,kBAAA,eAAe,MAAM,IAAI,QAAQ;AAC5B,uBAAA,EAAE,UAAU,OAAO,YAAY,MAAM,SAAS,IAAI;AAC3D,kBAAI,CAAC,UAAW,SAAS,OAAO,QAAQ,KAAK,MAAM,IAAK;AACtD,yBAAS,GAAG,YAAY;AAAA,cAC1B;AAAA,YACF;AAAA,UAAA;AAAA,QAEJ;AAAA,MACF;AACO,aAAA;AAAA,IACT;AAAA,EAAA;AAEJ;;"}