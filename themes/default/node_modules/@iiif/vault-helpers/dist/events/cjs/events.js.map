{"version":3,"file":"events.js","sources":["../../../src/events.ts"],"sourcesContent":["import type { Reference } from '@iiif/presentation-3';\nimport type { Vault } from '@iiif/vault';\n\nexport function createEventsHelper(vault: Vault) {\n  return {\n    addEventListener<T>(\n      resource: Reference<any>,\n      event: string,\n      listener: (e: any, resource: T) => void,\n      scope?: string[]\n    ) {\n      if (!resource) {\n        return;\n      }\n\n      vault.setMetaValue<Array<{ callback: any; scope?: string[] }>>(\n        [resource.id, 'eventManager', event],\n        (registeredCallbacks) => {\n          const callbacks = registeredCallbacks || [];\n          for (const registered of callbacks) {\n            if (registered.callback === listener) {\n              // @todo check for scopes matching, very edge-case as scopes should be fixed.\n              return callbacks;\n            }\n          }\n          return [...callbacks, { callback: listener, scope }];\n        }\n      );\n\n      return listener;\n    },\n\n    removeEventListener<T>(resource: Reference<any>, event: string, listener: (e: any, resource: T) => void) {\n      if (!resource) {\n        return;\n      }\n      vault.setMetaValue<Array<{ callback: () => void; scope?: string[] }>>(\n        [resource.id, 'eventManager', event],\n        (registeredCallbacks) => {\n          return (registeredCallbacks || []).filter((registeredCallback) => registeredCallback.callback !== listener);\n        }\n      );\n    },\n\n    getListenersAsProps(resourceOrId: string | Reference<any>, scope?: string[]) {\n      const resource = typeof resourceOrId === 'string' ? { id: resourceOrId } : resourceOrId;\n      if (!resource || !resource.id) {\n        return {};\n      }\n      const hooks = vault.getResourceMeta(resource.id, 'eventManager');\n      const props: any = {};\n      if (hooks && resource) {\n        for (const hook of Object.keys(hooks)) {\n          props[hook] = (e: any) => {\n            const fullResource = vault.get(resource);\n            for (const { callback, scope: _scope } of hooks[hook] || []) {\n              if (!_scope || (scope && _scope.indexOf(scope) !== -1)) {\n                callback(e, fullResource);\n              }\n            }\n          };\n        }\n      }\n      return props;\n    },\n  };\n}\n"],"names":["createEventsHelper","vault","resource","event","listener","scope","registeredCallbacks","callbacks","registered","registeredCallback","resourceOrId","hooks","props","hook","e","fullResource","callback","_scope"],"mappings":"4GAGO,SAASA,EAAmBC,EAAc,CACxC,MAAA,CACL,iBACEC,EACAC,EACAC,EACAC,EACA,CACA,GAAI,EAACH,EAIC,OAAAD,EAAA,aACJ,CAACC,EAAS,GAAI,eAAgBC,CAAK,EAClCG,GAAwB,CACjB,MAAAC,EAAYD,GAAuB,GACzC,UAAWE,KAAcD,EACnB,GAAAC,EAAW,WAAaJ,EAEnB,OAAAG,EAGX,MAAO,CAAC,GAAGA,EAAW,CAAE,SAAUH,EAAU,MAAAC,EAAO,CACrD,CAAA,EAGKD,CACT,EAEA,oBAAuBF,EAA0BC,EAAeC,EAAyC,CACnG,CAACF,GAGCD,EAAA,aACJ,CAACC,EAAS,GAAI,eAAgBC,CAAK,EAClCG,IACSA,GAAuB,CAAA,GAAI,OAAQG,GAAuBA,EAAmB,WAAaL,CAAQ,CAC5G,CAEJ,EAEA,oBAAoBM,EAAuCL,EAAkB,CAC3E,MAAMH,EAAW,OAAOQ,GAAiB,SAAW,CAAE,GAAIA,CAAiB,EAAAA,EAC3E,GAAI,CAACR,GAAY,CAACA,EAAS,GACzB,MAAO,GAET,MAAMS,EAAQV,EAAM,gBAAgBC,EAAS,GAAI,cAAc,EACzDU,EAAa,CAAA,EACnB,GAAID,GAAST,EACX,UAAWW,KAAQ,OAAO,KAAKF,CAAK,EAC5BC,EAAAC,GAASC,GAAW,CAClB,MAAAC,EAAed,EAAM,IAAIC,CAAQ,EAC5B,SAAA,CAAE,SAAAc,EAAU,MAAOC,KAAYN,EAAME,IAAS,IACnD,CAACI,GAAWZ,GAASY,EAAO,QAAQZ,CAAK,IAAM,KACjDW,EAASF,EAAGC,CAAY,CAE5B,EAIC,OAAAH,CACT,CAAA,CAEJ"}