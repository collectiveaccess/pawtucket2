import { ImageServiceLoader, getFixedSizeFromImage } from "@atlas-viewer/iiif-image-api";
function createThumbnailHelper(vault, dependencies = {}) {
  const imageServiceLoader = dependencies.imageServiceLoader || new ImageServiceLoader();
  async function getBestThumbnailAtSize(input, request, dereference, candidates = [], dimensions) {
    if (typeof input === "string") {
      return { best: getFixedSizeFromImage(input), fallback: [], log: [] };
    }
    const fullInput = vault.get(input);
    if (typeof fullInput === "string") {
      return { best: getFixedSizeFromImage(fullInput), fallback: [], log: [] };
    }
    switch (fullInput.type) {
      case "Annotation": {
        const contentResources = fullInput.body;
        const firstContentResources = vault.get(contentResources[0]);
        if (dimensions && !firstContentResources.width) {
          firstContentResources.width = dimensions.width;
          firstContentResources.height = dimensions.height;
        }
        return await imageServiceLoader.getThumbnailFromResource(
          firstContentResources,
          request,
          dereference,
          candidates
        );
      }
      case "Canvas": {
        const canvas = fullInput;
        if (canvas.thumbnail && canvas.thumbnail.length) {
          const thumbnail = vault.get(canvas.thumbnail[0]);
          const potentialThumbnails = await imageServiceLoader.getImageCandidates(thumbnail, dereference);
          if (potentialThumbnails && potentialThumbnails.length) {
            candidates.push(...potentialThumbnails);
          }
        }
        return getBestThumbnailAtSize(canvas.items[0], request, dereference, candidates, {
          width: canvas.width,
          height: canvas.height
        });
      }
      case "AnnotationPage": {
        const annotationPage = fullInput;
        return getBestThumbnailAtSize(annotationPage.items[0], request, dereference, candidates, dimensions);
      }
      case "Choice": {
        const choice = fullInput;
        return getBestThumbnailAtSize(choice.items[0], request, dereference, candidates, dimensions);
      }
      case "Collection": {
        const collection = fullInput;
        const firstManifest = collection.items[0];
        return getBestThumbnailAtSize(firstManifest, request, dereference, candidates, dimensions);
      }
      case "Manifest": {
        const manifest = fullInput;
        const firstCanvas = manifest.items[0];
        return getBestThumbnailAtSize(firstCanvas, request, dereference, candidates, dimensions);
      }
      case "SpecificResource":
      case "Image":
      case "Dataset":
      case "Sound":
      case "Text":
      case "TextualBody":
      case "Video":
        if (dimensions && !fullInput.width) {
          fullInput.width = dimensions.width;
          fullInput.height = dimensions.height;
        }
        return imageServiceLoader.getThumbnailFromResource(fullInput, request, dereference, candidates);
      case "Service":
      case "Range":
      case "AnnotationCollection":
      case "CanvasReference":
      case "ContentResource":
        return { best: void 0, fallback: [], log: [] };
    }
    return { best: void 0, fallback: [], log: [] };
  }
  return {
    getBestThumbnailAtSize
  };
}
export { createThumbnailHelper };
//# sourceMappingURL=thumbnail.mjs.map
