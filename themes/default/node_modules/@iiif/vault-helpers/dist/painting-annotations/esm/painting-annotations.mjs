function parseSpecificResource(resource) {
  if (resource.type === "SpecificResource") {
    return [resource.source, { selector: resource.selector }];
  }
  return [resource, { selector: null }];
}
function createPaintingAnnotationsHelper(vault) {
  function getAllPaintingAnnotations(canvasOrId) {
    const canvas = canvasOrId ? typeof canvasOrId === "string" ? vault.get(canvasOrId) : canvasOrId : null;
    if (!canvas) {
      return [];
    }
    const annotationPages = vault.get(canvas.items);
    const flatAnnotations = [];
    for (const page of annotationPages) {
      flatAnnotations.push(...vault.get(page.items));
    }
    return flatAnnotations;
  }
  function getPaintables(paintingAnnotationsOrCanvas, enabledChoices = []) {
    const paintingAnnotations = Array.isArray(paintingAnnotationsOrCanvas) ? paintingAnnotationsOrCanvas : getAllPaintingAnnotations(paintingAnnotationsOrCanvas);
    const types = [];
    let choice = null;
    const items = [];
    for (const annotation of paintingAnnotations) {
      if (annotation.type !== "Annotation") {
        throw new Error(`getPaintables() accept either a canvas or list of annotations`);
      }
      const bodies = vault.get(annotation.body);
      for (const unknownBody of bodies) {
        const [body, { selector }] = parseSpecificResource(unknownBody);
        const type = (body.type || "unknown").toLowerCase();
        if (type === "choice") {
          const nestedBodies = vault.get(body.items);
          const selected = enabledChoices.length ? enabledChoices.map((cid) => nestedBodies.find((b) => b.id === cid)).filter(Boolean) : [nestedBodies[0]];
          if (selected.length === 0) {
            selected.push(nestedBodies[0]);
          }
          choice = {
            type: "single-choice",
            items: nestedBodies.map((b) => ({
              id: b.id,
              label: b.label,
              selected: selected.indexOf(b) !== -1
            })),
            label: unknownBody.label
          };
          bodies.push(...selected);
          continue;
        }
        if (types.indexOf(type) === -1) {
          types.push(type);
        }
        items.push({
          type,
          resource: body,
          target: annotation.target,
          selector
        });
      }
    }
    return {
      types,
      items,
      choice
    };
  }
  function extractChoices(paintingAnnotationsOrCanvas) {
    const { choice } = getPaintables(paintingAnnotationsOrCanvas);
    return choice;
  }
  return {
    getAllPaintingAnnotations,
    getPaintables,
    extractChoices
  };
}
export { createPaintingAnnotationsHelper, parseSpecificResource };
//# sourceMappingURL=painting-annotations.mjs.map
