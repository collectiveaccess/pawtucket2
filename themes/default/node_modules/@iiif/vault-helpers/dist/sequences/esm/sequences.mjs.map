{"version":3,"file":"sequences.mjs","sources":["../../../src/ranges.ts","../../../src/sequences.ts"],"sourcesContent":["import { Vault } from '@iiif/vault';\nimport { ManifestNormalized, RangeNormalized, Reference } from '@iiif/presentation-3';\n\nexport function createRangeHelper(vault: Vault) {\n  return {\n    findFirstCanvasFromRange: (range: RangeNormalized) => findFirstCanvasFromRange(vault, range),\n    findAllCanvasesInRange: (range: RangeNormalized) => findAllCanvasesInRange(vault, range),\n    findManifestSelectedRange: (manifest: ManifestNormalized, canvasId: string) =>\n      findManifestSelectedRange(vault, manifest, canvasId),\n    findSelectedRange: (range: RangeNormalized, canvasId: string) => findSelectedRange(vault, range, canvasId),\n  };\n}\n\nexport function findFirstCanvasFromRange(vault: Vault, range: RangeNormalized): null | Reference<'Canvas'> {\n  for (const inner of range.items) {\n    if (inner.type === 'Canvas') {\n      return inner as Reference<'Canvas'>;\n    }\n    if (inner.type === 'Range') {\n      const found = findFirstCanvasFromRange(vault, vault.get(inner));\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport function findAllCanvasesInRange(vault: Vault, range: RangeNormalized): Array<Reference<'Canvas'>> {\n  const found: Reference<'Canvas'>[] = [];\n  for (const inner of range.items) {\n    if (inner.type === 'Canvas') {\n      if (inner.id.indexOf('#') !== -1) {\n        found.push({ id: inner.id.split('#')[0], type: 'Canvas' });\n      } else {\n        found.push(inner as Reference<'Canvas'>);\n      }\n    }\n    if (inner.type === 'Range') {\n      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));\n    }\n    if ((inner as any).type === 'SpecificResource') {\n      const sourceId = typeof (inner as any).source === 'string' ? (inner as any).source : (inner as any).source.id;\n      found.push({ id: sourceId, type: 'Canvas' });\n    }\n  }\n  return found;\n}\n\nexport function findManifestSelectedRange(\n  vault: Vault,\n  manifest: ManifestNormalized,\n  canvasId: string\n): null | RangeNormalized {\n  for (const range of manifest.structures) {\n    const found = findSelectedRange(vault, vault.get(range), canvasId);\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\nexport function findSelectedRange(vault: Vault, range: RangeNormalized, canvasId: string): null | RangeNormalized {\n  for (const inner of range.items) {\n    const parsedId = inner.id?.split('#')[0];\n    if ((inner as any).type === 'SpecificResource' && (inner as any).source === canvasId) {\n      return range;\n    }\n    if (inner.type === 'Canvas' && canvasId === parsedId) {\n      return range;\n    }\n    if (inner.type === 'Range') {\n      const found = findSelectedRange(vault, vault.get(inner), canvasId);\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n","import { CanvasNormalized, ManifestNormalized, RangeNormalized, Reference } from '@iiif/presentation-3';\nimport { Vault } from '@iiif/vault';\nimport { findAllCanvasesInRange } from './ranges';\n\nexport function createSequenceHelper(vault: Vault) {\n  return {\n    getVisibleCanvasesFromCanvasId: (\n      manifestOrRange: ManifestNormalized | RangeNormalized,\n      canvasId: string | null,\n      preventPaged = false\n    ) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),\n    getManifestSequence: (\n      manifestOrRange: ManifestNormalized | RangeNormalized,\n      options: { disablePaging?: boolean; skipNonPaged?: boolean } = {}\n    ) => getManifestSequence(vault, manifestOrRange, options),\n  };\n}\n\n/**\n * Get visible canvases from canvas ID\n *\n * This function returns a list of canvas references that should all be displayed\n * when the passed canvasId is visible. This should work for individual items,\n * 2-up paged view and continuous (scrolls).\n *\n * The options are listed below (from IIIF docs)\n *\n * - `unordered` - Valid on Collections, Manifests and Ranges. The Canvases included in resources that have this behavior\n *    have no inherent order, and user interfaces should avoid implying an order to the user. Disjoint with individuals,\n *    continuous, and paged.\n *\n * - `individuals` - Valid on Collections, Manifests, and Ranges. For Collections that have this behavior, each of the\n *    included Manifests are distinct objects in the given order. For Manifests and Ranges, the included Canvases are\n *    distinct views, and should not be presented in a page-turning interface. This is the default layout behavior if\n *    not specified. Disjoint with unordered, continuous, and paged.\n *\n * - `continuous`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and\n *    width dimensions. Canvases included in resources that have this behavior are partial views and an appropriate\n *    rendering might display all of the Canvases virtually stitched together, such as a long scroll split into\n *    sections. This behavior has no implication for audio resources. The viewingDirection of the Manifest will\n *    determine the appropriate arrangement of the Canvases. Disjoint with unordered, individuals and paged.\n *\n * - `paged`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and width\n *    dimensions. Canvases included in resources that have this behavior represent views that should be presented in\n *    a page-turning interface if one is available. The first canvas is a single view (the first recto) and thus the\n *    second canvas likely represents the back of the object in the first canvas. If this is not the case, see the\n *    behavior value non-paged. Disjoint with unordered, individuals, continuous, facing-pages and non-paged.\n *\n */\nexport function getVisibleCanvasesFromCanvasId(\n  vault: Vault,\n  manifestOrRange: ManifestNormalized | RangeNormalized,\n  canvasId: string | null,\n  preventPaged = false\n): Reference<'Canvas'>[] {\n  const behavior = manifestOrRange.behavior;\n  const fullCanvas = canvasId ? vault.get<CanvasNormalized>(canvasId) : null;\n  if (!fullCanvas) {\n    return [];\n  }\n\n  const canvasBehavior = fullCanvas.behavior;\n  const isPaged = preventPaged ? false : behavior.includes('paged');\n  const isContinuous = isPaged ? false : behavior.includes('continuous');\n  const isIndividuals = isPaged || isContinuous ? false : behavior.includes('individuals');\n  const isCanvasFacingPages = canvasBehavior.includes('facing-pages');\n  const isCanvasNonPaged = canvasBehavior.includes('non-paged');\n\n  // Individuals should just be the default.\n  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {\n    return [{ id: fullCanvas.id, type: 'Canvas' }];\n  }\n\n  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);\n\n  // Continuous should just return all items together.\n  if (isContinuous) {\n    return manifestItems;\n  }\n\n  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);\n  if (canvasIndex === -1) {\n    return [];\n  }\n\n  for (const indexes of ordering) {\n    if (indexes.includes(canvasIndex)) {\n      return indexes.map((index) => manifestItems[index]);\n    }\n  }\n\n  return [{ id: fullCanvas.id, type: 'Canvas' }];\n}\n\nexport function getManifestSequence(\n  vault: Vault,\n  manifestOrRange: ManifestNormalized | RangeNormalized,\n  { disablePaging, skipNonPaged }: { disablePaging?: boolean; skipNonPaged?: boolean } = {}\n): [Reference<'Canvas'>[], number[][]] {\n  const behavior = manifestOrRange.behavior;\n  const isPaged = behavior.includes('paged');\n  const isContinuous = isPaged ? false : behavior.includes('continuous');\n  const isIndividuals = isPaged || isContinuous ? false : behavior.includes('individuals');\n  const manifestItems =\n    manifestOrRange.type === 'Manifest' ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);\n\n  // Continuous should just return all items together.\n  if (isContinuous) {\n    return [manifestItems, [manifestItems.map((_, index) => index)]];\n  }\n\n  // Individuals should just be the default.\n  if (isIndividuals || !isPaged || disablePaging) {\n    return [manifestItems, manifestItems.map((_, index) => [index])];\n  }\n\n  // This is the tricky case.\n  const ordering: number[][] = [];\n  let currentOrdering: number[] = [];\n\n  const flush = () => {\n    if (currentOrdering.length) {\n      ordering.push([...currentOrdering]);\n      currentOrdering = [];\n    }\n  };\n\n  let offset = 0;\n  let flushNextPaged = false;\n  for (let i = 0; i < manifestItems.length; i++) {\n    const canvas = vault.get<CanvasNormalized>(manifestItems[i]);\n    if (canvas.behavior.includes('non-paged')) {\n      if (i === offset) {\n        offset++;\n      }\n      if (!skipNonPaged) {\n        flush();\n        ordering.push([i]);\n        flush();\n      }\n      continue;\n    }\n\n    if (i === offset || canvas.behavior.includes('facing-pages')) {\n      // Flush and push a single.\n      if (currentOrdering.length) {\n        flushNextPaged = true;\n      }\n      flush();\n      ordering.push([i]);\n      flush();\n      continue;\n    }\n\n    currentOrdering.push(i);\n\n    if (flushNextPaged) {\n      flush();\n      flushNextPaged = false;\n      continue;\n    }\n\n    if (currentOrdering.length > 1) {\n      flush();\n    }\n  }\n\n  if (currentOrdering.length) {\n    flush();\n  }\n\n  return [manifestItems, ordering];\n}\n"],"names":[],"mappings":"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"}