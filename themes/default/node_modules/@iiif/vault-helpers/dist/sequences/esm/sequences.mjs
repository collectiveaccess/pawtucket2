function findAllCanvasesInRange(vault, range) {
  const found = [];
  for (const inner of range.items) {
    if (inner.type === "Canvas") {
      if (inner.id.indexOf("#") !== -1) {
        found.push({ id: inner.id.split("#")[0], type: "Canvas" });
      } else {
        found.push(inner);
      }
    }
    if (inner.type === "Range") {
      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));
    }
    if (inner.type === "SpecificResource") {
      const sourceId = typeof inner.source === "string" ? inner.source : inner.source.id;
      found.push({ id: sourceId, type: "Canvas" });
    }
  }
  return found;
}
function createSequenceHelper(vault) {
  return {
    getVisibleCanvasesFromCanvasId: (manifestOrRange, canvasId, preventPaged = false) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),
    getManifestSequence: (manifestOrRange, options = {}) => getManifestSequence(vault, manifestOrRange, options)
  };
}
function getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged = false) {
  const behavior = manifestOrRange.behavior;
  const fullCanvas = canvasId ? vault.get(canvasId) : null;
  if (!fullCanvas) {
    return [];
  }
  const canvasBehavior = fullCanvas.behavior;
  const isPaged = preventPaged ? false : behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const isCanvasFacingPages = canvasBehavior.includes("facing-pages");
  const isCanvasNonPaged = canvasBehavior.includes("non-paged");
  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {
    return [{ id: fullCanvas.id, type: "Canvas" }];
  }
  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);
  if (isContinuous) {
    return manifestItems;
  }
  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);
  if (canvasIndex === -1) {
    return [];
  }
  for (const indexes of ordering) {
    if (indexes.includes(canvasIndex)) {
      return indexes.map((index) => manifestItems[index]);
    }
  }
  return [{ id: fullCanvas.id, type: "Canvas" }];
}
function getManifestSequence(vault, manifestOrRange, { disablePaging, skipNonPaged } = {}) {
  const behavior = manifestOrRange.behavior;
  const isPaged = behavior.includes("paged");
  const isContinuous = isPaged ? false : behavior.includes("continuous");
  const isIndividuals = isPaged || isContinuous ? false : behavior.includes("individuals");
  const manifestItems = manifestOrRange.type === "Manifest" ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);
  if (isContinuous) {
    return [manifestItems, [manifestItems.map((_, index) => index)]];
  }
  if (isIndividuals || !isPaged || disablePaging) {
    return [manifestItems, manifestItems.map((_, index) => [index])];
  }
  const ordering = [];
  let currentOrdering = [];
  const flush = () => {
    if (currentOrdering.length) {
      ordering.push([...currentOrdering]);
      currentOrdering = [];
    }
  };
  let offset = 0;
  let flushNextPaged = false;
  for (let i = 0; i < manifestItems.length; i++) {
    const canvas = vault.get(manifestItems[i]);
    if (canvas.behavior.includes("non-paged")) {
      if (i === offset) {
        offset++;
      }
      if (!skipNonPaged) {
        flush();
        ordering.push([i]);
        flush();
      }
      continue;
    }
    if (i === offset || canvas.behavior.includes("facing-pages")) {
      if (currentOrdering.length) {
        flushNextPaged = true;
      }
      flush();
      ordering.push([i]);
      flush();
      continue;
    }
    currentOrdering.push(i);
    if (flushNextPaged) {
      flush();
      flushNextPaged = false;
      continue;
    }
    if (currentOrdering.length > 1) {
      flush();
    }
  }
  if (currentOrdering.length) {
    flush();
  }
  return [manifestItems, ordering];
}
export { createSequenceHelper, getManifestSequence, getVisibleCanvasesFromCanvasId };
//# sourceMappingURL=sequences.mjs.map
