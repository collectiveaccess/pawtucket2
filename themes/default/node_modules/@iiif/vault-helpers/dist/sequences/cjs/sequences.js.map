{"version":3,"file":"sequences.js","sources":["../../../src/ranges.ts","../../../src/sequences.ts"],"sourcesContent":["import { Vault } from '@iiif/vault';\nimport { ManifestNormalized, RangeNormalized, Reference } from '@iiif/presentation-3';\n\nexport function createRangeHelper(vault: Vault) {\n  return {\n    findFirstCanvasFromRange: (range: RangeNormalized) => findFirstCanvasFromRange(vault, range),\n    findAllCanvasesInRange: (range: RangeNormalized) => findAllCanvasesInRange(vault, range),\n    findManifestSelectedRange: (manifest: ManifestNormalized, canvasId: string) =>\n      findManifestSelectedRange(vault, manifest, canvasId),\n    findSelectedRange: (range: RangeNormalized, canvasId: string) => findSelectedRange(vault, range, canvasId),\n  };\n}\n\nexport function findFirstCanvasFromRange(vault: Vault, range: RangeNormalized): null | Reference<'Canvas'> {\n  for (const inner of range.items) {\n    if (inner.type === 'Canvas') {\n      return inner as Reference<'Canvas'>;\n    }\n    if (inner.type === 'Range') {\n      const found = findFirstCanvasFromRange(vault, vault.get(inner));\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n\nexport function findAllCanvasesInRange(vault: Vault, range: RangeNormalized): Array<Reference<'Canvas'>> {\n  const found: Reference<'Canvas'>[] = [];\n  for (const inner of range.items) {\n    if (inner.type === 'Canvas') {\n      if (inner.id.indexOf('#') !== -1) {\n        found.push({ id: inner.id.split('#')[0], type: 'Canvas' });\n      } else {\n        found.push(inner as Reference<'Canvas'>);\n      }\n    }\n    if (inner.type === 'Range') {\n      found.push(...findAllCanvasesInRange(vault, vault.get(inner)));\n    }\n    if ((inner as any).type === 'SpecificResource') {\n      const sourceId = typeof (inner as any).source === 'string' ? (inner as any).source : (inner as any).source.id;\n      found.push({ id: sourceId, type: 'Canvas' });\n    }\n  }\n  return found;\n}\n\nexport function findManifestSelectedRange(\n  vault: Vault,\n  manifest: ManifestNormalized,\n  canvasId: string\n): null | RangeNormalized {\n  for (const range of manifest.structures) {\n    const found = findSelectedRange(vault, vault.get(range), canvasId);\n    if (found) {\n      return found;\n    }\n  }\n\n  return null;\n}\n\nexport function findSelectedRange(vault: Vault, range: RangeNormalized, canvasId: string): null | RangeNormalized {\n  for (const inner of range.items) {\n    const parsedId = inner.id?.split('#')[0];\n    if ((inner as any).type === 'SpecificResource' && (inner as any).source === canvasId) {\n      return range;\n    }\n    if (inner.type === 'Canvas' && canvasId === parsedId) {\n      return range;\n    }\n    if (inner.type === 'Range') {\n      const found = findSelectedRange(vault, vault.get(inner), canvasId);\n      if (found) {\n        return found;\n      }\n    }\n  }\n  return null;\n}\n","import { CanvasNormalized, ManifestNormalized, RangeNormalized, Reference } from '@iiif/presentation-3';\nimport { Vault } from '@iiif/vault';\nimport { findAllCanvasesInRange } from './ranges';\n\nexport function createSequenceHelper(vault: Vault) {\n  return {\n    getVisibleCanvasesFromCanvasId: (\n      manifestOrRange: ManifestNormalized | RangeNormalized,\n      canvasId: string | null,\n      preventPaged = false\n    ) => getVisibleCanvasesFromCanvasId(vault, manifestOrRange, canvasId, preventPaged),\n    getManifestSequence: (\n      manifestOrRange: ManifestNormalized | RangeNormalized,\n      options: { disablePaging?: boolean; skipNonPaged?: boolean } = {}\n    ) => getManifestSequence(vault, manifestOrRange, options),\n  };\n}\n\n/**\n * Get visible canvases from canvas ID\n *\n * This function returns a list of canvas references that should all be displayed\n * when the passed canvasId is visible. This should work for individual items,\n * 2-up paged view and continuous (scrolls).\n *\n * The options are listed below (from IIIF docs)\n *\n * - `unordered` - Valid on Collections, Manifests and Ranges. The Canvases included in resources that have this behavior\n *    have no inherent order, and user interfaces should avoid implying an order to the user. Disjoint with individuals,\n *    continuous, and paged.\n *\n * - `individuals` - Valid on Collections, Manifests, and Ranges. For Collections that have this behavior, each of the\n *    included Manifests are distinct objects in the given order. For Manifests and Ranges, the included Canvases are\n *    distinct views, and should not be presented in a page-turning interface. This is the default layout behavior if\n *    not specified. Disjoint with unordered, continuous, and paged.\n *\n * - `continuous`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and\n *    width dimensions. Canvases included in resources that have this behavior are partial views and an appropriate\n *    rendering might display all of the Canvases virtually stitched together, such as a long scroll split into\n *    sections. This behavior has no implication for audio resources. The viewingDirection of the Manifest will\n *    determine the appropriate arrangement of the Canvases. Disjoint with unordered, individuals and paged.\n *\n * - `paged`  Valid on Collections, Manifests and Ranges, which include Canvases that have at least height and width\n *    dimensions. Canvases included in resources that have this behavior represent views that should be presented in\n *    a page-turning interface if one is available. The first canvas is a single view (the first recto) and thus the\n *    second canvas likely represents the back of the object in the first canvas. If this is not the case, see the\n *    behavior value non-paged. Disjoint with unordered, individuals, continuous, facing-pages and non-paged.\n *\n */\nexport function getVisibleCanvasesFromCanvasId(\n  vault: Vault,\n  manifestOrRange: ManifestNormalized | RangeNormalized,\n  canvasId: string | null,\n  preventPaged = false\n): Reference<'Canvas'>[] {\n  const behavior = manifestOrRange.behavior;\n  const fullCanvas = canvasId ? vault.get<CanvasNormalized>(canvasId) : null;\n  if (!fullCanvas) {\n    return [];\n  }\n\n  const canvasBehavior = fullCanvas.behavior;\n  const isPaged = preventPaged ? false : behavior.includes('paged');\n  const isContinuous = isPaged ? false : behavior.includes('continuous');\n  const isIndividuals = isPaged || isContinuous ? false : behavior.includes('individuals');\n  const isCanvasFacingPages = canvasBehavior.includes('facing-pages');\n  const isCanvasNonPaged = canvasBehavior.includes('non-paged');\n\n  // Individuals should just be the default.\n  if (isCanvasFacingPages || isCanvasNonPaged || isIndividuals || preventPaged) {\n    return [{ id: fullCanvas.id, type: 'Canvas' }];\n  }\n\n  const [manifestItems, ordering] = getManifestSequence(vault, manifestOrRange);\n\n  // Continuous should just return all items together.\n  if (isContinuous) {\n    return manifestItems;\n  }\n\n  const canvasIndex = manifestItems.findIndex((r) => r.id === canvasId);\n  if (canvasIndex === -1) {\n    return [];\n  }\n\n  for (const indexes of ordering) {\n    if (indexes.includes(canvasIndex)) {\n      return indexes.map((index) => manifestItems[index]);\n    }\n  }\n\n  return [{ id: fullCanvas.id, type: 'Canvas' }];\n}\n\nexport function getManifestSequence(\n  vault: Vault,\n  manifestOrRange: ManifestNormalized | RangeNormalized,\n  { disablePaging, skipNonPaged }: { disablePaging?: boolean; skipNonPaged?: boolean } = {}\n): [Reference<'Canvas'>[], number[][]] {\n  const behavior = manifestOrRange.behavior;\n  const isPaged = behavior.includes('paged');\n  const isContinuous = isPaged ? false : behavior.includes('continuous');\n  const isIndividuals = isPaged || isContinuous ? false : behavior.includes('individuals');\n  const manifestItems =\n    manifestOrRange.type === 'Manifest' ? manifestOrRange.items : findAllCanvasesInRange(vault, manifestOrRange);\n\n  // Continuous should just return all items together.\n  if (isContinuous) {\n    return [manifestItems, [manifestItems.map((_, index) => index)]];\n  }\n\n  // Individuals should just be the default.\n  if (isIndividuals || !isPaged || disablePaging) {\n    return [manifestItems, manifestItems.map((_, index) => [index])];\n  }\n\n  // This is the tricky case.\n  const ordering: number[][] = [];\n  let currentOrdering: number[] = [];\n\n  const flush = () => {\n    if (currentOrdering.length) {\n      ordering.push([...currentOrdering]);\n      currentOrdering = [];\n    }\n  };\n\n  let offset = 0;\n  let flushNextPaged = false;\n  for (let i = 0; i < manifestItems.length; i++) {\n    const canvas = vault.get<CanvasNormalized>(manifestItems[i]);\n    if (canvas.behavior.includes('non-paged')) {\n      if (i === offset) {\n        offset++;\n      }\n      if (!skipNonPaged) {\n        flush();\n        ordering.push([i]);\n        flush();\n      }\n      continue;\n    }\n\n    if (i === offset || canvas.behavior.includes('facing-pages')) {\n      // Flush and push a single.\n      if (currentOrdering.length) {\n        flushNextPaged = true;\n      }\n      flush();\n      ordering.push([i]);\n      flush();\n      continue;\n    }\n\n    currentOrdering.push(i);\n\n    if (flushNextPaged) {\n      flush();\n      flushNextPaged = false;\n      continue;\n    }\n\n    if (currentOrdering.length > 1) {\n      flush();\n    }\n  }\n\n  if (currentOrdering.length) {\n    flush();\n  }\n\n  return [manifestItems, ordering];\n}\n"],"names":["findAllCanvasesInRange","vault","range","found","inner","sourceId","createSequenceHelper","manifestOrRange","canvasId","preventPaged","getVisibleCanvasesFromCanvasId","options","getManifestSequence","behavior","fullCanvas","canvasBehavior","isPaged","isContinuous","isIndividuals","isCanvasFacingPages","isCanvasNonPaged","manifestItems","ordering","canvasIndex","r","indexes","index","disablePaging","skipNonPaged","_","currentOrdering","flush","offset","flushNextPaged","canvas"],"mappings":"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"}