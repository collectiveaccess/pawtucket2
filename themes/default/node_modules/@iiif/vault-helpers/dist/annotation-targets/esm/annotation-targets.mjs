var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var TAU = Math.PI * 2;
var mapToEllipse = function mapToEllipse2(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
  var x = _ref.x, y = _ref.y;
  x *= rx;
  y *= ry;
  var xp = cosphi * x - sinphi * y;
  var yp = sinphi * x + cosphi * y;
  return {
    x: xp + centerx,
    y: yp + centery
  };
};
var approxUnitArc = function approxUnitArc2(ang1, ang2) {
  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
  var x1 = Math.cos(ang1);
  var y1 = Math.sin(ang1);
  var x2 = Math.cos(ang1 + ang2);
  var y2 = Math.sin(ang1 + ang2);
  return [{
    x: x1 - y1 * a,
    y: y1 + x1 * a
  }, {
    x: x2 + y2 * a,
    y: y2 - x2 * a
  }, {
    x: x2,
    y: y2
  }];
};
var vectorAngle = function vectorAngle2(ux, uy, vx, vy) {
  var sign = ux * vy - uy * vx < 0 ? -1 : 1;
  var dot = ux * vx + uy * vy;
  if (dot > 1) {
    dot = 1;
  }
  if (dot < -1) {
    dot = -1;
  }
  return sign * Math.acos(dot);
};
var getArcCenter = function getArcCenter2(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
  var rxsq = Math.pow(rx, 2);
  var rysq = Math.pow(ry, 2);
  var pxpsq = Math.pow(pxp, 2);
  var pypsq = Math.pow(pyp, 2);
  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;
  if (radicant < 0) {
    radicant = 0;
  }
  radicant /= rxsq * pypsq + rysq * pxpsq;
  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
  var centerxp = radicant * rx / ry * pyp;
  var centeryp = radicant * -ry / rx * pxp;
  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
  var vx1 = (pxp - centerxp) / rx;
  var vy1 = (pyp - centeryp) / ry;
  var vx2 = (-pxp - centerxp) / rx;
  var vy2 = (-pyp - centeryp) / ry;
  var ang1 = vectorAngle(1, 0, vx1, vy1);
  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);
  if (sweepFlag === 0 && ang2 > 0) {
    ang2 -= TAU;
  }
  if (sweepFlag === 1 && ang2 < 0) {
    ang2 += TAU;
  }
  return [centerx, centery, ang1, ang2];
};
var arcToBezier = function arcToBezier2(_ref2) {
  var px = _ref2.px, py = _ref2.py, cx = _ref2.cx, cy = _ref2.cy, rx = _ref2.rx, ry = _ref2.ry, _ref2$xAxisRotation = _ref2.xAxisRotation, xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation, _ref2$largeArcFlag = _ref2.largeArcFlag, largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag, _ref2$sweepFlag = _ref2.sweepFlag, sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
  var curves = [];
  if (rx === 0 || ry === 0) {
    return [];
  }
  var sinphi = Math.sin(xAxisRotation * TAU / 360);
  var cosphi = Math.cos(xAxisRotation * TAU / 360);
  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;
  if (pxp === 0 && pyp === 0) {
    return [];
  }
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp), _getArcCenter2 = _slicedToArray(_getArcCenter, 4), centerx = _getArcCenter2[0], centery = _getArcCenter2[1], ang1 = _getArcCenter2[2], ang2 = _getArcCenter2[3];
  var ratio = Math.abs(ang2) / (TAU / 4);
  if (Math.abs(1 - ratio) < 1e-7) {
    ratio = 1;
  }
  var segments = Math.max(Math.ceil(ratio), 1);
  ang2 /= segments;
  for (var i = 0; i < segments; i++) {
    curves.push(approxUnitArc(ang1, ang2));
    ang1 += ang2;
  }
  return curves.map(function(curve) {
    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery), x1 = _mapToEllipse.x, y1 = _mapToEllipse.y;
    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery), x2 = _mapToEllipse2.x, y2 = _mapToEllipse2.y;
    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery), x = _mapToEllipse3.x, y = _mapToEllipse3.y;
    return { x1, y1, x2, y2, x, y };
  });
};
var parseSvgPath = parse;
var length = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 };
var segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig;
function parse(path) {
  var data = [];
  path.replace(segment, function(_, command, args) {
    var type = command.toLowerCase();
    args = parseValues(args);
    if (type == "m" && args.length > 2) {
      data.push([command].concat(args.splice(0, 2)));
      type = "l";
      command = command == "m" ? "l" : "L";
    }
    while (true) {
      if (args.length == length[type]) {
        args.unshift(command);
        return data.push(args);
      }
      if (args.length < length[type])
        throw new Error("malformed path data");
      data.push([command].concat(args.splice(0, length[type])));
    }
  });
  return data;
}
var number = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;
function parseValues(args) {
  var numbers = args.match(number);
  return numbers ? numbers.map(Number) : [];
}
var absSvgPath = absolutize;
function absolutize(path) {
  var startX = 0;
  var startY = 0;
  var x = 0;
  var y = 0;
  return path.map(function(seg) {
    seg = seg.slice();
    var type = seg[0];
    var command = type.toUpperCase();
    if (type != command) {
      seg[0] = command;
      switch (type) {
        case "a":
          seg[6] += x;
          seg[7] += y;
          break;
        case "v":
          seg[1] += y;
          break;
        case "h":
          seg[1] += x;
          break;
        default:
          for (var i = 1; i < seg.length; ) {
            seg[i++] += x;
            seg[i++] += y;
          }
      }
    }
    switch (command) {
      case "Z":
        x = startX;
        y = startY;
        break;
      case "H":
        x = seg[1];
        break;
      case "V":
        y = seg[1];
        break;
      case "M":
        x = startX = seg[1];
        y = startY = seg[2];
        break;
      default:
        x = seg[seg.length - 2];
        y = seg[seg.length - 1];
    }
    return seg;
  });
}
function parseAndNormalizeSvgPath(path) {
  const parsed = parseSvgPath(path);
  const absolute = absSvgPath(parsed);
  let prevCmd;
  let startX = 0;
  let startY = 0;
  let bezierX = 0;
  let bezierY = 0;
  let quadX;
  let quadY;
  let x = 0;
  let y = 0;
  const out = [];
  for (let i = 0; i < absolute.length; i++) {
    let seg = absolute[i];
    const cmd = seg[0];
    switch (cmd) {
      case "M":
        startX = seg[1];
        startY = seg[2];
        break;
      case "H":
        seg = ["L", seg[1], startY];
        break;
      case "V":
        seg = ["L", startX, seg[1]];
        break;
      case "S":
        {
          let cx = x;
          let cy = y;
          if (prevCmd === "C" || prevCmd == "S") {
            cx += cx - bezierX;
            cy += cy - bezierY;
          }
          seg = ["C", cx, cy, seg[1], seg[2], seg[3], seg[4]];
        }
        break;
      case "T":
        if (prevCmd === "Q" || prevCmd == "T") {
          quadX = x * 2 - quadX;
          quadY = y * 2 - quadY;
        } else {
          quadX = x;
          quadY = y;
        }
        seg = ["Q", quadX, quadY, seg[1], seg[2]];
        break;
      case "Q":
        quadX = seg[1];
        quadY = seg[2];
        break;
      case "A":
        {
          const curves = arcToBezier({
            px: x,
            py: y,
            cx: seg[6],
            cy: seg[7],
            rx: seg[1],
            ry: seg[2],
            xAxisRotation: seg[3],
            largeArcFlag: seg[4],
            sweepFlag: seg[5]
          });
          if (!curves.length) {
            continue;
          }
          for (const [j, curve] of curves.entries()) {
            seg = ["C", curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];
            if (j < curves.length - 1) {
              out.push(seg);
            }
          }
          seg = seg;
        }
        break;
      case "Z":
        seg = ["L", startX, startY];
        break;
    }
    prevCmd = cmd;
    x = seg[seg.length - 2];
    y = seg[seg.length - 1];
    if (["C", "Q", "A"].indexOf(cmd) > -1) {
      bezierX = seg[seg.length - 4];
      bezierY = seg[seg.length - 3];
    } else {
      bezierX = x;
      bezierY = y;
    }
    out.push(seg);
  }
  return out;
}
/** Code to "flatten" quadratic and cubic Bézier curves to polylines.
 *
 * All code in this module is based on JavaScript code by Raph Levien, published on his blog at
 * https://raphlinus.github.io/.
 * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.
 *
 * Flattening of quadratic Bézier curves:
 * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html
 * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212
 *
 * Flattening of cubic Bézier curves: https://levien.com/tmp/flatten.html
 *
 * Note that the code in this module has a different license than the rest of the package,
 * due to the inclusion of Apache-licensed third party code.
 *
 * @license
 * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>
 * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function flattenQuadraticBezier(start, control, end, tolerance = 1) {
  return new QuadraticBezier(start, control, end).subdivide(tolerance);
}
function flattenCubicBezier(start, startControl, end, endControl, tolerance = 1) {
  return new CubicBezier(
    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])
  ).subdivide(tolerance);
}
function hypot2(p) {
  return p.x * p.x + p.y * p.y;
}
function approx_myint(x) {
  const d = 0.67;
  return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));
}
function approx_inv_myint(x) {
  const b = 0.39;
  return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));
}
class QuadraticBezier {
  constructor(start, control, end) {
    this.start = start;
    this.control = control;
    this.end = end;
  }
  eval(t) {
    const mt = 1 - t;
    return {
      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,
      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t
    };
  }
  mapToBasic() {
    const { x: x0, y: y0 } = this.start;
    const { x: x1, y: y1 } = this.control;
    const { x: x2, y: y2 } = this.end;
    const ddx = 2 * x1 - x0 - x2;
    const ddy = 2 * y1 - y0 - y2;
    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;
    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;
    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;
    const paramX0 = u0 / cross;
    const paramX2 = u2 / cross;
    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));
    return { x0, x2, scale, cross };
  }
  subdivide(tolerance) {
    const params = this.mapToBasic();
    const a0 = approx_myint(params.x0);
    const a2 = approx_myint(params.x2);
    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);
    const n = Math.ceil(count);
    const u0 = approx_inv_myint(a0);
    const u2 = approx_inv_myint(a2);
    const tValues = [0];
    for (let i = 1; i < n; i++) {
      const u = approx_inv_myint(a0 + (a2 - a0) * i / n);
      const t = (u - u0) / (u2 - u0);
      tValues.push(t);
    }
    tValues.push(1);
    return tValues.map((t) => this.eval(t));
  }
}
class CubicBezier {
  constructor(coords) {
    this.c = coords;
  }
  weightsum(c0, c1, c2, c3) {
    const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];
    const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];
    return { x, y };
  }
  eval(t) {
    const mt = 1 - t;
    const c0 = mt * mt * mt;
    const c1 = 3 * mt * mt * t;
    const c2 = 3 * mt * t * t;
    const c3 = t * t * t;
    return this.weightsum(c0, c1, c2, c3);
  }
  deriv(t) {
    const mt = 1 - t;
    const c0 = -3 * mt * mt;
    const c3 = 3 * t * t;
    const c1 = -6 * t * mt - c0;
    const c2 = 6 * t * mt - c3;
    return this.weightsum(c0, c1, c2, c3);
  }
  midpoint_quadbez() {
    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);
    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });
  }
  subsegment(t0, t1) {
    const c = new Float64Array(8);
    const p0 = this.eval(t0);
    const p3 = this.eval(t1);
    c[0] = p0.x;
    c[1] = p0.y;
    const scale = (t1 - t0) / 3;
    const d1 = this.deriv(t0);
    c[2] = p0.x + scale * d1.x;
    c[3] = p0.y + scale * d1.y;
    const d2 = this.deriv(t1);
    c[4] = p3.x - scale * d2.x;
    c[5] = p3.y - scale * d2.y;
    c[6] = p3.x;
    c[7] = p3.y;
    return new CubicBezier(c);
  }
  subdivide(tol) {
    const tol1 = 0.1 * tol;
    const tol2 = tol - tol1;
    const sqrt_tol2 = Math.sqrt(tol2);
    const err2 = hypot2(this.weightsum(1, -3, 3, -1));
    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));
    const quads = [];
    let sum = 0;
    for (let i2 = 0; i2 < n_quads; i2++) {
      const t0 = i2 / n_quads;
      const t1 = (i2 + 1) / n_quads;
      const quad = this.subsegment(t0, t1).midpoint_quadbez();
      const params = quad.mapToBasic();
      const a0 = approx_myint(params.x0);
      const a2 = approx_myint(params.x2);
      const scale = Math.sqrt(params.scale);
      let val2 = Math.abs(a2 - a0) * scale;
      if (Math.sign(params.x0) != Math.sign(params.x2)) {
        const xmin = sqrt_tol2 / scale;
        const cusp_val = sqrt_tol2 * Math.abs(a2 - a0) / approx_myint(xmin);
        val2 = Math.max(val2, cusp_val);
      }
      quads.push({
        quad,
        a0,
        a2,
        val: val2
      });
      sum += val2;
    }
    const count = 0.5 * sum / sqrt_tol2;
    const n = Math.ceil(count);
    const result = [{ x: this.c[0], y: this.c[1] }];
    let val = 0;
    let i = 0;
    for (let j = 1; j < n; j++) {
      const target = sum * j / n;
      while (val + quads[i].val < target) {
        val += quads[i].val;
        i++;
      }
      const a0 = quads[i].a0;
      const a2 = quads[i].a2;
      const u0 = approx_inv_myint(a0);
      const u2 = approx_inv_myint(a2);
      const a = a0 + (a2 - a0) * (target - val) / quads[i].val;
      const u = approx_inv_myint(a);
      const t = (u - u0) / (u2 - u0);
      result.push(quads[i].quad.eval(t));
    }
    result.push({ x: this.c[6], y: this.c[7] });
    return result;
  }
}
const BOX_SELECTOR = /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?),([0-9]+(?:\.[0-9]+)?)/;
const TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(.[0-9]+)?)?(,([0-9]+(.[0-9]+)?))?/;
const RGBA_COLOR = /^rgba\((\d+),(\d+),(\d+),([0-9.]+)\)$/;
function parseSelector(source, { domParser, svgPreprocessor } = {}) {
  var _a, _b;
  if (Array.isArray(source)) {
    return source.reduce(
      (data, nextSource) => {
        const { selector, selectors } = parseSelector(nextSource);
        if (selector) {
          if (!data.selector) {
            data.selector = selector;
          }
          data.selectors.push(...selectors);
        }
        return data;
      },
      {
        selector: null,
        selectors: []
      }
    );
  }
  if (!source) {
    return {
      selector: null,
      selectors: []
    };
  }
  if (typeof source === "string") {
    const [id, fragment] = source.split("#");
    if (!fragment) {
      return {
        selector: null,
        selectors: []
      };
    }
    return parseSelector({ type: "FragmentSelector", value: fragment });
  }
  if (source.type === "PointSelector" && (source.t || source.t === 0)) {
    const selector = {
      type: "TemporalSelector",
      temporal: {
        startTime: source.t
      }
    };
    return {
      selector,
      selectors: [selector]
    };
  }
  if (source.type === "FragmentSelector") {
    const matchBoxSelector = BOX_SELECTOR.exec(source.value);
    if (matchBoxSelector) {
      const selector = {
        type: "BoxSelector",
        spatial: {
          unit: matchBoxSelector[2] === "percent:" || matchBoxSelector[2] === "pct:" ? "percent" : "pixel",
          x: parseFloat(matchBoxSelector[3]),
          y: parseFloat(matchBoxSelector[4]),
          width: parseFloat(matchBoxSelector[5]),
          height: parseFloat(matchBoxSelector[6])
        }
      };
      return {
        selector,
        selectors: [selector]
      };
    }
    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);
    if (matchTimeSelector) {
      const selector = {
        type: "TemporalSelector",
        temporal: {
          startTime: matchTimeSelector[4] ? parseFloat(matchTimeSelector[4]) : 0,
          endTime: matchTimeSelector[7] ? parseFloat(matchTimeSelector[7]) : void 0
        }
      };
      return {
        selector,
        selectors: [selector]
      };
    }
    return {
      selector: null,
      selectors: []
    };
  }
  if (source.type === "SvgSelector" && "value" in source) {
    if (!domParser) {
      if (typeof window !== "undefined") {
        domParser = new window.DOMParser();
      } else {
        console.warn(
          "No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized."
        );
      }
    }
    let points = [];
    let rect;
    let style;
    let svg = (_a = svgPreprocessor == null ? void 0 : svgPreprocessor(source.value)) != null ? _a : source.value;
    let svgShape;
    if (domParser) {
      const svgElement = domParser.parseFromString(source.value, "image/svg+xml").querySelector("svg");
      if (!svgElement) {
        console.warn(`Illegal SVG selector: ${source.value}`);
        return {
          selector: null,
          selectors: []
        };
      }
      const selectorElem = getSelectorElement(svgElement);
      if (selectorElem) {
        points = selectorElem.points;
        svgShape = selectorElem.shapeType;
        rect = [
          Math.min(...points.map((p) => p[0])),
          Math.min(...points.map((p) => p[1])),
          Math.max(...points.map((p) => p[0])),
          Math.max(...points.map((p) => p[1]))
        ];
        ({ style, svg } = (_b = extractStyles(selectorElem.element)) != null ? _b : { svg });
      }
    }
    const sel = {
      type: "SvgSelector",
      svg,
      svgShape,
      style,
      points: points.length ? points : void 0,
      spatial: rect ? { unit: "pixel", x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] } : void 0
    };
    return {
      selector: sel,
      selectors: [sel]
    };
  }
  return {
    selector: null,
    selectors: []
  };
}
function getShapeTypeFromPath(svgPath) {
  const cmdFrequencies = svgPath.map((seg) => seg[0]).reduce(
    (acc, cmd) => {
      acc[cmd] += 1;
      return acc;
    },
    { C: 0, Q: 0, L: 0, M: 0 }
  );
  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));
  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {
    return "path";
  }
  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || cmdTypes.size === 2 && cmdTypes.has("M"))) {
    if (cmdFrequencies.L === 4) {
      return "rect";
    }
    const lastSeg = svgPath.slice(-1)[0];
    if (svgPath[0][0] === "M" && lastSeg[0] === "L" && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2] || lastSeg[1] === 0 && lastSeg[2] === 0) {
      return "polygon";
    } else {
      return "polyline";
    }
  }
  return "path";
}
function getSelectorElement(svgElem) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  for (const element of Array.from(svgElem.children)) {
    switch (element == null ? void 0 : element.tagName.toLowerCase()) {
      case "g":
        {
          const res = getSelectorElement(element);
          if (res) {
            return res;
          }
        }
        continue;
      case "path": {
        const p = element.getAttribute("d");
        if (!p) {
          continue;
        }
        const normalized = parseAndNormalizeSvgPath(p);
        return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };
      }
      case "circle": {
        const cx = parseFloat((_a = element.getAttribute("cx")) != null ? _a : "0");
        const cy = parseFloat((_b = element.getAttribute("cy")) != null ? _b : "0");
        const r = parseFloat((_c = element.getAttribute("r")) != null ? _c : "0");
        if (!r) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const rad = angle * Math.PI / 180;
          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);
        }
        return { element, points, shapeType: "circle" };
      }
      case "ellipse": {
        const cx = parseFloat((_d = element.getAttribute("cx")) != null ? _d : "0");
        const cy = parseFloat((_e = element.getAttribute("cy")) != null ? _e : "0");
        const rx = parseFloat((_f = element.getAttribute("rx")) != null ? _f : "0");
        const ry = parseFloat((_g = element.getAttribute("ry")) != null ? _g : "0");
        if (!rx && !ry) {
          continue;
        }
        const points = [];
        for (let angle = 0; angle <= 360; angle += 12) {
          const t = Math.tan(angle / 360 * Math.PI);
          const px = rx * (1 - t ** 2) / (1 + t ** 2);
          const py = ry * 2 * t / (1 + t ** 2);
          points.push([cx + px, cy + py]);
        }
        return { element, points, shapeType: "ellipse" };
      }
      case "line": {
        const x0 = parseFloat((_h = element.getAttribute("x0")) != null ? _h : "0");
        const y0 = parseFloat((_i = element.getAttribute("y0")) != null ? _i : "0");
        const x1 = parseFloat((_j = element.getAttribute("x1")) != null ? _j : "0");
        const y1 = parseFloat((_k = element.getAttribute("y1")) != null ? _k : "0");
        if (x0 === x1 && y0 === y1) {
          continue;
        }
        return {
          element,
          points: [
            [x0, y0],
            [x1, y1]
          ],
          shapeType: "polyline"
        };
      }
      case "polygon":
      case "polyline": {
        const points = (_m = (_l = element.getAttribute("points")) == null ? void 0 : _l.split(" ").map((ps) => ps.split(",").map(parseFloat))) != null ? _m : [];
        if (!points.length) {
          continue;
        }
        let shapeType = "polyline";
        if (element.tagName.toLowerCase() === "polygon") {
          points.push(points[0]);
          shapeType = "polygon";
        }
        return { element, points, shapeType };
      }
      case "rect": {
        const x = parseFloat((_n = element.getAttribute("x")) != null ? _n : "0");
        const y = parseFloat((_o = element.getAttribute("y")) != null ? _o : "0");
        const width = parseFloat((_p = element.getAttribute("width")) != null ? _p : "0");
        const height = parseFloat((_q = element.getAttribute("height")) != null ? _q : "0");
        if (!width || !height) {
          continue;
        }
        return {
          element,
          points: [
            [x, y],
            [x + width, y],
            [x + width, y + height],
            [x, y + height],
            [x, y]
          ],
          shapeType: "rect"
        };
      }
      default:
        continue;
    }
  }
  return null;
}
function pathToPoints(normalizedPath) {
  var _a;
  const out = [];
  for (let i = 0; i < normalizedPath.length; i++) {
    const startPoint = (_a = out[out.length - 1]) != null ? _a : [0, 0];
    const seg = normalizedPath[i];
    switch (seg[0]) {
      case "M":
      case "L":
        out.push([seg[1], seg[2]]);
        continue;
      case "C":
        out.push(
          ...flattenCubicBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] },
            { x: seg[5], y: seg[6] }
          ).map((p) => [p.x, p.y]).slice(1)
        );
        continue;
      case "Q":
        out.push(
          ...flattenQuadraticBezier(
            { x: startPoint[0], y: startPoint[1] },
            { x: seg[1], y: seg[2] },
            { x: seg[3], y: seg[4] }
          ).map((p) => [p.x, p.y]).slice(1)
        );
        continue;
    }
  }
  return out;
}
function extractStyles(selectorElement) {
  const style = {};
  if (selectorElement.hasAttribute("fill")) {
    style.fill = selectorElement.getAttribute("fill");
    selectorElement.removeAttribute("fill");
  } else if (selectorElement.style.fill) {
    style.fill = selectorElement.style.fill;
  }
  if (style.fill) {
    const rgbaMatch = RGBA_COLOR.exec(style.fill);
    if (rgbaMatch) {
      style.fillOpacity = parseFloat(rgbaMatch[4]);
      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("fill-opacity")) {
    style.fillOpacity = parseFloat(selectorElement.getAttribute("fill-opacity"));
    selectorElement.removeAttribute("fill-opacity");
  } else if (selectorElement.style.fillOpacity) {
    style.fillOpacity = parseFloat(selectorElement.style.fillOpacity);
  }
  if (selectorElement.hasAttribute("stroke")) {
    style.stroke = selectorElement.getAttribute("stroke");
    selectorElement.removeAttribute("stroke");
  } else if (selectorElement.style.stroke) {
    style.stroke = selectorElement.style.stroke;
  }
  if (style.stroke) {
    const rgbaMatch = RGBA_COLOR.exec(style.stroke);
    if (rgbaMatch) {
      style.strokeOpacity = parseFloat(rgbaMatch[4]);
      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;
    }
  }
  if (selectorElement.hasAttribute("stroke-opacity")) {
    style.strokeOpacity = parseFloat(selectorElement.getAttribute("stroke-opacity"));
    selectorElement.removeAttribute("stroke-opacity");
  } else if (selectorElement.style.strokeOpacity) {
    style.strokeOpacity = parseFloat(selectorElement.style.strokeOpacity);
  }
  if (selectorElement.hasAttribute("stroke-width")) {
    style.strokeWidth = selectorElement.getAttribute("stroke-width");
    selectorElement.removeAttribute("stroke-width");
  } else if (selectorElement.style.strokeWidth) {
    style.strokeWidth = selectorElement.style.strokeWidth;
  }
  if (selectorElement.hasAttribute("stroke-dasharray")) {
    style.strokeDasharray = selectorElement.getAttribute("stroke-dasharray");
    selectorElement.removeAttribute("stroke-dasharray");
  } else if (selectorElement.style.strokeDasharray) {
    style.strokeDasharray = selectorElement.style.strokeDasharray;
  }
  let rootElem = selectorElement;
  while (rootElem.tagName.toLowerCase() !== "svg") {
    rootElem = rootElem.parentElement;
    if (rootElem === null) {
      throw new Error("Could not find root SVG element");
    }
  }
  return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : void 0 };
}
function expandTarget(target, options = {}) {
  if (Array.isArray(target)) {
    return expandTarget(target[0]);
  }
  if (typeof target === "string") {
    const [id, fragment] = target.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: { id, type: options.typeMap && options.typeMap[id] || "Unknown" },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: { id, type: "Unknown" },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  if (target.type === "Choice" || target.type === "List" || target.type === "Composite" || target.type === "Independents") {
    return expandTarget(target.items[0]);
  }
  if (target.type === "SpecificResource") {
    if (target.source.type === "Canvas" && target.source.partOf && typeof target.source.partOf === "string") {
      target.source.partOf = [
        {
          id: target.source.partOf,
          type: "Manifest"
        }
      ];
    }
    const { selector, selectors } = target.selector ? parseSelector(target.selector, options) : { selector: null, selectors: [] };
    return {
      type: "SpecificResource",
      source: target.source,
      selector,
      selectors
    };
  }
  if (target.id) {
    if (target.type === "Canvas" && target.partOf && typeof target.partOf === "string") {
      target.partOf = [
        {
          id: target.partOf,
          type: "Manifest"
        }
      ];
    }
    const [id, fragment] = target.id.split("#");
    if (!fragment) {
      return {
        type: "SpecificResource",
        source: {
          ...target,
          id
        },
        selector: null,
        selectors: []
      };
    }
    return expandTarget({
      type: "SpecificResource",
      source: {
        ...target,
        id
      },
      selector: {
        type: "FragmentSelector",
        value: fragment
      }
    });
  }
  return {
    type: "SpecificResource",
    source: target,
    selector: null,
    selectors: []
  };
}
export { expandTarget, parseSelector };
//# sourceMappingURL=annotation-targets.mjs.map
