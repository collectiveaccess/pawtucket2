{"version":3,"file":"content-state.mjs","sources":["../../../node_modules/svg-arc-to-cubic-bezier/modules/index.js","../../../node_modules/parse-svg-path/index.js","../../../node_modules/abs-svg-path/index.js","../../../src/annotation-targets/normalize-svg.ts","../../../src/annotation-targets/bezier.ts","../../../src/annotation-targets/parse-selector.ts","../../../src/annotation-targets/expand-target.ts","../../../src/content-state.ts"],"sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport arcToCurve from 'svg-arc-to-cubic-bezier';\nimport parseSvgPath from 'parse-svg-path';\nimport absSvgPath, {\n  AbsoluteCubicBezierCommand,\n  AbsoluteLineCommand,\n  AbsoluteMoveCommand,\n  AbsoluteQuadraticBezierCommand,\n} from 'abs-svg-path';\n\nexport type NormalizedSvgPathCommand =\n  | AbsoluteMoveCommand\n  | AbsoluteLineCommand\n  | AbsoluteCubicBezierCommand\n  | AbsoluteQuadraticBezierCommand;\n\nexport type NormalizedSvgPathCommandType = 'M' | 'L' | 'C' | 'Q';\n\n/** Parse an SVG path and normalize it so it only contains Moves, Lines and Cubic or Quadratic BÃ©zier curves\n *  in their absolute form. */\nexport function parseAndNormalizeSvgPath(path: string): NormalizedSvgPathCommand[] {\n  const parsed = parseSvgPath(path);\n  const absolute = absSvgPath(parsed);\n\n  let prevCmd: 'M' | 'L' | 'H' | 'V' | 'C' | 'S' | 'Q' | 'T' | 'A' | 'Z' | undefined;\n  let startX = 0;\n  let startY = 0;\n  let bezierX = 0;\n  let bezierY = 0;\n  let quadX: number | undefined;\n  let quadY: number | undefined;\n  let x = 0;\n  let y = 0;\n  const out: NormalizedSvgPathCommand[] = [];\n  for (let i = 0; i < absolute.length; i++) {\n    let seg = absolute[i];\n    const cmd = seg[0];\n    switch (cmd) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'H':\n        seg = ['L', seg[1], startY];\n        break;\n      case 'V':\n        seg = ['L', startX, seg[1]];\n        break;\n      case 'S':\n        {\n          let cx = x;\n          let cy = y;\n          if (prevCmd === 'C' || prevCmd == 'S') {\n            cx += cx - bezierX;\n            cy += cy - bezierY;\n          }\n          seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        }\n        break;\n      case 'T':\n        if (prevCmd === 'Q' || prevCmd == 'T') {\n          quadX = x * 2 - quadX!;\n          quadY = y * 2 - quadY!;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = ['Q', quadX, quadY, seg[1], seg[2]];\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        break;\n      case 'A':\n        {\n          const curves = arcToCurve({\n            px: x,\n            py: y,\n            cx: seg[6],\n            cy: seg[7],\n            rx: seg[1],\n            ry: seg[2],\n            xAxisRotation: seg[3],\n            largeArcFlag: seg[4],\n            sweepFlag: seg[5],\n          });\n          if (!curves.length) {\n            continue;\n          }\n          for (const [j, curve] of curves.entries()) {\n            seg = ['C', curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];\n            if (j < curves.length - 1) {\n              out.push(seg);\n            }\n          }\n          // FIXME: Why do we need this cast?\n          seg = seg as NormalizedSvgPathCommand;\n        }\n        break;\n      case 'Z':\n        seg = ['L', startX, startY];\n        break;\n    }\n\n    prevCmd = cmd;\n    x = seg[seg.length - 2] as number;\n    y = seg[seg.length - 1] as number;\n    if (['C', 'Q', 'A'].indexOf(cmd) > -1) {\n      bezierX = seg[seg.length - 4] as number;\n      bezierY = seg[seg.length - 3] as number;\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    out.push(seg);\n  }\n\n  return out;\n}\n","/** Code to \"flatten\" quadratic and cubic BÃ©zier curves to polylines.\n *\n * All code in this module is based on JavaScript code by Raph Levien, published on his blog at\n * https://raphlinus.github.io/.\n * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.\n *\n * Flattening of quadratic BÃ©zier curves:\n * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html\n * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212\n *\n * Flattening of cubic BÃ©zier curves: https://levien.com/tmp/flatten.html\n *\n * Note that the code in this module has a different license than the rest of the package,\n * due to the inclusion of Apache-licensed third party code.\n *\n * @license\n * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>\n * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type Point = { x: number; y: number };\n\nexport function flattenQuadraticBezier(start: Point, control: Point, end: Point, tolerance = 1): Point[] {\n  return new QuadraticBezier(start, control, end).subdivide(tolerance);\n}\n\nexport function flattenCubicBezier(\n  start: Point,\n  startControl: Point,\n  end: Point,\n  endControl: Point,\n  tolerance = 1\n): Point[] {\n  return new CubicBezier(\n    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])\n  ).subdivide(tolerance);\n}\n\nfunction hypot2(p: Point): number {\n  return p.x * p.x + p.y * p.y;\n}\n\n// Compute an approximation to int (1 + 4x^2) ^ -0.25 dx\nfunction approx_myint(x: number): number {\n  const d = 0.67;\n  return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));\n}\n\n// Approximate the inverse of `approx_myint`\nfunction approx_inv_myint(x: number): number {\n  const b = 0.39;\n  return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));\n}\n\n// Parameters for a basic parabola corresponding to a quadratic bÃ©zier curve\ntype QuadraticBezierBasicParams = {\n  x0: number;\n  x2: number;\n  scale: number;\n  cross: number;\n};\n\nclass QuadraticBezier {\n  start: Point;\n  control: Point;\n  end: Point;\n\n  constructor(start: Point, control: Point, end: Point) {\n    this.start = start;\n    this.control = control;\n    this.end = end;\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    return {\n      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,\n      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t,\n    };\n  }\n\n  mapToBasic(): QuadraticBezierBasicParams {\n    const { x: x0, y: y0 } = this.start;\n    const { x: x1, y: y1 } = this.control;\n    const { x: x2, y: y2 } = this.end;\n\n    // Determine the x values and scaling to map to y=x^2\n    const ddx = 2 * x1 - x0 - x2;\n    const ddy = 2 * y1 - y0 - y2;\n    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;\n    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;\n    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;\n    const paramX0 = u0 / cross;\n    const paramX2 = u2 / cross;\n\n    // There's probably a more elegant formulation of this...\n    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));\n\n    return { x0, x2, scale, cross };\n  }\n\n  subdivide(tolerance: number): Point[] {\n    const params = this.mapToBasic();\n    const a0 = approx_myint(params.x0);\n    const a2 = approx_myint(params.x2);\n    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);\n    const n = Math.ceil(count);\n    const u0 = approx_inv_myint(a0);\n    const u2 = approx_inv_myint(a2);\n    const tValues = [0];\n    for (let i = 1; i < n; i++) {\n      const u = approx_inv_myint(a0 + ((a2 - a0) * i) / n);\n      const t = (u - u0) / (u2 - u0);\n      tValues.push(t);\n    }\n    tValues.push(1);\n    return tValues.map((t) => this.eval(t));\n  }\n}\n\nclass CubicBezier {\n  private c: Float64Array;\n\n  /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].\n  constructor(coords: Float64Array) {\n    this.c = coords;\n  }\n\n  weightsum(c0: number, c1: number, c2: number, c3: number): Point {\n    const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];\n    const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];\n    return { x, y };\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    const c0 = mt * mt * mt;\n    const c1 = 3 * mt * mt * t;\n    const c2 = 3 * mt * t * t;\n    const c3 = t * t * t;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  deriv(t: number): Point {\n    const mt = 1 - t;\n    const c0 = -3 * mt * mt;\n    const c3 = 3 * t * t;\n    const c1 = -6 * t * mt - c0;\n    const c2 = 6 * t * mt - c3;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  // quadratic bezier with matching endpoints and minimum max vector error\n  midpoint_quadbez(): QuadraticBezier {\n    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);\n    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });\n  }\n\n  subsegment(t0: number, t1: number): CubicBezier {\n    const c = new Float64Array(8);\n    const p0 = this.eval(t0);\n    const p3 = this.eval(t1);\n    c[0] = p0.x;\n    c[1] = p0.y;\n    const scale = (t1 - t0) / 3;\n    const d1 = this.deriv(t0);\n    c[2] = p0.x + scale * d1.x;\n    c[3] = p0.y + scale * d1.y;\n    const d2 = this.deriv(t1);\n    c[4] = p3.x - scale * d2.x;\n    c[5] = p3.y - scale * d2.y;\n    c[6] = p3.x;\n    c[7] = p3.y;\n    return new CubicBezier(c);\n  }\n\n  // Very fancy subdivision scheme\n  subdivide(tol: number) {\n    const tol1 = 0.1 * tol; // error for subdivision into quads\n    const tol2 = tol - tol1; // error for subdivision of quads into lines\n    const sqrt_tol2 = Math.sqrt(tol2);\n    const err2 = hypot2(this.weightsum(1, -3, 3, -1));\n    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));\n    const quads = [];\n    let sum = 0;\n    for (let i = 0; i < n_quads; i++) {\n      const t0 = i / n_quads;\n      const t1 = (i + 1) / n_quads;\n      const quad = this.subsegment(t0, t1).midpoint_quadbez();\n      const params = quad.mapToBasic();\n      const a0 = approx_myint(params.x0);\n      const a2 = approx_myint(params.x2);\n      const scale = Math.sqrt(params.scale);\n      let val = Math.abs(a2 - a0) * scale;\n      if (Math.sign(params.x0) != Math.sign(params.x2)) {\n        // min x value in basic parabola to make sure we don't skip cusp\n        const xmin = sqrt_tol2 / scale;\n        const cusp_val = (sqrt_tol2 * Math.abs(a2 - a0)) / approx_myint(xmin);\n        // I *think* it will always be larger, but just in case...\n        val = Math.max(val, cusp_val);\n      }\n      quads.push({\n        quad: quad,\n        a0: a0,\n        a2: a2,\n        val: val,\n      });\n      sum += val;\n    }\n    const count = (0.5 * sum) / sqrt_tol2;\n    const n = Math.ceil(count);\n    const result = [{ x: this.c[0], y: this.c[1] }];\n    let val = 0; // sum of vals from [0..i]\n    let i = 0;\n    for (let j = 1; j < n; j++) {\n      const target = (sum * j) / n;\n      while (val + quads[i].val < target) {\n        val += quads[i].val;\n        i++;\n      }\n      const a0 = quads[i].a0;\n      const a2 = quads[i].a2;\n      // Note: we can cut down on recomputing these\n      const u0 = approx_inv_myint(a0);\n      const u2 = approx_inv_myint(a2);\n      const a = a0 + ((a2 - a0) * (target - val)) / quads[i].val;\n      const u = approx_inv_myint(a);\n      const t = (u - u0) / (u2 - u0);\n      result.push(quads[i].quad.eval(t));\n    }\n    result.push({ x: this.c[6], y: this.c[7] });\n    return result;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {\n  ParsedSelector,\n  SupportedSelectors,\n  TemporalSelector,\n  SvgSelector,\n  SelectorStyle,\n  SvgShapeType,\n} from './selector-types';\nimport { Selector } from '@iiif/presentation-3';\nimport { NormalizedSvgPathCommand, NormalizedSvgPathCommandType, parseAndNormalizeSvgPath } from './normalize-svg';\nimport { flattenCubicBezier, flattenQuadraticBezier } from './bezier';\n\nconst BOX_SELECTOR =\n  /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?)/;\n\n// Does not support 00:00:00 or 00:00 formats.\nconst TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(.[0-9]+)?)?(,([0-9]+(.[0-9]+)?))?/;\n\nconst RGBA_COLOR = /^rgba\\((\\d+),(\\d+),(\\d+),([0-9.]+)\\)$/;\n\nexport function parseSelector(\n  source: Selector | Selector[],\n  { domParser, svgPreprocessor }: { domParser?: DOMParser; svgPreprocessor?: (svg: string) => string } = {}\n): ParsedSelector {\n  if (Array.isArray(source)) {\n    return (source as Array<string | Selector>).reduce(\n      <ParseSelector>(data: ParsedSelector, nextSource: string | Selector) => {\n        const { selector, selectors } = parseSelector(nextSource);\n        if (selector) {\n          if (!data.selector) {\n            data.selector = selector;\n          }\n          data.selectors.push(...selectors);\n        }\n        return data;\n      },\n      {\n        selector: null,\n        selectors: [],\n      } as ParsedSelector\n    );\n  }\n\n  if (!source) {\n    return {\n      selector: null,\n      selectors: [],\n    };\n  }\n\n  if (typeof source === 'string') {\n    const [id, fragment] = source.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return parseSelector({ type: 'FragmentSelector', value: fragment });\n  }\n\n  if (source.type === 'PointSelector' && (source.t || source.t === 0)) {\n    const selector: TemporalSelector = {\n      type: 'TemporalSelector',\n      temporal: {\n        startTime: source.t,\n      },\n    };\n\n    return {\n      selector,\n      selectors: [selector],\n    };\n  }\n\n  if (source.type === 'FragmentSelector') {\n    const matchBoxSelector = BOX_SELECTOR.exec(source.value);\n    if (matchBoxSelector) {\n      const selector: SupportedSelectors = {\n        type: 'BoxSelector',\n        spatial: {\n          unit: matchBoxSelector[2] === 'percent:' || matchBoxSelector[2] === 'pct:' ? 'percent' : 'pixel',\n          x: parseFloat(matchBoxSelector[3]),\n          y: parseFloat(matchBoxSelector[4]),\n          width: parseFloat(matchBoxSelector[5]),\n          height: parseFloat(matchBoxSelector[6]),\n        },\n      };\n\n      return {\n        selector,\n        selectors: [selector],\n      };\n    }\n\n    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);\n    if (matchTimeSelector) {\n      const selector: TemporalSelector = {\n        type: 'TemporalSelector',\n        temporal: {\n          startTime: matchTimeSelector[4] ? parseFloat(matchTimeSelector[4]) : 0,\n          endTime: matchTimeSelector[7] ? parseFloat(matchTimeSelector[7]) : undefined,\n        },\n      };\n\n      return {\n        selector,\n        selectors: [selector],\n      };\n    }\n\n    return {\n      selector: null,\n      selectors: [],\n    };\n  }\n\n  if (source.type === 'SvgSelector' && 'value' in source) {\n    if (!domParser) {\n      if (typeof window !== 'undefined') {\n        domParser = new window.DOMParser();\n      } else {\n        console.warn(\n          'No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized.'\n        );\n      }\n    }\n    let points: [number, number][] = [];\n    let rect: [number, number, number, number] | undefined;\n    let style: SelectorStyle | undefined;\n    let svg = svgPreprocessor?.(source.value) ?? source.value;\n    let svgShape: SvgShapeType | undefined;\n    if (domParser) {\n      const svgElement: SVGElement | null = domParser\n        .parseFromString(source.value, 'image/svg+xml')\n        .querySelector('svg');\n      if (!svgElement) {\n        console.warn(`Illegal SVG selector: ${source.value}`);\n        return {\n          selector: null,\n          selectors: [],\n        };\n      }\n      const selectorElem = getSelectorElement(svgElement);\n      if (selectorElem) {\n        points = selectorElem.points;\n        svgShape = selectorElem.shapeType;\n        rect = [\n          Math.min(...points.map((p) => p[0])), // llx\n          Math.min(...points.map((p) => p[1])), // lly\n          Math.max(...points.map((p) => p[0])), // urx\n          Math.max(...points.map((p) => p[1])), // ury\n        ];\n        ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });\n      }\n    }\n    const sel: SvgSelector = {\n      type: 'SvgSelector',\n      svg,\n      svgShape,\n      style,\n      points: points.length ? points : undefined,\n      spatial: rect\n        ? { unit: 'pixel', x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] }\n        : undefined,\n    };\n    return {\n      selector: sel,\n      selectors: [sel],\n    };\n  }\n  return {\n    selector: null,\n    selectors: [],\n  };\n}\n\nexport type SelectorElement = {\n  element: SVGElement;\n  points: [number, number][];\n  shapeType: SvgShapeType;\n};\n\nfunction getShapeTypeFromPath(svgPath: NormalizedSvgPathCommand[]): SvgShapeType {\n  const cmdFrequencies = svgPath\n    .map((seg) => seg[0])\n    .reduce(\n      (acc: Record<NormalizedSvgPathCommandType, number>, cmd) => {\n        acc[cmd] += 1;\n        return acc;\n      },\n      { C: 0, Q: 0, L: 0, M: 0 }\n    );\n  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));\n  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {\n    return 'path';\n  }\n  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || (cmdTypes.size === 2 && cmdTypes.has('M')))) {\n    // Only lines and moves: rectangle, polygon or polyline?\n    if (cmdFrequencies.L === 4) {\n      return 'rect';\n    }\n\n    // Check if the path is closed to decide if we have a polygon or a polyline\n    const lastSeg = svgPath.slice(-1)[0];\n    if (\n      (svgPath[0][0] === 'M' && lastSeg[0] === 'L' && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2]) ||\n      (lastSeg[1] === 0 && lastSeg[2] === 0)\n    ) {\n      return 'polygon';\n    } else {\n      return 'polyline';\n    }\n  }\n  return 'path';\n}\n\nfunction getSelectorElement(svgElem: SVGElement): SelectorElement | null {\n  for (const element of Array.from(svgElem.children) as SVGElement[]) {\n    switch (element?.tagName.toLowerCase()) {\n      case 'g':\n        {\n          // Check if any of the children in the container can be converted to points\n          const res = getSelectorElement(element as SVGElement);\n          if (res) {\n            return res;\n          }\n        }\n        continue;\n      case 'path': {\n        const p = element.getAttribute('d');\n        if (!p) {\n          continue;\n        }\n        const normalized = parseAndNormalizeSvgPath(p);\n        return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };\n      }\n      case 'circle': {\n        const cx = parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = parseFloat(element.getAttribute('cy') ?? '0');\n        const r = parseFloat(element.getAttribute('r') ?? '0');\n        if (!r) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        // TODO: Get rid of the degree -> radian conversion and use radians from the beginning\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const rad = (angle * Math.PI) / 180;\n          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);\n        }\n        return { element, points, shapeType: 'circle' };\n      }\n      case 'ellipse': {\n        const cx = parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = parseFloat(element.getAttribute('cy') ?? '0');\n        const rx = parseFloat(element.getAttribute('rx') ?? '0');\n        const ry = parseFloat(element.getAttribute('ry') ?? '0');\n        if (!rx && !ry) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const t = Math.tan((angle / 360) * Math.PI);\n          const px = (rx * (1 - t ** 2)) / (1 + t ** 2);\n          const py = (ry * 2 * t) / (1 + t ** 2);\n          points.push([cx + px, cy + py]);\n        }\n        return { element, points, shapeType: 'ellipse' };\n      }\n      case 'line': {\n        const x0 = parseFloat(element.getAttribute('x0') ?? '0');\n        const y0 = parseFloat(element.getAttribute('y0') ?? '0');\n        const x1 = parseFloat(element.getAttribute('x1') ?? '0');\n        const y1 = parseFloat(element.getAttribute('y1') ?? '0');\n        if (x0 === x1 && y0 === y1) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x0, y0],\n            [x1, y1],\n          ],\n          shapeType: 'polyline',\n        };\n      }\n      case 'polygon':\n      case 'polyline': {\n        const points =\n          element\n            .getAttribute('points')\n            ?.split(' ')\n            .map((ps) => ps.split(',').map(parseFloat) as [number, number]) ?? [];\n        if (!points.length) {\n          continue;\n        }\n        let shapeType: SvgShapeType = 'polyline';\n        if (element.tagName.toLowerCase() === 'polygon') {\n          // A polygon is a closed path, so the last point is the same as the first.\n          points.push(points[0]);\n          shapeType = 'polygon';\n        }\n        return { element, points, shapeType };\n      }\n      case 'rect': {\n        const x = parseFloat(element.getAttribute('x') ?? '0');\n        const y = parseFloat(element.getAttribute('y') ?? '0');\n        const width = parseFloat(element.getAttribute('width') ?? '0');\n        const height = parseFloat(element.getAttribute('height') ?? '0');\n        if (!width || !height) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x, y],\n            [x + width, y],\n            [x + width, y + height],\n            [x, y + height],\n            [x, y],\n          ],\n          shapeType: 'rect',\n        };\n      }\n      default:\n        // Try next element\n        continue;\n    }\n  }\n  return null;\n}\n\nfunction pathToPoints(normalizedPath: NormalizedSvgPathCommand[]): [number, number][] {\n  const out: [number, number][] = [];\n  for (let i = 0; i < normalizedPath.length; i++) {\n    const startPoint = out[out.length - 1] ?? [0, 0];\n    const seg = normalizedPath[i];\n    switch (seg[0]) {\n      case 'M':\n      case 'L':\n        out.push([seg[1], seg[2]]);\n        continue;\n      case 'C':\n        out.push(\n          ...flattenCubicBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] },\n            { x: seg[5], y: seg[6] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n      case 'Q':\n        out.push(\n          ...flattenQuadraticBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n    }\n  }\n  return out;\n}\n\n/** Extract styling information from SVG selector.\n *\n * Will remove all styling information from the SVG element\n * and normalize `rgba` colors for `fill` and `stroke` to\n * `rgb` and store the opacity in `fillOpacity` and `strokeOpacity`.\n */\nfunction extractStyles(selectorElement: SVGElement): { style?: SelectorStyle; svg: string } | undefined {\n  // TODO: Can this be simplified somehow?\n  const style: SelectorStyle = {};\n  if (selectorElement.hasAttribute('fill')) {\n    style.fill = selectorElement.getAttribute('fill')!;\n    selectorElement.removeAttribute('fill');\n  } else if (selectorElement.style.fill) {\n    style.fill = selectorElement.style.fill;\n  }\n  if (style.fill) {\n    const rgbaMatch = RGBA_COLOR.exec(style.fill);\n    if (rgbaMatch) {\n      style.fillOpacity = parseFloat(rgbaMatch[4]);\n      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('fill-opacity')) {\n    style.fillOpacity = parseFloat(selectorElement.getAttribute('fill-opacity')!);\n    selectorElement.removeAttribute('fill-opacity');\n  } else if (selectorElement.style.fillOpacity) {\n    style.fillOpacity = parseFloat(selectorElement.style.fillOpacity);\n  }\n\n  if (selectorElement.hasAttribute('stroke')) {\n    style.stroke = selectorElement.getAttribute('stroke')!;\n    selectorElement.removeAttribute('stroke');\n  } else if (selectorElement.style.stroke) {\n    style.stroke = selectorElement.style.stroke;\n  }\n  if (style.stroke) {\n    const rgbaMatch = RGBA_COLOR.exec(style.stroke);\n    if (rgbaMatch) {\n      style.strokeOpacity = parseFloat(rgbaMatch[4]);\n      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('stroke-opacity')) {\n    style.strokeOpacity = parseFloat(selectorElement.getAttribute('stroke-opacity')!);\n    selectorElement.removeAttribute('stroke-opacity');\n  } else if (selectorElement.style.strokeOpacity) {\n    style.strokeOpacity = parseFloat(selectorElement.style.strokeOpacity);\n  }\n  if (selectorElement.hasAttribute('stroke-width')) {\n    style.strokeWidth = selectorElement.getAttribute('stroke-width')!;\n    selectorElement.removeAttribute('stroke-width');\n  } else if (selectorElement.style.strokeWidth) {\n    style.strokeWidth = selectorElement.style.strokeWidth;\n  }\n  if (selectorElement.hasAttribute('stroke-dasharray')) {\n    style.strokeDasharray = selectorElement.getAttribute('stroke-dasharray')!;\n    selectorElement.removeAttribute('stroke-dasharray');\n  } else if (selectorElement.style.strokeDasharray) {\n    style.strokeDasharray = selectorElement.style.strokeDasharray;\n  }\n\n  let rootElem: SVGElement | null = selectorElement;\n  while (rootElem.tagName.toLowerCase() !== 'svg') {\n    rootElem = rootElem.parentElement as SVGElement | null;\n    if (rootElem === null) {\n      throw new Error('Could not find root SVG element');\n    }\n  }\n  return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : undefined };\n}\n","import { ExternalWebResource, W3CAnnotationTarget } from '@iiif/presentation-3';\nimport { SupportedTarget } from './target-types';\nimport { parseSelector } from './parse-selector';\n\nexport function expandTarget(\n  target: W3CAnnotationTarget | W3CAnnotationTarget[],\n  options: {\n    typeMap?: Record<string, string>;\n    domParser?: DOMParser;\n    svgPreprocessor?: (svg: string) => string;\n  } = {}\n): SupportedTarget {\n  if (Array.isArray(target)) {\n    // Don't support multiple targets for now.\n    return expandTarget(target[0]);\n  }\n\n  if (typeof target === 'string') {\n    const [id, fragment] = target.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: { id, type: (options.typeMap && (options.typeMap[id] as any)) || 'Unknown' },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget({\n      type: 'SpecificResource',\n      source: { id, type: 'Unknown' },\n      selector: {\n        type: 'FragmentSelector',\n        value: fragment,\n      },\n    });\n  }\n\n  // @todo, how do we want to support choices for targets.\n  if (\n    target.type === 'Choice' ||\n    target.type === 'List' ||\n    target.type === 'Composite' ||\n    target.type === 'Independents'\n  ) {\n    // we also don't support these, just choose the first.\n    return expandTarget(target.items[0]);\n  }\n\n  if (target.type === 'SpecificResource') {\n    if (target.source.type === 'Canvas' && target.source.partOf && typeof target.source.partOf === 'string') {\n      target.source.partOf = [\n        {\n          id: target.source.partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const { selector, selectors } = target.selector\n      ? parseSelector(target.selector, options)\n      : { selector: null, selectors: [] };\n\n    return {\n      type: 'SpecificResource',\n      source: target.source,\n      selector,\n      selectors,\n    };\n  }\n\n  if (target.id) {\n    if ((target as any).type === 'Canvas' && (target as any).partOf && typeof (target as any).partOf === 'string') {\n      (target as any).partOf = [\n        {\n          id: (target as any).partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const [id, fragment] = target.id.split('#');\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget({\n      type: 'SpecificResource',\n      source: {\n        ...(target as any),\n        id,\n      },\n      selector: {\n        type: 'FragmentSelector',\n        value: fragment,\n      },\n    });\n  }\n\n  return {\n    type: 'SpecificResource',\n    source: target as ExternalWebResource,\n    selector: null,\n    selectors: [],\n  };\n}\n","import { Annotation } from '@iiif/presentation-3';\nimport { expandTarget } from './annotation-targets/expand-target';\nimport { SupportedTarget } from './annotation-targets/target-types';\n\nexport type ContentState =\n  | string\n  | (Annotation & { '@context'?: string })\n  | (StateSource & { '@context'?: string })\n  | Array<string | (Annotation & { '@context'?: string }) | (StateSource & { '@context'?: string })>;\n\nexport type StateSource = {\n  id: string;\n  type: 'Manifest' | 'Canvas' | 'Range';\n  partOf?:\n    | string\n    | { id: string; type: string }\n    | Array<{\n        id: string;\n        type: string;\n      }>;\n};\n\n// Normalised content state?\nexport type NormalisedContentState = {\n  id: string;\n  type: 'Annotation';\n  motivation: ['contentState', ...string[]];\n  target: Array<SupportedTarget>;\n  extensions: Record<string, any>;\n};\n\ntype ValidationResponse = readonly [false, { reason?: string }] | readonly [true];\n\nexport function validateContentState(annotation: ContentState, strict = false): ValidationResponse {\n  // Valid content state.\n  if (typeof annotation === 'string') {\n    if (annotation.startsWith('{')) {\n      try {\n        const parsed = JSON.parse(annotation);\n        return validateContentState(parsed);\n      } catch (err) {\n        return [false, { reason: 'Invalid JSON' }];\n      }\n    }\n    return [true];\n  }\n\n  if (Array.isArray(annotation)) {\n    for (const anno of annotation) {\n      const [valid, reason] = validateContentState(anno);\n      if (!valid && reason) {\n        return [valid, reason] as const;\n      }\n    }\n\n    return [true];\n  }\n\n  if (annotation.type === 'Annotation') {\n    // We are validating the annotation.\n    return [true];\n  }\n\n  if (strict && annotation.type === 'Canvas' && !annotation.partOf) {\n    return [false, { reason: 'Canvas without partOf cannot be loaded' }];\n  }\n\n  return [true];\n}\n\nexport function serialiseContentState(annotation: ContentState): string {\n  return encodeContentState(typeof annotation === 'string' ? annotation : JSON.stringify(annotation));\n}\n\nexport function parseContentState(state: string): ContentState;\nexport function parseContentState(state: string, async: false): ContentState;\nexport async function parseContentState(state: string, async: true): Promise<ContentState>;\nexport function parseContentState(state: string, asyncOrFetcher?: boolean): ContentState | Promise<ContentState> {\n  state = state.trim();\n\n  if (state[0] === '{') {\n    // we might have json.\n    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);\n  }\n\n  if (state.startsWith('http')) {\n    if (!asyncOrFetcher) {\n      throw new Error('Cannot fetch remote fetch with async=false in parseContentState');\n    }\n    // resolve.\n    return fetch(state).then((r) => r.json());\n  }\n\n  return parseContentState(decodeContentState(state), asyncOrFetcher as any);\n}\n\nexport function encodeContentState(state: string): string {\n  const uriEncoded = encodeURIComponent(state); // using built in function\n  const base64 = typeof btoa === 'undefined' ? Buffer.from(uriEncoded, 'utf-8').toString('base64') : btoa(uriEncoded); // using built in function\n  const base64url = base64.replace(/\\+/g, '-').replace(/\\//g, '_');\n  return base64url.replace(/=/g, '');\n}\n\nexport function decodeContentState(encodedContentState: string): string {\n  const base64url = restorePadding(encodedContentState);\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const base64Decoded = typeof atob === 'undefined' ? Buffer.from(base64, 'base64').toString('utf-8') : atob(base64); // using built in function\n  return decodeURIComponent(base64Decoded).trim(); // using built in function\n}\n\nfunction restorePadding(s: string) {\n  // The length of the restored string must be a multiple of 4\n  const pad = s.length % 4;\n\n  if (pad === 1) {\n    throw new Error('InvalidLengthError: Input base64url string is the wrong length to determine padding');\n  }\n\n  return s + (pad ? '===='.slice(0, 4 - pad) : '');\n}\n\nexport function normaliseContentState(state: ContentState): NormalisedContentState {\n  if (!state) {\n    throw new Error('Content state is empty');\n  }\n\n  if (!Array.isArray(state)) {\n    // We have multiples.\n    // throw new Error('Content state is an [Array] and not yet supported');\n    state = [state];\n  }\n\n  let annoId = 'vault://virtual-annotation/' + new Date().getTime(); // <-- need a virtual id\n  const motivation = ['contentState'];\n  const targets = [];\n\n  for (const source of state) {\n    if (typeof source === 'string') {\n      // Note: this is unlikely to happen in conjunction with parseContentState()\n      throw new Error('Content state is a [String] type and cannot be inferred');\n    }\n\n    // If we DO have annotation, then this is all we should be returning.\n    if (source.type === 'Annotation') {\n      annoId = source.id;\n      if (Array.isArray(source.motivation)) {\n        for (const singleMotivation of source.motivation) {\n          if (motivation.indexOf(singleMotivation) === -1) {\n            motivation.push(singleMotivation);\n          }\n        }\n      }\n\n      if (Array.isArray(source.target)) {\n        for (const target of source.target) {\n          const expanded = expandTarget(target as any);\n          targets.push(expanded);\n        }\n      } else {\n        const expanded = expandTarget(source.target as any);\n        targets.push(expanded);\n      }\n\n      continue;\n    }\n\n    const target = expandTarget(source as any);\n    targets.push(target);\n  }\n\n  return {\n    id: annoId,\n    type: 'Annotation',\n    motivation: ['contentState', ...((state as any).motivation || [])],\n    target: targets,\n    extensions: {},\n  };\n}\n"],"names":["mapToEllipse","approxUnitArc","vectorAngle","getArcCenter","arcToBezier","arcToCurve","i","val","target"],"mappings":"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"}