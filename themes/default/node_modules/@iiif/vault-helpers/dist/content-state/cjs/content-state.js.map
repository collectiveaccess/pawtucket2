{"version":3,"file":"content-state.js","sources":["../../../node_modules/svg-arc-to-cubic-bezier/modules/index.js","../../../node_modules/parse-svg-path/index.js","../../../node_modules/abs-svg-path/index.js","../../../src/annotation-targets/normalize-svg.ts","../../../src/annotation-targets/bezier.ts","../../../src/annotation-targets/parse-selector.ts","../../../src/annotation-targets/expand-target.ts","../../../src/content-state.ts"],"sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar TAU = Math.PI * 2;\n\nvar mapToEllipse = function mapToEllipse(_ref, rx, ry, cosphi, sinphi, centerx, centery) {\n  var x = _ref.x,\n      y = _ref.y;\n\n  x *= rx;\n  y *= ry;\n\n  var xp = cosphi * x - sinphi * y;\n  var yp = sinphi * x + cosphi * y;\n\n  return {\n    x: xp + centerx,\n    y: yp + centery\n  };\n};\n\nvar approxUnitArc = function approxUnitArc(ang1, ang2) {\n  // If 90 degree circular arc, use a constant\n  // as derived from http://spencermortensen.com/articles/bezier-circle\n  var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);\n\n  var x1 = Math.cos(ang1);\n  var y1 = Math.sin(ang1);\n  var x2 = Math.cos(ang1 + ang2);\n  var y2 = Math.sin(ang1 + ang2);\n\n  return [{\n    x: x1 - y1 * a,\n    y: y1 + x1 * a\n  }, {\n    x: x2 + y2 * a,\n    y: y2 - x2 * a\n  }, {\n    x: x2,\n    y: y2\n  }];\n};\n\nvar vectorAngle = function vectorAngle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n\n  var dot = ux * vx + uy * vy;\n\n  if (dot > 1) {\n    dot = 1;\n  }\n\n  if (dot < -1) {\n    dot = -1;\n  }\n\n  return sign * Math.acos(dot);\n};\n\nvar getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {\n  var rxsq = Math.pow(rx, 2);\n  var rysq = Math.pow(ry, 2);\n  var pxpsq = Math.pow(pxp, 2);\n  var pypsq = Math.pow(pyp, 2);\n\n  var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;\n\n  if (radicant < 0) {\n    radicant = 0;\n  }\n\n  radicant /= rxsq * pypsq + rysq * pxpsq;\n  radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);\n\n  var centerxp = radicant * rx / ry * pyp;\n  var centeryp = radicant * -ry / rx * pxp;\n\n  var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;\n  var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;\n\n  var vx1 = (pxp - centerxp) / rx;\n  var vy1 = (pyp - centeryp) / ry;\n  var vx2 = (-pxp - centerxp) / rx;\n  var vy2 = (-pyp - centeryp) / ry;\n\n  var ang1 = vectorAngle(1, 0, vx1, vy1);\n  var ang2 = vectorAngle(vx1, vy1, vx2, vy2);\n\n  if (sweepFlag === 0 && ang2 > 0) {\n    ang2 -= TAU;\n  }\n\n  if (sweepFlag === 1 && ang2 < 0) {\n    ang2 += TAU;\n  }\n\n  return [centerx, centery, ang1, ang2];\n};\n\nvar arcToBezier = function arcToBezier(_ref2) {\n  var px = _ref2.px,\n      py = _ref2.py,\n      cx = _ref2.cx,\n      cy = _ref2.cy,\n      rx = _ref2.rx,\n      ry = _ref2.ry,\n      _ref2$xAxisRotation = _ref2.xAxisRotation,\n      xAxisRotation = _ref2$xAxisRotation === undefined ? 0 : _ref2$xAxisRotation,\n      _ref2$largeArcFlag = _ref2.largeArcFlag,\n      largeArcFlag = _ref2$largeArcFlag === undefined ? 0 : _ref2$largeArcFlag,\n      _ref2$sweepFlag = _ref2.sweepFlag,\n      sweepFlag = _ref2$sweepFlag === undefined ? 0 : _ref2$sweepFlag;\n\n  var curves = [];\n\n  if (rx === 0 || ry === 0) {\n    return [];\n  }\n\n  var sinphi = Math.sin(xAxisRotation * TAU / 360);\n  var cosphi = Math.cos(xAxisRotation * TAU / 360);\n\n  var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;\n  var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;\n\n  if (pxp === 0 && pyp === 0) {\n    return [];\n  }\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n  var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),\n      _getArcCenter2 = _slicedToArray(_getArcCenter, 4),\n      centerx = _getArcCenter2[0],\n      centery = _getArcCenter2[1],\n      ang1 = _getArcCenter2[2],\n      ang2 = _getArcCenter2[3];\n\n  // If 'ang2' == 90.0000000001, then `ratio` will evaluate to\n  // 1.0000000001. This causes `segments` to be greater than one, which is an\n  // unecessary split, and adds extra points to the bezier curve. To alleviate\n  // this issue, we round to 1.0 when the ratio is close to 1.0.\n\n\n  var ratio = Math.abs(ang2) / (TAU / 4);\n  if (Math.abs(1.0 - ratio) < 0.0000001) {\n    ratio = 1.0;\n  }\n\n  var segments = Math.max(Math.ceil(ratio), 1);\n\n  ang2 /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    curves.push(approxUnitArc(ang1, ang2));\n    ang1 += ang2;\n  }\n\n  return curves.map(function (curve) {\n    var _mapToEllipse = mapToEllipse(curve[0], rx, ry, cosphi, sinphi, centerx, centery),\n        x1 = _mapToEllipse.x,\n        y1 = _mapToEllipse.y;\n\n    var _mapToEllipse2 = mapToEllipse(curve[1], rx, ry, cosphi, sinphi, centerx, centery),\n        x2 = _mapToEllipse2.x,\n        y2 = _mapToEllipse2.y;\n\n    var _mapToEllipse3 = mapToEllipse(curve[2], rx, ry, cosphi, sinphi, centerx, centery),\n        x = _mapToEllipse3.x,\n        y = _mapToEllipse3.y;\n\n    return { x1: x1, y1: y1, x2: x2, y2: y2, x: x, y: y };\n  });\n};\n\nexport default arcToBezier;","\nmodule.exports = parse\n\n/**\n * expected argument lengths\n * @type {Object}\n */\n\nvar length = {a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0}\n\n/**\n * segment pattern\n * @type {RegExp}\n */\n\nvar segment = /([astvzqmhlc])([^astvzqmhlc]*)/ig\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * @param {String} path\n * @return {Array}\n */\n\nfunction parse(path) {\n\tvar data = []\n\tpath.replace(segment, function(_, command, args){\n\t\tvar type = command.toLowerCase()\n\t\targs = parseValues(args)\n\n\t\t// overloaded moveTo\n\t\tif (type == 'm' && args.length > 2) {\n\t\t\tdata.push([command].concat(args.splice(0, 2)))\n\t\t\ttype = 'l'\n\t\t\tcommand = command == 'm' ? 'l' : 'L'\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (args.length == length[type]) {\n\t\t\t\targs.unshift(command)\n\t\t\t\treturn data.push(args)\n\t\t\t}\n\t\t\tif (args.length < length[type]) throw new Error('malformed path data')\n\t\t\tdata.push([command].concat(args.splice(0, length[type])))\n\t\t}\n\t})\n\treturn data\n}\n\nvar number = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig\n\nfunction parseValues(args) {\n\tvar numbers = args.match(number)\n\treturn numbers ? numbers.map(Number) : []\n}\n","\nmodule.exports = absolutize\n\n/**\n * redefine `path` with absolute coordinates\n *\n * @param {Array} path\n * @return {Array}\n */\n\nfunction absolutize(path){\n\tvar startX = 0\n\tvar startY = 0\n\tvar x = 0\n\tvar y = 0\n\n\treturn path.map(function(seg){\n\t\tseg = seg.slice()\n\t\tvar type = seg[0]\n\t\tvar command = type.toUpperCase()\n\n\t\t// is relative\n\t\tif (type != command) {\n\t\t\tseg[0] = command\n\t\t\tswitch (type) {\n\t\t\t\tcase 'a':\n\t\t\t\t\tseg[6] += x\n\t\t\t\t\tseg[7] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'v':\n\t\t\t\t\tseg[1] += y\n\t\t\t\t\tbreak\n\t\t\t\tcase 'h':\n\t\t\t\t\tseg[1] += x\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tfor (var i = 1; i < seg.length;) {\n\t\t\t\t\t\tseg[i++] += x\n\t\t\t\t\t\tseg[i++] += y\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// update cursor state\n\t\tswitch (command) {\n\t\t\tcase 'Z':\n\t\t\t\tx = startX\n\t\t\t\ty = startY\n\t\t\t\tbreak\n\t\t\tcase 'H':\n\t\t\t\tx = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'V':\n\t\t\t\ty = seg[1]\n\t\t\t\tbreak\n\t\t\tcase 'M':\n\t\t\t\tx = startX = seg[1]\n\t\t\t\ty = startY = seg[2]\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tx = seg[seg.length - 2]\n\t\t\t\ty = seg[seg.length - 1]\n\t\t}\n\n\t\treturn seg\n\t})\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport arcToCurve from 'svg-arc-to-cubic-bezier';\nimport parseSvgPath from 'parse-svg-path';\nimport absSvgPath, {\n  AbsoluteCubicBezierCommand,\n  AbsoluteLineCommand,\n  AbsoluteMoveCommand,\n  AbsoluteQuadraticBezierCommand,\n} from 'abs-svg-path';\n\nexport type NormalizedSvgPathCommand =\n  | AbsoluteMoveCommand\n  | AbsoluteLineCommand\n  | AbsoluteCubicBezierCommand\n  | AbsoluteQuadraticBezierCommand;\n\nexport type NormalizedSvgPathCommandType = 'M' | 'L' | 'C' | 'Q';\n\n/** Parse an SVG path and normalize it so it only contains Moves, Lines and Cubic or Quadratic BÃ©zier curves\n *  in their absolute form. */\nexport function parseAndNormalizeSvgPath(path: string): NormalizedSvgPathCommand[] {\n  const parsed = parseSvgPath(path);\n  const absolute = absSvgPath(parsed);\n\n  let prevCmd: 'M' | 'L' | 'H' | 'V' | 'C' | 'S' | 'Q' | 'T' | 'A' | 'Z' | undefined;\n  let startX = 0;\n  let startY = 0;\n  let bezierX = 0;\n  let bezierY = 0;\n  let quadX: number | undefined;\n  let quadY: number | undefined;\n  let x = 0;\n  let y = 0;\n  const out: NormalizedSvgPathCommand[] = [];\n  for (let i = 0; i < absolute.length; i++) {\n    let seg = absolute[i];\n    const cmd = seg[0];\n    switch (cmd) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'H':\n        seg = ['L', seg[1], startY];\n        break;\n      case 'V':\n        seg = ['L', startX, seg[1]];\n        break;\n      case 'S':\n        {\n          let cx = x;\n          let cy = y;\n          if (prevCmd === 'C' || prevCmd == 'S') {\n            cx += cx - bezierX;\n            cy += cy - bezierY;\n          }\n          seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        }\n        break;\n      case 'T':\n        if (prevCmd === 'Q' || prevCmd == 'T') {\n          quadX = x * 2 - quadX!;\n          quadY = y * 2 - quadY!;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = ['Q', quadX, quadY, seg[1], seg[2]];\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        break;\n      case 'A':\n        {\n          const curves = arcToCurve({\n            px: x,\n            py: y,\n            cx: seg[6],\n            cy: seg[7],\n            rx: seg[1],\n            ry: seg[2],\n            xAxisRotation: seg[3],\n            largeArcFlag: seg[4],\n            sweepFlag: seg[5],\n          });\n          if (!curves.length) {\n            continue;\n          }\n          for (const [j, curve] of curves.entries()) {\n            seg = ['C', curve.x1, curve.y1, curve.x2, curve.y2, curve.x, curve.y];\n            if (j < curves.length - 1) {\n              out.push(seg);\n            }\n          }\n          // FIXME: Why do we need this cast?\n          seg = seg as NormalizedSvgPathCommand;\n        }\n        break;\n      case 'Z':\n        seg = ['L', startX, startY];\n        break;\n    }\n\n    prevCmd = cmd;\n    x = seg[seg.length - 2] as number;\n    y = seg[seg.length - 1] as number;\n    if (['C', 'Q', 'A'].indexOf(cmd) > -1) {\n      bezierX = seg[seg.length - 4] as number;\n      bezierY = seg[seg.length - 3] as number;\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    out.push(seg);\n  }\n\n  return out;\n}\n","/** Code to \"flatten\" quadratic and cubic BÃ©zier curves to polylines.\n *\n * All code in this module is based on JavaScript code by Raph Levien, published on his blog at\n * https://raphlinus.github.io/.\n * I merely changed the structure a bit, removed some unneeded parts and added some comments and type hints.\n *\n * Flattening of quadratic BÃ©zier curves:\n * - Article: https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html\n * - Code: https://github.com/raphlinus/raphlinus.github.io/blob/master/_posts/2019-12-23-flatten-quadbez.md?plain=1#L73-L212\n *\n * Flattening of cubic BÃ©zier curves: https://levien.com/tmp/flatten.html\n *\n * Note that the code in this module has a different license than the rest of the package,\n * due to the inclusion of Apache-licensed third party code.\n *\n * @license\n * Copyright 2022 Johannes Baiter <johannes.baiter@gmail.com>\n * Copyright 2019, 2022 Raph Levien <raph.levien@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport type Point = { x: number; y: number };\n\nexport function flattenQuadraticBezier(start: Point, control: Point, end: Point, tolerance = 1): Point[] {\n  return new QuadraticBezier(start, control, end).subdivide(tolerance);\n}\n\nexport function flattenCubicBezier(\n  start: Point,\n  startControl: Point,\n  end: Point,\n  endControl: Point,\n  tolerance = 1\n): Point[] {\n  return new CubicBezier(\n    new Float64Array([start.x, start.y, startControl.x, startControl.y, end.x, end.y, endControl.x, endControl.y])\n  ).subdivide(tolerance);\n}\n\nfunction hypot2(p: Point): number {\n  return p.x * p.x + p.y * p.y;\n}\n\n// Compute an approximation to int (1 + 4x^2) ^ -0.25 dx\nfunction approx_myint(x: number): number {\n  const d = 0.67;\n  return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));\n}\n\n// Approximate the inverse of `approx_myint`\nfunction approx_inv_myint(x: number): number {\n  const b = 0.39;\n  return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));\n}\n\n// Parameters for a basic parabola corresponding to a quadratic bÃ©zier curve\ntype QuadraticBezierBasicParams = {\n  x0: number;\n  x2: number;\n  scale: number;\n  cross: number;\n};\n\nclass QuadraticBezier {\n  start: Point;\n  control: Point;\n  end: Point;\n\n  constructor(start: Point, control: Point, end: Point) {\n    this.start = start;\n    this.control = control;\n    this.end = end;\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    return {\n      x: this.start.x * mt * mt + 2 * this.control.x * mt * t + this.end.x * t * t,\n      y: this.start.y * mt * mt + 2 * this.control.y * mt * t + this.end.y * t * t,\n    };\n  }\n\n  mapToBasic(): QuadraticBezierBasicParams {\n    const { x: x0, y: y0 } = this.start;\n    const { x: x1, y: y1 } = this.control;\n    const { x: x2, y: y2 } = this.end;\n\n    // Determine the x values and scaling to map to y=x^2\n    const ddx = 2 * x1 - x0 - x2;\n    const ddy = 2 * y1 - y0 - y2;\n    const u0 = (x1 - x0) * ddx + (y1 - y0) * ddy;\n    const u2 = (x2 - x1) * ddx + (y2 - y1) * ddy;\n    const cross = (x2 - x0) * ddy - (y2 - y0) * ddx;\n    const paramX0 = u0 / cross;\n    const paramX2 = u2 / cross;\n\n    // There's probably a more elegant formulation of this...\n    const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(paramX2 - paramX0));\n\n    return { x0, x2, scale, cross };\n  }\n\n  subdivide(tolerance: number): Point[] {\n    const params = this.mapToBasic();\n    const a0 = approx_myint(params.x0);\n    const a2 = approx_myint(params.x2);\n    const count = 0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tolerance);\n    const n = Math.ceil(count);\n    const u0 = approx_inv_myint(a0);\n    const u2 = approx_inv_myint(a2);\n    const tValues = [0];\n    for (let i = 1; i < n; i++) {\n      const u = approx_inv_myint(a0 + ((a2 - a0) * i) / n);\n      const t = (u - u0) / (u2 - u0);\n      tValues.push(t);\n    }\n    tValues.push(1);\n    return tValues.map((t) => this.eval(t));\n  }\n}\n\nclass CubicBezier {\n  private c: Float64Array;\n\n  /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].\n  constructor(coords: Float64Array) {\n    this.c = coords;\n  }\n\n  weightsum(c0: number, c1: number, c2: number, c3: number): Point {\n    const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];\n    const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];\n    return { x, y };\n  }\n\n  eval(t: number): Point {\n    const mt = 1 - t;\n    const c0 = mt * mt * mt;\n    const c1 = 3 * mt * mt * t;\n    const c2 = 3 * mt * t * t;\n    const c3 = t * t * t;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  deriv(t: number): Point {\n    const mt = 1 - t;\n    const c0 = -3 * mt * mt;\n    const c3 = 3 * t * t;\n    const c1 = -6 * t * mt - c0;\n    const c2 = 6 * t * mt - c3;\n    return this.weightsum(c0, c1, c2, c3);\n  }\n\n  // quadratic bezier with matching endpoints and minimum max vector error\n  midpoint_quadbez(): QuadraticBezier {\n    const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);\n    return new QuadraticBezier({ x: this.c[0], y: this.c[1] }, p1, { x: this.c[6], y: this.c[7] });\n  }\n\n  subsegment(t0: number, t1: number): CubicBezier {\n    const c = new Float64Array(8);\n    const p0 = this.eval(t0);\n    const p3 = this.eval(t1);\n    c[0] = p0.x;\n    c[1] = p0.y;\n    const scale = (t1 - t0) / 3;\n    const d1 = this.deriv(t0);\n    c[2] = p0.x + scale * d1.x;\n    c[3] = p0.y + scale * d1.y;\n    const d2 = this.deriv(t1);\n    c[4] = p3.x - scale * d2.x;\n    c[5] = p3.y - scale * d2.y;\n    c[6] = p3.x;\n    c[7] = p3.y;\n    return new CubicBezier(c);\n  }\n\n  // Very fancy subdivision scheme\n  subdivide(tol: number) {\n    const tol1 = 0.1 * tol; // error for subdivision into quads\n    const tol2 = tol - tol1; // error for subdivision of quads into lines\n    const sqrt_tol2 = Math.sqrt(tol2);\n    const err2 = hypot2(this.weightsum(1, -3, 3, -1));\n    const n_quads = Math.ceil(Math.pow(err2 / (432 * tol1 * tol1), 1 / 6));\n    const quads = [];\n    let sum = 0;\n    for (let i = 0; i < n_quads; i++) {\n      const t0 = i / n_quads;\n      const t1 = (i + 1) / n_quads;\n      const quad = this.subsegment(t0, t1).midpoint_quadbez();\n      const params = quad.mapToBasic();\n      const a0 = approx_myint(params.x0);\n      const a2 = approx_myint(params.x2);\n      const scale = Math.sqrt(params.scale);\n      let val = Math.abs(a2 - a0) * scale;\n      if (Math.sign(params.x0) != Math.sign(params.x2)) {\n        // min x value in basic parabola to make sure we don't skip cusp\n        const xmin = sqrt_tol2 / scale;\n        const cusp_val = (sqrt_tol2 * Math.abs(a2 - a0)) / approx_myint(xmin);\n        // I *think* it will always be larger, but just in case...\n        val = Math.max(val, cusp_val);\n      }\n      quads.push({\n        quad: quad,\n        a0: a0,\n        a2: a2,\n        val: val,\n      });\n      sum += val;\n    }\n    const count = (0.5 * sum) / sqrt_tol2;\n    const n = Math.ceil(count);\n    const result = [{ x: this.c[0], y: this.c[1] }];\n    let val = 0; // sum of vals from [0..i]\n    let i = 0;\n    for (let j = 1; j < n; j++) {\n      const target = (sum * j) / n;\n      while (val + quads[i].val < target) {\n        val += quads[i].val;\n        i++;\n      }\n      const a0 = quads[i].a0;\n      const a2 = quads[i].a2;\n      // Note: we can cut down on recomputing these\n      const u0 = approx_inv_myint(a0);\n      const u2 = approx_inv_myint(a2);\n      const a = a0 + ((a2 - a0) * (target - val)) / quads[i].val;\n      const u = approx_inv_myint(a);\n      const t = (u - u0) / (u2 - u0);\n      result.push(quads[i].quad.eval(t));\n    }\n    result.push({ x: this.c[6], y: this.c[7] });\n    return result;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport {\n  ParsedSelector,\n  SupportedSelectors,\n  TemporalSelector,\n  SvgSelector,\n  SelectorStyle,\n  SvgShapeType,\n} from './selector-types';\nimport { Selector } from '@iiif/presentation-3';\nimport { NormalizedSvgPathCommand, NormalizedSvgPathCommandType, parseAndNormalizeSvgPath } from './normalize-svg';\nimport { flattenCubicBezier, flattenQuadraticBezier } from './bezier';\n\nconst BOX_SELECTOR =\n  /&?(xywh=)?(pixel:|percent:|pct:)?([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?),([0-9]+(?:\\.[0-9]+)?)/;\n\n// Does not support 00:00:00 or 00:00 formats.\nconst TEMPORAL_SELECTOR = /&?(t=)(npt:)?([0-9]+(.[0-9]+)?)?(,([0-9]+(.[0-9]+)?))?/;\n\nconst RGBA_COLOR = /^rgba\\((\\d+),(\\d+),(\\d+),([0-9.]+)\\)$/;\n\nexport function parseSelector(\n  source: Selector | Selector[],\n  { domParser, svgPreprocessor }: { domParser?: DOMParser; svgPreprocessor?: (svg: string) => string } = {}\n): ParsedSelector {\n  if (Array.isArray(source)) {\n    return (source as Array<string | Selector>).reduce(\n      <ParseSelector>(data: ParsedSelector, nextSource: string | Selector) => {\n        const { selector, selectors } = parseSelector(nextSource);\n        if (selector) {\n          if (!data.selector) {\n            data.selector = selector;\n          }\n          data.selectors.push(...selectors);\n        }\n        return data;\n      },\n      {\n        selector: null,\n        selectors: [],\n      } as ParsedSelector\n    );\n  }\n\n  if (!source) {\n    return {\n      selector: null,\n      selectors: [],\n    };\n  }\n\n  if (typeof source === 'string') {\n    const [id, fragment] = source.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return parseSelector({ type: 'FragmentSelector', value: fragment });\n  }\n\n  if (source.type === 'PointSelector' && (source.t || source.t === 0)) {\n    const selector: TemporalSelector = {\n      type: 'TemporalSelector',\n      temporal: {\n        startTime: source.t,\n      },\n    };\n\n    return {\n      selector,\n      selectors: [selector],\n    };\n  }\n\n  if (source.type === 'FragmentSelector') {\n    const matchBoxSelector = BOX_SELECTOR.exec(source.value);\n    if (matchBoxSelector) {\n      const selector: SupportedSelectors = {\n        type: 'BoxSelector',\n        spatial: {\n          unit: matchBoxSelector[2] === 'percent:' || matchBoxSelector[2] === 'pct:' ? 'percent' : 'pixel',\n          x: parseFloat(matchBoxSelector[3]),\n          y: parseFloat(matchBoxSelector[4]),\n          width: parseFloat(matchBoxSelector[5]),\n          height: parseFloat(matchBoxSelector[6]),\n        },\n      };\n\n      return {\n        selector,\n        selectors: [selector],\n      };\n    }\n\n    const matchTimeSelector = source.value.match(TEMPORAL_SELECTOR);\n    if (matchTimeSelector) {\n      const selector: TemporalSelector = {\n        type: 'TemporalSelector',\n        temporal: {\n          startTime: matchTimeSelector[4] ? parseFloat(matchTimeSelector[4]) : 0,\n          endTime: matchTimeSelector[7] ? parseFloat(matchTimeSelector[7]) : undefined,\n        },\n      };\n\n      return {\n        selector,\n        selectors: [selector],\n      };\n    }\n\n    return {\n      selector: null,\n      selectors: [],\n    };\n  }\n\n  if (source.type === 'SvgSelector' && 'value' in source) {\n    if (!domParser) {\n      if (typeof window !== 'undefined') {\n        domParser = new window.DOMParser();\n      } else {\n        console.warn(\n          'No DOMParser available, cannot parse SVG selector, `points`, `spatial` and `style` will be unavailable and the SVG will not be normalized.'\n        );\n      }\n    }\n    let points: [number, number][] = [];\n    let rect: [number, number, number, number] | undefined;\n    let style: SelectorStyle | undefined;\n    let svg = svgPreprocessor?.(source.value) ?? source.value;\n    let svgShape: SvgShapeType | undefined;\n    if (domParser) {\n      const svgElement: SVGElement | null = domParser\n        .parseFromString(source.value, 'image/svg+xml')\n        .querySelector('svg');\n      if (!svgElement) {\n        console.warn(`Illegal SVG selector: ${source.value}`);\n        return {\n          selector: null,\n          selectors: [],\n        };\n      }\n      const selectorElem = getSelectorElement(svgElement);\n      if (selectorElem) {\n        points = selectorElem.points;\n        svgShape = selectorElem.shapeType;\n        rect = [\n          Math.min(...points.map((p) => p[0])), // llx\n          Math.min(...points.map((p) => p[1])), // lly\n          Math.max(...points.map((p) => p[0])), // urx\n          Math.max(...points.map((p) => p[1])), // ury\n        ];\n        ({ style, svg } = extractStyles(selectorElem.element) ?? { svg });\n      }\n    }\n    const sel: SvgSelector = {\n      type: 'SvgSelector',\n      svg,\n      svgShape,\n      style,\n      points: points.length ? points : undefined,\n      spatial: rect\n        ? { unit: 'pixel', x: rect[0], y: rect[1], width: rect[2] - rect[0], height: rect[3] - rect[1] }\n        : undefined,\n    };\n    return {\n      selector: sel,\n      selectors: [sel],\n    };\n  }\n  return {\n    selector: null,\n    selectors: [],\n  };\n}\n\nexport type SelectorElement = {\n  element: SVGElement;\n  points: [number, number][];\n  shapeType: SvgShapeType;\n};\n\nfunction getShapeTypeFromPath(svgPath: NormalizedSvgPathCommand[]): SvgShapeType {\n  const cmdFrequencies = svgPath\n    .map((seg) => seg[0])\n    .reduce(\n      (acc: Record<NormalizedSvgPathCommandType, number>, cmd) => {\n        acc[cmd] += 1;\n        return acc;\n      },\n      { C: 0, Q: 0, L: 0, M: 0 }\n    );\n  const cmdTypes = new Set(svgPath.map((seg) => seg[0]));\n  if (cmdFrequencies.C > 0 || cmdFrequencies.Q > 0) {\n    return 'path';\n  }\n  if (cmdFrequencies.L > 0 && (cmdTypes.size === 1 || (cmdTypes.size === 2 && cmdTypes.has('M')))) {\n    // Only lines and moves: rectangle, polygon or polyline?\n    if (cmdFrequencies.L === 4) {\n      return 'rect';\n    }\n\n    // Check if the path is closed to decide if we have a polygon or a polyline\n    const lastSeg = svgPath.slice(-1)[0];\n    if (\n      (svgPath[0][0] === 'M' && lastSeg[0] === 'L' && lastSeg[1] == svgPath[0][1] && lastSeg[2] === svgPath[0][2]) ||\n      (lastSeg[1] === 0 && lastSeg[2] === 0)\n    ) {\n      return 'polygon';\n    } else {\n      return 'polyline';\n    }\n  }\n  return 'path';\n}\n\nfunction getSelectorElement(svgElem: SVGElement): SelectorElement | null {\n  for (const element of Array.from(svgElem.children) as SVGElement[]) {\n    switch (element?.tagName.toLowerCase()) {\n      case 'g':\n        {\n          // Check if any of the children in the container can be converted to points\n          const res = getSelectorElement(element as SVGElement);\n          if (res) {\n            return res;\n          }\n        }\n        continue;\n      case 'path': {\n        const p = element.getAttribute('d');\n        if (!p) {\n          continue;\n        }\n        const normalized = parseAndNormalizeSvgPath(p);\n        return { element, points: pathToPoints(normalized), shapeType: getShapeTypeFromPath(normalized) };\n      }\n      case 'circle': {\n        const cx = parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = parseFloat(element.getAttribute('cy') ?? '0');\n        const r = parseFloat(element.getAttribute('r') ?? '0');\n        if (!r) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        // TODO: Get rid of the degree -> radian conversion and use radians from the beginning\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const rad = (angle * Math.PI) / 180;\n          points.push([cx + r * Math.cos(rad), cy + r * Math.sin(rad)]);\n        }\n        return { element, points, shapeType: 'circle' };\n      }\n      case 'ellipse': {\n        const cx = parseFloat(element.getAttribute('cx') ?? '0');\n        const cy = parseFloat(element.getAttribute('cy') ?? '0');\n        const rx = parseFloat(element.getAttribute('rx') ?? '0');\n        const ry = parseFloat(element.getAttribute('ry') ?? '0');\n        if (!rx && !ry) {\n          continue;\n        }\n        const points: [number, number][] = [];\n        for (let angle = 0; angle <= 360; angle += 12) {\n          const t = Math.tan((angle / 360) * Math.PI);\n          const px = (rx * (1 - t ** 2)) / (1 + t ** 2);\n          const py = (ry * 2 * t) / (1 + t ** 2);\n          points.push([cx + px, cy + py]);\n        }\n        return { element, points, shapeType: 'ellipse' };\n      }\n      case 'line': {\n        const x0 = parseFloat(element.getAttribute('x0') ?? '0');\n        const y0 = parseFloat(element.getAttribute('y0') ?? '0');\n        const x1 = parseFloat(element.getAttribute('x1') ?? '0');\n        const y1 = parseFloat(element.getAttribute('y1') ?? '0');\n        if (x0 === x1 && y0 === y1) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x0, y0],\n            [x1, y1],\n          ],\n          shapeType: 'polyline',\n        };\n      }\n      case 'polygon':\n      case 'polyline': {\n        const points =\n          element\n            .getAttribute('points')\n            ?.split(' ')\n            .map((ps) => ps.split(',').map(parseFloat) as [number, number]) ?? [];\n        if (!points.length) {\n          continue;\n        }\n        let shapeType: SvgShapeType = 'polyline';\n        if (element.tagName.toLowerCase() === 'polygon') {\n          // A polygon is a closed path, so the last point is the same as the first.\n          points.push(points[0]);\n          shapeType = 'polygon';\n        }\n        return { element, points, shapeType };\n      }\n      case 'rect': {\n        const x = parseFloat(element.getAttribute('x') ?? '0');\n        const y = parseFloat(element.getAttribute('y') ?? '0');\n        const width = parseFloat(element.getAttribute('width') ?? '0');\n        const height = parseFloat(element.getAttribute('height') ?? '0');\n        if (!width || !height) {\n          continue;\n        }\n        return {\n          element,\n          points: [\n            [x, y],\n            [x + width, y],\n            [x + width, y + height],\n            [x, y + height],\n            [x, y],\n          ],\n          shapeType: 'rect',\n        };\n      }\n      default:\n        // Try next element\n        continue;\n    }\n  }\n  return null;\n}\n\nfunction pathToPoints(normalizedPath: NormalizedSvgPathCommand[]): [number, number][] {\n  const out: [number, number][] = [];\n  for (let i = 0; i < normalizedPath.length; i++) {\n    const startPoint = out[out.length - 1] ?? [0, 0];\n    const seg = normalizedPath[i];\n    switch (seg[0]) {\n      case 'M':\n      case 'L':\n        out.push([seg[1], seg[2]]);\n        continue;\n      case 'C':\n        out.push(\n          ...flattenCubicBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] },\n            { x: seg[5], y: seg[6] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n      case 'Q':\n        out.push(\n          ...flattenQuadraticBezier(\n            { x: startPoint[0], y: startPoint[1] },\n            { x: seg[1], y: seg[2] },\n            { x: seg[3], y: seg[4] }\n          )\n            .map((p) => [p.x, p.y] as [number, number])\n            .slice(1) // skip first point, already part of output\n        );\n        continue;\n    }\n  }\n  return out;\n}\n\n/** Extract styling information from SVG selector.\n *\n * Will remove all styling information from the SVG element\n * and normalize `rgba` colors for `fill` and `stroke` to\n * `rgb` and store the opacity in `fillOpacity` and `strokeOpacity`.\n */\nfunction extractStyles(selectorElement: SVGElement): { style?: SelectorStyle; svg: string } | undefined {\n  // TODO: Can this be simplified somehow?\n  const style: SelectorStyle = {};\n  if (selectorElement.hasAttribute('fill')) {\n    style.fill = selectorElement.getAttribute('fill')!;\n    selectorElement.removeAttribute('fill');\n  } else if (selectorElement.style.fill) {\n    style.fill = selectorElement.style.fill;\n  }\n  if (style.fill) {\n    const rgbaMatch = RGBA_COLOR.exec(style.fill);\n    if (rgbaMatch) {\n      style.fillOpacity = parseFloat(rgbaMatch[4]);\n      style.fill = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('fill-opacity')) {\n    style.fillOpacity = parseFloat(selectorElement.getAttribute('fill-opacity')!);\n    selectorElement.removeAttribute('fill-opacity');\n  } else if (selectorElement.style.fillOpacity) {\n    style.fillOpacity = parseFloat(selectorElement.style.fillOpacity);\n  }\n\n  if (selectorElement.hasAttribute('stroke')) {\n    style.stroke = selectorElement.getAttribute('stroke')!;\n    selectorElement.removeAttribute('stroke');\n  } else if (selectorElement.style.stroke) {\n    style.stroke = selectorElement.style.stroke;\n  }\n  if (style.stroke) {\n    const rgbaMatch = RGBA_COLOR.exec(style.stroke);\n    if (rgbaMatch) {\n      style.strokeOpacity = parseFloat(rgbaMatch[4]);\n      style.stroke = `rgb(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]})`;\n    }\n  }\n  if (selectorElement.hasAttribute('stroke-opacity')) {\n    style.strokeOpacity = parseFloat(selectorElement.getAttribute('stroke-opacity')!);\n    selectorElement.removeAttribute('stroke-opacity');\n  } else if (selectorElement.style.strokeOpacity) {\n    style.strokeOpacity = parseFloat(selectorElement.style.strokeOpacity);\n  }\n  if (selectorElement.hasAttribute('stroke-width')) {\n    style.strokeWidth = selectorElement.getAttribute('stroke-width')!;\n    selectorElement.removeAttribute('stroke-width');\n  } else if (selectorElement.style.strokeWidth) {\n    style.strokeWidth = selectorElement.style.strokeWidth;\n  }\n  if (selectorElement.hasAttribute('stroke-dasharray')) {\n    style.strokeDasharray = selectorElement.getAttribute('stroke-dasharray')!;\n    selectorElement.removeAttribute('stroke-dasharray');\n  } else if (selectorElement.style.strokeDasharray) {\n    style.strokeDasharray = selectorElement.style.strokeDasharray;\n  }\n\n  let rootElem: SVGElement | null = selectorElement;\n  while (rootElem.tagName.toLowerCase() !== 'svg') {\n    rootElem = rootElem.parentElement as SVGElement | null;\n    if (rootElem === null) {\n      throw new Error('Could not find root SVG element');\n    }\n  }\n  return { svg: rootElem.outerHTML, style: Object.keys(style).length > 0 ? style : undefined };\n}\n","import { ExternalWebResource, W3CAnnotationTarget } from '@iiif/presentation-3';\nimport { SupportedTarget } from './target-types';\nimport { parseSelector } from './parse-selector';\n\nexport function expandTarget(\n  target: W3CAnnotationTarget | W3CAnnotationTarget[],\n  options: {\n    typeMap?: Record<string, string>;\n    domParser?: DOMParser;\n    svgPreprocessor?: (svg: string) => string;\n  } = {}\n): SupportedTarget {\n  if (Array.isArray(target)) {\n    // Don't support multiple targets for now.\n    return expandTarget(target[0]);\n  }\n\n  if (typeof target === 'string') {\n    const [id, fragment] = target.split('#');\n\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: { id, type: (options.typeMap && (options.typeMap[id] as any)) || 'Unknown' },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget({\n      type: 'SpecificResource',\n      source: { id, type: 'Unknown' },\n      selector: {\n        type: 'FragmentSelector',\n        value: fragment,\n      },\n    });\n  }\n\n  // @todo, how do we want to support choices for targets.\n  if (\n    target.type === 'Choice' ||\n    target.type === 'List' ||\n    target.type === 'Composite' ||\n    target.type === 'Independents'\n  ) {\n    // we also don't support these, just choose the first.\n    return expandTarget(target.items[0]);\n  }\n\n  if (target.type === 'SpecificResource') {\n    if (target.source.type === 'Canvas' && target.source.partOf && typeof target.source.partOf === 'string') {\n      target.source.partOf = [\n        {\n          id: target.source.partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const { selector, selectors } = target.selector\n      ? parseSelector(target.selector, options)\n      : { selector: null, selectors: [] };\n\n    return {\n      type: 'SpecificResource',\n      source: target.source,\n      selector,\n      selectors,\n    };\n  }\n\n  if (target.id) {\n    if ((target as any).type === 'Canvas' && (target as any).partOf && typeof (target as any).partOf === 'string') {\n      (target as any).partOf = [\n        {\n          id: (target as any).partOf,\n          type: 'Manifest',\n        },\n      ];\n    }\n\n    const [id, fragment] = target.id.split('#');\n    if (!fragment) {\n      // This is an unknown selector.\n      return {\n        type: 'SpecificResource',\n        source: {\n          ...(target as any),\n          id,\n        },\n        selector: null,\n        selectors: [],\n      };\n    }\n\n    return expandTarget({\n      type: 'SpecificResource',\n      source: {\n        ...(target as any),\n        id,\n      },\n      selector: {\n        type: 'FragmentSelector',\n        value: fragment,\n      },\n    });\n  }\n\n  return {\n    type: 'SpecificResource',\n    source: target as ExternalWebResource,\n    selector: null,\n    selectors: [],\n  };\n}\n","import { Annotation } from '@iiif/presentation-3';\nimport { expandTarget } from './annotation-targets/expand-target';\nimport { SupportedTarget } from './annotation-targets/target-types';\n\nexport type ContentState =\n  | string\n  | (Annotation & { '@context'?: string })\n  | (StateSource & { '@context'?: string })\n  | Array<string | (Annotation & { '@context'?: string }) | (StateSource & { '@context'?: string })>;\n\nexport type StateSource = {\n  id: string;\n  type: 'Manifest' | 'Canvas' | 'Range';\n  partOf?:\n    | string\n    | { id: string; type: string }\n    | Array<{\n        id: string;\n        type: string;\n      }>;\n};\n\n// Normalised content state?\nexport type NormalisedContentState = {\n  id: string;\n  type: 'Annotation';\n  motivation: ['contentState', ...string[]];\n  target: Array<SupportedTarget>;\n  extensions: Record<string, any>;\n};\n\ntype ValidationResponse = readonly [false, { reason?: string }] | readonly [true];\n\nexport function validateContentState(annotation: ContentState, strict = false): ValidationResponse {\n  // Valid content state.\n  if (typeof annotation === 'string') {\n    if (annotation.startsWith('{')) {\n      try {\n        const parsed = JSON.parse(annotation);\n        return validateContentState(parsed);\n      } catch (err) {\n        return [false, { reason: 'Invalid JSON' }];\n      }\n    }\n    return [true];\n  }\n\n  if (Array.isArray(annotation)) {\n    for (const anno of annotation) {\n      const [valid, reason] = validateContentState(anno);\n      if (!valid && reason) {\n        return [valid, reason] as const;\n      }\n    }\n\n    return [true];\n  }\n\n  if (annotation.type === 'Annotation') {\n    // We are validating the annotation.\n    return [true];\n  }\n\n  if (strict && annotation.type === 'Canvas' && !annotation.partOf) {\n    return [false, { reason: 'Canvas without partOf cannot be loaded' }];\n  }\n\n  return [true];\n}\n\nexport function serialiseContentState(annotation: ContentState): string {\n  return encodeContentState(typeof annotation === 'string' ? annotation : JSON.stringify(annotation));\n}\n\nexport function parseContentState(state: string): ContentState;\nexport function parseContentState(state: string, async: false): ContentState;\nexport async function parseContentState(state: string, async: true): Promise<ContentState>;\nexport function parseContentState(state: string, asyncOrFetcher?: boolean): ContentState | Promise<ContentState> {\n  state = state.trim();\n\n  if (state[0] === '{') {\n    // we might have json.\n    return asyncOrFetcher ? Promise.resolve(JSON.parse(state)) : JSON.parse(state);\n  }\n\n  if (state.startsWith('http')) {\n    if (!asyncOrFetcher) {\n      throw new Error('Cannot fetch remote fetch with async=false in parseContentState');\n    }\n    // resolve.\n    return fetch(state).then((r) => r.json());\n  }\n\n  return parseContentState(decodeContentState(state), asyncOrFetcher as any);\n}\n\nexport function encodeContentState(state: string): string {\n  const uriEncoded = encodeURIComponent(state); // using built in function\n  const base64 = typeof btoa === 'undefined' ? Buffer.from(uriEncoded, 'utf-8').toString('base64') : btoa(uriEncoded); // using built in function\n  const base64url = base64.replace(/\\+/g, '-').replace(/\\//g, '_');\n  return base64url.replace(/=/g, '');\n}\n\nexport function decodeContentState(encodedContentState: string): string {\n  const base64url = restorePadding(encodedContentState);\n  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');\n  const base64Decoded = typeof atob === 'undefined' ? Buffer.from(base64, 'base64').toString('utf-8') : atob(base64); // using built in function\n  return decodeURIComponent(base64Decoded).trim(); // using built in function\n}\n\nfunction restorePadding(s: string) {\n  // The length of the restored string must be a multiple of 4\n  const pad = s.length % 4;\n\n  if (pad === 1) {\n    throw new Error('InvalidLengthError: Input base64url string is the wrong length to determine padding');\n  }\n\n  return s + (pad ? '===='.slice(0, 4 - pad) : '');\n}\n\nexport function normaliseContentState(state: ContentState): NormalisedContentState {\n  if (!state) {\n    throw new Error('Content state is empty');\n  }\n\n  if (!Array.isArray(state)) {\n    // We have multiples.\n    // throw new Error('Content state is an [Array] and not yet supported');\n    state = [state];\n  }\n\n  let annoId = 'vault://virtual-annotation/' + new Date().getTime(); // <-- need a virtual id\n  const motivation = ['contentState'];\n  const targets = [];\n\n  for (const source of state) {\n    if (typeof source === 'string') {\n      // Note: this is unlikely to happen in conjunction with parseContentState()\n      throw new Error('Content state is a [String] type and cannot be inferred');\n    }\n\n    // If we DO have annotation, then this is all we should be returning.\n    if (source.type === 'Annotation') {\n      annoId = source.id;\n      if (Array.isArray(source.motivation)) {\n        for (const singleMotivation of source.motivation) {\n          if (motivation.indexOf(singleMotivation) === -1) {\n            motivation.push(singleMotivation);\n          }\n        }\n      }\n\n      if (Array.isArray(source.target)) {\n        for (const target of source.target) {\n          const expanded = expandTarget(target as any);\n          targets.push(expanded);\n        }\n      } else {\n        const expanded = expandTarget(source.target as any);\n        targets.push(expanded);\n      }\n\n      continue;\n    }\n\n    const target = expandTarget(source as any);\n    targets.push(target);\n  }\n\n  return {\n    id: annoId,\n    type: 'Annotation',\n    motivation: ['contentState', ...((state as any).motivation || [])],\n    target: targets,\n    extensions: {},\n  };\n}\n"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_i","_s","err","TAU","mapToEllipse","_ref","rx","ry","cosphi","sinphi","centerx","centery","x","y","xp","yp","approxUnitArc","ang1","ang2","a","x1","y1","x2","y2","vectorAngle","ux","uy","vx","vy","sign","dot","getArcCenter","px","py","cx","cy","largeArcFlag","sweepFlag","pxp","pyp","rxsq","rysq","pxpsq","pypsq","radicant","centerxp","centeryp","vx1","vy1","vx2","vy2","arcToBezier","_ref2","_ref2$xAxisRotation","xAxisRotation","_ref2$largeArcFlag","_ref2$sweepFlag","curves","lambda","_getArcCenter","_getArcCenter2","ratio","segments","curve","_mapToEllipse","_mapToEllipse2","_mapToEllipse3","parseSvgPath","parse","length","segment","path","data","_","command","args","type","parseValues","number","numbers","absSvgPath","absolutize","startX","startY","seg","parseAndNormalizeSvgPath","parsed","absolute","prevCmd","bezierX","bezierY","quadX","quadY","out","cmd","arcToCurve","j","flattenQuadraticBezier","start","control","end","tolerance","QuadraticBezier","flattenCubicBezier","startControl","endControl","CubicBezier","hypot2","p","approx_myint","approx_inv_myint","t","mt","x0","y0","ddx","ddy","u0","u2","cross","paramX0","paramX2","scale","params","a0","a2","count","n","tValues","coords","c0","c1","c2","c3","p1","t0","t1","c","p0","p3","d1","d2","tol","tol1","tol2","sqrt_tol2","err2","n_quads","quads","sum","quad","val","xmin","cusp_val","result","target","BOX_SELECTOR","TEMPORAL_SELECTOR","RGBA_COLOR","parseSelector","source","domParser","svgPreprocessor","nextSource","selector","selectors","id","fragment","matchBoxSelector","matchTimeSelector","points","rect","style","svg","_a","svgShape","svgElement","selectorElem","getSelectorElement","_b","extractStyles","sel","getShapeTypeFromPath","svgPath","cmdFrequencies","acc","cmdTypes","lastSeg","svgElem","element","res","normalized","pathToPoints","r","_c","angle","rad","_f","_g","_h","_j","_k","_m","_l","ps","shapeType","_o","width","_p","height","_q","normalizedPath","startPoint","selectorElement","rgbaMatch","rootElem","expandTarget","options","validateContentState","annotation","strict","anno","valid","reason","serialiseContentState","encodeContentState","parseContentState","state","asyncOrFetcher","decodeContentState","uriEncoded","encodedContentState","base64","restorePadding","base64Decoded","s","pad","normaliseContentState","annoId","targets","singleMotivation","expanded"],"mappings":"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"}